- en: Chapter 1. Introduction to NoSQL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。NoSQL简介
- en: 'In this chapter, you will learn about the emerging realm of NoSQL and get introduced
    to various classifications in the NoSQL domain. We will also understand the position
    of **Redis** in the NoSQL domain. We''ll cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解新兴的NoSQL领域，并介绍NoSQL领域的各种分类。我们还将了解**Redis**在NoSQL领域的位置。我们将涵盖以下主题：
- en: Data in Enterprise
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业中的数据
- en: NoSQL
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NoSQL
- en: Use cases for NoSQL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NoSQL的用例
- en: An Internet-enabled world
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互联网化的世界
- en: We live in interesting times; in the last decade, a lot of changes have happened
    that have changed the way we experience the world of the Internet and the ecosystem
    around it. In this chapter, we will focus on some of the reasons that led to progress
    and discuss the developments happening in the world of data storage.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生活在一个有趣的时代；在过去的十年里，发生了许多改变，改变了我们体验互联网世界及其周围生态系统的方式。在本章中，我们将重点讨论一些促成进步的原因，并讨论数据存储领域的发展。
- en: 'The following figure is a rough sketch of the evolution process that happened
    in cyberspace, the data for which is collected from the Internet, and gives a
    rough idea of the growth experienced in Internet-based services:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 下图是对网络空间中发生的演变过程的粗略草图，其数据来自互联网，并大致展示了互联网服务的增长情况：
- en: '![An Internet-enabled world](img/1794_01_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![互联网化的世界](img/1794_01_01.jpg)'
- en: 'Evolution: Social media, processors and cores, databases (NoSQL)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 演变：社交媒体、处理器和核心、数据库（NoSQL）
- en: The preceding chart indicates that the hardware industry saw a paradigm shift
    during the middle half of the first decade. Instead of new processors coming out
    with increased clock speeds, the newer generation of processors came with multiple
    cores and their numbers increased in processors with a subsequent release. Gone
    were the days when a big machine with lots of memory and a powerful processor
    could solve any problem or, in other words, when an Enterprise depended on vertical
    scaling to solve their performance issues. What it signaled, in a way, was that
    parallel computing was the future and it will be deployed on commodity-based machines.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表表明，硬件行业在第一个十年的中期发生了一场范式转变。新处理器不再以增加时钟速度为目标，而是新一代处理器采用了多核技术，随后发布的处理器数量也在增加。过去，大型机器配备大量内存和强大的处理器可以解决任何问题，或者换句话说，企业依赖垂直扩展来解决性能问题的日子一去不复返。这在某种程度上预示着并行计算是未来，并且将部署在基于商品的机器上。
- en: With the hardware industry signaling the arrival of parallel computing, the
    newer generation of solutions had to be distributed and parallel in nature. This
    means that they needed to have logic executed in parallel and data stored in distributed
    datastores; in other words, horizontal scaling was the way to go. Moreover, with
    Web 2.0, there was an emergence of social media, online gaming, online shopping,
    collaborative computing, cloud computing, and so on. The Internet was becoming
    a ubiquitous platform.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 随着硬件行业预示着并行计算的到来，新一代解决方案必须是分布式和并行的。这意味着它们需要以并行方式执行逻辑，并将数据存储在分布式数据存储中；换句话说，水平扩展是未来的发展方向。此外，随着Web
    2.0的出现，社交媒体、在线游戏、在线购物、协作计算、云计算等也开始出现。互联网正在成为一个无处不在的平台。
- en: The popularity of the Internet and the number of people using the Internet was
    increasing by the day, and the amount of time spent on the Internet was also increasing.
    Another important aspect to be looked at was that users across geographies were
    coming together in this Internet-enabled world. There are many reasons for this;
    for one, websites were becoming intelligent and in a way, were engaging end users
    far effectively than their predecessors. Another factor that was making Internet
    adoption faster and easier were innovative handheld devices, such as smartphones,
    tablets, and so on. Nowadays, the kind of compute power these handheld devices
    have can be compared to that of computers. In this dynamically changing world,
    Internet-based software solutions and services are expanding the horizon of social
    media, which brings people together on a common platform. This created a new business
    domain like social-Enterprise media, where social media bridges with Enterprise.
    This was definitely going to have an impact on traditional Enterprise solutions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网的普及和使用互联网的人数每天都在增加，使用互联网的时间也在增加。需要注意的另一个重要方面是，来自不同地理位置的用户在这个互联网化的世界中聚集在一起。这有很多原因；首先，网站变得更加智能，以一种更有效地吸引终端用户的方式进行交互。另一个使互联网采用速度更快、更容易的因素是创新的手持设备，如智能手机、平板电脑等。如今，这些手持设备具有的计算能力可以与计算机相媲美。在这个动态变化的世界中，基于互联网的软件解决方案和服务正在拓展社交媒体的视野，将人们聚集在一个共同的平台上。这创造了一个新的商业领域，如社交企业媒体，其中社交媒体与企业融合。这肯定会对传统企业解决方案产生影响。
- en: The Internet effect made Enterprise solutions undergo a metamorphic shift. The
    shift in Enterprise architecture went from a nuanced set of requirements, typically
    expected from Enterprise solutions, to adopting newer requirements, which were
    the bastion of social media solutions. Nowadays, Enterprise solutions are integrating
    with social media sites to know what their customers are talking about; they themselves
    have started creating platforms and forums where the customer can come and contribute
    their impressions about products and services. All this data exchange happens
    in real time and needs a highly concurrent and scalable ecosystem. To sum it up,
    Enterprise solutions want to adopt the features of social media solutions, and
    this has a direct and proportional bearing on the nonfunctional requirements of
    their architectures. Features such as fault management, real-time big data crunching,
    eventual consistency, high numbers of reads and writes, responsiveness, horizontal
    scalability, manageability, maintainability, agility, and so on, and their impact
    on Enterprise architecture, are being looked at with renewed interest. Techniques,
    paradigms, frameworks, and patterns that were used in social media architecture
    are being studied and reapplied in Enterprise architecture.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网的影响使得企业解决方案经历了一次变革性的转变。企业架构的转变从通常期望的企业解决方案的微妙需求，转向了采纳社交媒体解决方案的新需求。如今，企业解决方案正在与社交媒体网站整合，以了解他们的客户在谈论什么；他们自己也开始创建平台和论坛，让客户可以来贡献他们对产品和服务的印象。所有这些数据交换都是实时进行的，需要一个高并发和可扩展的生态系统。总之，企业解决方案希望采纳社交媒体解决方案的特性，这直接和成比例地影响了他们架构的非功能性需求。故障管理、实时大数据处理、最终一致性、大量读写、响应性、水平扩展性、可管理性、可维护性、灵活性等特性，以及它们对企业架构的影响，都受到了新的关注。社交媒体架构中使用的技术、范例、框架和模式正在被研究和重新应用到企业架构中。
- en: One of the key layers in any solution (social media or Enterprise) is the data
    layer. Data, the way it is arranged and managed, and the choice of datastore forms
    the data layer. From a designer's perspective, data handling in any datastore
    is governed by perspectives such as consistency, availability, and partition tolerance,
    or better known as Eric Brewer's **CAP** theorem. While it is desirable to have
    all the three, in reality, any data layer can have a combination of two of the
    mentioned perspectives. What this means is that the data in a solution can have
    many combinations of perspectives, such as availability-partition tolerance (this
    combination has to forego consistency in data handling), availability-consistency
    (this combination has to forego partition tolerance which will impact the amount
    of data that the data layer can handle), and consistency-partition tolerance (this
    combination has to forego availability).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何解决方案（社交媒体或企业）中，关键层之一是数据层。数据的排列和管理方式，以及数据存储的选择构成了数据层。从设计师的角度来看，任何数据存储中的数据处理都受到一致性、可用性和分区容忍性等视角的影响，也就是著名的Eric
    Brewer的CAP定理。虽然同时拥有这三个视角是可取的，但实际上，任何数据层都可能同时具有两种以上的视角。这意味着解决方案中的数据可能具有多种视角的组合，比如可用性-分区容忍性（这种组合必须放弃数据处理中的一致性），可用性-一致性（这种组合必须放弃分区容忍性，这将影响数据层处理的数据量），以及一致性-分区容忍性（这种组合必须放弃可用性）。
- en: The CAP theorem has a direct bearing on the behavior of the system, read/write
    speeds, concurrency, maintainability, clustering patterns, fault tolerance, data
    loads, and so on.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: CAP定理直接影响系统的行为、读写速度、并发性、可维护性、集群模式、容错性、数据负载等。
- en: The most common approach when designing the data model is to arrange it in a
    relational and normalized way. This works well when the data is in transactional
    mode, needs consistency, and is structured, that is, it has a fixed schema. This
    approach of normalizing data appears over-engineered when the data is semistructured,
    has a tree-like structure, or is schema-less, where consistency can be relaxed.
    The end result of making semistructured data fit into a structured data model
    is the explosion of tables and a complicated data model to store simple data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 设计数据模型时最常见的方法是以关系型和规范化的方式排列数据。当数据处于事务模式、需要一致性并且是结构化的时候，这种方法效果很好，也就是说，它有一个固定的模式。但当数据是半结构化的、具有树状结构或者是无模式的时候，这种规范化数据的方法就显得过度设计了，这种情况下一致性可以放松。将半结构化数据适应到结构化数据模型中的结果就是表的爆炸和一个复杂的数据模型来存储简单的数据。
- en: Due to the lack of alternatives, the solutions have been overtly relying on
    **RDBMS** to address concerns regarding data handling. The problem with this approach
    is RDBMS, which was primarily designed to address consistency and the availability
    perspective of data handling, also started to store data, which had concerns of
    partition tolerance. The end result was a bloated RDBMS with a very complex data
    model. This started impacting the nonfunctional requirements of a solution negatively,
    in the areas of fault management, performance, scalability, manageability, maintainability,
    and agility.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缺乏替代方案，解决方案过度依赖关系型数据库管理系统（RDBMS）来解决数据处理方面的问题。这种方法的问题在于RDBMS最初是为了解决数据处理的一致性和可用性问题而设计的，但后来也开始存储具有分区容忍性问题的数据。最终的结果是一个臃肿的RDBMS和一个非常复杂的数据模型。这开始对解决方案的非功能性需求产生负面影响，包括故障管理、性能、可扩展性、可管理性、可维护性和灵活性等方面。
- en: Another area of concern was **Data Interpretation**, which is very important
    while designing the data layer. In a solution, the same data is viewed and interpreted
    differently by a different concerned group. To give a better idea, let's say that
    we have an e-commerce website that sells products. Three basic functional domains
    come into play in the design of this data layer; they are inventory management,
    account management, and customer management. From a core business standpoint,
    all the domains need **atomicity, consistency, isolation, durability** (**ACID**)
    properties in their data management, and from the CAP theorem point of view, they
    need consistency and availability. However, if the website needs to understand
    its customer in real time, an analytics team needs to analyze data from the inventory
    management, account management, and customer management domains. Apart from other
    data, it might collect separately at real time. The way the analytics team views
    the same data is totally different from the way other teams view it; for them,
    consistency is less of a concern, as they are more interested in the overall statistics,
    and a little inconsistent data will have no impact on the overall report. If all
    the data required for analytics from these domains is kept in the same data model
    as that for core business, the analytics will run into difficulty because it has
    to now work with this highly normalized and optimized structured data for business
    operations. The analytics team will also like to have their data denormalized
    for faster analysis.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关注领域是**数据解释**，在设计数据层时非常重要。在一个解决方案中，同一数据被不同的相关团队以不同的方式查看和解释。为了更好地理解，假设我们有一个销售产品的电子商务网站。在设计这个数据层时，有三个基本的功能领域涉及其中，它们是库存管理、账户管理和客户管理。从核心业务的角度来看，所有领域在其数据管理中都需要**原子性、一致性、隔离性、持久性**（**ACID**）属性，从CAP定理的角度来看，它们需要一致性和可用性。然而，如果网站需要实时了解其客户，分析团队需要分析来自库存管理、账户管理和客户管理领域的数据。除了实时收集的其他数据。分析团队查看相同数据的方式与其他团队的方式完全不同；对于他们来说，一致性不是一个问题，因为他们更感兴趣的是整体统计数据，一些不一致的数据对整体报告没有影响。如果来自这些领域的所有分析所需数据都保存在与核心业务相同的数据模型中，分析将会遇到困难，因为现在它必须使用这些高度规范化和优化的结构化数据进行业务操作。分析团队还希望将其数据去规范化以加快分析速度。
- en: Now, running real-time analytics on this normalized data on a RDBMS system will
    require heavy compute resources, which will impact the performance of core business
    during business hours. So, it is better for overall business if separate data
    models are created for these domains, one for business and one for analytics,
    where each is maintained separately as they have separate concerns. We will see
    in subsequent topics why RDBMS is not the right fit for analytics and some other
    use cases and how NoSQL solves the problem of explosion of data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在RDBMS系统上对这些规范化数据进行实时分析将需要大量的计算资源，这将影响核心业务在营业时间的性能。因此，如果为这些领域创建单独的数据模型，一个用于业务，一个用于分析，每个都分开维护，对整体业务更有利。我们将在后续主题中看到为什么RDBMS不适合分析和其他用例，以及NoSQL如何解决数据爆炸问题。
- en: The NoSQL primer
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NoSQL入门
- en: '**Not only SQL** or **NoSQL**, as it is popularly called, was coined by Carlo
    Strozzi in 1998 and was reintroduced by Eric Evans in 2009\. This is an exciting
    area in data handling which, in a way, has filled up the many gaps existing in
    the data handling layer. Before the emergence of NoSQL as an alternate choice
    to store data, SQL-oriented databases (RDBMS) were the only choice available for
    the developers to position or retrofit their data. In other words, RDBMS was one
    hammer to nail all data problems. When NoSQL and its different categories started
    emerging, data models and data sizes that were not meant for RDBMS started finding
    NoSQL as a perfect datastore. There was also a shift in attention from a consistency
    standpoint; there was a shift was from ACID to BASE properties.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**非仅SQL**或**NoSQL**，正如它被普遍称呼的那样，是由Carlo Strozzi在1998年创造的，并在2009年由Eric Evans重新引入。这是数据处理中一个令人兴奋的领域，以某种方式填补了数据处理层中存在的许多空白。在NoSQL作为存储数据的备选选择出现之前，面向SQL的数据库（RDBMS）是开发人员定位或改装其数据的唯一选择。换句话说，RDBMS是一把钉所有数据问题的锤子。当NoSQL及其不同类别开始出现时，那些不适合RDBMS的数据模型和数据大小开始发现NoSQL是一个完美的数据存储。还有一个关注点是从一致性的角度转变；从ACID转变为BASE属性。'
- en: 'ACID properties represent the consistency and availability of the CAP theorem.
    These properties are exhibited by RDBMS and stand for the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ACID属性代表CAP定理的一致性和可用性。这些属性由RDBMS展示，并代表以下内容：
- en: '**Atomicity**: In a transaction, all operations will complete or none will
    be completed (rollback)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子性**：在事务中，所有操作将完成或全部不会完成（回滚）'
- en: '**Consistency**: The database will be in a consistent state during the start
    and end of a transaction and cannot leave the state in between'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：数据库在事务开始和结束时将处于一致状态，并且不能在中间状态离开'
- en: '**Isolation**: There will be no interference among the concurrent transactions'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离**：并发事务之间不会有干扰'
- en: '**Durability**: Once a transaction commits, it will remain so even after the
    server restarts or fails'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：一旦事务提交，即使服务器重新启动或失败，它也将保持不变'
- en: '**BASE** properties are exhibited by NoSQL; they represent the availability
    and partition tolerance of the CAP theorem. They basically give up on the strong
    consistency shown by RDBMS. BASE stands for following features:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL表现出**BASE**属性；它们代表了CAP定理的可用性和分区容忍性。它们基本上放弃了RDBMS所显示的强一致性。BASE代表以下特性：
- en: '**Basically available**: This guarantees a response to a request even if the
    data is in the stale state.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本可用**：这保证了对请求的响应，即使数据处于陈旧状态。'
- en: '**Soft state**: The state of the data is always in a position to accept change
    even when there is no request to change its state. What this means is that suppose
    there are two nodes holding the same state of a data (the replication of data),
    if there is a request to change the state in one of the nodes, the state in the
    other node will not change during the lifespan of the request. The data in the
    other node will change its state due to an asynchronous process triggered by the
    datastore, thus making the state soft.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软状态**：数据的状态始终处于接受更改的状态，即使没有请求更改其状态。这意味着假设有两个节点持有相同的数据状态（数据的复制），如果有一个请求在一个节点中更改状态，另一个节点中的状态在请求的生命周期内不会更改。另一个节点中的数据将由数据存储触发的异步过程更改其状态，从而使状态变得软化。'
- en: '**Eventually consistent**: Due to the distributed nature of the nodes, the
    system will eventually become consistent.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终一致性**：由于节点的分布性，系统最终将变得一致。'
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The data write and reads should be faster and easier.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的写入和读取应该更快更容易。
- en: 'Another interesting development took place in the field of software development.
    Vertical scalability had reached its limit and solutions had to be designed that
    were horizontally scalable in nature, so the data layer also had to be distributed
    and partition tolerant. Apart from that social media solution, online gaming and
    game theory-based websites (where target marketing was done, that is, users are
    rewarded based on their purchase history with the site. These kind of sites need
    real-time analytics) started gaining prominence. Social media wanted the synching
    of huge amount of data from across geographies in the shortest possible time,
    and the gaming world was interested in high performance. E-commerce sites were
    interested in knowing about their customers and products in real time, as well
    as profiling their customers to know their needs before they could realize the
    need for it. The categories in NoSQL that emerged based on different data models
    are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发领域发生了另一个有趣的发展。垂直可扩展性已经达到了极限，必须设计出具有水平可扩展性的解决方案，因此数据层也必须是分布式和分区容错的。除了社交媒体解决方案外，在线游戏和基于游戏理论的网站（进行目标营销，即根据用户的购买历史奖励用户。这类网站需要实时分析）开始受到关注。社交媒体希望在最短时间内同步来自各地的大量数据，游戏世界对高性能感兴趣。电子商务网站对实时了解他们的客户和产品以及对客户进行概括以在客户意识到需求之前了解他们的需求感兴趣。根据不同数据模型出现的NoSQL中的类别如下：
- en: Graph-oriented NoSQL
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向图形的NoSQL
- en: Document-oriented NoSQL
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向文档的NoSQL
- en: Key-value oriented NoSQL
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向键值的NoSQL
- en: Column-oriented NoSQL
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向列的NoSQL
- en: Graph-oriented NoSQL
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向图形的NoSQL
- en: Graph databases are a special kind of NoSQL databases. The data models stored
    by graph databases are graph structures, which are a bit different from other
    datastores. A graph structure consists of a node, edges, and properties. The way
    to understand graph databases is to think of them as mindmaps with bidirectional
    relationships. What this means is that if A is related to B and B is related to
    C, then C is related to A. Graph databases tend to solve the problems that arise
    out of relationships formed among unstructured entities at runtime, which can
    be bidirectional. As compared to this, RDBMS also has a concept of relationships
    called **table joins**, but these relationships are on structured data and cannot
    be bidirectional.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图形数据库是一种特殊类型的NoSQL数据库。图形数据库存储的数据模型是图形结构，与其他数据存储有些不同。图形结构由节点、边和属性组成。理解图形数据库的方法是将它们视为具有双向关系的思维导图。这意味着如果A与B相关，B与C相关，那么C与A相关。图形数据库倾向于解决在运行时形成的非结构化实体之间形成的关系所引发的问题，这些关系可以是双向的。相比之下，关系型数据库也有一种称为**表连接**的关系概念，但这些关系是在结构化数据上的，不能是双向的。
- en: Moreover, these table joins add complexity to the data model with foreign keys
    and have performance penalties on table join-based queries when the dataset grows
    over a period time. A few of the most promising graph datastores are Neo4i, FlockDB,
    OrientDB, and so on.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些表连接会在数据集随着时间的推移而增长时，对具有外键的数据模型增加复杂性，并对基于表连接的查询产生性能惩罚。一些最有前途的图形数据存储包括Neo4i、FlockDB、OrientDB等。
- en: To understand this better, let's take a sample use case and see how easy it
    becomes to solve complex graph-based business use cases with graph-oriented NoSQL.
    The following figure is a sample use case, which an e-commerce website might be
    interested in solving. The use case is to capture visitors' purchase history and
    people's relationships in the microblogging component of the website.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，让我们来看一个示例用例，并看看如何使用面向图形的NoSQL解决复杂的基于图形的业务用例变得多么容易。以下图是一个示例用例，一个电子商务网站可能有兴趣解决。用例是捕获访问者的购买历史和网站微博组件中的人际关系。
- en: '![Graph-oriented NoSQL](img/1794_01_02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![面向图形的NoSQL](img/1794_01_02.jpg)'
- en: Sample module for graph DB
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图形数据库的示例模块
- en: Business entities such as the publisher, author, customer, product, and so on
    are represented as nodes in the graph. Relationships such as authored by, author,
    publisher, published by, and so on are represented by edges in the graph. Interestingly,
    a nonbusiness node, such as *user-1*, which is from the blogging site, can be
    represented in the graph along with its relationship, *follows*, with the other
    node, *user-2*. By combining the business and nonbusiness entities, the website
    can find target customers for the products. In the graph, both nodes and edges
    have properties that are used while running analytics.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 业务实体，如出版商、作者、客户、产品等，在图中表示为节点。例如，由作者、出版商发布的关系等在图中由边表示。有趣的是，来自博客网站的*用户-1*等非业务节点可以与其关系*关注*一起在图中表示。通过结合业务和非业务实体，网站可以为产品找到目标客户。在图中，节点和边都有在运行分析时使用的属性。
- en: 'The following set of questions can be easily answered by a graph database based
    on the relationships stored in the systems:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 基于关系存储在系统中的图形数据库可以轻松回答以下一组问题：
- en: Who authored *Learning Redis*?
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁是*Learning Redis*的作者？
- en: 'Answer: Vinoo Das'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：Vinoo Das
- en: How are Packt Publishing and *Learning Redis* related?
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Packt Publishing和*Learning Redis*有什么关系？
- en: 'Answer: Publisher'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：发布者
- en: Who has their own NoSQL book published by Packt Publishing?
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁有自己的NoSQL书由Packt Publishing出版？
- en: 'Answer: user-2'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：user-2
- en: Who is following the customer who has purchased *Learning Redis* and is interested
    in NoSQL?
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁正在关注购买了*Learning Redis*并对NoSQL感兴趣的客户？
- en: 'Answer: user-1'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：user-1
- en: List all the NoSQL books that cost less than X USD and that can be bought by
    the followers of user-2.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出所有价格低于X美元且可以被user-2的关注者购买的NoSQL书籍。
- en: 'Answer: *Learning Redis*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：*Learning Redis*
- en: Document-oriented NoSQL
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向文档的NoSQL
- en: Document-oriented datastores are designed to store data with the philosophy
    of storing a document. To understand this simplistically, the data here is arranged
    in the form of a book. A book can be divided into any number of chapters, where
    each chapter can be divided into any number of topics, and each topic is further
    divided into subtopics and so on and so forth.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 面向文档的数据存储设计用于存储具有存储文档哲学的数据。简单地说，这里的数据以书的形式排列。一本书可以分为任意数量的章节，每个章节可以分为任意数量的主题，每个主题进一步分为子主题等等。
- en: '![Document-oriented NoSQL](img/1794_01_03.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![面向文档的NoSQL](img/1794_01_03.jpg)'
- en: Composition of a book
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一本书的组成
- en: If the data has a similar structure, that is, it is hierarchical and does not
    have a fixed depth or schema, then document-oriented datastores are the perfect
    option to store such data. **MongoDB** and **CouchDB** (**Couchbase**) are two
    well-known document-oriented datastores that are getting a lot of attention these
    days. Like a book, which has indexes for faster searches, these datastores also
    have the indexes of keys stored in memory for faster searches.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据具有类似的结构，即层次化且没有固定深度或模式，则面向文档的数据存储是存储此类数据的完美选择。MongoDB和CouchDB（Couchbase）是目前备受关注的两种知名的面向文档的数据存储。就像一本书有索引以进行更快的搜索一样，这些数据存储也有存储在内存中的键的索引以进行更快的搜索。
- en: Document-oriented datastores have data stored in the XML, JSON, and other formats.
    They can hold scalar values, maps, lists, and tuples as values. Unlike RDBMS,
    where the data is viewed as rows of data stored in a tabular form, the data stored
    here is in a hierarchical tree-like structure where every value stored in these
    datastores is always associated with a key. Another unique feature is that document-oriented
    datastores are schema-less. The following screenshot shows an example which shows
    how the data is stored in document-oriented datastores. The format in which the
    data is stored is JSON. One of the beauties of document-oriented datastores is
    that the information can be stored in the way you think of the data. This, in
    a way, is a paradigm shift from RDBMS, where the data is broken into various smaller
    parts and then stored in rows and columns in a normalized way.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 面向文档的数据存储以XML、JSON和其他格式存储数据。它们可以保存标量值、映射、列表和元组作为值。与关系型数据库管理系统（RDBMS）不同，后者将数据视为以表格形式存储的数据行，这里存储的数据是以分层树状结构存储的，其中存储在这些数据存储中的每个值始终与一个键相关联。另一个独特的特点是面向文档的数据存储是无模式的。以下截图显示了一个示例，展示了数据存储在面向文档的数据存储中的方式。数据存储的格式是JSON。面向文档的数据存储的一个美妙之处在于信息可以以您所想到的数据方式存储。从某种意义上说，这是与关系型数据库管理系统的范式转变，后者将数据分解为各种较小的部分，然后以规范化的方式存储在行和列中。
- en: '![Document-oriented NoSQL](img/1794_01_04.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![面向文档的NoSQL](img/1794_01_04.jpg)'
- en: Composition of sample data in JASON format
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: JASON格式示例数据的组成
- en: The two most famous document-oriented stores in use are MongoDB and CouchDB,
    and it will be interesting to pit them against each other in order to have a better
    overview.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 目前使用最广泛的两种面向文档的存储是MongoDB和CouchDB，将它们相互对比将有助于更好地了解它们。
- en: Salient features of MongoDB and CouchDB
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MongoDB和CouchDB的显著特点
- en: 'Well, the fact that both MongoDB and CouchDB are document-oriented is established,
    but both differ in various aspects, which will be of interest to people who want
    to learn about document-oriented datastores and adopt them in their projects.
    Following are some features of MongoDB and CouchDB:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB和CouchDB都是面向文档的事实已经确立，但它们在各个方面有所不同，这将对想要了解面向文档的数据存储并在其项目中采用它们的人们感兴趣。以下是MongoDB和CouchDB的一些特点：
- en: '**Insertion of small and large data sets**: Both MongoDB and CouchDB are very
    good for the insertion of small data sets. MongoDB is a tad better than CouchDB
    when it comes to the insertion of large data sets. Overall, speed consistencies
    are very good in both of these document datastores.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入小型和大型数据集**：MongoDB和CouchDB都非常适合插入小型数据集。在插入大型数据集时，MongoDB比CouchDB稍微更好。总体而言，这两种文档数据存储的速度一致性都非常好。'
- en: '**Random reads**: Both MongoDB and CouchDB are fast when it comes to read speeds.
    MongoDB is a tad better when it comes to reading large data sets.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机读取**：在读取速度方面，MongoDB和CouchDB都很快。当涉及到读取大数据集时，MongoDB稍微更好一些。'
- en: '**Fault tolerance**: Both MongoDB and CouchDB have comparable and good fault
    tolerance capability. CouchDB uses **Erlang**/**OTP** as the underlying technology
    platform for its implementation. Erlang is a language and a platform that was
    developed to make fault-tolerant, scalable, and highly concurrent systems. The
    fact that Erlang act as a backbone for CouchDB gives it a very good fault-tolerant
    capability. MongoDB uses C++ as the primary language for its underlying implementation.
    Industry adoption and its proven track record in the area of fault tolerance give
    MongoDB a good heads-up in this area.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容错性：MongoDB和CouchDB都具有可比较且良好的容错能力。CouchDB使用Erlang/OTP作为其实现的基础技术平台。Erlang是一种语言和平台，旨在实现容错、可扩展和高并发的系统。Erlang作为CouchDB的支撑使其具有非常好的容错能力。MongoDB使用C++作为其底层实现的主要语言。在容错领域的行业采用和其经过验证的记录使MongoDB在这一领域具有很好的优势。
- en: '**Sharding**: MongoDB has an in-built sharding capability, whereas CouchDB
    does not. Nevertheless, Couchbase, which is another document datastore built on
    top of CouchDB, has an automatic sharding capability.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分片**：MongoDB具有内置的分片功能，而CouchDB没有。然而，建立在CouchDB之上的另一个文档数据存储Couchbase具有自动分片功能。'
- en: '**Load balancing**: MongoDB and CouchDB have a good load balancing capability.
    However, since the underlying technology, that is the actor paradigm, in CouchDB
    has a good provision for load balancing, it can be said that the capability in
    CouchDB scores over the capability in MongoDB.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载平衡**：MongoDB和CouchDB都具有良好的负载平衡能力。然而，由于CouchDB中的底层技术，即Actor范式，具有良好的负载平衡规定，可以说CouchDB的能力胜过MongoDB的能力。'
- en: '**Multi-data center support**: CouchDB has multi-data center support, whereas
    MongoDB at the time of researching for this book, didn''t have this support. However,
    I guess that in the future, with the popularity of MongoDB, we can expect it.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多数据中心支持**：CouchDB具有多数据中心支持，而在撰写本书时，MongoDB并没有这种支持。然而，我猜想随着MongoDB的普及，我们可以期待它在未来具有这种支持。'
- en: '**Scalability**: Both CouchDB and MongoDB are highly scalable.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：CouchDB和MongoDB都具有高度可扩展性。'
- en: '**Manageability**: Both CouchDB and MongoDB have good manageability.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可管理性**：CouchDB和MongoDB都具有良好的可管理性。'
- en: '**Client**: CouchDB has JSON for data exchange, whereas MongoDB has BSON, which
    is proprietary to MongoDB.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：CouchDB使用JSON进行数据交换，而MongoDB使用BSON，这是MongoDB专有的。'
- en: Column-oriented NoSQL
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列式NoSQL
- en: Column-oriented NoSQL is designed with the philosophy to store data in columns
    rather than rows. This way to store data is diametrically opposite to the way
    data is stored in RDBMS, such as in rows. Column-oriented databases are designed
    from the ground up to be highly scalable and hence, are distributed in nature.
    They give up on consistency to have this massive scalability.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列式NoSQL的设计理念是将数据存储在列而不是行中。这种存储数据的方式与RDBMS中存储数据的方式完全相反，RDBMS中数据是按行存储的。列式数据库从一开始就被设计为高度可扩展的，因此具有分布式特性。它们放弃了一致性以获得这种大规模的可扩展性。
- en: 'The following screenshot is a depiction of a small inventory for smart tablets
    based on our perception; here, the idea is to show how the data is stored in RDBMS
    as compared to the data stored in a columnar database:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图描述了基于我们的感知的智能平板电脑的小型库存；在这里，想要展示RDBMS中存储的数据与列式数据库中存储的数据的对比：
- en: '![Column-oriented NoSQL](img/1794_01_05.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![列式NoSQL](img/1794_01_05.jpg)'
- en: Presentation of data in columns and rows
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以列和行的形式呈现数据
- en: 'The preceding tabular data is stored in RDBMS in the hard disk, in the format
    shown here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表格数据以如下格式存储在硬盘的RDBMS中：
- en: '![Column-oriented NoSQL](img/1794_01_06.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![列式NoSQL](img/1794_01_06.jpg)'
- en: Data serialized as columns
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 数据序列化为列
- en: The source of the information in the preceding screenshot is [http://en.wikipedia.org/wiki/Column-oriented_DBMS](http://en.wikipedia.org/wiki/Column-oriented_DBMS).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图信息的来源是[http://en.wikipedia.org/wiki/Column-oriented_DBMS](http://en.wikipedia.org/wiki/Column-oriented_DBMS)。
- en: 'The same data in a columnar datastore will be stored as shown in the following
    figure; here, the data is serialized in columns:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列式数据存储中的相同数据将存储如下图所示；在这里，数据是按列序列化的：
- en: '![Column-oriented NoSQL](img/1794_01_07.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![列式NoSQL](img/1794_01_07.jpg)'
- en: Data serialized as rows
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 数据序列化为行
- en: A world where vertical scalability is reaching its limit and horizontal scalability
    is the way organizations want to adopt to store data, columnar datastores are
    offering solutions that can store petabytes of data in a very cost-effective way.
    Google, Yahoo!, Facebook, and so on have pioneered the storage of data in a columnar
    way, and the proof is in the pudding, that is, the amount of data that these companies
    store is a well-known fact. HBase and Cassandra are a few of the well-known products
    that are columnar in nature and can store a huge amount of data. Both the datastores
    are built with eventual consistency in mind. The underlying language in the case
    of HBase and Cassandra is Java; it will be interesting to put them against each
    other in order to have a better overview.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在垂直可扩展性达到极限、水平可扩展性是组织希望采用的存储数据方式的世界中，列式数据存储提供了可以以非常具有成本效益的方式存储百万兆字节数据的解决方案。谷歌、雅虎、Facebook等公司率先采用了列式存储数据的方式，而这些公司存储的数据量是众所周知的事实。HBase和Cassandra是一些以列为基础的知名产品，可以存储大量数据。这两种数据存储都是以最终一致性为目标构建的。在HBase和Cassandra的情况下，底层语言是Java；将它们相互对比将会很有趣，以便更好地了解它们。
- en: Salient features of HBase and Cassandra
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HBase和Cassandra的显著特点
- en: HBase is a datastore that belongs to the category of columnar-oriented datastores.
    This datastore came into existence after Hadoop became popular with its HDFS file
    storage system, inspired from the *Google File System* paper published in 2003\.
    The fact that HBase is based on Hadoop makes it an excellent choice for data warehousing
    and large-scale data processing and analysis. HBase provides a SQL-type interface
    over the existing Hadoop ecosystem, which is similar to the way we have been viewing
    data in a RDBMS, that is row-oriented, but the data is stored in a column-oriented
    way internally. HBase stores row data against a row key, and it is in a sorted
    order as per the row key. It has components such as the Region Server, which can
    be plugged to the DataNode provided with Hadoop. This means that the Region Server
    is collocated with the DataNode and acts as a gateway for interacting with HBase
    clients. Behind the scenes, the HBase master handles the DDL operations. Apart
    from this, it also manages the Region assignments and other book keeping activities
    associated with that. Cluster information and management, which includes state
    management, is taken care of by Zookeeper nodes. HBase clients interact directly
    with Region Servers to put and get data. Components such as Zookeeper (used to
    coordinate between the master and slave nodes), Name Node, and HBase master node
    do not participate directly in the exchange of data between the HBase client and
    Region Server nodes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: HBase是一种属于列定向数据存储类别的数据存储。这种数据存储在Hadoop变得流行之后出现，受到了2003年发布的*Google文件系统*论文的启发。HBase基于Hadoop，使其成为数据仓库和大规模数据处理和分析的绝佳选择。HBase在现有的Hadoop生态系统上提供了类似于我们在关系型数据库管理系统中查看数据的SQL类型接口，即面向行，但数据在内部以列为导向的方式存储。HBase根据行键存储行数据，并按行键的排序顺序进行排序。它具有诸如Region
    Server之类的组件，可以连接到Hadoop提供的DataNode。这意味着Region Server与DataNode共存，并充当与HBase客户端交互的网关。在幕后，HBase
    master处理DDL操作。除此之外，它还管理Region分配和与之相关的其他簿记活动。Zookeeper节点负责集群信息和管理，包括状态管理。HBase客户端直接与Region
    Server交互以放置和获取数据。诸如Zookeeper（用于协调主节点和从节点之间的协调）、Name Node和HBase主节点等组件不直接参与HBase客户端和Region
    Server节点之间的数据交换。
- en: '![Salient features of HBase and Cassandra](img/1794_01_08.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![HBase和Cassandra的显著特点](img/1794_01_08.jpg)'
- en: HBASE node set up
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: HBASE节点设置
- en: Cassandra is a datastore which belongs to the category of columnar-oriented
    datastores and also shows some features of the key-value datastore. Cassandra,
    which was initially started by Facebook but later forked to the Apache open source
    community, is best suited for real-time transaction processing and real-time analytics.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra是一种属于列定向数据存储类别的数据存储，同时也显示了一些键-值数据存储的特性。Cassandra最初由Facebook启动，但后来分叉到Apache开源社区，最适合实时事务处理和实时分析。
- en: One of the key differentiators between Cassandra and HBase is that unlike HBase,
    which depends on the existing architecture of Hadoop, Cassandra is standalone
    in nature. Cassandra takes its inspiration from Amazon's Dynamo to store data.
    In short, the architectural approach of HBase makes the Region Server and DataNodes
    dependent on other components such as HBase master, Name Node, Zookeeper, whereas
    the nodes in Cassandra manage these responsibilities within and thus are not dependent
    on external components.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra和HBase之间的一个关键区别在于，与HBase依赖于Hadoop的现有架构不同，Cassandra是独立的。Cassandra受亚马逊的Dynamo的启发来存储数据。简而言之，HBase的架构方法使得Region
    Server和DataNodes依赖于其他组件，如HBase master、Name Node、Zookeeper，而Cassandra中的节点在内部管理这些责任，因此不依赖于外部组件。
- en: A Cassandra cluster can be viewed as a ring of nodes, of which there are a few
    seeds. These seeds are like any node but are responsible for up-to-date cluster
    state data. In the event of a seed node going down, a new seed can be elected
    among the available nodes. The data is distributed evenly across the ring, depending
    on the hash value of the row key. In Cassandra, data can be queried according
    to its row-key. Clients for Cassandra come in many flavors; that is, Thrift is
    one of the most native clients that can be used to interact with the Cassandra
    ring. Apart from this, there are clients that expose the **Cassandra Query Language**
    (**CQL**) interface, which has quite a resemblance to SQL.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra集群可以被视为一个节点环，其中有一些种子节点。这些种子节点与任何节点相似，但负责最新的集群状态数据。如果种子节点出现故障，可以在可用节点中选举出一个新的种子。数据根据行键的哈希值均匀分布在环上。在Cassandra中，数据可以根据其行键进行查询。Cassandra的客户端有多种类型；也就是说，Thrift是最原生的客户端之一，可以用来与Cassandra环进行交互。除此之外，还有一些客户端暴露了与SQL非常相似的Cassandra查询语言（CQL）接口。
- en: '![Salient features of HBase and Cassandra](img/1794_01_09.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![HBase和Cassandra的显著特点](img/1794_01_09.jpg)'
- en: Cassandra nodes set up
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra节点设置
- en: '**Insertion of small and large data sets**: Both HBase and Cassandra are very
    good at the insertion of small data sets. The fact that both these datastores
    use multiple nodes to distribute writes on top of it. Both of them write the data
    first to memory-based storage such as RAM, which makes its insertion performance
    good.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入小型和大型数据集**：HBase和Cassandra都非常擅长插入小型数据集。事实上，这两种数据存储都使用多个节点来分发写入。它们都首先将数据写入基于内存的存储，如RAM，这使得其插入性能很好。'
- en: '**Random reads**: Both HBase and Cassandra are fast when it comes to read speeds.
    In HBase, consistency was one of the key features that was kept in mind when designing
    the architecture. In Cassandra, data consistency was kept tunable, but one has
    to sacrifice speed in order to have higher consistency.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机读取**：在读取速度方面，HBase和Cassandra都很快。在设计架构时，HBase考虑到了一致性是其中的一个关键特性。在Cassandra中，数据一致性是可调的，但为了获得更高的一致性，必须牺牲速度。'
- en: '**Eventual consistency**: HBase has strong consistency and Cassandra has eventual
    consistency, but interestingly, the consistency model in Cassandra is tunable.
    It can be tuned to have better consistency, but one has to give up performance
    in the read and write speeds.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终一致性**：HBase具有强一致性，Cassandra具有最终一致性，但有趣的是，Cassandra中的一致性模型是可调节的。它可以调整为具有更好的一致性，但必须在读写速度上牺牲性能。'
- en: '**Load balancing**: HBase and Cassandra have load balancing built into them.
    The idea is to have many nodes serving read and writes on a commodity grade node.
    Consistent hashing is used to distribute the load between the nodes.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡**：HBase和Cassandra内置了负载均衡。其想法是让许多节点在商品级节点上提供读写服务。一致性哈希用于在节点之间分配负载。'
- en: '**Sharding**: HBase and Cassandra both have sharding capability. This is essential
    since both claim to give good performance from a commodity grade node, which has
    limited disk and memory space.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分片**：HBase和Cassandra都具有分片能力。这是必不可少的，因为两者都声称可以从商品级节点获得良好的性能，而商品级节点的磁盘和内存空间有限。'
- en: '**Multi-data center support**: Of the two, Cassandra has multi-data center
    support.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多数据中心支持**：在这两者中，Cassandra具有多数据中心支持。'
- en: '**Scalability**: HBase and Cassandra have very good scalability, which was
    one of the design requirements.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：HBase和Cassandra都具有非常好的可扩展性，这是设计要求之一。'
- en: '**Manageability**: Of the two, Cassandra has better manageability. This is
    because in Cassandra, there are nodes to manage but in HBase, there are many components
    that need to work in tandem, such as Zookeeper, DataNode, Name Node, Region Server,
    and so on.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可管理性**：在这两者中，Cassandra的可管理性更好。这是因为在Cassandra中，需要管理节点，但在HBase中，有许多需要协同工作的组件，如Zookeeper、DataNode、Name
    Node、Region Server等。'
- en: '**Client**: Both HBase and Cassandra have clients in Java, Python, Ruby, Node.js,
    and many more, making it easy to work with heterogeneous environments.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：HBase和Cassandra都有Java、Python、Ruby、Node.js等客户端，使其在异构环境中易于使用。'
- en: Key value-oriented NoSQL
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 键值导向的NoSQL
- en: Key-value datastores are probably one of the fastest and simplest NoSQL databases.
    In their most simplistic form, they can be understood as a big hash table. From
    a usage perspective, every value stored in the database has a key. The key can
    be used to search for values and the values can be deleted by deleting the key.
    Some popular choices in key-value databases are Redis, Riak, Amazon's DynamoDB,
    project voldermort, and more.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 键值数据存储可能是最快和最简单的NoSQL数据库之一。在其最简单的形式中，它们可以被理解为一个大的哈希表。从使用的角度来看，数据库中存储的每个值都有一个键。键可以用来搜索值，通过删除键可以删除值。在键值数据库中一些受欢迎的选择包括Redis、Riak、亚马逊的DynamoDB、voldermort项目等。
- en: How does Redis fare in some of the nonfunctional requirements as a key-value
    datastore?
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Redis在作为键值数据存储的一些非功能性需求方面表现如何？
- en: 'Redis is one of the fastest key-value stores, which is seeing a very fast adoption
    throughout the industry, cutting across many domains. Since this book focuses
    on Redis, let''s find out a bit more about how Redis fares in some of the nonfunctional
    requirements in brief. We will be talking about them in length as the book progresses:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Redis是最快的键值存储之一，在整个行业中得到了非常快的采用，涵盖了许多领域。由于本书侧重于Redis，让我们简要了解一下Redis在一些非功能性需求方面的表现。随着本书的进展，我们将会更详细地讨论它们：
- en: '**Insertion of data sets**: The insertions of data sets is very fast in key-value
    datastores and Redis is no exception.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据集的插入**：在键值数据存储中，数据集的插入非常快，Redis也不例外。'
- en: '**Random reads**: Random reads are very fast in key-value datastores. In Redis,
    all the keys are stored in memory. This ensures faster lookups, so the read speeds
    are higher. While it will be great if all the keys and values are kept in memory,
    this has a drawback. The problem with this approach is that memory requirements
    will be very high. Redis takes care of this by introducing something called *virtual
    memory*. Virtual memory will keep all the keys in the memory but will write the
    least recently-used values to disk.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机读取**：在键值数据存储中，随机读取非常快。在Redis中，所有键都存储在内存中。这确保了更快的查找速度，因此读取速度更快。虽然如果所有键和值都保留在内存中将会很好，但这也有一个缺点。这种方法的问题在于内存需求会非常高。Redis通过引入一种称为*虚拟内存*的东西来解决这个问题。虚拟内存将所有键保留在内存中，但将最近未使用的值写入磁盘。'
- en: '**Fault tolerance**: Fault handling in Redis depends on the cluster''s topology.
    Redis uses the master-slave topology for its cluster deployment. All the data
    in the master is asynchronously copied to the slave; so, in case the master node
    goes to the failure state, one of the slave nodes can be promoted to master using
    the Redis sentinel.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容错性**：Redis中的故障处理取决于集群的拓扑结构。Redis在其集群部署中使用主从拓扑结构。主节点中的所有数据都会异步复制到从节点；因此，如果主节点进入故障状态，其中一个从节点可以通过Redis
    sentinel晋升为主节点。'
- en: '**Eventual consistency**: Key-value datastores have master-slave topology,
    which means that once the master is updated, all the slave nodes are updated asynchronously.
    This can be envisaged in Redis since slaves are used by clients for a read-only
    mode; it is possible that the master might have the latest value written but while
    reading from the slave, the client might get the stale value because the master
    has not updated the slaves. Thus, this lag can cause inconsistency for a brief
    moment.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终一致性**：键值数据存储具有主从拓扑结构，这意味着一旦主节点更新，所有从节点都会异步更新。这在Redis中可以想象，因为客户端使用从节点进行只读模式；可能主节点已经写入了最新值，但在从节点读取时，客户端可能会得到旧值，因为主节点尚未更新从节点。因此，这种滞后可能会导致短暂的不一致性。'
- en: '**Load balancing**: Redis has a simple way of achieving load balancing. As
    previously discussed, the master is used to write data, and slaves are used to
    read the data. So, the clients should have the logic built into them, have the
    read request evenly spread across the slave nodes, or use third-party proxies,
    such as Twemproxy to do so.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡**：Redis有一种简单的实现负载均衡的方法。如前所述，主节点用于写入数据，从节点用于读取数据。因此，客户端应该在其内部构建逻辑，将读取请求均匀分布在从节点上，或者使用第三方代理，如Twemproxy来实现。'
- en: '**Sharding**: It is possible to have datasets that are bigger than the available
    memory, which makes presharding the data across various peer nodes a horizontal
    scalable option.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分片**：可能会有比可用内存更大的数据集，这使得在各个对等节点之间预先分片数据成为一种水平可扩展的选择。'
- en: '**Multi-data center support**: Redis and key-value NoSQL do not provide inherent
    multi-data center support where the replications are consistent. However, we can
    have the master node in one data center and slaves in the other data center, but
    we will have to live with eventual consistency.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多数据中心支持**：Redis和键值NoSQL不提供内在的多数据中心支持，其中复制是一致的。但是，我们可以在一个数据中心拥有主节点，在另一个数据中心拥有从节点，但我们必须接受最终一致性。'
- en: '**Scalability**: When it comes to scaling and data partitioning, the Redis
    server lacks the logic to do so. Primarily, the logic to partition the data across
    many nodes should reside with the client or should use third-party proxies such
    as Twemproxy.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：在扩展和数据分区方面，Redis服务器缺乏相应的逻辑。主要的数据分区逻辑应该由客户端或者使用第三方代理（如Twemproxy）来实现。'
- en: '**Manageability**: Redis as a key value NoSQL is simple to manage.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可管理性**：Redis作为一个键值NoSQL数据库，管理起来很简单。'
- en: '**Client**: There are clients for Redis in Java, Python, and Node.js that implement
    the **REdis Serialization Protocol** (**RESP**).'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：Redis有Java、Python和Node.js的客户端，实现了**REdis Serialization Protocol**（RESP）。'
- en: Use cases of NoSQL
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NoSQL的用例
- en: Understand your business first; this will help you to understand your data.
    This will also give you deep insights on the kind of data layer that you need
    to have. The idea is to have a top-to-bottom design methodology. Deciding on the
    persistence mechanism first and then fitting the data for the business use case
    in that persistence mechanism is a bad idea (bottom-to-top design methodology).
    So, define your business requirements first, decide on the roadmap for the future,
    and then decide on the data layer. Another important factor to take into consideration
    when understanding the business requirements specification is to factor the nonfunctional
    requirements for every business use case, which I believe is paramount.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先了解你的业务；这将帮助你了解你的数据。这也将让你深入了解你需要拥有的数据层的类型。关键是要有一个自上而下的设计方法。首先决定持久性机制，然后将业务用例的数据适配到该持久性机制中是一个不好的想法（自下而上的设计方法）。因此，首先定义你的业务需求，然后决定未来的路线图，然后再决定数据层。在理解业务需求规范时，另一个重要因素是考虑每个业务用例的非功能性需求，我认为这是至关重要的。
- en: 'Failing to add a nonfunctional requirement in the business or, functional requirement
    causes problems when the system goes to performance test or worse, when it goes
    live. If you feel that the data model requires NoSQL from a functional requirement
    standpoint, then ask a few questions as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在业务或功能需求中没有添加非功能性需求，那么当系统进行性能测试或更糟的是上线时会出现问题。如果你觉得从功能需求的角度来看数据模型需要NoSQL，那么可以问一些问题，如下所示：
- en: What type of NoSQL do you need for the data model?
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的数据模型需要什么类型的NoSQL？
- en: How big can the data grow, and how much scalability is required?
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据可以增长到多大，需要多大的可扩展性？
- en: How will you handle node failure? What is its impact on your business use case?
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将如何处理节点故障？它对你的业务用例有什么影响？
- en: Which is better data replication or infrastructure investment when data is growing?
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据增长时，数据复制和基础设施投资哪个更好？
- en: What are the strategies for handling read/write loads and how much concurrency
    is planned?
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理读/写负载的策略是什么，计划的并发量有多大？
- en: What is the level of data consistency required for the business use case?
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务用例需要什么级别的数据一致性？
- en: How will the data reside (on a single data center or multiple data centers across
    geographies)?
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据将存放在哪里（单个数据中心还是跨地理位置的多个数据中心）？
- en: What are the clustering strategies and data synch strategies?
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群策略和数据同步策略是什么？
- en: What are the data backup strategies?
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据备份策略是什么？
- en: What kind of network topology do you plan to use? What is the impact of network
    latency on performance?
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你计划使用什么样的网络拓扑？网络延迟对性能有什么影响？
- en: How comfortable is the team in handling, monitoring, administrating, and developing
    in the polyglot persistence environment?
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队在处理、监控、管理和开发多语言持久性环境方面有多舒适？
- en: 'Here''s the summary of some of the NoSQL databases and how they are placed
    as per the CAP theorem. The following chart does not claim to be exhaustive, but
    is a snapshot of the most popular ones:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些NoSQL数据库及其根据CAP定理的放置方式的摘要。以下图表并不是详尽无遗的，但是是最受欢迎的数据库的一个快照：
- en: '![Use cases of NoSQL](img/1794_01_10.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![NoSQL的用例](img/1794_01_10.jpg)'
- en: NoSQL databases placed as per CAP theorem
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 根据CAP定理放置的NoSQL数据库
- en: 'Let''s analyze how companies are using NoSQL, which will give us ideas on how
    we can use NoSQL in our solutions effectively:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下公司如何使用NoSQL，这将给我们一些关于如何有效地在我们的解决方案中使用NoSQL的想法：
- en: '**Big data**: This very term evokes a picture of hundreds and thousands of
    servers crunching petabytes of data for analysis. The use case for big data is
    self-evident and simple to argue for using NoSQL datastores. Columnar databases,
    one of the patterns of NoSQL, are the obvious choice for this kind of activity.
    Being distributed in nature, these solutions also have no single point of failure,
    parallel computing, write availability, and scalability. The following is a sample
    list of the different types of use cases where companies have successfully used
    columnar datastores in their business:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大数据**：这个术语让人联想到数百甚至数千台服务器处理数据以进行分析。大数据的用例是不言而喻的，很容易证明使用NoSQL数据存储的必要性。作为NoSQL的一种模式，列式数据库是这种活动的明显选择。由于分布式的特性，这些解决方案也没有单点故障，可以进行并行计算、写入可用性和可扩展性。以下是一些不同类型的用例列表，其中公司已经成功地在他们的业务中使用了列式数据存储：'
- en: Spotify uses Hadoop for data aggregation, reporting, and analysis
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spotify使用Hadoop进行数据聚合、报告和分析
- en: Twitter uses Hadoop to process tweets and log files
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter使用Hadoop处理推文和日志文件
- en: Netflix uses Cassandra for their backend datastore in order to stream services
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netflix使用Cassandra作为其后端数据存储以提供流媒体服务
- en: Zoho uses Cassandra to generate inbox previews for mail services
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zoho使用Cassandra为邮件服务生成收件箱预览
- en: Facebook uses Cassandra for its Instagram operations
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Facebook使用Cassandra进行Instagram操作
- en: Facebook uses HBase in its message infrastructure
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Facebook在其消息基础设施中使用HBase
- en: Su.pr uses HBase for real-time data storage and the analytics platform
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Su.pr使用HBase进行实时数据存储和分析平台
- en: HP IceWall SSO uses HBase to store user data in order to authenticate users
    for their web-based single sign-on solution
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HP IceWall SSO使用HBase存储用户数据，以便为其基于Web的单点登录解决方案对用户进行身份验证
- en: '**Heavy read/write**: This nonfunctional requirement instantly gives us the
    impression of a social or a gaming website. For Enterprises where this is a requirement,
    they can take inspiration for the choice of NoSQL.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大量读/写**：这个非功能性需求立即让我们联想到社交或游戏网站。对于这是一个要求的企业，他们可以从NoSQL的选择中获得灵感。'
- en: LinkedIn uses Voldermort (the key-value datastore) to cater to millions of read
    and writes per day under a few milliseconds
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LinkedIn使用Voldermort（键值数据存储）为数百万读写每天提供服务，在几毫秒内完成
- en: Wooga (a social network game and mobile developer) uses Redis for its gaming
    platform; some of the games have a million plus users in a day
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wooga（社交网络游戏和移动开发者）使用Redis进行游戏平台；一些游戏每天有超过一百万用户
- en: Twitter caters to 200 million tweets a day and uses NoSQL, such as Cassandra,
    HBase, Memcached, and FlockDB, and also uses RDBMS, such as MySQL
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter每天处理2亿条推文，并使用NoSQL，如Cassandra、HBase、Memcached和FlockDB，还使用关系型数据库，如MySQL
- en: Stack overflow uses Redis to cater to 30 million registered users in a month
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Stack overflow使用Redis为每月3000万注册用户提供服务
- en: '**Document store**: The growth of Web 2.0 adoption and the rise in Internet
    content is creating data that is schema-less in nature. Having NoSQL (document-oriented)
    specially designed to store this kind of data makes the job of a developer simpler
    and the solution more stable in nature. Following are the examples of some companies
    that use different document stores:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档存储**：Web 2.0采用的增长和互联网内容的增加正在创造无模式的数据。专门设计用于存储这种数据的NoSQL（文档导向）使开发人员的工作更简单，解决方案的稳定性更强。以下是一些使用不同文档存储的公司的示例：'
- en: SourceForge uses MongoDB to store front pages, project pages, and download pages;
    Allura on SourceForge is based on MongoDB
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SourceForge使用MongoDB存储首页、项目页面和下载页面；SourceForge上的Allura基于MongoDB
- en: MetLife uses MongoDB for datastore for *the wall*, a customer service platform
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MetLife使用MongoDB作为*the wall*的数据存储，这是一个客户服务平台
- en: Semantic News Portal uses CouchDB to store news data
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Semantic News Portal使用CouchDB存储新闻数据
- en: Vermont public radio website's homepage uses CouchDB to stores news headlines,
    commentaries and more
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 佛蒙特公共广播网站的主页使用CouchDB存储新闻标题、评论等
- en: AOL advertising uses Couchbase (a new avatar of CouchDB) to serve billions of
    impressions a month for 100 million plus users
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AOL广告使用Couchbase（CouchDB的新化身）为10亿多用户提供每月数十亿次印象
- en: '**Real-time experience and e-commerce platform**: Shopping carts, user profile
    management, voting, user session management, real-time page counters, real-time
    analytics, and more are the services that are being offered by companies to give
    real-time experience to the end user. Following are the examples of some companies
    that use real-time experience and e-commerce platform:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时体验和电子商务平台**：购物车、用户资料管理、投票、用户会话管理、实时页面计数器、实时分析等是公司提供的服务，以给用户提供实时体验。以下是一些使用实时体验和电子商务平台的公司的示例：'
- en: Flickr push uses Redis to push real-time updates
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flickr push使用Redis推送实时更新
- en: Instagram uses Redis to store hundreds and millions of media content against
    keys and to serve them in real time
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Instagram使用Redis存储数以百万计的媒体内容，并实时提供服务
- en: Digg uses Redis for its page views and user clicks solution
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Digg使用Redis进行页面浏览和用户点击的解决方案
- en: Best Buy uses Riak for its e-commerce platform
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 百思买使用Riak进行电子商务平台
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you saw how the Internet world is undergoing a paradigm shift,
    the evolution of the NoSQL world, and how social media is championing NoSQL adoption.
    You also saw the various alternatives in the NoSQL world and how they equate.
    Finally, you saw how Redis maps up in the NoSQL ecosystem.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您看到互联网世界正在经历一场范式转变，NoSQL世界的演变，以及社交媒体如何领导NoSQL的采用。您还看到了NoSQL世界中的各种替代方案以及它们的等价性。最后，您看到了Redis如何在NoSQL生态系统中映射。
- en: In the next chapter, we will take a plunge into the world of Redis.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨Redis的世界。
