- en: Chapter 7. Redis in Business Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 Redis在商业应用程序中
- en: In [Chapter 6](ch06.html "Chapter 6. Redis in Web Applications"), *Redis in
    Web Applications*, you saw how Redis can be useful in web applications. This usefulness
    of Redis can be extended to business applications. As with any enterprise, the
    outer layer or the boundary application usually comprises of a web application,
    which in a way encapsulates the core heterogeneous business applications. These
    business applications form the core backbone of the enterprise.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章 Redis在Web应用程序中")中，*Redis在Web应用程序中*，你看到了Redis在Web应用程序中的用处。Redis的这种用处可以扩展到商业应用程序。与任何企业一样，外层或边界应用程序通常由Web应用程序组成，这在某种程度上封装了核心异构的业务应用程序。这些业务应用程序构成了企业的核心骨干。
- en: '![Redis in Business Applications](img/0123OS_07_01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Redis在商业应用程序中](img/0123OS_07_01.jpg)'
- en: Simple representation of application in an enterprise ecosystem
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 企业生态系统中应用程序的简单表示
- en: As many of you will have experienced in your projects and assignments over the
    years, these business applications are as varied as one can imagine in their business
    functionality. However, they all share some features and aspects that are common
    to most of them. In this chapter, we will take a few of these features and see
    how Redis fits into the landscape of business applications. To begin with, the
    most common and humble feature in any application is **configuration management**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你们在多年的项目和任务中所经历的那样，这些商业应用程序在业务功能上是多种多样的。然而，它们都有一些共同的特征和方面。在本章中，我们将介绍其中一些特征，并看看Redis如何适应商业应用程序的环境。首先，任何应用程序中最常见和最基本的特性就是**配置管理**。
- en: The subsequent topic takes into consideration configuration management and puts
    in Redis as a core component in constructing an enterprise-level application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 随后的主题考虑了配置管理，并将Redis作为构建企业级应用程序的核心组件之一。
- en: Configuration management
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置管理
- en: Very often, you may have seen improper configuration management or the lack
    of it create problems at a later point in the development and maintenance life
    cycles. Another problem is when scalability comes into picture and more nodes
    of software are added; then, maintaining state across all the nodes becomes a
    challenge. Business applications have been relying on RDBMS to store configuration
    data. The problem with this approach is performance; if the design is **PULL**-based
    and the problem with **PULL**-based design is performance penalty. Another problem
    is if the concurrency is high (because of other business functionalities), then
    these RDBMS also have to cater to these requests as well as the requests for configuration
    data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 经常会看到不当的配置管理或缺乏配置管理在开发和维护周期的后期造成问题。另一个问题是当可伸缩性成为问题时，添加更多的软件节点；然后，跨所有节点维护状态就成为一个挑战。商业应用程序一直依赖于RDBMS来存储配置数据。这种方法的问题在于性能；如果设计是**基于PULL**的，那么**PULL**-based设计的问题就是性能惩罚。另一个问题是如果并发性高（因为其他业务功能），那么这些RDBMS也必须满足这些请求以及配置数据的请求。
- en: '![Configuration management](img/0123OS_07_02.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![配置管理](img/0123OS_07_02.jpg)'
- en: PULL-based design for config management
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 基于PULL的配置管理设计
- en: The idea is to convert the design from **PULL**-based to **PUSH**-based. The
    big advantage of this technique is performance. The state or configuration data
    stays close to the application, and whenever change takes place, the data is pushed
    to the local cache of the application. Another requirement is to have a system
    that is low on the compute resource footprint.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是将设计从**基于PULL**改为**基于PUSH**。这种技术的最大优势是性能。状态或配置数据保持接近应用程序，每当发生变化时，数据就会被推送到应用程序的本地缓存中。另一个要求是要有一个在计算资源占用方面较低的系统。
- en: '![Configuration management](img/0123OS_07_03.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![配置管理](img/0123OS_07_03.jpg)'
- en: PUSH-based design for config management
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 基于PUSH的配置管理设计
- en: Redis with its Swiss knife-like capability, low resource footprint, availability
    of client libraries in various languages, and capability to scale massively makes
    it a good candidate to be used to take care of this requirement. The sample application
    that we are going to discuss in subsequent topics will highlight that. This sample
    application is just for demo and does not take any guarantee in the production
    environment. So, let's have some fun developing one configuration management server
    with Redis as the backbone, and let's call it the **gossip server**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Redis凭借其类似瑞士军刀的功能、低资源占用、各种语言的客户端库的可用性以及大规模扩展的能力，使其成为处理这一需求的良好选择。我们将在随后的主题中讨论的示例应用程序将突出这一点。这个示例应用程序只是用于演示，并不保证在生产环境中使用。所以，让我们开心地开发一个以Redis为支撑的配置管理服务器，并称之为**gossip
    server**。
- en: Gossip server
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gossip server
- en: 'The gossip server is a centralized node that manages configuration data and
    groups services in a synchronized way. The **Gossip Server** will hold data and
    will be managed by a node called the **Gossip Server (Admin)**. The **Gossip Server**
    in turn will manage all the other nodes hooked to it. The following diagram depicts
    that it is the responsibility of the gossip server to push configuration data
    to all the nodes that are connected to it:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: gossip server是一个集中管理配置数据并以同步方式分组服务的节点。**Gossip Server**将保存数据，并由一个名为**Gossip
    Server (Admin)**的节点管理。**Gossip Server**反过来将管理连接到它的所有其他节点。以下图表描述了gossip server的责任是将配置数据推送到连接到它的所有节点：
- en: '![Gossip server](img/0123OS_07_04.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Gossip server](img/0123OS_07_04.jpg)'
- en: Gossip Server design overview
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Gossip Server设计概述
- en: Internal to this gossip server is the Redis server, which provides all the capabilities
    that might be required by the proposed configuration management system. The nodes
    can be implemented in any programming language, but keeping in tradition with
    the examples in the book, we are going to use Java as the language of implementation
    in this example. The main idea of this gossip server is to keep aside a common
    component for configuration management the next time that you need to architect
    or design an enterprise grade solution, and to keep in mind Redis when doing so.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个八卦服务器内部是Redis服务器，它提供了所提议的配置管理系统可能需要的所有功能。节点可以用任何编程语言实现，但是为了与本书中的示例保持一致，我们将在这个示例中使用Java作为实现语言。这个八卦服务器的主要思想是在下次需要设计企业级解决方案时，为配置管理保留一个共同的组件，并在这样做时牢记Redis。
- en: Before we get into the implementation and design specifications of our common
    component, let's agree upon the capabilities of this gossip server.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入我们共同组件的实施和设计规范之前，让我们就这个八卦服务器的功能达成一致。
- en: 'The following are the capabilities of the gossip server:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是八卦服务器的功能：
- en: The gossip server maintains all the information or configuration data
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 八卦服务器维护所有信息或配置数据
- en: It acts like a hub and distributes the information or configuration data to
    all the connected nodes
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它充当中心枢并将信息或配置数据分发给所有连接的节点
- en: All the nodes, including the master node, connect to the hub in order to send
    messages
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有节点，包括主节点，都连接到中心枢以发送消息
- en: The master node is responsible for pushing data to a specific client node or
    all the client nodes
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主节点负责向特定客户端节点或所有客户端节点推送数据
- en: All the client nodes are in the same position in the hierarchy
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有客户端节点在层次结构中处于相同位置
- en: All the client nodes can be embedded in the solutions that are to be made a
    part of this configuration management
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有客户端节点可以嵌入到要成为配置管理一部分的解决方案中
- en: The nodes have a life cycle and they are managed by themselves
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点有一个生命周期，它们由自己管理
- en: The nodes, when they change state, inform the master and other peer client nodes
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当节点改变状态时，它们会通知主节点和其他对等客户端节点
- en: The nodes can also send messages to other peer nodes if the business logic demands
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点也可以根据业务逻辑向其他对等节点发送消息
- en: Node
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 节点
- en: A node in the gossip server is the client component between which all the messages
    flow. In the current example, the node can be classified into two types, client
    nodes and the master node.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 八卦服务器中的节点是所有消息流动的客户端组件。在当前示例中，节点可以分为两种类型，客户端节点和主节点。
- en: The client node is inherently meant to be the component that can be plugged
    into any solution where there is a need for configuration management. The client
    nodes are responsible for the application data that they store in Redis. Data
    in the node can come either from the application they are plugged into or from
    the master node, which can push the data to the client node. The whole idea behind
    allowing the master node to push data or rather publish data into the gossip server
    is to spread the control of the configuration data of the application from the
    application itself to another source. The benefit of doing this will be to take
    out the responsibility of the configuration data management from the application
    and have a centralized node from where data can be managed. Another advantage
    is that new configuration data can be introduced into the application at runtime
    without stopping the application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端节点本质上是可以插入任何需要配置管理的解决方案中的组件。客户端节点负责它们在Redis中存储的应用程序数据。节点中的数据可以来自它们所插入的应用程序，也可以来自主节点，主节点可以将数据推送到客户端节点。允许主节点推送数据或者发布数据到八卦服务器的整个想法是将应用程序的配置数据管理责任从应用程序本身转移到另一个源头。这样做的好处是可以在运行时将新的配置数据引入应用程序，而无需停止应用程序。
- en: 'The following diagram is a representation of the configuration data pushing
    capability of the gossip server:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表是八卦服务器的配置数据推送能力的表示：
- en: '![Node](img/0123OS_07_05.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![节点](img/0123OS_07_05.jpg)'
- en: Pushing data into Gossip Server either via application or master node
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用程序或主节点将数据推送到八卦服务器
- en: 'Before we go further into the implementation, it''s better to understand the
    various states that the client node can traverse in its life cycle. The following
    diagram is a snapshot of the various paths that the client node can take:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步实施之前，最好了解客户端节点在其生命周期中可以遍历的各种状态。以下图表是客户端节点可以采取的各种路径的快照：
- en: '![Node](img/0123OS_07_06.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![节点](img/0123OS_07_06.jpg)'
- en: Pushing data into Gossip Server either via application or master node
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用程序或主节点将数据推送到八卦服务器
- en: The client node begins its journey with **Register**. After **Register**, the
    client node needs to **Activate** itself. Once the client node is activated, it
    can either **Passivate** itself or reach the **Archive** state. The **Archive**
    state can be achieved if the application is brought down or a `Kill` command is
    sent by the master node. Once the client node is in the **Passivate** state, it
    can be made **Activate** through an intermediate state of **Reactivate**. If the
    client node is in the **Archive** state, it can be brought to the **Activate**
    state via an intermediary state of **Reconnect**.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端节点从**注册**开始其旅程。在**注册**之后，客户端节点需要**激活**自己。一旦客户端节点被激活，它可以**停用**自己或者达到**归档**状态。**归档**状态可以通过关闭应用程序或者主节点发送`Kill`命令来实现。一旦客户端节点处于**停用**状态，它可以通过中间状态**重新激活**来激活自己。如果客户端节点处于**归档**状态，它可以通过中间状态**重新连接**来转换为**激活**状态。
- en: The commands for the client node are modelled around the mentioned states, and
    there are other commands for the management of data and for messaging data around
    the ecosystem. Without wasting much time, let's dive into the design of the system.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端节点的命令围绕着上述状态进行建模，并且还有其他用于数据管理和在生态系统中传递数据的命令。不浪费时间，让我们深入了解系统的设计。
- en: Layered design
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分层设计
- en: 'The design for the gossip server is minimalistic and very simple to follow,
    but there are certain considerations to be kept in mind. As discussed, the nodes
    participating in the gossip server are of two types: client nodes and master nodes.
    Every client node is responsible for its own life cycle, and the master node has
    limited control over it. The nodes can communicate with each other by passing
    messages. The design includes four primary layers, as depicted in the following
    diagram:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 八卦服务器的设计是极简主义的，非常简单易懂，但有一些需要考虑的事项。正如讨论的那样，参与八卦服务器的节点有两种类型：客户端节点和主节点。每个客户端节点对自己的生命周期负责，主节点对其有有限的控制。节点可以通过传递消息与彼此通信。设计包括四个主要层，如下图所示：
- en: '![Layered design](img/0123OS_07_07.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![分层设计](img/0123OS_07_07.jpg)'
- en: Gossip Server structural layers overview
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 八卦服务器结构层概述
- en: 'The packages in the gossip server correspond to the layers described in the
    preceding diagram and include a few extra. Let''s have a brief introduction of
    the packages and the classes they contain. Here''s a list of the packages and
    the layers they correspond to:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 八卦服务器中的包对应于前面图表中描述的层，并包括一些额外的内容。让我们简要介绍一下这些包和它们包含的类。以下是包和它们对应的层的列表：
- en: '`org.redisch7.gossipserver.shell`: This corresponds to the **Shell layer**'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.redisch7.gossipserver.shell`: 这对应于**Shell层**'
- en: '`org.redisch7.gossipserver.commands`: This corresponds to the **Command layer**'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.redisch7.gossipserver.commands`: 这对应于**命令层**'
- en: '`org.redisch7.gossipserver.commandhandlers`: This corresponds to the **Command
    Handler layer**'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.redisch7.gossipserver.commandhandlers`: 这对应于**命令处理层**'
- en: '`org.redisch7.gossipserver.datahandler`: This corresponds to the **Data Handler
    layer**'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.redisch7.gossipserver.datahandler`: 这对应于**数据处理层**'
- en: '`org.redisch7.gossipserver.util.commandparser`: This is a utility package'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.redisch7.gossipserver.util.commandparser`: 这是一个实用程序包'
- en: Shell
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Shell
- en: 'Shell is a program that acts like a standalone gateway to the gossip server
    as well as a plugin to an application that wants to use the gossip server. The
    shell activates the node, which in turn prepares the listeners and the command
    library for the node. As discussed, there are two types of nodes: client nodes
    and master nodes; a detailed discussion of these nodes is done in the latter portion
    of the chapter.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Shell是一个程序，它像一个独立的网关一样作用于八卦服务器，同时也是一个应用程序的插件，该应用程序想要使用八卦服务器。Shell激活节点，节点又为节点准备监听器和命令库。正如讨论的那样，有两种类型的节点：客户端节点和主节点；这些节点的详细讨论在本章的后半部分进行。
- en: '![Shell](img/0123OS_07_08.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Shell](img/0123OS_07_08.jpg)'
- en: Interaction with shell
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与shell的交互
- en: 'The code for the gossip server is simple and basically commands delegation
    to the node for processing. In the case of Shell as a standalone program, the
    response is displayed in Command Prompt, whereas in the case of Shell as an API
    plugin, the result object `CheckResult` is passed back to the program calling
    it. Shell is implemented as a singleton. This is the code for `Shell.java`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 八卦服务器的代码很简单，基本上是将命令委托给节点进行处理。在Shell作为独立程序的情况下，响应显示在命令提示符中，而在Shell作为API插件的情况下，结果对象`CheckResult`被传递回调用它的程序。Shell被实现为单例。这是`Shell.java`的代码：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Listeners
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监听器
- en: Listeners are spawned by nodes and execute independently of the thread executing
    the Shell. The basic job of a listener is to constantly listen for any message
    event coming to the node. The message is then parsed and executed accordingly.
    The basic idea is to provide a mechanism for the nodes to interact with each other.
    In the current implementation, it's the master node that interacts with the client
    nodes. This provides a limited remote control of the master over the client nodes.
    The implementation for the other way around communication is not done and can
    be incorporated easily if the need arises, that is, if the client nodes interact
    with the master node. Not all commands can be remotely executed on client nodes
    via this arrangement. Commands that can be executed remotely (by the master node)
    are `SET`, `KILL`, and `CLONE`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 监听器由节点生成并独立于执行Shell的线程执行。监听器的基本工作是不断监听传递给节点的任何消息事件。然后解析并相应执行消息。基本思想是为节点提供相互交互的机制。在当前的实现中，是主节点与客户端节点进行交互。这提供了主节点对客户端节点的有限远程控制。另一种通信方式的实现尚未完成，如果需要的话可以很容易地加入，即客户端节点与主节点进行交互。并非所有命令都可以通过这种安排在客户端节点上远程执行。可以远程执行（由主节点）的命令有`SET`、`KILL`和`CLONE`。
- en: '![Listeners](img/0123OS_07_09.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![监听器](img/0123OS_07_09.jpg)'
- en: Relation between Node, Message Listener Manager, Meassage Listeners, and Subscriber
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 节点、消息监听器管理器、消息监听器和订阅者之间的关系
- en: Listeners internally have a subscriber that extends the `JedisPubSub` abstract
    class, which is Jedis's client library's hook to Redis's messaging capability.
    The node maintains the life cycle of the listeners. The node activates the listeners
    on some commands, such as **Activate**, **Reconnect**, and so on, and deactivates
    on some commands, such as `Passivate`, `KILL`, and so on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 监听器内部有一个订阅者，它扩展了`JedisPubSub`抽象类，这是Jedis客户端库对Redis消息传递能力的钩子。节点维护着监听器的生命周期。节点在一些命令上激活监听器，比如**激活**、**重新连接**等，而在一些命令上停用监听器，比如`停用`、`KILL`等。
- en: 'Here''s the code for the client listener, which is `ClientEventMessageListener`.Java:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '这是客户端监听器的代码，即`ClientEventMessageListener`.Java:'
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here''s the code for the master listener, that is, `MasterEventMessageListener.java`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主监听器的代码，即`MasterEventMessageListener.java`：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Listener manager
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 监听器管理器
- en: '**Listener managers** are responsible for maintaining the life cycle of the
    listeners. Listeners can either exist in the start mode or in the stop mode. The
    gossip server has an event-oriented design; therefore, on every event that the
    client node accepts, there is a corresponding command that gets executed.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**监听管理器**负责维护监听器的生命周期。监听器可以存在于启动模式或停止模式。Gossip服务器具有面向事件的设计；因此，客户端节点接受的每个事件都有一个相应的命令被执行。'
- en: In the system, there are two types of listener managers, one for the client
    node called the client node listener manager and the other for the master node
    called master node listener manager.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统中，有两种类型的监听管理器，一个是针对客户端节点的称为客户端节点监听管理器，另一个是针对主节点的称为主节点监听管理器。
- en: The client node listener manager is programmed to start the listeners on commands
    such as `Activate`, `Reactivate`, and `Reconnect` and to stop the listeners on
    commands such as `Passivate` and `Kill`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端节点监听管理器被编程为在“激活”、“重新激活”和“重新连接”等命令上启动监听器，并在“停用”和“终止”等命令上停止监听器。
- en: The master node listener manager is programmed to start the listener on commands
    such as `Start` and to stop on commands such as `Stop`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 主节点监听管理器被编程为在“启动”等命令上启动监听器，并在“停止”等命令上停止监听器。
- en: 'The following is the code for `ClientNodeListenerManager.java`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是“ClientNodeListenerManager.java”的代码：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here''s the code for `MasterNodeListenerManager.java`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是“MasterNodeListenerManager.java”的代码：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The data handler layer
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据处理层
- en: This layer or package is straightforward in its activity, such as interacting
    with the Redis server. This layer is responsible for encapsulating Redis from
    the rest of the application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个层或包在其活动中非常直接，比如与Redis服务器交互。这一层负责将Redis封装起来，使其与应用程序的其余部分隔离开来。
- en: '![The data handler layer](img/0123OS_07_10.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![数据处理层](img/0123OS_07_10.jpg)'
- en: Gossip Server structural layers overview
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Gossip服务器结构层概述
- en: 'The following are the data structures used for the current application:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是当前应用程序使用的数据结构：
- en: '**Registration holder**: This is going to be implemented as a Set in the Redis
    datastore. This will hold all the nodes that are going to be registered in the
    system.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注册持有者**：这将作为Redis数据存储中的一个集合来实现。这将保存系统中将要注册的所有节点。'
- en: '**Activation holder**: This is going to be implemented as a Set in the Redis
    data store. This will hold all the nodes that are going to be in the `Active`
    state.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**激活持有者**：这将作为Redis数据存储中的一个集合来实现。这将保存所有将处于“激活”状态的节点。'
- en: '**Passivation holder**: This is going to be implemented as a Set in the Redis
    data store. This will hold all the nodes that are going to be in the **Passive**
    state.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停用持有者**：这将作为Redis数据存储中的一个集合来实现。这将保存所有将处于**停用**状态的节点。'
- en: '**Configuration store**: This is going to be implemented as a Map in the Redis
    data store. This will hold all the configuration data pertaining to a node in
    the name-value format.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置存储**：这将作为Redis数据存储中的一个映射来实现。这将保存所有与节点相关的配置数据，以名称-值格式进行存储。'
- en: '**Archive store**: This is going to be implemented as a File store in the local
    file system of the client node. This will hold all the configuration data pertaining
    to a node in the name-value format that is going to be archived in the JSON format.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存档存储**：这将作为客户端节点本地文件系统中的文件存储来实现。这将保存所有与节点相关的配置数据，以名称-值格式进行存档，并以JSON格式存档。'
- en: The most important class in this layer is `JedisUtilImpl`; let's spend some
    time understanding this class. The very nature of this class makes this class
    pretty big but easy to understand.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层中最重要的类是“JedisUtilImpl”；让我们花一些时间来了解这个类。这个类的性质使得这个类非常庞大但易于理解。
- en: JedisUtil.java
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JedisUtil.java
- en: This class is instrumental in conversing with the data store. All the logic
    around managing the account, state, and data of a node is managed here.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类在与数据存储进行交互时起着关键作用。所有关于管理节点帐户、状态和数据的逻辑都在这里管理。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we are using `jedis_2.1.0` as our choice of client API in order to
    connect to Redis. There is a bug related to using `MULTI` in `PIPELINE` functions
    with this version of the client library.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们选择使用`jedis_2.1.0`作为客户端API来连接Redis。在这个客户端库的这个版本中，使用`PIPELINE`函数中的`MULTI`存在一个相关的bug。
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since Redis is single-thread server, we have sacrificed the use of `MULTI` in
    `PIPELINE` for this application, as this will have no implications on the sanctity
    of the data in Redis and minimally affect the performance. We have gone ahead
    with sending our commands singularly and not in bulk, as in the case of `PIPELINE`.
    The future API of Jedis might have a solution for this, and it is up to you to
    change the class as you see fit if you are using a newer version of Jedis.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Redis是单线程服务器，我们牺牲了在这个应用程序中使用`PIPELINE`中的`MULTI`，因为这不会对Redis中的数据完整性产生影响，并且对性能的影响很小。我们继续以单个命令发送命令，而不是批量发送，就像`PIPELINE`的情况一样。Jedis的未来API可能会对此有解决方案，如果您使用更新版本的Jedis，您可以根据需要更改类。
- en: Client implementation in other languages or other client implementations for
    Redis in Java, will not have a problem as this is specific to Jedis.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中实现客户端或在Java中实现Redis的其他客户端实现，不会有问题，因为这是特定于Jedis的。
- en: 'Now that we have an understanding of the `JedisUtil` class, we in a way understand
    the working of the gossip server and the capabilities that the gossip server has
    to offer. So, let''s focus on the commands and how they are implemented. As a
    rule of thumb, the flow of data can be summarized as shown in the following diagram:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对“JedisUtil”类有了一定的了解，我们也在某种程度上了解了gossip服务器的工作原理以及gossip服务器所提供的功能。因此，让我们专注于命令以及它们是如何实现的。作为一个经验法则，数据流可以总结如下图所示：
- en: '![JedisUtil.java](img/0123OS_07_11.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![JedisUtil.java](img/0123OS_07_11.jpg)'
- en: Sequence of flow of data in a command
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的数据流顺序
- en: Client node commands
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端节点命令
- en: 'The following is a list of commands that can be fired from client nodes:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以从客户端节点触发的命令列表：
- en: The `register` command
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “注册”命令
- en: The `activate` command
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “激活”命令
- en: The `set` command
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “设置”命令
- en: The `get` command
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取命令
- en: The `status` command
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态命令
- en: The `del` command
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除命令
- en: The `passivate` command
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停用命令
- en: The `reacyivate` command
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reacyivate`命令'
- en: The `archive` command
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存档命令
- en: The `sync` command
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步命令
- en: The `reconnect` command
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新连接命令
- en: Let's take a look at each command from a design and implementation perspective.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设计和实现的角度来看每个命令。
- en: The register command
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册命令
- en: This command will register the node into the gossip server ecosystem. The precondition
    for executing this command is that the node name should be unique; otherwise,
    a response of failure will be sent to the **Shell**. The node name will be stored
    in the Registration holder, which is implemented as a Set data structure in Redis.
    Apart from this, when the registration process takes place, an archive file is
    created in the local machine of the node.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将注册节点进入八卦服务器生态系统。执行此命令的先决条件是节点名称应该是唯一的；否则，将向**Shell**发送失败响应。节点名称将存储在Registration
    holder中，该holder在Redis中实现为Set数据结构。除此之外，在注册过程发生时，节点的本地机器上将创建一个存档文件。
- en: '![The register command](img/0123OS_07_12.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![注册命令](img/0123OS_07_12.jpg)'
- en: Sequence of flow of data in a Register command
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注册命令中数据流的顺序
- en: 'The syntax for this command is: `register`. The following screenshot shows
    the response in the Shell console:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的语法是：`register`。以下屏幕截图显示了Shell控制台中的响应：
- en: '![The register command](img/0123OS_07_13.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![注册命令](img/0123OS_07_13.jpg)'
- en: Implementation of RegisterCommand
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RegisterCommand的实现
- en: 'The RegisterCommand is implemented as shown in the following code snippet:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: RegisterCommand的实现如下所示：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Implementation of RegisterCommandHandler
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RegisterCommandHandler的实现
- en: 'The RegisterCommandHandler is implemented as shown in the following code snippet:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: RegisterCommandHandler的实现如下所示：
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The activate command
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 激活命令
- en: This command will activate the node into the gossip server ecosystem. The precondition
    for executing this command is that the node should be registered. When the node
    is activated, an entry is added to the ACTIVATION-HOLDER, which is implemented
    as Set in Redis. Apart from this, on activation, the client node will spawn listeners,
    which will be up and ready to listen to any event that can come from the master.
    The listeners will be basically listening for events on a separate thread.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将激活节点进入八卦服务器生态系统。执行此命令的先决条件是节点应该已注册。激活节点时，将向ACTIVATION-HOLDER添加一个条目，该条目在Redis中实现为Set。除此之外，在激活时，客户端节点将生成监听器，这些监听器将准备好监听来自主节点的任何事件。这些监听器基本上将在单独的线程上监听事件。
- en: '![The activate command](img/0123OS_07_14.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![激活命令](img/0123OS_07_14.jpg)'
- en: Sequence of flow of data in Activate command
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 激活命令中数据流的顺序
- en: 'The syntax for this command is: `activate`. The following screenshot shows
    the response in the shell console:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的语法是：`activate`。以下屏幕截图显示了Shell控制台中的响应：
- en: '![The activate command](img/0123OS_07_15.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![激活命令](img/0123OS_07_15.jpg)'
- en: Implementation of ActivateCommand
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ActivateCommand的实现
- en: 'The ActivateCommand is implemented as shown in the following code snippet:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ActivateCommand的实现如下所示：
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Implementation of ActivateCommandHandler
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ActivateCommandHandler的实现
- en: 'The ActivateCommandHandler is implemented as shown in the following code snippet:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ActivateCommandHandler的实现如下所示：
- en: '[PRE9]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The set command
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置命令
- en: This command will set the data in the nodes. The precondition for executing
    this command is that the node should be in the activated state. The command is
    going to insert the name values into the node's *Config-store*. The *Config store*
    is implemented as the Hashes data structure in Redis. As evident, multiple name-value
    pairs can be inserted in the *Config store*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将设置节点中的数据。执行此命令的先决条件是节点应该处于激活状态。该命令将插入名称值到节点的*Config-store*中。*Config store*在Redis中实现为Hashes数据结构。显然，可以在*Config
    store*中插入多个名称值对。
- en: '![The set command](img/0123OS_07_16.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![设置命令](img/0123OS_07_16.jpg)'
- en: Sequence of flow of data in Set command
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 设置命令中数据流的顺序
- en: 'The syntax for this command is: `set <name=value>,<name=value>`. The following
    screenshot shows the response in the Shell console:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的语法是：`set <name=value>,<name=value>`。以下屏幕截图显示了Shell控制台中的响应：
- en: '![The set command](img/0123OS_07_17.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![设置命令](img/0123OS_07_17.jpg)'
- en: Implementation of SetCommand
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SetCommand的实现
- en: 'The SetCommand is implemented as shown in the following lines of code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: SetCommand的实现如下所示：
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Implementation of SetCommandHandler
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SetCommandHandler的实现
- en: 'The `set` command handler is implemented as shown here:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 设置命令处理程序的实现如下所示：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The get command
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取命令
- en: This command will get the data from the nodes. The precondition for executing
    this command is that the node should be in the activated state. The input will
    be a list of variables and the data needs to be picked up from the Config store.
    Every node will have its own Config store.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将从节点获取数据。执行此命令的先决条件是节点应该处于激活状态。输入将是一个变量列表，数据需要从Config存储中获取。每个节点都将有自己的Config存储。
- en: '![The get command](img/0123OS_07_18.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![获取命令](img/0123OS_07_18.jpg)'
- en: Sequence of flow of data in Get command
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 获取命令中数据流的顺序
- en: 'The syntax foe this command is: `get`. The following screenshot shows the response
    in the shell console:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的语法是：`get`。以下屏幕截图显示了Shell控制台中的响应：
- en: '![The get command](img/0123OS_07_19.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![获取命令](img/0123OS_07_19.jpg)'
- en: Implementation of GetCommand
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GetCommand的实现
- en: 'The GetCommand is implemented as shown in the following code snippet:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: GetCommand的实现如下所示：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Implementation of GetCommandHandler
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GetCommandHandler的实现
- en: 'The `get` command handler is implemented as shown here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 获取命令处理程序的实现如下所示：
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The del command
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除命令
- en: This command will delete the data in the nodes. The precondition for executing
    this command is that the node should be activated. The command will be executed
    by passing the name of the variable that needs to be deleted.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将删除节点中的数据。执行此命令的先决条件是节点应该处于激活状态。通过传递需要删除的变量的名称来执行命令。
- en: '![The del command](img/0123OS_07_20.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![删除命令](img/0123OS_07_20.jpg)'
- en: Sequence of flow of data in Delete command
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Delete命令中数据流的顺序
- en: 'The syntax for this command is: `del <parameter>`. The following screenshot
    shows the response in the shell console:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的语法是：`del <parameter>`。以下截图显示了shell控制台中的响应：
- en: '![The del command](img/0123OS_07_21.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![删除命令](img/0123OS_07_21.jpg)'
- en: Implementation of DeleteCommand
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DeleteCommand的实现
- en: 'The DeleteCommand is implemented as shown in the following code snippet:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: DeleteCommand的实现如下所示：
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Implementation of DeleteCommandHandler
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DeleteCommandHandler的实现
- en: 'The `delete` command handler is implemented as shown here:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`命令处理程序的实现如下所示：'
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The status command
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态命令
- en: This command is used to get the current status of a node. The precondition for
    executing this command is that the node should be in some state. The command in
    the client focuses on the data of the client node.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令用于获取节点的当前状态。执行此命令的前提条件是节点应处于某种状态。客户端中的命令关注客户端节点的数据。
- en: '![The status command](img/0123OS_07_22.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![状态命令](img/0123OS_07_22.jpg)'
- en: Sequence of flow of data in Passivate command
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Passivate命令中数据流的顺序
- en: 'The syntax for this command is: `status`. The following screenshot shows the
    response in the shell console:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的语法是：`status`。以下截图显示了shell控制台中的响应：
- en: '![The status command](img/0123OS_07_23.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![状态命令](img/0123OS_07_23.jpg)'
- en: Implementation of StatusCommand
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: StatusCommand的实现
- en: 'The `status` command is implemented as shown in the following code snippet:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`status`命令的实现如下所示：'
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Implementation of StatusCommandHandler
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: StatusCommandHandler的实现
- en: 'The `passive` command handler is implemented as shown here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`passive`命令处理程序的实现如下所示：'
- en: '[PRE17]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The passivate command
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: passivate命令
- en: This command will passivate the node into the gossip server ecosystem. The precondition
    for executing this command is that the node should be in the activated state.
    On passivation, the client's event listeners will be shut down and will not be
    in a position to take events from the master. Since the node is passivated, the
    data in the node's Config store will be taken and pushed into the archive file
    of the node.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将节点转为gossip服务器生态系统中的被动状态。执行此命令的前提条件是节点应处于激活状态。在被动化时，客户端的事件监听器将被关闭，并且将无法接收来自主节点的事件。由于节点被动化，节点的Config存储中的数据将被取出并推送到节点的归档文件中。
- en: '![The passivate command](img/0123OS_07_24.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![passivate命令](img/0123OS_07_24.jpg)'
- en: Sequence of flow of data in Passivate command
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Passivate命令中数据流的顺序
- en: 'The syntax for this command is: `passivate`. The following screenshot shows
    the response in the shell console:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的语法是：`passivate`。以下截图显示了shell控制台中的响应：
- en: '![The passivate command](img/0123OS_07_25.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![passivate命令](img/0123OS_07_25.jpg)'
- en: Implementation of PassivateCommand
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PassivateCommand的实现
- en: 'The `passivate` command is implemented as shown in the following code snippet:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`passivate`命令的实现如下所示：'
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Implementation of PassivateCommandHandler
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PassivateCommandHandler的实现
- en: 'The `passivate` command handler is implemented as shown in the following code
    snippet:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`passivate`命令处理程序的实现如下所示：'
- en: '[PRE19]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The reactivate command
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: reactivate命令
- en: This command will reactivate the node. The precondition for executing this command
    is that the node should be in the passive mode. Upon reactivation, the client's
    event listener will be spawned once again. The data in the archive file will be
    pumped back again to the node's Config store.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将重新激活节点。执行此命令的前提条件是节点应处于被动模式。重新激活后，客户端的事件监听器将再次启动。归档文件中的数据将再次被泵回节点的Config存储中。
- en: '![The reactivate command](img/0123OS_07_26.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![reactivate命令](img/0123OS_07_26.jpg)'
- en: Sequence of flow of data in Reactivate command
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Reactivate命令中数据流的顺序
- en: 'The syntax for this command is: `reactivate`. The following screenshot shows
    the response in the shell console:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的语法是：`reactivate`。以下截图显示了shell控制台中的响应：
- en: '![The reactivate command](img/0123OS_07_27.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![reactivate命令](img/0123OS_07_27.jpg)'
- en: Implementation of ReactivateCommand
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ReactivateCommand的实现
- en: 'The `passivate` command is implemented as shown here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`passivate`命令的实现如下所示：'
- en: '[PRE20]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Implementation of ReactivateCommandHandler
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ReactivateCommandHandler的实现
- en: 'The `reactivate` command handler is implemented as shown here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`reactivate`命令处理程序的实现如下所示：'
- en: '[PRE21]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The archive command
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 归档命令
- en: This `command` will archive the data of a node in the gossip server ecosystem.
    The precondition for executing this command is that the node should be in the
    registered mode. When this command is issued, the data in the node's Config store
    will be flushed and put into an archive file in the filesystem of the client node's
    machine.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此`command`将对gossip服务器生态系统中的节点数据进行归档。执行此命令的前提条件是节点应处于注册模式。当发出此命令时，节点的Config存储中的数据将被刷新并放入客户端节点机器的文件系统中的归档文件中。
- en: '![The archive command](img/0123OS_07_28.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![archive命令](img/0123OS_07_28.jpg)'
- en: Sequence of flow of data in Archive command
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Archive命令中数据流的顺序
- en: 'The syntax for this command is: `archive`. The following screenshot shows the
    response in the shell console:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的语法是：`archive`。以下截图显示了shell控制台中的响应：
- en: '![The archive command](img/0123OS_07_29.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![archive命令](img/0123OS_07_29.jpg)'
- en: Implementation of ArchiveCommand
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ArchiveCommand的实现
- en: 'The `archive` command is implemented as shown in the following code snippet:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`archive`命令的实现如下所示：'
- en: '[PRE22]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Implementation of ArchiveCommandHandler
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ArchiveCommandHandler的实现
- en: 'The `reactive` command handler is implemented as shown in the following code
    snippet:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`reactive`命令处理程序的实现如下所示：'
- en: '[PRE23]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The sync command
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步命令
- en: The `sync` command will synchronize the data of a node in the gossip server
    ecosystem. The precondition for executing this command is that the node should
    be in the registered mode. When this command is issued, the data in the archive
    file is pumped back into the Config store of the user.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync`命令将同步gossip服务器生态系统中节点的数据。执行此命令的前提条件是节点应处于注册模式。当发出此命令时，归档文件中的数据将被泵回用户的Config存储中。'
- en: '![The sync command](img/0123OS_07_30.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![同步命令](img/0123OS_07_30.jpg)'
- en: Sequence of flow of data in Sync command
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 同步命令的数据流序列
- en: 'The syntax of this command is: `sync`. The following screenshot shows the response
    in the shell console:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的语法是：`sync`。以下截图显示了shell控制台中的响应：
- en: '![The sync command](img/0123OS_07_31.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![同步命令](img/0123OS_07_31.jpg)'
- en: Implementation of SyncCommand
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SyncCommand的实现
- en: 'The `sync` command is implemented as shown here:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync`命令的实现如下所示：'
- en: '[PRE24]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Implementation of SyncCommandHandler
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SyncCommandHandler的实现
- en: 'The `sync` command handler is implemented as shown in the following code snippet:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync`命令处理程序的实现如下所示：'
- en: '[PRE25]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The reconnect command
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新连接命令
- en: The `reconnect` command will reconnect a node in the gossip server ecosystem.
    The precondition for executing this command is that the node should be in the
    activated state and the node should have undergone a shut down. So, when the node
    comes up after the shut down and this command is fired, then the listeners for
    the client node will get spawned and the node will be back in the activated state.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`reconnect`命令将重新连接八卦服务器生态系统中的一个节点。执行此命令的前提是节点应处于激活状态，并且节点应经历了关闭。因此，当节点在关闭后重新启动并触发此命令时，客户端节点的监听器将被生成，并且节点将重新处于激活状态。'
- en: '![The reconnect command](img/0123OS_07_32.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![重新连接命令](img/0123OS_07_32.jpg)'
- en: Sequence of flow of data in Reconnect command
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 重新连接命令的数据流序列
- en: 'The syntax for this command is: `reconnect`. The following screenshot shows
    the response in the shell console:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的语法是：`reconnect`。以下截图显示了shell控制台中的响应：
- en: '![The reconnect command](img/0123OS_07_33.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![重新连接命令](img/0123OS_07_33.jpg)'
- en: Implementation of ReconnectCommand
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ReconnectCommand的实现
- en: 'The `reconnect` command is implemented as shown here:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`reconnect`命令的实现如下所示：'
- en: '[PRE26]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Implementation of ReconnectCommandHandler
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ReconnectCommandHandler的实现
- en: 'The `reconnect` command handler is implemented as shown in the following code
    snippet:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 重新连接命令处理程序的实现如下所示：
- en: '[PRE27]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Master node commands
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主节点命令
- en: 'The following is a list of commands that can be fired from the master nodes:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以从主节点触发的命令列表：
- en: The `start` command
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`命令'
- en: The `status` command
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`命令'
- en: The `get` command
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`命令'
- en: The `msg` command
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`msg`命令'
- en: The `kill` command
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kill`命令'
- en: The `clone` command
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clone`命令'
- en: The `stop` command
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop`命令'
- en: Let's take a look at each command from a design and implementation perspective.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设计和实现的角度来看每个命令。
- en: The start command
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始命令
- en: The `start` command will start the master node in the gossip server ecosystem.
    The precondition for executing this command is that the node name should be unique.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`命令将启动八卦服务器生态系统中的主节点。执行此命令的前提是节点名称应该是唯一的。'
- en: '![The start command](img/0123OS_07_34.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![开始命令](img/0123OS_07_34.jpg)'
- en: Sequence of flow of data in Start command
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 开始命令的数据流序列
- en: 'The syntax for this command is: `start`. The following screenshot shows the
    response in the shell console:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的语法是：`start`。以下截图显示了shell控制台中的响应：
- en: '![The start command](img/0123OS_07_35.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![开始命令](img/0123OS_07_35.jpg)'
- en: Implementation of StartMasterCommand
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: StartMasterCommand的实现
- en: 'The `start` command is implemented as shown here:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`命令的实现如下所示：'
- en: '[PRE28]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The stop command
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 停止命令
- en: The `stop` command will stop the master node in the gossip server ecosystem.
    The precondition for executing this command is that the node should be in the
    start mode.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`stop`命令将停止八卦服务器生态系统中的主节点。执行此命令的前提是节点应处于启动模式。'
- en: '![The stop command](img/0123OS_07_36.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![停止命令](img/0123OS_07_36.jpg)'
- en: Sequence of flow of data in Start command
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 开始命令的数据流序列
- en: 'The syntax for this code is: `stop`. The following screenshot shows the response
    in the shell console:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码的语法是：`stop`。以下截图显示了shell控制台中的响应：
- en: '![The stop command](img/0123OS_07_37.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![停止命令](img/0123OS_07_37.jpg)'
- en: Implementation of StopMasterCommand
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: StopMasterCommand的实现
- en: 'The `stop` command is implemented as shown in the following code snippet:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`stop`命令的实现如下所示：'
- en: '[PRE29]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The status command
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态命令
- en: The `status` command will show the current status of a node in the gossip server
    ecosystem.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`status`命令将显示八卦服务器生态系统中节点的当前状态。'
- en: '![The status command](img/0123OS_07_38.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![状态命令](img/0123OS_07_38.jpg)'
- en: Sequence of flow of data in Status command
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 状态命令的数据流序列
- en: 'The syntax for this command is: `status`. The following screenshot shows the
    response in the shell console:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的语法是：`status`。以下截图显示了shell控制台中的响应：
- en: '![The status command](img/0123OS_07_39.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![状态命令](img/0123OS_07_39.jpg)'
- en: Implementation of StatusCommand
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: StatusCommand的实现
- en: 'The `status` command is implemented as shown here:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`status`命令的实现如下所示：'
- en: '[PRE30]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Implementation of StatusCommandHandler
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: StatusCommandHandler的实现
- en: 'The `status` command handler is implemented as shown in the following code
    snippet:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`status`命令处理程序的实现如下所示：'
- en: '[PRE31]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The get command
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取命令
- en: The `get` command will display the state of all the nodes that are registered
    in the gossip server ecosystem.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`命令将显示注册在八卦服务器生态系统中的所有节点的状态。'
- en: 'The syntax for this command is: `get <field1>,<field2> where nodes are <nodename1>,<nodename2>`.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的语法是：`get <field1>,<field2> where nodes are <nodename1>,<nodename2>`。
- en: 'The following screenshot shows the response in the shell console:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了shell控制台中的响应：
- en: '![The get command](img/0123OS_07_40.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![获取命令](img/0123OS_07_40.jpg)'
- en: Implementation of GetNodeDataCommand
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GetNodeDataCommand的实现
- en: 'The `get` command is implemented as shown in the following code snippet:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`命令的实现如下所示：'
- en: '[PRE32]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Implementation of GetNodeDataCommandHandler
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GetNodeDataCommandHandler的实现
- en: 'The `get` command handler is implemented as shown here:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`命令处理程序的实现如下所示：'
- en: '[PRE33]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The msg command
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息命令
- en: The `msg` command is used to send messages to the nodes in the gossip server
    ecosystem. The precondition for executing this command is that the master node
    should be in the start mode.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`msg`命令用于向八卦服务器生态系统中的节点发送消息。执行此命令的前提是主节点应处于启动模式。'
- en: '![The msg command](img/0123OS_07_41.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![消息命令](img/0123OS_07_41.jpg)'
- en: Sequence of flow of data in Message command
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 消息命令的数据流序列
- en: '![The msg command](img/0123OS_07_42.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![消息命令](img/0123OS_07_42.jpg)'
- en: Messaging between master and client nodes
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 主节点和客户端节点之间的消息传递
- en: 'The syntax for this command is: `mgs <node name> where command = set, field
    1, field 2`.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的语法是：`mgs <node name> where command = set, field 1, field 2`。
- en: 'The following screenshot shows the response in the master shell console:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了主shell控制台中的响应：
- en: '![The msg command](img/0123OS_07_43.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![消息命令](img/0123OS_07_43.jpg)'
- en: 'The response in the client node (`vinoo`) is as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端节点（`vinoo`）中的响应如下：
- en: '![The msg command](img/0123OS_07_44.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![消息命令](img/0123OS_07_44.jpg)'
- en: Implementation of MessageCommand
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MessageCommand的实现
- en: 'The `MessageCommand` is implemented as shown here:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageCommand`的实现如下所示：'
- en: '[PRE34]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Implementation of MessageCommandHandler
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MessageCommandHandler的实现
- en: 'The `messageCommandHandler` is implemented as shown in the following code snippet:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`messageCommandHandler`的实现如下所示：'
- en: '[PRE35]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The kill command
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 杀死命令
- en: The `kill` command is used to kill a node in the gossip server ecosystem. The
    precondition for executing this command is that the master node should be in the
    start mode. Here we'll do it via the `msg` command.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`kill`命令用于在八卦服务器生态系统中杀死节点。执行此命令的前提条件是主节点应处于启动模式。在这里，我们将通过`msg`命令执行。'
- en: '![The kill command](img/0123OS_07_45.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![杀死命令](img/0123OS_07_45.jpg)'
- en: Sequence of flow of data in Kill command
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Kill命令中数据流的顺序
- en: 'The syntax for this command is: `mgs <node name> where command = kill`'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的语法是：`mgs <node name> where command = kill`
- en: 'The following screenshot shows the response in the master shell console:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了主shell控制台中的响应：
- en: '![The kill command](img/0123OS_07_46.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![杀死命令](img/0123OS_07_46.jpg)'
- en: 'The response in the client node (`vinoo`) is as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端节点（`vinoo`）中的响应如下：
- en: '![The kill command](img/0123OS_07_47.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![杀死命令](img/0123OS_07_47.jpg)'
- en: Implementation of KillNodeCommand
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: KillNodeCommand的实现
- en: 'The `kill` command is implemented as shown here:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`kill`命令的实现如下所示：'
- en: '[PRE36]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Implementation of KillNodeCommandHandler
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: KillNodeCommandHandler的实现
- en: 'The `Kill` command handler is implemented as shown in the following code snippet:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`Kill`命令处理程序的实现如下所示：'
- en: '[PRE37]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The clone command
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 克隆命令
- en: The `clone` command is used to make a clone of a node in the gossip server ecosystem.
    The precondition for executing this command is that the master node should be
    in the start mode and a minimum of two client nodes should be in the activated
    mode.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`clone`命令用于在八卦服务器生态系统中克隆节点。执行此命令的前提条件是主节点应处于启动模式，并且至少有两个客户端节点应处于激活模式。'
- en: '![The clone command](img/0123OS_07_48.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![克隆命令](img/0123OS_07_48.jpg)'
- en: Sequence of flow of data in Clone command
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Clone命令中数据流的顺序
- en: 'The syntax for this code is: `mgs <node name> where command = clone, target
    =<node name>, source=<node name>`.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的语法是：`mgs <node name> where command = clone, target =<node name>, source=<node
    name>`。
- en: 'The following screenshot shows the response in the master shell console:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了主shell控制台中的响应：
- en: '![The clone command](img/0123OS_07_49.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![克隆命令](img/0123OS_07_49.jpg)'
- en: 'This is the response in the client node (`loki`):'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这是客户端节点（`loki`）的响应：
- en: '![The clone command](img/0123OS_07_50.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![克隆命令](img/0123OS_07_50.jpg)'
- en: At this point, all the attributes in the source node will be copied to the target
    node.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，源节点中的所有属性将被复制到目标节点。
- en: Implementation of CloneNodeCommand
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CloneNodeCommand的实现
- en: 'The `clone` command is implemented as shown here:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`clone`命令的实现如下所示：'
- en: '[PRE38]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Implementation of CloneNodeCommandHandler
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CloneNodeCommandHandler的实现
- en: 'The `cloneCommandHandler` is implemented as shown in the following code snippet:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`cloneCommandHandler`的实现如下所示：'
- en: '[PRE39]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Redis configuration – data management
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redis配置-数据管理
- en: 'To manage data in Redis, it''s important to understand the application we are
    trying to build. Since the gossip server is meant to be a Config server, the reads
    are will be more than the writes. Redis provides a couple of data persistence
    mechanisms that we have already dealt with in the previous chapters, and the current
    section can act as a refresher. The mechanisms that Redis provides are the following:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 要管理Redis中的数据，了解我们试图构建的应用程序是很重要的。由于八卦服务器旨在成为配置服务器，因此读取次数将多于写入次数。Redis提供了一些数据持久性机制，我们在前几章中已经处理过，当前部分可以作为一个复习。Redis提供的机制如下：
- en: The RDB option
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RDB选项
- en: The AOF option
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AOF选项
- en: VM over commit memory (LINUX environments only)
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机超额内存（仅限LINUX环境）
- en: The RDB option
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RDB选项
- en: 'The RDB option provides a mechanism to take a snapshot of the data at regular
    intervals. Since this is a periodic activity, which dumps the data into the `dump.rdb`
    file, it makes it a good option to take data backups. For our current application,
    the configuration in the `redis.conf` file for RDB can be one of the following:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: RDB选项提供了定期对数据进行快照的机制。由于这是一个周期性活动，将数据转储到`dump.rdb`文件中，因此它是一个很好的选项来备份数据。对于我们当前的应用程序，RDB在`redis.conf`文件中的配置可以是以下之一：
- en: '`save 60 10`: This will save data every 1 minute if 10 keys have changed'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`save 60 10`：如果有10个键发生变化，将每1分钟保存一次数据'
- en: '`save 900 10`: This will save data every 15 minutes if 1 key has changed'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`save 900 10`：如果有1个键发生变化，将每15分钟保存一次数据'
- en: The AOF option
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AOF选项
- en: 'This works for all the write operations. The AOF option dumps the write data
    commands to an `appendonly.aof` file by default. There are combinations that can
    be used to write commands to this file, but every strategy comes with a performance
    to data persistence rider. What this means is that Redis can be configured to
    write to this file every time it encounters a write command, but this can make
    the entire process slow. Leaving the persistence to the underlying operating system
    in order to flush the buffer to this file can take the control away from the system,
    but this makes the application very fast. For the gossip server, the configuration
    is as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于所有的写操作。AOF选项默认将写入数据命令转储到`appendonly.aof`文件中。可以使用不同的组合将命令写入到这个文件中，但每种策略都会带来性能和数据持久性的权衡。这意味着Redis可以配置为每次遇到写命令时都写入到这个文件，但这可能会使整个过程变慢。将持久性留给底层操作系统来刷新缓冲区到这个文件可能会使系统失去控制，但这会使应用程序非常快。对于gossip服务器，配置如下：
- en: '`appendonly yes`: This will create an `appendonly.aof` file'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appendonly yes`：这将创建一个`appendonly.aof`文件'
- en: '`appendfsync everysec`: This will call the `fsync()` function every second'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appendfsync everysec`：这将每秒调用`fsync()`函数。'
- en: VM overcommit memory
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VM过度承诺内存
- en: This is achieved by tuning the `/etc/stsctl.conf` of your Linux box. This command
    will take care of how virtual memory management will take place inside the Linux
    box. The problem occurs when the `BGSAVE` function is called and the parent process
    forks a child process. By rule, the child process will have as much memory in
    the shared memory pages as the parent process. So, if the data changes in the
    parent, the child process also needs to have the same dataset to flush to disk.
    If the combined memory requirement for the parent and child does not add up to
    the shared memory, then `BGSAVE` fails.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过调整Linux系统的`/etc/stsctl.conf`来实现的。这个命令将处理Linux系统内部的虚拟内存管理。当调用`BGSAVE`函数并且父进程fork一个子进程时会出现问题。按照规则，子进程将拥有与父进程一样多的共享内存页。因此，如果父进程中的数据发生变化，子进程也需要具有相同的数据集以刷新到磁盘。如果父进程和子进程的组合内存需求不足以达到共享内存，则`BGSAVE`将失败。
- en: 'Discussion on VM memory management is outside the scope of the book. However,
    lack of this setting can cause Redis to fail in writing data to the disk. The
    change that should be made to the `/etc/stsctl.conf` is: `vm.overcommit_memory=1`.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不涉及VM内存管理的讨论。然而，缺少这个设置可能会导致Redis在写入数据到磁盘时失败。应该对`/etc/stsctl.conf`进行的更改是：`vm.overcommit_memory=1`。
- en: Summary
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this application, you learned how to make a Config server, also called as
    a gossip server that can store properties and pass information around to its peer
    nodes. In this chapter, we have made provisions for the client node to store and
    access information and have a life cycle. Also, we provided a master node, which
    can have control over any of the client nodes.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在本应用程序中，您学习了如何创建一个Config服务器，也称为gossip服务器，它可以存储属性并将信息传递给其对等节点。在本章中，我们为客户端节点提供了存储和访问信息以及生命周期的规定。此外，我们提供了一个主节点，它可以控制任何客户端节点。
- en: In the subsequent chapters, we will take this further and add capabilities for
    the server to scale and have fault tolerance.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将进一步扩展并为服务器增加扩展和容错能力。
