- en: Chapter 1. Installing and Starting the Server
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。安装和启动服务器
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Installing single node MongoDB
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装单节点MongoDB
- en: Starting a single node instance using the command-line options
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行选项启动单个节点实例
- en: Installing single node MongoDB with options from the config file
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用配置文件从安装单节点MongoDB
- en: Connecting to a single node in the Mongo shell with JavaScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Mongo shell中使用JavaScript连接到单个节点
- en: Connecting to a single node from a Java client
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Java客户端连接到单个节点
- en: Connecting to a single node from a Python client
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Python客户端连接到单个节点
- en: Starting multiple instances as part of a replica set
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为副本集的一部分启动多个实例
- en: Connecting to the replica set in the shell to query and insert data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到副本集以查询和插入数据
- en: Connecting to the replica set to query and insert data from a Java client
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Java客户端连接到副本集以查询和插入数据
- en: Connecting to the replica set to query and insert data using a Python client
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Python客户端连接到副本集以查询和插入数据
- en: Starting a simple sharded environment of two shards
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动包含两个分片的简单分片环境
- en: Connecting to a shard in the shell and performing operations
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在shell中连接到分片并执行操作
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will look at starting up the MongoDB server. Though it is
    a cakewalk to start the server with default settings for development purposes,
    there are numerous options available to fine-tune the start up behavior. We will
    start the server as a single node and then introduce various configuration options.
    We will conclude this chapter by setting up a simple replica set and running a
    sharded cluster. So, let's get started with installing and setting up the MongoDB
    server in the easiest way possible for simple development purposes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看如何启动MongoDB服务器。虽然对于开发目的以默认设置启动服务器很容易，但有许多可用于微调启动行为的选项。我们将作为单个节点启动服务器，然后介绍各种配置选项。我们将通过设置一个简单的副本集并运行一个分片集群来结束本章。因此，让我们开始以最简单的方式安装和设置MongoDB服务器，以用于简单的开发目的。
- en: Installing single node MongoDB
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装单节点MongoDB
- en: In this recipe, we will look at installing MongoDB in the standalone mode. This
    is the simplest and quickest way to start a MongoDB server, but it is seldom used
    for production use cases. However, this is the most common way to start the server
    for development purposes. In this recipe, we will start the server without looking
    at a lot of other startup options.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将看看如何以独立模式安装MongoDB。这是启动MongoDB服务器的最简单和最快的方法，但很少用于生产用例。然而，这是开发目的中启动服务器的最常见方式。在这个配方中，我们将在不看很多其他启动选项的情况下启动服务器。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Well, assuming that we have downloaded the MongoDB binaries from the download
    site, extracted it, and have the resulting bin directory in the operating system's
    path variable. (This is not mandatory, but it really becomes convenient after
    doing so.) The binaries can be downloaded from [http://www.mongodb.org/downloads](http://www.mongodb.org/downloads)
    after selecting your host operating system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，假设我们已经从下载站点下载了MongoDB二进制文件，解压缩并将生成的bin目录放在操作系统的路径变量中。（这不是强制性的，但这样做后确实变得更加方便。）可以从[http://www.mongodb.org/downloads](http://www.mongodb.org/downloads)下载二进制文件，然后选择您的主机操作系统。
- en: How to do it…
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Create the directory, `/data/mongo/db` (or any of your choice). This will be
    our database directory, and it needs to have permission to write to it by the
    `mongod` (the mongo server process) process.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建目录`/data/mongo/db`（或您选择的任何目录）。这将是我们的数据库目录，并且需要由`mongod`（mongo服务器进程）进程具有写入权限。
- en: 'We will start the server from the console with the data directory, `/data/mongo/db`,
    as follows:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从控制台启动服务器，数据目录为`/data/mongo/db`，如下所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works…
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'If you see the following line on the console, you have successfully started
    the server:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在控制台上看到以下行，则已成功启动服务器：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Starting a server can't get easier than this. Despite the simplicity in starting
    the server, there are a lot of configuration options that can be used to tune
    the behavior of the server on startup. Most of the default options are sensible
    and need not be changed. With the default values, the server should be listening
    to port `27017` for new connections, and the logs will be printed out to the standard
    output.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 启动服务器再也没有比这更容易的了。尽管启动服务器的简单性，但有许多配置选项可用于调整服务器在启动时的行为。大多数默认选项是合理的，不需要更改。使用默认值，服务器应该监听端口`27017`以进行新连接，并且日志将打印到标准输出。
- en: See also
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: There are times where we would like to configure some options on server startup.
    In the *Installing single node MongoDB* recipe, we will use some more start up
    options.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们希望在服务器启动时配置一些选项。在*安装单节点MongoDB*配方中，我们将使用一些更多的启动选项。
- en: Starting a single node instance using command-line options
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命令行选项启动单个节点实例
- en: 'In this recipe, we will see how to start a standalone single node server with
    some command-line options. We will see an example where we want to do the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将看到如何使用一些命令行选项启动独立的单节点服务器。我们将看一个例子，我们想要做以下事情：
- en: Start the server listening to port `27000`
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动服务器监听端口`27000`
- en: Logs should be written to `/logs/mongo.log`
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志应写入`/logs/mongo.log`
- en: The database directory is `/data/mongo/db`
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库目录是`/data/mongo/db`
- en: As the server has been started for development purposes, we don't want to preallocate
    full-size database files. (We will soon see what this means.)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务器已经为开发目的启动，我们不希望预先分配完整大小的数据库文件。（我们很快会看到这意味着什么。）
- en: Getting ready
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you have already seen and executed the *Installing single node MongoDB* recipe,
    you need not do anything different. If all these prerequisites are met, we are
    good for this recipe.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经看过并执行了*安装单节点MongoDB*配方，则无需做任何不同的事情。如果所有这些先决条件都得到满足，那么我们就可以开始本配方了。
- en: How to do it…
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: The `/data/mongo/db` directory for the database and `/logs/` for the logs should
    be created and present on your filesystem with appropriate permissions to write
    to it.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库的 `/data/mongo/db` 目录和日志的 `/logs/` 应该在您的文件系统上创建并存在，并具有适当的权限进行写入。
- en: 'Execute the following command:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works…
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'Ok, this wasn''t too difficult and is similar to the previous recipe, but we
    have some additional command-line options this time around. MongoDB actually supports
    quite a few options at startup, and we will see a list of the most common and
    important ones in my opinion:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这并不太困难，与之前的配方类似，但这次我们有一些额外的命令行选项。MongoDB实际上在启动时支持相当多的选项，我认为我们将看到一些最常见和最重要的选项列表：
- en: '| Option | Description |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `--help` or `-h` | This is used to print the information of various start
    up options available. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `--help` 或 `-h` | 用于打印可用的各种启动选项的信息。'
- en: '| `--config` or `-f` | This specifies the location of the configuration file
    that contains all the configuration options. We will see more on this option in
    a later recipe. It is just a convenient way of specifying the configurations in
    a file rather than on the command prompt; especially when the number of options
    specified is more. Using a separate configuration file shared across different
    MongoDB instances will also ensure that all the instances are running with identical
    configurations. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `--config` 或 `-f` | 这指定包含所有配置选项的配置文件的位置。我们将在以后的配方中更多地了解这个选项。这只是一种方便的方式，可以在文件中指定配置，而不是在命令提示符中指定；特别是当指定的选项数量更多时。使用一个共享的配置文件跨不同的MongoDB实例也将确保所有实例都使用相同的配置运行。'
- en: '| `--verbose` or `-v` | This makes the logs more verbose; we can put more v''s
    to make the output even more verbose, for example, `-vvvvv`. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `--verbose` 或 `-v` | 这会使日志更冗长；我们可以添加更多的v来使输出更冗长，例如，`-vvvvv`。'
- en: '| `--quiet` | This gives a quieter output; this is the opposite of verbose
    or the `-` `v` option. It will keep the logs less chatty and clean. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `--quiet` | 这会产生更安静的输出；这与冗长或 `-v` 选项相反。它将使日志更少，更整洁。 |'
- en: '| `--port` | This option is used if you are looking to start the server listening
    to some port other than the default `27017`. We would be frequently using this
    option whenever we are looking to start multiple mongo servers on the same machine,
    for example, `--port 27018` will start the server listening to port `27018` for
    new connections. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `--port` | 如果您希望启动服务器侦听除默认端口 `27017` 以外的某个端口，则使用此选项。每当我们希望在同一台机器上启动多个mongo服务器时，我们会经常使用此选项，例如，`--port
    27018` 将使服务器侦听端口 `27018` 以获取新连接。 |'
- en: '| `--logpath` | This provides a path to a log file where the logs will be written.
    The value defaults to `STDOUT`. For example, `--logpath /logs/server.out` will
    use `/logs/server.out` as the log file for the server. Remember that the value
    provided should be a file and not a directory where the logs will be written.
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `--logpath` | 这提供了一个日志文件的路径，日志将被写入其中。该值默认为 `STDOUT`。例如，`--logpath /logs/server.out`
    将使用 `/logs/server.out` 作为服务器的日志文件。请记住，提供的值应该是一个文件，而不是日志将被写入的目录。 |'
- en: '| `--logappend` | This option appends to the existing log file, if any. The
    default behavior is to rename the existing log file and then create a new file
    for the logs of the currently started mongo instance. Suppose that we have used
    the name of the log file as `server.out`, and on startup, the file exists, then
    by default this file will be renamed as `server.out.<timestamp>`, where `<timestamp>`
    is the current time. The time is GMT as against the local time. Let''s assume
    that the current date is October 28th, 2013 and time is 12:02:15, then the file
    generated will have the following value as the timestamp: `2013-10-28T12-02-15`.
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `--logappend` | 如果有的话，此选项将追加到现有的日志文件。默认行为是重命名现有的日志文件，然后为当前启动的mongo实例的日志创建一个新文件。假设我们已经将日志文件命名为
    `server.out`，并且在启动时该文件存在，则默认情况下此文件将被重命名为 `server.out.<timestamp>`，其中 `<timestamp>`
    是当前时间。时间是GMT时间，而不是本地时间。假设当前日期是2013年10月28日，时间是12:02:15，则生成的文件将具有以下值作为时间戳：`2013-10-28T12-02-15`。'
- en: '| `--dbpath` | This provides you with the directory where a new database will
    be created or an existing database is present. The value defaults to `/data/db`.
    We will start the server using `/data /mongo/db` as the database directory. Note
    that the value should be a directory rather than the name of the file. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `--dbpath` | 这为您提供了一个新数据库将被创建或现有数据库存在的目录。该值默认为 `/data/db`。我们将使用 `/data/mongo/db`
    作为数据库目录启动服务器。请注意，该值应该是一个目录，而不是文件的名称。 |'
- en: '| `--smallfiles` | This is used frequently for development purposes when we
    plan to start more than one mongo instance on our local machine. Mongo, on startup,
    creates a database file of size 64 MB (on 64-bit machines). This preallocation
    happens for performance reasons, and the file is created with zeros written to
    it to fill out space on the disk. Adding this option on startup creates a preallocated
    file of 16 MB only (again, on a 64-bit machine). This option also reduces the
    maximum size of the database and journal files. Avoid using this option for production
    deployments. Additionally, the file sizes double to a maximum of 2 GB by default.
    If the `--smallfile` option is chosen, it goes up to a maximum of 512 MB. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `--smallfiles` | 这在开发过程中经常使用，当我们计划在本地机器上启动多个mongo实例时。Mongo在启动时会在64位机器上创建一个大小为64MB的数据库文件。出于性能原因，这种预分配会发生，并且文件将被创建并写入零以填充磁盘上的空间。在启动时添加此选项将仅创建一个预分配文件，大小为16MB（同样，在64位机器上）。此选项还会减小数据库和日志文件的最大大小。不要在生产部署中使用此选项。另外，默认情况下，文件大小会增加到最大2GB。如果选择了
    `--smallfile` 选项，则最大增加到512MB。'
- en: '| `--replSet` | This option is used to start the server as a member of the
    replica set. The value of this `arg` is the name of the replica set, for example,
    `--replSet repl1`. You will learn more on this option in a later recipe where
    we will start a simple mongo replica set. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `--replSet` | 此选项用于将服务器启动为复制集的成员。此`arg`的值是复制集的名称，例如，`--replSet repl1`。在以后的食谱中，您将更多地了解这个选项，我们将启动一个简单的mongo复制集。
    |'
- en: '| `--configsvr` | This option is used to start the server as a configuration
    server. The role of the configuration server will be made clearer when we set
    up a simple sharded environment in a later recipe in this chapter. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `--configsvr` | 此选项用于将服务器启动为配置服务器。当我们在本章的后续食谱中设置一个简单的分片环境时，配置服务器的角色将更加清晰。
    |'
- en: '| `--shardsvr` | This informs the started mongod process that this server is
    being started as a shard server. By giving this option, the server also listens
    to port `27018` instead of the default `27017`. We will know more on this option
    when we start a simple sharded server. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `--shardsvr` | 这通知启动的mongod进程，该服务器正在作为分片服务器启动。通过给出此选项，服务器还会监听端口`27018`，而不是默认的`27017`。当我们启动一个简单的分片服务器时，我们将更多地了解这个选项。
    |'
- en: '| `--oplogSize` | Oplog is the backbone of replication. It is a capped collection
    where the data being written to the primary instances is stored in order to be
    replicated to the secondary instances. This collection resides in a database named
    `local`. On initialization of the replica set, the disk space for oplog is preallocated,
    and the database file (for the local database) is filled with zeros as placeholders.
    The default value is 5% of the disk space, which should be good enough for most
    of the cases.The size of oplog is crucial because capped collections are of a
    fixed size and they discard the oldest documents in them on exceeding their size,
    thereby making space for new documents. Having a very small oplog size can result
    in data being discarded before being replicated to secondary nodes. A large oplog
    size can result in unnecessary disk space utilization and large duration for the
    replica set initialization.For development purposes, when we start multiple server
    processes on the same host, we might want to keep the oplog size to a minimum
    value, quickly initiate the replica set, and use minimum disk space. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `--oplogSize` | Oplog是复制的支柱。它是一个有上限的集合，主实例写入的数据存储在其中，以便复制到次要实例。此集合位于名为`local`的数据库中。在初始化复制集时，oplog的磁盘空间被预先分配，并且数据库文件（用于本地数据库）被填充为占位符的零。默认值为磁盘空间的5%，对于大多数情况来说应该足够好。oplog的大小至关重要，因为有上限的集合是固定大小的，当超过其大小时，它们会丢弃其中的最旧文档，从而为新文档腾出空间。oplog大小非常小可能导致数据在复制到次要节点之前被丢弃。oplog大小很大可能导致不必要的磁盘空间利用和复制集初始化的持续时间很长。对于开发目的，当我们在同一主机上启动多个服务器进程时，我们可能希望将oplog大小保持在最小值，快速启动复制集，并使用最小的磁盘空间。
    |'
- en: '| `--storageEngine` | Starting with MongoDB 3.0, a new storage engine called
    Wired Tiger was introduced. The previous (default) storage engine is now called
    **mmapv1**. To start MongoDB with Wired Tiger instead of `mmapv1`, use the `wiredTiger`
    value with this option. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `--storageEngine` | 从MongoDB 3.0开始，引入了一个名为Wired Tiger的新存储引擎。以前（默认）的存储引擎现在称为**mmapv1**。要使用Wired
    Tiger而不是`mmapv1`启动MongoDB，请使用此选项的`wiredTiger`值。 |'
- en: '| `--dirctoryperdb` | By default, MongoDB''s database files are stored in a
    common directory (as provided in `--dbpath`). This option allows you to store
    each database in its own subdirectory in the aforementioned data directory. Having
    such granular control allows you to have separate disks for each database. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `--dirctoryperdb` | 默认情况下，MongoDB的数据库文件存储在一个公共目录中（如`--dbpath`中提供的）。此选项允许您将每个数据库存储在上述数据目录中的自己的子目录中。具有这样细粒度的控制允许您为每个数据库拥有单独的磁盘。
    |'
- en: There's more…
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: For an exhaustive list of options that are available, use the `--help` or `-h`
    option. This list of options is not exhaustive, and we will see some more coming
    up in later recipes as and when we need them. In the next recipe, we will see
    how to use a configuration file instead of the command-line arguments.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取可用选项的详尽列表，请使用`--help`或`-h`选项。这些选项列表并不详尽，我们将在以后的食谱中看到更多的选项，只要我们需要它们。在下一个食谱中，我们将看到如何使用配置文件而不是命令行参数。
- en: See also
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Single node installation of MongoDB with options from config file* for using
    configuration files to provide start up options'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用配置文件提供启动选项的MongoDB单节点安装*'
- en: '*Starting multiple instances as part of a replica set* to start a replica set'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*启动多个实例作为复制集的一部分* 来启动一个复制集'
- en: '*Starting a simple sharded environment of two shards* to set up a sharded environment'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*启动一个包含两个分片的简单分片环境* 来设置一个分片环境'
- en: Single node installation of MongoDB with options from the config file
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用配置文件进行MongoDB的单节点安装
- en: As we can see, providing options from the command line does the work, but it
    starts getting awkward as soon as the number of options that we provide increase.
    We have a nice and clean alternative to provide the start up options from a configuration
    file rather than as command-line arguments.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，从命令行提供选项可以完成工作，但是一旦我们提供的选项数量增加，情况就开始变得尴尬了。我们有一个干净而好的选择，可以从配置文件而不是作为命令行参数来提供启动选项。
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you have already executed the *Installing single node MongoDB* recipe, you
    need not do anything different as all the prerequisites of this recipe are the
    same.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经执行了*安装单节点MongoDB*食谱，那么您无需做任何不同的事情，因为此食谱的所有先决条件都是相同的。
- en: How to do it…
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The `/data/mongo/db` directory for the database and `/logs/` for the logs should
    be created and present on your filesystem with the appropriate permissions to
    write to it and perform the following steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的`/data/mongo/db`目录和日志的`/logs/`应该在您的文件系统上创建并存在，并具有适当的权限以写入它并执行以下步骤：
- en: 'Create a configuration file that can have any arbitrary name. In our case,
    let''s say that we create this in `/conf/mongo.conf`. We then edit the file and
    add the following lines to it:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个可以有任意名称的配置文件。在我们的情况下，假设我们在`/conf/mongo.conf`中创建了这个文件。然后编辑文件并添加以下行：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Start the mongo server using the following command:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启动mongo服务器：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works…
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: All the command-line options that we discussed in the previous recipe, *Starting
    a single node instance using command-line options*, hold true. We are just providing
    them in a configuration file instead. If you have not visited the previous recipe,
    I would recommend you to do so as that is where we discussed some of the common
    command-line options. The properties are specified as `<property name> = <value>`.
    For all the properties that don't have values, for example, the `smallfiles` option,
    the value given is a Boolean value, true. If we need to have a verbose output,
    we would `add v=true` (or multiple v's to make it more verbose) to our configuration
    file. If you already know what the command-line option is, then it is pretty easy
    to guess what the value of the property is in the file. It is almost the same
    as the command-line option with just the hyphen removed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在配置文件中提供了前面一篇文章中讨论的所有命令行选项，*使用命令行选项启动单个节点实例*。我们只是将它们提供在一个配置文件中。如果您还没有阅读前一篇文章，我建议您这样做，因为那里我们讨论了一些常见的命令行选项。属性被指定为`<property
    name> = <value>`。对于所有没有值的属性，例如`smallfiles`选项，给定的值是一个布尔值，true。如果我们需要有详细的输出，我们会在我们的配置文件中`添加v=true`（或多个v以使其更详细）。如果您已经知道命令行选项是什么，那么猜测属性在文件中的值就很容易了。它几乎与去掉连字符的命令行选项相同。
- en: Connecting to a single node in the Mongo shell with JavaScript
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JavaScript在Mongo shell中连接到单个节点
- en: This recipe is about starting the mongo shell and connecting to a MongoDB server.
    Here we also demonstrate how to load JavaScript code in the shell. Though this
    is not always required, it is handy when we have a large block of JavaScript code
    with variables and functions with some business logic in them that is required
    to be executed from the shell frequently and we want these functions to be available
    in the shell always.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是关于启动mongo shell并连接到MongoDB服务器。在这里，我们还演示了如何在shell中加载JavaScript代码。虽然这并不总是必需的，但当我们有一大块带有变量和函数的JavaScript代码，并且这些函数需要经常从shell中执行并且我们希望这些函数始终在shell中可用时，这是很方便的。
- en: Getting ready
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Although it is possible to run the mongo shell without connecting to the MongoDB
    server using `mongo --nodb`, we would rarely need to do so. To start a server
    on the localhost without much of a hassle, take a look at the first recipe, *Installing
    single node MongoDB*, and start the server.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能会在不连接到MongoDB服务器的情况下运行mongo shell，但我们很少需要这样做。要在本地主机上启动服务器而不费吹灰之力，请查看第一篇文章*安装单节点MongoDB*，并启动服务器。
- en: How to do it…
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'First, we create a simple JavaScript file and call it `hello.js`. Type the
    following body in the `hello.js` file:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个简单的JavaScript文件并将其命名为`hello.js`。在`hello.js`文件中输入以下内容：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Save this file at the location, `/mongo/scripts/hello.js`. (This can be saved
    at any other location too.)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此文件保存在位置`/mongo/scripts/hello.js`。（这也可以保存在任何其他位置。）
- en: 'On the command prompt, execute the following:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符上执行以下操作：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'On executing this, we should see the following printed to our console:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此命令时，我们应该在控制台上看到以下内容打印出来：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Test the database that the shell is connected to by typing the following command:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入以下命令来测试shell连接的数据库：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This should print out `test` to the console.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在控制台上打印出`test`。
- en: 'Now, type the following command in the shell:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在shell中输入以下命令：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should get the following response:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该收到以下响应：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: This book was written with MongoDB version 3.0.2\. There is a good chance
    that you may be using a later version and hence see a different version number
    in the mongo shell.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本书是使用MongoDB版本3.0.2编写的。您可能正在使用更新的版本，因此在mongo shell中可能看到不同的版本号。
- en: How it works…
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The JavaScript function that we executed here is of no practical use and is
    just used to demonstrate how a function can be preloaded on the startup of the
    shell. There could be multiple functions in the `.js` file containing valid JavaScript
    code—possibly some complex business logic.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里执行的JavaScript函数没有实际用途，只是用来演示如何在shell启动时预加载函数。`.js`文件中可能包含有效的JavaScript代码，可能是一些复杂的业务逻辑。
- en: 'On executing the `mongo` command without any arguments, we connect to the MongoDB
    server running on localhost and listen for new connections on the default port
    `27017`. Generally speaking, the format of the command is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有任何参数的情况下执行`mongo`命令时，我们连接到在本地主机上运行的MongoDB服务器，并在默认端口`27017`上监听新连接。一般来说，命令的格式如下：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In cases where there are no arguments passed to the mongo executable, it is
    equivalent to the passing of the `db address` as `localhost:27017/test`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有传递参数给mongo可执行文件的情况下，它相当于将`db地址`传递为`localhost:27017/test`。
- en: 'Let''s look at some example values of the `db address` command-line option
    and its interpretation:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些`db地址`命令行选项的示例值及其解释：
- en: '`mydb`: This will connect to the server running on localhost and listen for
    a connection on port `27017`. The database connected will be `mydb`.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mydb`：这将连接到在本地主机上运行并监听端口`27017`上的连接的服务器。连接的数据库将是`mydb`。'
- en: '`mongo.server.host/mydb`: This will connect to the server running on `mongo.server.host`
    and the default port `27017`. The database connected will be `mydb`.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mongo.server.host/mydb`：这将连接到在`mongo.server.host`上运行并使用默认端口`27017`的服务器。连接的数据库将是`mydb`。'
- en: '`mongo.server.host:27000/mydb`: This will connect to the server running on
    `mongo.server.host` and the port `27000`. The database connected will be `mydb`.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mongo.server.host:27000/mydb`：这将连接到在`mongo.server.host`上运行并使用端口`27000`的服务器。连接的数据库将是`mydb`。'
- en: '`mongo.server.host:27000`: This will connect to the server running on `mongo.server.host`
    and the port `27000`. The database connected will be the default database test.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mongo.server.host:27000`：这将连接到运行在`mongo.server.host`上的服务器，端口为`27000`。连接的数据库将是默认数据库test。'
- en: 'Now, there are quite a few options available on the mongo client too. We will
    see a few of them in the following table:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Mongo客户端也有很多选项可用。我们将在下表中看到其中一些：
- en: '| Option | Description |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `--help` or `-h` | This shows help regarding the usage of various command-line
    options. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `--help`或`-h` | 这显示有关各种命令行选项使用的帮助。 |'
- en: '| `--shell` | When the `.js` files are given as arguments, these scripts get
    executed and the mongo client will exit. Providing this option ensures that the
    shell remains running after the JavaScript files execute. All the functions and
    variables defined in these `.js` files are available in the shell on startup.
    As in the preceding case, the `sayHello` function defined in the JavaScript file
    is available in the shell for invocation. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `--shell` | 当给定`.js`文件作为参数时，这些脚本将被执行，mongo客户端将退出。提供此选项可以确保在JavaScript文件执行后，shell保持运行。在启动时，这些`.js`文件中定义的所有函数和变量都可在shell中使用。与前面的情况一样，JavaScript文件中定义的`sayHello`函数可在shell中调用。
    |'
- en: '| `--port` | The specifies the port of the mongo server where the client needs
    to connect. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `--port` | 指定客户端需要连接的mongo服务器的端口。 |'
- en: '| `--host` | This specifies the hostname of the mongo server where the client
    needs to connect. If the `db address` is provided with the hostname, port, and
    database, then both the `--host` and `--port` options need not be specified. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `--host` | 这指定了客户端需要连接的mongo服务器的主机名。如果`db地址`提供了主机名、端口和数据库，那么`--host`和`--port`选项都不需要指定。
    |'
- en: '| `--username` or `-u` | This is relevant when security is enabled for mongo.
    It is used to provide the username of the user to be logged in. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `--username`或`-u` | 当Mongo启用安全性时，这是相关的。它用于提供要登录的用户的用户名。 |'
- en: '| `--password` or `-p` | This option is relevant when security is enabled for
    mongo. It is used to provide the password of the user to be logged in. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `--password`或`-p` | 当Mongo启用安全性时，这个选项是相关的。它用于提供要登录的用户的密码。 |'
- en: Connecting to a single node using a Java client
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Java客户端连接到单个节点
- en: This recipe is about setting up the Java client for MongoDB. You will repeatedly
    refer to this recipe while working on others, so read it very carefully.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程是关于为MongoDB设置Java客户端的。在处理其他教程时，您将反复参考这个教程，所以请仔细阅读。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The following are the prerequisites for this recipe:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个教程的先决条件：
- en: Java SDK 1.6 or above is recommended.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议使用Java SDK 1.6或更高版本。
- en: Use the latest version of Maven available. Version 3.3.3 was the latest at the
    time of writing this book.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最新版本的Maven。在撰写本书时，版本3.3.3是最新版本。
- en: MongoDB Java driver version 3.0.1 was the latest at the time of writing this
    book.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在撰写本书时，MongoDB Java驱动程序版本3.0.1是最新版本。
- en: Connectivity to the Internet to access the online maven repository or a local
    repository. Alternatively, you may choose an appropriate local repository accessible
    to you from your computer.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到互联网以访问在线maven存储库或本地存储库。或者，您可以选择一个适合您的计算机访问的本地存储库。
- en: The Mongo server is up and running on localhost and port `27017`. Take a look
    at the first recipe, *Installing single node MongoDB*, and start the server.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mongo服务器正在本地主机和端口`27017`上运行。查看第一个教程，*安装单节点MongoDB*，并启动服务器。
- en: How to do it…
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤如下：
- en: Install the latest version of JDK from [https://www.java.com/en/download/](https://www.java.com/en/download/)
    if you don't already have it on your machine. We will not be going through the
    steps to install JDK in this recipe, but before moving on with the next step,
    JDK should be present.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您的机器上还没有安装最新版本的JDK，请从[https://www.java.com/en/download/](https://www.java.com/en/download/)下载。我们不会在这个教程中介绍安装JDK的步骤，但在进行下一步之前，JDK应该已经安装好了。
- en: Maven needs to be downloaded from [http://maven.apache.org/download.cgi](http://maven.apache.org/download.cgi).
    We should see something similar to the following image on the download page. Choose
    the binaries in a `.tar.gz` or `.zip` format and download it. This recipe is executed
    on a machine running on the Windows platform and thus these steps are for installation
    on Windows.![How to do it…](img/4831_01_01.jpg)
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要从[http://maven.apache.org/download.cgi](http://maven.apache.org/download.cgi)下载Maven。在下载页面上应该看到类似以下图片的内容。选择`.tar.gz`或`.zip`格式的二进制文件并下载。这个教程是在运行Windows平台的机器上执行的，因此这些安装步骤是针对Windows的。![操作步骤如下：](img/4831_01_01.jpg)
- en: Once the archive has been downloaded, we need to extract it and put the absolute
    path of the `bin` folder in the extracted archive in the operating system's path
    variable. Maven also needs the path of JDK to be set as the `JAVA_HOME` environment
    variable. Remember to set the root of your JDK as the value of this variable.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完档案后，我们需要解压它，并将提取的档案中的`bin`文件夹的绝对路径放入操作系统的路径变量中。Maven还需要将JDK的路径设置为`JAVA_HOME`环境变量。记得将你的JDK根目录设置为这个变量的值。
- en: 'All we need to do now is type `mvn -version` on the command prompt, and if
    we see the output that begins with something as follows, we have successfully
    set up maven:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们只需要在命令提示符上输入`mvn -version`，如果看到以下开头的输出，我们就成功设置了maven：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At this stage, we have maven installed, and we are now ready to create our
    simple project to write our first Mongo client in Java. We start by creating a
    `project` folder. Let''s say that we create a folder called `Mongo Java`. Then
    we create a folder structure, `src/main/java`, in this `project` folder. The root
    of the `project` folder then contains a file called `pom.xml`. Once this folder''s
    creation is done, the folder structure should look as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经安装了maven，现在准备创建我们的简单项目，在Java中编写我们的第一个Mongo客户端。我们首先创建一个`project`文件夹。假设我们创建一个名为`Mongo
    Java`的文件夹。然后在这个`project`文件夹中创建一个文件夹结构`src/main/java`。`project`文件夹的根目录包含一个名为`pom.xml`的文件。一旦这个文件夹创建完成，文件夹结构应该如下所示：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We just have the project skeleton with us. We shall now add some content to
    the `pom.xml` file. Not much is needed for this. The following content is all
    we need in the `pom.xml` file:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在只有项目的框架。我们将在`pom.xml`文件中添加一些内容。这并不需要太多。以下内容是我们在`pom.xml`文件中所需要的全部内容：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We finally write our Java client that will be used to connect to the Mongo
    server and execute some very basic operations. The following is the Java class
    in the `src/main/java` location in the `com.packtpub.mongo.cookbook` package,
    and the name of the class is `FirstMongoClient`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们编写一个Java客户端，用于连接到Mongo服务器并执行一些非常基本的操作。以下是`com.packtpub.mongo.cookbook`包中`src/main/java`位置中的Java类，类名为`FirstMongoClient`：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It''s now time to execute the preceding Java code. We will execute it using
    maven from the shell. You should be in the same directory as `pom.xml` of the
    project:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是执行前面的Java代码的时候了。我们将使用maven从shell中执行它。您应该在项目的`pom.xml`所在的同一目录中：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works…
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: These were quite a lot of steps to follow. Let's look at some of them in more
    detail. Everything up to step 6 is straightforward and doesn't need any explanation.
    Let's look at step 7 onwards.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是相当多的步骤要遵循。让我们更详细地看一些步骤。直到第6步为止，都是直接的，不需要任何解释。让我们从第7步开始看起。
- en: The `pom.xml` file that we have here is pretty simple. We defined a dependency
    on mongo's Java driver. It relies on the online repository, `repo.maven.apache.org`,
    to resolve the artifacts. For a local repository, all we need to do is define
    the repositories and `pluginRepositories` tags in `pom.xml`. For more information
    on maven, refer to the maven documentation at [http://maven.apache.org/guides/index.html](http://maven.apache.org/guides/index.html).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有的`pom.xml`文件非常简单。我们在mongo的Java驱动程序上定义了一个依赖关系。它依赖于在线存储库`repo.maven.apache.org`来解析这些构件。对于本地存储库，我们所需要做的就是在`pom.xml`中定义`repositories`和`pluginRepositories`标签。有关maven的更多信息，请参阅maven文档[http://maven.apache.org/guides/index.html](http://maven.apache.org/guides/index.html)。
- en: 'For the Java class, the `org.mongodb.MongoClient` class is the backbone. We
    first instantiate it using one of its overloaded constructors giving the server''s
    host and port. In this case, the hostname and port were not really needed as the
    values provided are the default values anyway, and the no-argument constructor
    would have worked well too. The following code snippet instantiates this client:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java类，`org.mongodb.MongoClient`类是主干。我们首先使用其重载的构造函数实例化它，给出服务器的主机和端口。在这种情况下，主机名和端口实际上并不是必需的，因为提供的值已经是默认值，而且无参数的构造函数也可以很好地工作。以下代码片段实例化了这个客户端：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The next step is to get the database, in this case, test using the `getDB` method.
    This is returned as an object of the `com.mongodb.DB` type. Note that this database
    might not exist, yet `getDB` will not throw any exception. Instead, the database
    will get created whenever we add a new document to the collection in this database.
    Similarly, `getCollection` on the DB object will return an object of the `com.mongodb.DBCollection`
    type representing the collection in the database. This too might not exist in
    the database and will get created on inserting the first document automatically.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是获取数据库，在这种情况下，使用`getDB`方法来测试。这将作为`com.mongodb.DB`类型的对象返回。请注意，这个数据库可能不存在，但`getDB`不会抛出任何异常。相反，只有在我们向该数据库的集合中添加新文档时，数据库才会被创建。同样，DB对象上的`getCollection`将返回一个代表数据库中集合的`com.mongodb.DBCollection`类型的对象。这个集合在数据库中也可能不存在，并且在插入第一个文档时会自动创建。
- en: 'The following two code snippets from our class show you how to get an instance
    of `DB` and `DBCollection`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类中以下两个代码片段向您展示了如何获取`DB`和`DBCollection`的实例：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Before we insert a document, we will drop the collection so that even upon
    multiple executions of the program, we will have just one document in the person
    collection. The collection is dropped using the `drop()` method on the `DBCollection`
    object''s instance. Next, we create an instance of `com.mongodb.DBObject`. This
    is an object that represents the document to be inserted into the collection.
    The concrete class used here is `BasicDBObject`, which is a type of `java.util.LinkedHashMap`,
    where the key is String and the value is Object. The value can be another `DBObject`
    too, in which case, it is a document nested within another document. In our case,
    we have two keys, name and age, which are the field names in the document to be
    inserted and the values are of the String and Integer types, respectively. The
    append method of `BasicDBObject` adds a new key value pair to the `BasicDBObject`
    instance and returns the same instance, which allows us to chain the append method
    calls to add multiple key value pairs. This created `DBObject` is then inserted
    into the collection using the insert method. This is how we instantiated `DBObject`
    for the person collection and inserted it into the collection as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入文档之前，我们将删除集合，以便即使在程序的多次执行中，person集合中也只有一个文档。使用`DBCollection`对象的`drop()`方法来删除集合。接下来，我们创建一个`com.mongodb.DBObject`的实例。这是一个表示要插入到集合中的文档的对象。这里使用的具体类是`BasicDBObject`，它是`java.util.LinkedHashMap`类型，其中键是String，值是Object。值也可以是另一个`DBObject`，在这种情况下，它是嵌套在另一个文档中的文档。在我们的例子中，我们有两个键，name和age，它们是要插入的文档中的字段名，值分别是String和Integer类型。`BasicDBObject`的`append`方法将一个新的键值对添加到`BasicDBObject`实例中，并返回相同的实例，这使我们可以链接`append`方法调用以添加多个键值对。然后使用insert方法将创建的`DBObject`插入到集合中。这就是我们为person集合实例化`DBObject`并将其插入到集合中的方式：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `findOne` method on `DBCollection` is straightforward and returns one document
    from the collection. This version of `findOne` doesn't accept `DBObject` (which
    otherwise acts as a query executed before a document is selected and returned)
    as a parameter. This is synonymous to doing `db.person.findOne()` from the shell.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`DBCollection`上的`findOne`方法很简单，它从集合中返回一个文档。这个版本的`findOne`不接受`DBObject`（否则会在选择和返回文档之前执行的查询）作为参数。这相当于在shell中执行`db.person.findOne()`。'
- en: 'Finally, we simply invoke `getDatabaseNames` to get a list of databases'' names
    in the server. At this point of time, we should at least be having `test` and
    the `local` database in the returned result. Once all the operations are complete,
    we close the client. The `MongoClient` class is thread-safe and generally one
    instance is used per application. To execute the program, we use the maven''s
    exec plugin. On executing step 9, we should see the following lines toward the
    end in the console:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需调用`getDatabaseNames`来获取服务器中数据库名称的列表。此时，我们应该至少在返回的结果中有`test`和`local`数据库。完成所有操作后，我们关闭客户端。`MongoClient`类是线程安全的，通常一个应用程序使用一个实例。要执行该程序，我们使用maven的exec插件。在执行第9步时，我们应该在控制台的最后看到以下行：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Connecting to a single node using a Python client
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python客户端连接到单个节点
- en: In this recipe, we will connect to a single MongoDB instance using the Python
    MongoDB driver called PyMongo. With Python's simple syntax and versatility clubbed
    together with MongoDB, many programmers find that this stack allows faster prototyping
    and reduced development cycles.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用Python MongoDB驱动程序PyMongo连接到单个MongoDB实例。使用Python的简单语法和多功能性与MongoDB结合在一起，许多程序员发现这个堆栈可以实现更快的原型设计和减少的开发周期。
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The following are the prerequisites for this recipe:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此配方的先决条件：
- en: Python 2.7.*x* (although the code is compatible with Python 3.*x*).
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 2.7.*x*（尽管该代码与Python 3.*x*兼容）。
- en: 'PyMongo 3.0.1: Python MongoDB driver.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyMongo 3.0.1：Python MongoDB驱动程序。
- en: Python package installer (pip).
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python软件包安装程序（pip）。
- en: The Mongo server is up and running on localhost and port `27017`. Take a look
    at the first recipe, *Installing single node MongoDB*, and start the server.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mongo服务器正在localhost和端口`27017`上运行。查看第一个配方，*安装单节点MongoDB*，并启动服务器。
- en: How to do it…
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Depending on your operating system, install the pip utility, say, on the Ubuntu/Debian
    system. You can use the following command to install pip:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据您的操作系统，在Ubuntu/Debian系统上安装pip实用程序。您可以使用以下命令安装pip：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Install the latest PyMongo driver using pip:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用pip安装最新的PyMongo驱动程序：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Lastly, create a new file called `my_client.py` and type in the following code:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个名为`my_client.py`的新文件，并输入以下代码：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run the script using the following command:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行脚本：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works…
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We start off by installing the Python MongoDB driver, pymongo, on the system
    with the help of the pip package manager. In the given Python code, we begin by
    importing `print_function` from the `__future__` module to allow compatibility
    with Python 3.*x*. Next, we import pymongo so that it can be used in the script.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过使用pip软件包管理器在系统上安装Python MongoDB驱动程序pymongo。在给定的Python代码中，我们首先从`__future__`模块中导入`print_function`，以兼容Python
    3.*x*。接下来，我们导入pymongo，以便在脚本中使用它。
- en: We instantiate `pymongo.MongoClient()` with localhost and `27017` as the mongo
    server host and port, respectively. In pymongo, we can directly refer to the database
    and its collection by using the `<client>.<database_name>.<collection_name>` convention.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用localhost和`27017`作为mongo服务器主机和端口来实例化`pymongo.MongoClient()`。在pymongo中，我们可以直接使用`<client>.<database_name>.<collection_name>`的约定来引用数据库及其集合。
- en: In our recipe, we used the client handler to select the database test simply
    by referring to `client.test`. This returns a database object even if the database
    does not exist. As a part of this recipe, we drop the collection by calling `testdb.person.drop()`,
    where `testdb` is a reference to `client.test` and `person` is a collection that
    we wish to drop. For this recipe, we are intentionally dropping the collection
    so that recurring runs will always yield one record in the collection.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配方中，我们使用客户端处理程序通过引用`client.test`来选择数据库test。即使数据库不存在，这也会返回一个数据库对象。作为这个配方的一部分，我们通过调用`testdb.person.drop()`来删除集合，其中`testdb`是对`client.test`的引用，`person`是我们希望删除的集合。对于这个配方，我们有意地删除集合，以便重复运行将始终在集合中产生一条记录。
- en: Next, we instantiate a dictionary called `employee` with a few values such as
    name and age. We will now add this entry to our `person` collection using the
    `insert_one()` method.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实例化一个名为`employee`的字典，其中包含一些值，如姓名和年龄。现在，我们将使用`insert_one()`方法将此条目添加到我们的`person`集合中。
- en: As we now know that there is an entry in the person collection, we will fetch
    one document using the `find_one()` method. This method returns the first document
    in the collection, depending on the order of documents stored on the disk.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道person集合中有一个条目，我们将使用`find_one()`方法获取一个文档。该方法根据磁盘上存储的文档的顺序返回集合中的第一个文档。
- en: Following this, we also try to get the list of all the databases by calling
    the `get_databases()` method to the client. This method returns a list of database
    names present on the server. This method may come in handy when you are trying
    to assert the existence of a database on the server.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们还尝试通过调用`get_databases()`方法来获取所有数据库的列表到客户端。该方法返回服务器上存在的数据库名称列表。当您尝试断言服务器上是否存在数据库时，此方法可能会派上用场。
- en: Finally, we close the client connection using the `close()` method.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`close()`方法关闭客户端连接。
- en: Starting multiple instances as part of a replica set
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为副本集的一部分启动多个实例
- en: In this recipe, we will look at starting multiple servers on the same host but
    as a cluster. Starting a single mongo server is enough for development purposes
    or non-mission-critical applications. For crucial production deployments, we need
    the availability to be high, where if one server instance fails, another instance
    takes over and the data remains available to query, insert, or update. Clustering
    is an advanced concept and we won't be doing justice by covering this whole concept
    in one recipe. Here, we will be touching the surface and going into more detail
    in other recipes in the administration section later in the book. In this recipe,
    we will start multiple mongo server processes on the same machine for the purpose
    of testing. In a production environment, they will be running on different machines
    (or virtual machines) in the same or even different data centers.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将看看在同一主机上启动多个服务器作为集群。启动单个mongo服务器足以用于开发目的或非关键应用。对于关键的生产部署，我们需要高可用性，如果一个服务器实例失败，另一个实例接管并且数据仍然可用于查询、插入或更新。集群是一个高级概念，我们无法在一个配方中涵盖整个概念。在这里，我们将浅尝辄止，并在本书后面的管理部分的其他配方中进行更详细的讨论。在这个配方中，我们将在同一台机器上启动多个mongo服务器进程，用于测试目的。在生产环境中，它们将在同一数据中心甚至不同数据中心的不同机器（或虚拟机）上运行。
- en: Let's see in brief what a replica set exactly is. As the name suggests, it is
    a set of servers that are replicas of each other in terms of data. Looking at
    how they are kept in sync with each other and other internals is something we
    will defer to some later recipes in the administration section, but one thing
    to remember is that write operations will happen only on one node, which is the
    primary one. All the querying also happens from the primary by default, though
    we may permit read operations on secondary instances explicitly. An important
    fact to remember is that replica sets are not meant to achieve scalability by
    distributing the read operations across various nodes in a replica set. Its sole
    objective is to ensure high availability.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要看一下什么是副本集。顾名思义，它是一组服务器，它们在数据方面彼此是副本。查看它们如何保持彼此同步以及其他内部情况是我们将推迟到管理部分的一些后续配方中，但要记住的一件事是，写操作只会发生在一个节点上，即主节点。默认情况下，所有查询也都是从主节点进行的，尽管我们可能会明确允许在次要实例上进行读操作。要记住的一个重要事实是，副本集并不是为了通过在副本集的各个节点之间分发读操作来实现可伸缩性。它的唯一目标是确保高可用性。
- en: Getting ready
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Though not a prerequisite, taking a look at the *Starting a single node instance
    using command-line options* recipe will definitely make things easier just in
    case you are not aware of various command-line options and their significance
    while starting a mongo server. Additionally, the necessary binaries and setups
    as mentioned in the single server setup must be done before we continue with this
    recipe. Let's sum up on what we need to do.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是必需条件，但查看*使用命令行选项启动单节点实例*的配方将会让事情变得更容易，以防您不了解在启动mongo服务器时各种命令行选项及其重要性。此外，在继续进行此配方之前，必须完成单服务器设置中提到的必要二进制文件和设置。让我们总结一下我们需要做什么。
- en: We will start three mongod processes (mongo server instances) on our localhost.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本地主机上启动三个mongod进程（mongo服务器实例）。
- en: 'We will create three data directories, `/data/n1`, `/data/n2`, and `/data/n3`
    for `Node1`, `Node2`, and `Node3`, respectively. Similarly, we will redirect the
    logs to `/logs/n1.log`, `/logs/n2.log`, and `/logs/n3.log`. The following image
    will give you an idea on how the cluster would look:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为`Node1`、`Node2`和`Node3`分别创建三个数据目录`/data/n1`、`/data/n2`和`/data/n3`。同样，我们将把日志重定向到`/logs/n1.log`、`/logs/n2.log`和`/logs/n3.log`。以下图片将让您对集群的外观有一个概念：
- en: '![Getting ready](img/4831_01_02.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/4831_01_02.jpg)'
- en: How to do it…
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s take a look at the steps in detail:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看一下步骤：
- en: Create the `/data/n1`, `/data/n2`, `/data/n3`, and `/logs` directories for the
    data and logs of the three nodes respectively. On the Windows platform, you can
    choose the `c:\data\n1`, `c:\data\n2`, `c:\data\n3`, and `c:\logs\` directories
    or any other directory of your choice for the data and logs respectively. Ensure
    that these directories have appropriate write permissions for the mongo server
    to write the data and logs.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为三个节点的数据和日志创建`/data/n1`、`/data/n2`、`/data/n3`和`/logs`目录。在Windows平台上，您可以选择`c:\data\n1`、`c:\data\n2`、`c:\data\n3`和`c:\logs\`目录，或者选择其他目录来分别存放数据和日志。确保这些目录对于mongo服务器来说具有适当的写权限。
- en: 'Start the three servers as follows. Users on the Windows platform need to skip
    the `--fork` option as it is not supported:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式启动三个服务器。在Windows平台上，用户需要跳过`--fork`选项，因为它不受支持：
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Start the mongo shell and connect to any of the mongo servers running. In this
    case, we connect to the first one (listening to port `27000`). Execute the following
    command:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动mongo shell并连接到正在运行的任何mongo服务器。在这种情况下，我们连接到第一个（监听端口`27000`）。执行以下命令：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Try to execute an insert operation from the mongo shell after connecting to
    it:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到mongo shell后，尝试执行一个插入操作：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This operation should fail as the replica set has not been initialized yet.
    More information can be found in the *How it works…* section.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作应该失败，因为副本集尚未初始化。更多信息可以在*它是如何工作的……*部分找到。
- en: 'The next step is to start configuring the replica set. We start by preparing
    a JSON configuration in the shell as follows:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是开始配置副本集。我们首先在shell中准备一个JSON配置，如下所示：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The last step is to initiate the replica set with the preceding configuration
    as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是使用上述配置初始化副本集。
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Execute `rs.status()` after a few seconds on the shell to see the status. In
    a few seconds, one of them should become a primary and the remaining two should
    become secondary.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在shell上几秒钟后执行`rs.status()`，查看状态。几秒钟后，其中一个应该成为主节点，其余两个应该成为次要节点。
- en: How it works…
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: We described the common options in the *Installing single node MongoDB* recipe
    with the command-line options recipe before and all these command-line options
    are described in detail.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*安装单节点MongoDB*示例中描述了常见的选项，之前的命令行选项示例中也描述了所有这些命令行选项的详细信息。
- en: As we are starting three independent mongod services, we have three dedicated
    database paths on the filesystem. Similarly, we have three separate log file locations
    for each of the processes. We then start three mongod processes with the database
    and log file path specified. As this setup is for test purposes and is started
    on the same machine, we use the `--smallfiles` and `--oplogSize` options. As these
    processes are running on the same host, we also choose the ports explicitly to
    avoid port conflicts. The ports that we chose here were `27000`, `27001`, and
    `27002`. When we start the servers on different hosts, we may or may not choose
    a separate port. We can very well choose to use the default one whenever possible.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们启动了三个独立的mongod服务，因此在文件系统上有三个专用的数据库路径。同样，我们为每个进程有三个单独的日志文件位置。然后，我们使用指定的数据库和日志文件路径启动了三个mongod进程。由于这个设置是为了测试目的，并且在同一台机器上启动，我们使用了`--smallfiles`和`--oplogSize`选项。由于这些进程在同一主机上运行，我们还选择了显式端口，以避免端口冲突。我们选择的端口是`27000`、`27001`和`27002`。当我们在不同的主机上启动服务器时，我们可能会选择一个单独的端口，也可能不选择。在可能的情况下，我们可以选择使用默认端口。
- en: The `--fork` option demands some explanation. By choosing this option, we start
    the server as a background process from our operating system's shell and get the
    control back in the shell where we can then start more such mongod processes or
    perform other operations. In the absence of the `--fork` option, we cannot start
    more than one process per shell and would need to start three mongod processes
    in three separate shells.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`--fork`选项需要一些解释。通过选择此选项，我们可以从操作系统的shell中将服务器作为后台进程启动，并在shell中恢复控制，然后可以启动更多这样的mongod进程或执行其他操作。如果没有`--fork`选项，我们不能在一个shell中启动多个进程，需要在三个单独的shell中启动三个mongod进程。'
- en: 'If we take a look at the logs generated in the log directory, we should see
    the following lines in it:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看日志目录中生成的日志，我们应该看到其中的以下行：
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Though we started three mongod processes with the `--replSet` option, we still
    haven't configured them to work with each other as a replica set. This command-line
    option is just used to tell the server on startup that this process will be running
    as a part of a replica set. The name of the replica set is the same as the value
    of this option passed on the command prompt. This also explains why the insert
    operation executed on one of the nodes failed before the replica set was initialized.
    In mongo replica sets, there can be only one primary node where all the inserting
    and querying happens. In the image shown, the **N1** node is shown as the primary
    and listens to port **27000** for client connections. All the other nodes are
    slave/secondary instances, which sync themselves up with the primary and hence
    querying too is disabled on them by default. It is only when the primary goes
    down that one of the secondary takes over and becomes a primary node. However,
    it is possible to query the secondary for data as we have shown in the image;
    we will see how to query from a secondary instance in the next recipe.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们使用`--replSet`选项启动了三个mongod进程，但我们仍然没有将它们配置为副本集。这个命令行选项只是用来告诉服务器在启动时，这个进程将作为副本集的一部分运行。副本集的名称与传递给命令提示符的选项的值相同。这也解释了为什么在初始化副本集之前，在一个节点上执行的插入操作失败了。在mongo副本集中，只能有一个主节点，所有的插入和查询都在这里进行。在显示的图像中，**N1**节点显示为主节点，并监听端口**27000**以进行客户端连接。所有其他节点都是从节点，它们与主节点同步，因此默认情况下也禁用了查询。只有在主节点宕机时，其中一个从节点才会接管并成为主节点。但是，可以查询从节点的数据，就像我们在图像中所示的那样；我们将在下一个示例中看到如何从从节点实例查询。
- en: 'Well, all that is left now is to configure the replica set by grouping the
    three processes that we started. This is done by first defining a JSON object
    as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是通过将我们启动的三个进程分组来配置副本集。首先定义一个JSON对象如下：
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There are two fields, `_id` and `members`, for the unique ID of the replica
    set and an array of the hostnames and port numbers of the mongod server processes
    as part of this replica set, respectively. Using localhost to refer to the host
    is not a very good idea and is usually discouraged; however, in this case, as
    we started all the processes on the same machine, we are ok with it. It is preferred
    that you refer to the hosts by their hostnames even if they are running on localhost.
    Note that you cannot mix referring to the instances using localhost and hostnames
    both in the same configuration. It is either the hostname or localhost. To configure
    the replica set, we then connect to any one of the three running mongod processes;
    in this case, we connect to the first one and then execute the following from
    the shell:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个字段，`_id`和`members`，分别用于副本集的唯一ID和该副本集中mongod服务器进程的主机名和端口号数组。在这种情况下，使用localhost来引用主机并不是一个很好的主意，通常是不鼓励的；然而，在这种情况下，因为我们在同一台机器上启动了所有进程，所以可以接受。最好是通过主机名来引用主机，即使它们在localhost上运行。请注意，您不能在同一配置中混合使用localhost和主机名来引用实例。要么是主机名，要么是localhost。然后，我们连接到三个运行中的mongod进程中的任何一个来配置副本集；在这种情况下，我们连接到第一个，然后从shell中执行以下操作：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `_id` field in the `cfg` object passed has a value that is the same as
    the value we gave to the `--replSet` option on the command prompt when we started
    the server processes. Not giving the same value would throw the following error:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 传递的`cfg`对象中的`_id`字段的值与我们在启动服务器进程时给`--replSet`选项的值相同。如果不给出相同的值，将会抛出以下错误：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If all goes well and the initiate call is successful, we should see something
    similar to the following JSON response on the shell:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，初始化调用成功，我们应该在shell上看到类似以下JSON响应：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In a few seconds, you should see a different prompt for the shell that we executed
    this command from. It should now become a primary or secondary. The following
    is an example of the shell connected to a primary member of the replica set:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，我们应该看到从我们执行此命令的shell的不同提示。它现在应该成为主服务器或辅助服务器。以下是连接到副本集的主成员的shell的示例：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Executing `rs.status()` should give us some stats on the replica set's status,
    which we will explore in depth in a recipe later in the book in the administration
    section. For now, the `stateStr` field is important and contains the `PRIMARY`,
    `SECONDARY`, and other texts.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`rs.status()`应该给我们一些关于副本集状态的统计信息，我们将在本书的管理部分的后面的教程中深入探讨。目前，`stateStr`字段很重要，包含`PRIMARY`、`SECONDARY`和其他文本。
- en: There's more…
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Look at the *Connecting to the replica set in the shell to query and insert
    data* recipe to perform more operations from the shell after connecting to a replica
    set. Replication isn't as simple as we saw here. See the administration section
    for more advanced recipes on replication.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 查看*在shell中连接到副本集以查询和插入数据*教程，以在连接到副本集后从shell执行更多操作。复制并不像我们在这里看到的那么简单。请参阅管理部分，了解更多关于复制的高级教程。
- en: See also
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'If you are looking to convert a standalone instance to a replica set, then
    the instance with the data needs to become a primary first, and then empty secondary
    instances will be added to which the data will be synchronized. Refer to the following
    URL on how to perform this operation:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要将独立实例转换为副本集，那么具有数据的实例首先需要成为主服务器，然后将空的辅助实例添加到其中，数据将被同步。请参考以下网址以了解如何执行此操作：
- en: '[http://docs.mongodb.org/manual/tutorial/convert-standalone-to-replica-set/](http://docs.mongodb.org/manual/tutorial/convert-standalone-to-replica-set/)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.mongodb.org/manual/tutorial/convert-standalone-to-replica-set/](http://docs.mongodb.org/manual/tutorial/convert-standalone-to-replica-set/)'
- en: Connecting to the replica set in the shell to query and insert data
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在shell中连接到副本集以查询和插入数据
- en: In the previous recipe, we started a replica set of three mongod processes.
    In this recipe, we will work with this setup by connecting to it using the mongo
    client application, perform queries, insert data, and take a look at some of the
    interesting aspects of a replica set from a client's perspective.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个教程中，我们启动了三个mongod进程的副本集。在本教程中，我们将通过使用mongo客户端应用程序连接到它，执行查询，插入数据，并从客户端的角度查看副本集的一些有趣方面。
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The prerequisite for this recipe is that the replica set should be set up and
    running. Refer to the previous recipe, *Starting multiple instances as part of
    a replica set*, for details on how to start the replica set.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此教程的先决条件是副本集应该已经设置并运行。有关如何启动副本集的详细信息，请参考上一个教程，*作为副本集的一部分启动多个实例*。
- en: How to do it…
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We will start two shells here, one for `PRIMARY` and one for `SECONDARY`. Execute
    the following command on the command prompt:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在这里启动两个shell，一个用于`PRIMARY`，一个用于`SECONDARY`。在命令提示符上执行以下命令：
- en: '[PRE36]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The prompt of the shell tells us whether the server to which we have connected
    is `PRIMARY` or `SECONDARY`. It should show the replica set's name followed by
    a `:`, followed by the server state. In this case, if the replica set is initialized,
    up, and running, we should see either `repSetTest:PRIMARY>` or `repSetTest:SECONDARY>`.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: shell的提示告诉我们我们连接的服务器是`PRIMARY`还是`SECONDARY`。它应该显示副本集的名称，后跟`:`，后跟服务器状态。在这种情况下，如果副本集已初始化，正在运行，我们应该看到`repSetTest:PRIMARY>`或`repSetTest:SECONDARY>`。
- en: Suppose that the first server we connected to is a secondary, we need to find
    the primary. Execute the `rs.status()` command in the shell and look out for the
    `stateStr` field. This should give us the primary server. Use the mongo shell
    to connect to this server.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们连接到的第一个服务器是一个辅助服务器，我们需要找到主服务器。在shell中执行`rs.status()`命令，并查找`stateStr`字段。这应该给我们主服务器。使用mongo
    shell连接到此服务器。
- en: At this point, we should be having two shells running, one connected to a primary
    and another connected to a secondary.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，我们应该有两个运行的shell，一个连接到主服务器，另一个连接到辅助服务器。
- en: 'In the shell connected to the primary node, execute the following insert:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在连接到主节点的shell中，执行以下插入：
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There is nothing special about this. We just inserted a small document in a
    collection that we will use for the replication test.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这没什么特别的。我们只是在一个我们将用于复制测试的集合中插入了一个小文档。
- en: 'By executing the following query on the primary, we should get the following
    result:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在主服务器上执行以下查询，我们应该得到以下结果：
- en: '[PRE38]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So far, so good. Now, we will go to the shell that is connected to the `SECONDARY`
    node and execute the following:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。现在，我们将转到连接到`SECONDARY`节点的shell，并执行以下操作：
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'On doing this, we should see the following error on the console:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做后，我们应该在控制台上看到以下错误：
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now execute the following on the console:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在控制台上执行以下操作：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Execute the query that we executed in step 7 again on the shell. This should
    now get the results as follows:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在shell上再次执行我们在步骤7中执行的查询。现在应该得到以下结果：
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Execute the following insert on the secondary node; it should not succeed with
    the following message:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在辅助节点上执行以下插入；它不应该成功，并显示以下消息：
- en: '[PRE43]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works…
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We have done a lot of things in this recipe, and we will try to throw some light
    on some of the important concepts to remember.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们做了很多事情，并且将尝试对一些重要的概念进行一些解释。
- en: We basically connect to a primary and secondary node from the shell and perform
    (I would say, try to perform) selects and inserts. The architecture of a Mongo
    replica set is made of one primary (just one, no more, no less) and multiple secondary
    nodes. All writes happen on the `PRIMARY` only. Note that replication is not a
    mechanism to distribute the read request load that enables scaling the system.
    Its primary intent is to ensure high availability of data. By default, we are
    not permitted to read data from the secondary nodes. In step 6, we simply insert
    data from the primary node and then execute a query to get the document that we
    inserted. This is straightforward and nothing related to clustering here. Just
    note that we inserted the document from the primary and then queried it back.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上从shell连接到主节点和从节点，并执行（我会说，尝试执行）选择和插入操作。Mongo副本集的架构由一个主节点（只有一个，不多不少）和多个从节点组成。所有写操作只发生在`PRIMARY`上。请注意，复制不是一种分发读请求负载以实现系统扩展的机制。它的主要目的是确保数据的高可用性。默认情况下，我们不被允许从从节点读取数据。在第6步中，我们只是从主节点插入数据，然后执行查询以获取我们插入的文档。这很简单，与集群无关。只需注意我们是从主节点插入文档，然后再查询它。
- en: In the next step, we execute the same query but this time, from the secondary's
    shell. By default, querying is not enabled on the `SECONDARY`. There might be
    a small lag in replicating the data possibly due to heavy data volumes to be replicated,
    network latency, or hardware capacity to name a few of the causes, and thus, querying
    on the secondary might not reflect the latest inserts or updates made on the primary.
    However, if we are ok with it and can live with the slight lag in the data being
    replicated, all we need to do is enable querying on the `SECONDARY` node explicitly
    by just executing one command, `rs.slaveOk()` or `rs.slaveOk(true)`. Once this
    is done, we are free to execute queries on the secondary nodes too.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们执行相同的查询，但这次是从辅助的shell中执行。默认情况下，`SECONDARY`上未启用查询。由于要复制的数据量大、网络延迟或硬件容量等原因，可能会出现数据复制的小延迟，因此，在辅助上进行查询可能无法反映在主服务器上进行的最新插入或更新。但是，如果我们可以接受并且可以容忍数据复制中的轻微延迟，我们只需要通过执行一个命令`rs.slaveOk()`或`rs.slaveOk(true)`来显式地在`SECONDARY`节点上启用查询。完成此操作后，我们可以自由地在辅助节点上执行查询。
- en: Finally, we try to insert the data into a collection of the slave node. Under
    no circumstances is this permitted, regardless of whether we have done `rs.slaveOk()`.
    When `rs.slaveOk()` is invoked, it just permits the data to be queried from the
    `SECONDARY` node. All write operations still have to go to the primary and then
    flow down to the secondary. The internals of replication will be covered in a
    different recipe in the administration section.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们尝试将数据插入到从节点的集合中。无论我们是否执行了`rs.slaveOk()`，在任何情况下都不允许这样做。当调用`rs.slaveOk()`时，它只允许从`SECONDARY`节点查询数据。所有写操作仍然必须发送到主节点，然后流向从节点。复制的内部将在管理部分的不同示例中进行介绍。
- en: See also
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The next recipe, *Connecting to the replica set to query and insert data from
    a Java client*, is about connecting to a replica set from a Java client.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例，*连接到副本集以从Java客户端查询和插入数据*，是关于从Java客户端连接到副本集。
- en: Connecting to the replica set to query and insert data from a Java client
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到副本集以从Java客户端查询和插入数据
- en: In this recipe, we will demonstrate how to connect to a replica set from a Java
    client and how the client would automatically failover to another node in the
    replica set, should a primary node fail.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将演示如何从Java客户端连接到副本集，以及客户端如何在主节点失败时自动切换到副本集中的另一个节点。
- en: Getting ready
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to take a look at the *Connecting to the single node using a Java client*
    recipe as it contains all the prerequisites and steps to set up maven and other
    dependencies. As we are dealing with a Java client for replica sets, a replica
    set must be up and running. Refer to the *Starting multiple instances as part
    of a replica set* recipe for details on how to start the replica set.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要查看*使用Java客户端连接到单个节点*示例，因为它包含了设置maven和其他依赖项的所有先决条件和步骤。由于我们正在处理副本集的Java客户端，因此副本集必须处于运行状态。有关如何启动副本集的详细信息，请参阅*作为副本集的一部分启动多个实例*示例。
- en: How to do it…
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Write/copy the following piece of code: (This Java class is also available
    for download from the Packt website.)'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写/复制以下代码片段：（此Java类也可从Packt网站下载。）
- en: '[PRE44]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Connect to any of the nodes in the replica set, say to `localhost:27000`, and
    execute `rs.status()` from the shell. Take a note of the primary instance in the
    replica set and connect to it from the shell if `localhost:27000` is not a primary.
    Here, switch to the administrator database as follows:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到副本集中的任何节点，比如`localhost:27000`，并从shell中执行`rs.status()`。记录副本集中的主实例，并从shell连接到它，如果`localhost:27000`不是主实例。在这里，切换到管理员数据库如下：
- en: '[PRE45]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We now execute the preceding program from the operating system shell as follows:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们从操作系统shell中执行前面的程序：
- en: '[PRE46]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Shut down the primary instance by executing the following on the mongo shell
    that is connected to the primary:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在连接到主实例的mongo shell上执行以下操作来关闭主实例：
- en: '[PRE47]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Watch the output on the console where the `com.packtpub.mongo.cookbook.ReplicaSetMongoClient`
    class is executed using maven.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察在使用maven执行`com.packtpub.mongo.cookbook.ReplicaSetMongoClient`类时控制台上的输出。
- en: How it works…
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'An interesting thing to observe is how we instantiate the `MongoClient` instance.
    It is done as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的事情是观察我们如何实例化`MongoClient`实例。它是这样做的：
- en: '[PRE48]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The constructor takes a list of `com.mongodb.ServerAddress`. This class has
    a lot of overloaded constructors but we choose to use the one that takes the hostname
    and then port. What we have done is provided all the server details in a replica
    set as a list. We haven't mentioned what is the `PRIMARY` node and what are the
    `SECONDARY` nodes. `MongoClient` is intelligent enough to figure this out and
    connect to the appropriate instance. The list of servers provided is called the
    seed list. It need not contain an entire set of servers in a replica set though
    the objective is to provide as much as we can. `MongoClient` will figure out all
    the server details from the provided subset. For example, if the replica set is
    of five nodes but we provide only three servers, it works fine. On connecting
    with the provided replica set servers, the client will query them to get the replica
    set metadata and figure out the rest of the provided servers in the replica set.
    In the preceding case, we instantiated the client with three instances in the
    replica set. If the replica set was to have five members, then instantiating the
    client with just three of them is still good enough and the remaining two instances
    will be automatically discovered.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受一个`com.mongodb.ServerAddress`列表。这个类有很多重载的构造函数，但我们选择使用一个接受主机名和端口的构造函数。我们所做的是将副本集中的所有服务器详细信息提供为一个列表。我们没有提到什么是`PRIMARY`节点，什么是`SECONDARY`节点。`MongoClient`足够智能，可以弄清楚这一点，并连接到适当的实例。提供的服务器列表称为种子列表。它不一定要包含副本集中的所有服务器，尽管目标是尽可能提供尽可能多的服务器。`MongoClient`将从提供的子集中找出所有服务器的详细信息。例如，如果副本集有五个节点，但我们只提供了三个服务器，它也可以正常工作。连接到提供的副本集服务器后，客户端将查询它们以获取副本集元数据，并找出副本集中提供的其他服务器的其余部分。在前面的情况下，我们用三个实例实例化了客户端。如果副本集有五个成员，那么用其中的三个实例化客户端仍然是足够的，剩下的两个实例将被自动发现。
- en: 'Next, we start the client from the command prompt using maven. Once the client
    is running in the loop, we bring down the primary instance to find one document.
    We should see something as the following output to the console:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用maven从命令提示符启动客户端。一旦客户端在循环中运行，我们关闭主实例以找到一个文档。我们应该在控制台上看到以下输出：
- en: '[PRE49]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As we can see, the query in the loop was interrupted when the primary node went
    down. However, the client switched to the new primary seamlessly. Well, nearly
    seamlessly, as the client might have to catch an exception and retry the operation
    after a predetermined interval has elapsed.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，在主节点宕机时，循环中的查询被中断。然而，客户端无缝地切换到了新的主节点。嗯，几乎是无缝的，因为客户端可能需要捕获异常，并在经过预定的时间间隔后重试操作。
- en: Connecting to the replica set to query and insert data using a Python client
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python客户端连接到副本集以查询和插入数据
- en: In this recipe, we will demonstrate how to connect to a replica set using a
    Python client and how the client would automatically failover to another node
    in the replica set, should a primary node fail.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将演示如何使用Python客户端连接到副本集，以及客户端在主节点故障时如何自动切换到副本集中的另一个节点。
- en: Getting ready
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Refer to the *Connecting to the single node using a Python client* recipe as
    it describes how to set up and install PyMongo, the Python driver for MongoDB.
    Additionally, a replica set must be up and running. Refer to the *Starting multiple
    instances as part of a replica set* recipe for details on how to start the replica
    set.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考*使用Python客户端连接到单个节点*示例，因为它描述了如何设置和安装PyMongo，MongoDB的Python驱动程序。此外，副本集必须处于运行状态。请参考*作为副本集的一部分启动多个实例*示例，了解如何启动副本集的详细信息。
- en: How to do it…
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'Write/copy the following piece of code to `replicaset_client.py`: (This script
    is also available for download from the Packt website.)'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码写入/复制到`replicaset_client.py`中：（此脚本也可从Packt网站下载。）
- en: '[PRE50]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Connect to any of the nodes in the replica set, say to `localhost:27000`, and
    execute `rs.status()` from the shell. Take a note of the primary instance in the
    replica set and connect to it from the shell, if `localhost:27000` is not a primary.
    Here, switch to the administrator database as follows:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到副本集中的任何节点，比如`localhost:27000`，并从shell中执行`rs.status()`。记下副本集中的主实例，并从shell中连接到它，如果`localhost:27000`不是主节点。在这里，切换到管理员数据库如下：
- en: '[PRE51]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We now execute the preceding script from the operating system shell as follows:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们从操作系统shell中执行上述脚本如下：
- en: '[PRE52]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Shut down the primary instance by executing the following on the mongo shell
    that is connected to the primary:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在连接到主节点的mongo shell上执行以下操作关闭主实例：
- en: '[PRE53]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Watch the output on the console where the Python script is executed.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察在执行Python脚本的控制台上的输出。
- en: How it works…
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: You will notice that, in this script, we instantiated the mongo client by giving
    a list of hosts instead of a single host. As of version 3.0, the pymongo driver's
    `MongoClient()` class can accept either a list of hosts or a single host during
    initialization and deprecate `MongoReplicaSetClient()`. The client will attempt
    to connect to the first host in the list, and if successful, will be able to determine
    the other nodes in the replica set. We are also passing the `replicaSet='repSetTest'`
    parameter exclusively, ensuring that the client checks whether the connected node
    is a part of this replica set.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，在这个脚本中，我们通过给出主机列表而不是单个主机来实例化mongo客户端。从版本3.0开始，pymongo驱动程序的`MongoClient()`类在初始化时可以接受主机列表或单个主机，并弃用了`MongoReplicaSetClient()`。客户端将尝试连接列表中的第一个主机，如果成功，将能够确定副本集中的其他节点。我们还专门传递了`replicaSet='repSetTest'`参数，确保客户端检查连接的节点是否是这个副本集的一部分。
- en: Once connected, we perform normal database operations such as selecting the
    test database, dropping the `repTest` collection, and inserting a single document
    into the collection.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接，我们执行正常的数据库操作，比如选择测试数据库、删除`repTest`集合，并向集合中插入一个文档。
- en: 'Following this, we enter a conditional for loop, iterating five times. Each
    time, we fetch the record, display it, and sleep for three seconds. While the
    script is in this loop, we shut down the primary node in the replica set as mentioned
    in step 4\. We should see an output similar to this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进入一个条件循环，循环五次。每次，我们获取记录，显示它，并休眠三秒。在脚本处于此循环时，我们关闭副本集中的主节点，如步骤4中所述。我们应该看到类似于以下的输出：
- en: '[PRE54]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the preceding output, the client gets disconnected from the primary node
    midway. However, very soon, a new primary node is selected by the remaining nodes
    and the mongo client is able to resume the connection.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，客户端在主节点中途断开连接。然而，很快，剩余节点选择了一个新的主节点，mongo客户端能够恢复连接。
- en: Starting a simple sharded environment of two shards
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动由两个分片组成的简单分片环境
- en: In this recipe, we will set up a simple sharded setup made up of two data shards.
    There will be no replication configured as this is the most basic shard setup
    to demonstrate the concept. We won't be getting deep into the internals of sharding,
    which we will explore more in the administration section.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将建立一个由两个数据分片组成的简单分片设置。由于这是最基本的分片设置来演示概念，因此不会配置任何复制。我们不会深入研究分片的内部结构，这将在管理部分中更多地探讨。
- en: Here is a bit of theory before we proceed. Scalability and availability are
    two important cornerstones to build any mission-critical application. Availability
    is something that was taken care of by the replica sets, which we discussed in
    previous recipes in this chapter. Let's look at scalability now. Simply put, scalability
    is the ease with which the system can cope with increasing data and request load.
    Consider an e-commerce platform. On regular days, the number of hits to the site
    and load is fairly modest and the system's response times and error rates are
    minimal. (This is subjective.) Now, consider the days where the system load becomes
    twice, thrice, or even more than that of an average day's load, say on Thanksgiving
    day, Christmas, and so on. If the platform is able to deliver similar levels of
    service on these high load days as on any other day, the system is said to have
    scaled up well to the sudden increase in the number of requests.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，这里有一点理论。可伸缩性和可用性是构建任何关键任务应用程序的两个重要基石。可用性是由我们在本章前面的配方中讨论的副本集来处理的。现在让我们来看看可伸缩性。简单地说，可伸缩性是系统应对不断增长的数据和请求负载的能力。考虑一个电子商务平台。在正常的日子里，对网站的点击次数和负载都相当适度，系统的响应时间和错误率都很低。（这是主观的。）现在，考虑系统负载变成平常日负载的两倍、三倍，甚至更多，比如感恩节、圣诞节等。如果平台能够在这些高负载日提供与任何其他日子相似的服务水平，系统就被认为已经很好地应对了请求数量的突然增加。
- en: Now, consider an archiving application that needs to store the details of all
    the requests that hit a particular website over the past decade. For each request
    hitting the website, we create a new record in the underlying data store. Suppose
    that each record is of 250 bytes with an average load of three million requests
    per day, we will cross 1 TB of the data mark in about five years. This data would
    be used for various analytics purposes and might be frequently queried. The query
    performance should not be drastically affected when the data size increases. If
    the system is able to cope with this increasing data volume and still give decent
    performance comparable to performance on low data volumes, the system is said
    to have scaled up well.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑一个需要存储过去十年中击中特定网站的所有请求的详细信息的归档应用程序。对于击中网站的每个请求，我们在底层数据存储中创建一个新记录。假设每个记录的大小为250字节，平均每天有300万个请求，我们将在大约五年内超过1
    TB的数据标记。这些数据将用于各种分析目的，并可能经常被查询。当数据量增加时，查询性能不应受到严重影响。如果系统能够应对不断增长的数据量，并且在数据量较低时仍能提供与低数据量时相当的性能，系统就被认为已经很好地扩展了。
- en: Now that we have seen in brief what scalability is, let me tell you that sharding
    is a mechanism that lets a system scale to increasing demands. The crux lies in
    the fact that the entire data is partitioned into smaller segments and distributed
    across various nodes called shards. Suppose that we have a total of 10 million
    documents in a mongo collection. If we shard this collection across 10 shards,
    then we will ideally have *10,000,000/10 = 1,000,000* documents on each shard.
    At a given point of time, only one document will reside on one shard (which by
    itself will be a replica set in a production system). However, there is some magic
    involved that keeps this concept hidden from the developer who is querying the
    collection and who gets one unified view of the collection irrespective of the
    number of shards. Based on the query, it is mongo that decides which shard to
    query for the data and returns the entire result set. With this background, let's
    set up a simple shard and take a closer look at it.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们简要地了解了可伸缩性是什么，让我告诉你，分片是一种机制，让系统能够满足不断增长的需求。关键在于整个数据被分成更小的段，并分布在称为分片的各个节点上。假设我们在mongo集合中有1000万个文档。如果我们将这个集合分片到10个分片上，那么理想情况下每个分片上将有*10,000,000/10
    = 1,000,000*个文档。在任何给定的时间点，只有一个文档会驻留在一个分片上（这本身将是生产系统中的一个副本集）。然而，有一些魔法使这个概念隐藏在查询集合的开发人员之外，无论分片的数量如何，他们都会得到一个统一的集合视图。根据查询，mongo决定查询哪个分片的数据并返回整个结果集。有了这个背景，让我们建立一个简单的分片并仔细研究它。
- en: Getting ready
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Apart from the MongoDB server already installed, no prerequisites are there
    from a software perspective. We will be creating two data directories, one for
    each shard. There will be a directory for the data and one for logs.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 除了已经安装的MongoDB服务器，从软件角度来看，没有其他先决条件。我们将创建两个数据目录，一个用于每个分片。将有一个用于数据和一个用于日志的目录。
- en: How to do it…
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We start by creating directories for the logs and data. Create the following
    directories, `/data/s1/db`, `/data/s2/db`, and `/logs`. On Windows, we can have
    `c:\data\s1\db` and so on for the data and log directories. There is also a configuration
    server that is used in the sharded environment to store some metadata. We will
    use `/data/con1/db` as the data directory for the configuration server.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建日志和数据的目录。创建以下目录，`/data/s1/db`，`/data/s2/db`和`/logs`。在Windows上，我们可以有`c:\data\s1\db`等等用于数据和日志目录。在分片环境中还有一个用于存储一些元数据的配置服务器。我们将使用`/data/con1/db`作为配置服务器的数据目录。
- en: Start the following mongod processes, one for each of the two shards, one for
    the configuration database, and one mongos process. For the Windows platform,
    skip the `--fork` parameter as it is not supported.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动以下mongod进程，一个用于两个分片中的每一个，一个用于配置数据库，一个用于mongos进程。对于Windows平台，跳过`--fork`参数，因为它不受支持。
- en: '[PRE55]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'From the command prompt, execute the following command. This should show a
    mongos prompt as follows:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令提示符中执行以下命令。这应该显示一个mongos提示，如下所示：
- en: '[PRE56]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, we set up the shard. From the mongos shell, execute the following
    two commands:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们设置分片。从mongos shell中，执行以下两个命令：
- en: '[PRE57]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'On each addition of a shard, we should get an ok reply. The following JSON
    message should be seen giving the unique ID for each shard added:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每次添加分片时，我们应该收到一个ok回复。应该看到以下JSON消息，为每个添加的分片提供唯一ID：
- en: '[PRE58]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We used localhost everywhere to refer to the locally running servers. It is
    not a recommended approach and is discouraged. The better approach would be to
    use hostnames even if they are local processes.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在所有地方都使用localhost来引用本地运行的服务器。这不是一种推荐的方法，也是不鼓励的。更好的方法是使用主机名，即使它们是本地进程。
- en: How it works…
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Let's see what all we did in the process. We created three directories for data
    (two for the shards and one for the configuration database) and one directory
    for logs. We can have a shell script or batch file to create the directories as
    well. In fact, in large production deployments, setting up shards manually is
    not only time-consuming but also error-prone.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们在这个过程中做了什么。我们为数据创建了三个目录（两个用于分片，一个用于配置数据库）和一个日志目录。我们也可以有一个shell脚本或批处理文件来创建这些目录。事实上，在大型生产部署中，手动设置分片不仅耗时，而且容易出错。
- en: Tip
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的帐户中购买的所有Packt图书下载示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接发送到您的邮箱。
- en: 'Let''s try to get a picture of what exactly we have done and are trying to
    achieve. The following is an image of the shard setup that we just did:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着了解我们到底做了什么，以及我们试图实现什么。以下是我们刚刚设置的分片设置的图像：
- en: '![How it works…](img/4831_01_03.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/4831_01_03.jpg)'
- en: If we look at the preceding image and the servers started in step 2, we have
    shard servers that would store the actual data in the collections. These were
    the first two of the four processes that we started listening to ports `27000`
    and `27001`. Next, we started a configuration server that is seen on the left
    side in this image. It is the third server of the four servers started in step
    2 and it listens to port `25000` for the incoming connections. The sole purpose
    of this database is to maintain the metadata about the shard servers. Ideally,
    only the mongos process or drivers connect to this server for the shard details/metadata
    and the shard key information. We will see what a shard key is in the next recipe,
    where we play around a sharded collection and see the shards that we have created
    in action.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下前面的图像和第2步中启动的服务器，我们有分片服务器，它们将在集合中存储实际数据。这是我们启动的四个进程中的前两个，它们监听端口`27000`和`27001`。接下来，我们启动了一个配置服务器，在这个图像的左侧可以看到。这是第2步中启动的四个服务器中的第三个服务器，它监听端口`25000`以进行传入连接。这个数据库的唯一目的是维护有关分片服务器的元数据。理想情况下，只有mongos进程或驱动程序连接到此服务器以获取有关分片的详细信息/元数据和分片键信息。我们将在下一个示例中看到分片键是什么，我们将在其中操作一个分片集合并查看我们创建的分片的操作。
- en: Finally, we have a mongos process. This is a lightweight process that doesn't
    do any persistence of data and just accepts connections from clients. This is
    the layer that acts as a gatekeeper and abstracts the client from the concept
    of shards. For now, we can view it as basically a router that consults the configuration
    server and takes the decision to route the client's query to the appropriate shard
    server for execution. It then aggregates the result from various shards if applicable
    and returns the result to the client. It is safe to say that no client connects
    directly to the configuration or shard servers; in fact, no one ideally should
    connect to these processes directly except for some administration operations.
    Clients simply connect to the mongos process and execute their queries and insert
    or update operations.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个mongos进程。这是一个轻量级的进程，不做任何数据持久化，只接受来自客户端的连接。这是一个作为网关的层，将客户端与分片的概念抽象出来。现在，我们可以将其视为基本上是一个路由器，它会查询配置服务器并决定将客户端的查询路由到适当的分片服务器以执行。然后，如果适用，它会聚合来自各个分片的结果并将结果返回给客户端。可以肯定地说，没有客户端直接连接到配置或分片服务器；事实上，除了一些管理操作外，理想情况下没有人应该直接连接到这些进程。客户端只需连接到mongos进程并执行他们的查询和插入或更新操作。
- en: 'Just starting the shard server, configuration server, and mongos process doesn''t
    create a sharded environment. On starting up the mongos process, we provided it
    with the details of the configuration server. What about the two shards that would
    be storing the actual data? However, the two mongod processes started as shard
    servers are not yet declared anywhere as shard servers in the configuration. This
    is exactly what we do in the final step by invoking `sh.addShard()` for both the
    shard servers. The mongos process is provided with the configuration server''s
    details on startup. Adding shards from the shell stores this metadata about the
    shards in the configuration database, and the mongos processes then would be querying
    this config database for the shard''s information. On executing all the steps
    of the recipe, we have an operational shard as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅启动碎片服务器、配置服务器和mongos进程并不能创建一个分片化的环境。在启动mongos进程时，我们提供了配置服务器的详细信息。那么存储实际数据的两个碎片怎么办？然而，作为碎片服务器启动的两个mongod进程尚未在配置中声明为碎片服务器。这正是我们在最后一步中通过为两个碎片服务器调用
    `sh.addShard()` 来完成的。在启动时，mongos进程提供了配置服务器的详细信息。从shell中添加碎片将存储关于碎片的元数据在配置数据库中，并且mongos进程随后将查询此配置数据库以获取碎片的信息。执行示例的所有步骤后，我们将得到一个操作中的碎片，如下所示：
- en: '![How it works…](img/4831_01_04.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/4831_01_04.jpg)'
- en: Before we conclude, the shard that we have set up here is far from ideal and
    not how it would be done in a production environment. The preceding image gives
    us an idea of how a typical shard would be in a production environment. The number
    of shards would not be two but many more. Additionally, each shard will be a replica
    set to ensure high availability. There would be three configuration servers to
    ensure availability of the configuration servers as well. Similarly, there will
    be any number of mongos processes created for a shard listening for client connections.
    In some cases, it might even be started on a client application's server.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束之前，我们在这里设置的碎片远非理想，也不是在生产环境中的操作方式。前面的图片给了我们一个关于生产环境中典型碎片的想法。碎片的数量不会是两个，而是更多。此外，每个碎片将是一个副本集，以确保高可用性。将有三个配置服务器来确保配置服务器的可用性。同样，将创建任意数量的用于监听客户端连接的碎片的mongos进程。在某些情况下，甚至可以在客户端应用程序的服务器上启动。
- en: There's more…
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: What good is a shard unless we put it to action and see what happens from the
    shell on inserting and querying the data? In the next recipe, we will make use
    of the shard setup here, add some data, and see it in action.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们将碎片投入使用并从shell中插入和查询数据，否则碎片有何用处？在下一个示例中，我们将利用这里的碎片设置，添加一些数据，并查看其运行情况。
- en: Connecting to a shard in the shell and performing operations
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在shell中连接到一个碎片并执行操作
- en: In this recipe, we will connect to a shard from a command prompt, see how to
    shard a collection, and observe the data splitting in action on some test data.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将从命令提示符连接到一个碎片，看看如何为一个集合分片，并观察一些测试数据的分割情况。
- en: Getting ready
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Obviously, we need a sharded mongo server setup up and running. See the previous
    recipe, *Starting a simple sharded environment of two shards*, for more details
    on how to set up a simple shard. The mongos process, as in the previous recipe,
    should be listening to port number `27017`. We have got some names in a JavaScript
    file called `names.js`. This file needs to be downloaded from the Packt website
    and kept on the local filesystem. The file contains a variable called `names`
    and the value is an array with some JSON documents as the values, each one representing
    a person. The contents look as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要一个运行中的分片化mongo服务器设置。有关如何设置简单碎片的更多详细信息，请参阅上一个示例，*启动由两个碎片组成的简单分片环境*。mongos进程，如上一个示例中所述，应该监听端口号
    `27017`。我们在一个名为 `names.js` 的JavaScript文件中得到了一些名称。这个文件需要从Packt网站下载并保存在本地文件系统上。该文件包含一个名为
    `names` 的变量，其值是一个包含一些JSON文档的数组，每个文档代表一个人。内容如下：
- en: '[PRE59]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How to do it…
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'Start the mongo shell and connect to the default port on localhost as follows.
    This will ensure that the names will be available in the current shell:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动mongo shell并连接到本地主机上的默认端口，如下所示。这将确保名称在当前shell中可用：
- en: '[PRE60]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Switch to the database that would be used to test the sharding; we call it
    `shardDB`:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到将用于测试分片的数据库；我们称之为 `shardDB`：
- en: '[PRE61]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Enable sharding at the database level as follows:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据库级别启用分片如下：
- en: '[PRE62]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Shard a collection called `person` as follows:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示为一个名为 `person` 的集合分片：
- en: '[PRE63]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Add the test data to the sharded collection:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将测试数据添加到分片集合中：
- en: '[PRE64]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Execute the following to get a query plan and the number of documents on each
    shard:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下操作以获取查询计划和每个碎片上的文档数量：
- en: '[PRE65]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: How it works…
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: This recipe demands some explanation. We downloaded a JavaScript file that defines
    an array of 20 people. Each element of the array is a JSON object with the `name`
    and `age` attributes. We start the shell connecting to the mongos process loaded
    with this JavaScript file. We then switch to `shardDB`, which we use for the purpose
    of sharding.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例需要一些解释。我们下载了一个JavaScript文件，其中定义了一个包含20个人的数组。数组的每个元素都是一个具有 `name` 和 `age`
    属性的JSON对象。我们启动shell连接到加载了这个JavaScript文件的mongos进程。然后切换到我们用于分片目的的 `shardDB`。
- en: For a collection to be sharded, the database in which it will be created needs
    to be enabled for the sharding first. We do this using `sh.enableSharding()`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 要使集合分片化，首先需要为将创建集合的数据库启用分片。我们使用 `sh.enableSharding()` 来实现这一点。
- en: The next step is to enable the collection to be sharded. By default, all the
    data will be kept on one shard and not split across different shards. Think about
    it; how will Mongo be able to split the data meaningfully? The whole intention
    is to split it meaningfully and as evenly as possible so that whenever we query
    based on the shard key, Mongo would easily be able to determine which shard(s)
    to query. If a query doesn't contain the shard key, the execution of the query
    will happen on all the shards and the data would then be collated by the mongos
    process before returning it to the client. Thus, choosing the right shard key
    is very crucial.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是启用集合进行分片。默认情况下，所有数据将保存在一个分片上，而不会分散在不同的分片上。想想看；Mongo如何能够有意义地分割数据？整个意图是有意义地分割数据，并尽可能均匀地分割，以便每当我们基于分片键进行查询时，Mongo都能轻松地确定要查询哪个分片。如果查询不包含分片键，查询将在所有分片上执行，然后数据将由mongos进程汇总后返回给客户端。因此，选择正确的分片键非常关键。
- en: 'Let''s now see how to shard the collection. We do this by invoking `sh.shardCollection("shardDB.person",
    {name: "hashed"}, false)`. There are three parameters here:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '现在让我们看看如何对集合进行分片。我们通过调用`sh.shardCollection("shardDB.person", {name: "hashed"},
    false)`来实现这一点。这里有三个参数：'
- en: The fully qualified name of the collection in the `<db name>.<collection name>`
    format is the first parameter of the `shardCollection` method.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shardCollection`方法的第一个参数是`<db name>.<collection name>`格式的集合的完全限定名称。'
- en: 'The second parameter is the field name to shard on in the collection. This
    is the field that would be used to split the documents on the shards. One of the
    requirements of a good shard key is that it should have high cardinality. (The
    number of possible values should be high.) In our test data, the name value has
    very low cardinality and thus is not a good choice as a shard key. We hash this
    key when using this as a shard key. We do so by mentioning the key as `{name:
    "hashed"}`.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '第二个参数是集合中用于分片的字段名称。这是用于在分片上拆分文档的字段。一个好的分片键的要求之一是它应该具有很高的基数（可能值的数量应该很高）。在我们的测试数据中，名称值的基数非常低，因此不是一个好的分片键选择。当使用此作为分片键时，我们对此键进行哈希。我们通过将键标记为`{name:
    "hashed"}`来实现这一点。'
- en: The last parameter specifies whether the value used as the shard key is unique
    or not. The name field is definitely not unique and thus it will be false. If
    the field was, say, the person's social security number, it could have been set
    as true. Additionally, SSN is a good choice for a shard key due to its high cardinality.
    Remember that the shard key has to be present for the query to be efficient.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个参数指定用作分片键的值是否是唯一的。名称字段肯定不是唯一的，因此它将是false。如果该字段是，比如说，人的社会安全号码，它可以被设置为true。此外，社会安全号码是一个很好的分片键选择，因为它的基数很高。请记住，分片键必须存在才能使查询有效。
- en: 'The last step is to see the execution plan for the finding of all the data.
    The intent of this operation is to see how the data is being split across two
    shards. With 300,000 documents, we expect something around 150,000 documents on
    each shard. However, from the distribution statistics, we can observe that `shard0000`
    has `1,49,715` documents whereas `shard0001` has `150285`:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是查看查找所有数据的执行计划。此操作的目的是查看数据如何分布在两个分片上。对于30万个文档，我们期望每个分片大约有15万个文档。然而，从分布统计数据中，我们可以观察到`shard0000`有`1,49,715`个文档，而`shard0001`有`150285`个文档：
- en: '[PRE66]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: There are a couple of additional suggestions that I would recommend you to do.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您做一些额外的建议。
- en: Connect to the individual shard from the mongo shell and execute queries on
    the person collection. See that the counts in these collections are similar to
    what we see in the preceding plan. Additionally, one can find out that no document
    exists on both the shards at the same time.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 从mongo shell连接到各个分片，并在person集合上执行查询。查看这些集合中的计数是否与前面的计划中看到的相似。此外，可以发现没有文档同时存在于两个分片上。
- en: 'We discussed in brief about how cardinality affects the way the data is split
    across shards. Let''s do a simple exercise. We first drop the person collection
    and execute the shardCollection operation again but, this time, with the `{name:
    1}` shard key instead of `{name: "hashed"}`. This ensures that the shard key is
    not hashed and stored as is. Now, load the data using the JavaScript function
    we used earlier in step number 5, and then execute the `explain()` command on
    the collection once the data is loaded. Observe how the data is now split (or
    not) across the shards.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '我们简要讨论了基数如何影响数据在分片上的分布方式。让我们做一个简单的练习。我们首先删除person集合，然后再次执行shardCollection操作，但这次使用`{name:
    1}`分片键，而不是`{name: "hashed"}`。这确保分片键不被哈希并按原样存储。现在，使用我们在第5步中使用的JavaScript函数加载数据，然后在数据加载后对集合执行`explain()`命令。观察数据如何在分片上分割（或不分割）。'
- en: There's more…
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: A lot of questions must now be coming up such as what are the best practices?
    What are some tips and tricks? How is the sharding thing pulled off by MongoDB
    behind the scenes in a way that is transparent to the end user?
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一定会有很多问题涌现出来，比如什么是最佳实践？有什么技巧和窍门？MongoDB在幕后是如何实现分片的，以使其对最终用户透明呢？
- en: This recipe here only explained the basics. In the administration section, all
    such questions will be answered.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的配方只解释了基础知识。在管理部分，所有这些问题都将得到解答。
