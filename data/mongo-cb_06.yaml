- en: Chapter 6. Monitoring and Backups
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。监控和备份
- en: 'In this chapter, we will take a look at the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将查看以下教程：
- en: Signing up for MMS and setting up an MMS monitoring agent
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册MMS并设置MMS监控代理
- en: Managing users and groups in MMS Console
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MMS控制台中管理用户和组
- en: Monitoring instances and setting up alerts in MMS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MMS中监视实例并设置警报
- en: Setting up monitoring alerts in MMS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MMS中设置监控警报
- en: Back up and restore data in Mongo using out-of-the-box tools
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用现成的工具备份和恢复Mongo中的数据
- en: Configuring MMS Backup service
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置MMS备份服务
- en: Managing backups in MMS Backup service
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MMS备份服务中管理备份
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Monitoring and backup is an important aspect of any mission-critical software
    in production. Monitoring proactively lets us take action whenever an abnormal
    event occurs in the system that can compromise data consistency, availability,
    or the performance of the system. Issues may come to light after having a significant
    impact in the absence of monitoring the systems proactively. We covered administration-related
    recipes in [Chapter 4](ch04.html "Chapter 4. Administration"), *Administration*,
    and both these activities are part of it; however, they demand a separate chapter
    as the content to be covered is extensive. In this chapter, we will see how to
    monitor various parameters and set up alerts for various parameters of your MongoDB
    cluster using the **Mongo Monitoring Service** (**MMS**). We will look at some
    mechanisms to backup data using the out-of-the-box tools and also using the MMS
    backup service.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中，监控和备份是任何关键任务关键软件的重要方面。主动监控让我们在系统中发生异常事件时采取行动，这些事件可能危及数据一致性、可用性或系统性能。如果没有主动监控系统，问题可能在对系统产生重大影响后才会显现出来。我们在[第4章](ch04.html
    "第4章。管理")中涵盖了与管理相关的教程，这两个活动都是其中的一部分；但是，它们需要一个单独的章节，因为要涵盖的内容很广泛。在本章中，我们将看到如何使用**Mongo
    Monitoring Service**（**MMS**）监控MongoDB集群的各种参数并设置警报。我们将研究一些使用现成工具和MMS备份服务备份数据的机制。
- en: Signing up for MMS and setting up an MMS monitoring agent
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册MMS并设置MMS监控代理
- en: MMS is a cloud-based or on-premise service that enables you to monitor your
    MongoDB cluster. The on-premise version is available with an enterprise subscription
    only. It gives you one central place that lets the administrators monitor the
    health of the server instances and the boxes on which the instances are running.
    In this recipe, we will see what the software requirements are and how to set
    up MMS for Mongo.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: MMS是一个基于云或本地的服务，可以让您监视MongoDB集群。本地版本仅适用于企业订阅。它为管理员提供了一个中心位置，让管理员监视服务器实例的健康状况以及实例所在的服务器。在本教程中，我们将看到软件要求是什么，以及如何为Mongo设置MMS。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be starting a single instance of `mongod`, which we will use for monitoring
    purposes. Refer to the recipe *Installing single node MongoDB* from [Chapter 1](ch01.html
    "Chapter 1. Installing and Starting the Server"), *Installing and Starting the
    Server* to start a MongoDB instance and connect to it from a Mongo shell. The
    monitoring agent used for sending the statistics of the mongo instance to the
    monitoring service uses Python and pymongo. Refer to the recipe *Connecting to
    a single node using a Python client* in [Chapter 1](ch01.html "Chapter 1. Installing
    and Starting the Server"), *Installing and Starting the Server* to learn more
    about how to install Python and pymongo, the Python client of MongoDB.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将启动一个`mongod`的单个实例，用于监视目的。参考[第1章](ch01.html "第1章。安装和启动服务器")中的*安装单节点MongoDB*的步骤，启动MongoDB实例并从Mongo
    shell连接到它。用于将mongo实例的统计信息发送到监控服务的监控代理使用Python和pymongo。参考[第1章](ch01.html "第1章。安装和启动服务器")中的*使用Python客户端连接到单节点*的步骤，了解如何安装Python和pymongo，MongoDB的Python客户端。
- en: How to do it…
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'If you don''t already have a MMS account, then log in to [https://mms.mongodb.com/](https://mms.mongodb.com/)
    and sign up for an account. On signing up and logging in, you should see the following
    page:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有MMS帐户，请登录[https://mms.mongodb.com/](https://mms.mongodb.com/)并注册一个帐户。注册并登录后，您应该看到以下页面：
- en: '![How to do it…](img/B04831_06_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤…](img/B04831_06_01.jpg)'
- en: Click on the **Get Started** button under **Monitoring**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 单击**监控**下的**开始**按钮。
- en: Once we reach the **Download Agent** option in the menu, click on the appropriate
    OS platform to download the agent. Follow the instructions given after selecting
    the appropriate OS platform. Note down the **apiKey** too. For example, if the
    Windows platform is selected, we would see the following:![How to do it…](img/B04831_06_02.jpg)
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦到达菜单中的**下载代理**选项，请单击适当的操作系统平台以下载代理。选择适当的操作系统平台后，按照给定的说明进行操作。也记下**apiKey**。例如，如果选择了Windows平台，我们将看到以下内容：![操作步骤…](img/B04831_06_02.jpg)
- en: Once the installation is complete, open the file `monitoring-agent.config`.
    It will be present in the configuration folder selected while installing the agent.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，打开`monitoring-agent.config`文件。它将位于安装代理时选择的配置文件夹中。
- en: Look out for the key `mmsApiKey` in the file and set its value to the API key
    that was noted down in step 1.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中查找关键的`mmsApiKey`，并将其值设置为在第1步中记录的API密钥。
- en: Once the service is started (we have to go to `services.msc` on Windows, which
    can be done by typing `services.msc` in the run dialog (Windows + *R*) and start
    the service manually). The service would be named **MMS Monitoring Agent**. On
    the web page, click on the **Verify Agent** button. If all goes well, the started
    agent will be verified and a success message will be shown.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦服务启动（我们必须在Windows上转到`services.msc`，可以通过在运行对话框中输入`services.msc`（Windows + *R*）并手动启动服务来完成）。服务将被命名为**MMS
    Monitoring Agent**。在网页上，点击**验证代理**按钮。如果一切顺利，启动的代理将被验证，并显示成功消息。
- en: The next step is to configure the host. This host is the one that is seen from
    the agent's perspective running on the organization or individual's infrastructure.
    The following screen shows the screen used for the addition of a host. The hostname
    is the internal hostname (the hostname on the client's network), and the MMS on
    the cloud doesn't need to reach out to the MongoDB processes. It is the agent
    that collects the data from these mongodb processes and sends the data to the
    MMS service.![How to do it…](img/B04831_06_03.jpg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是配置主机。这个主机是从代理的角度看到的，在组织或个人基础设施上运行。下面的屏幕显示了用于添加主机的屏幕。主机名是内部主机名（客户网络上的主机名），云上的MMS不需要访问MongoDB进程。收集这些mongodb进程的数据并将数据发送到MMS服务的是代理。![如何操作...](img/B04831_06_03.jpg)
- en: Once the host's details are added, click on the **Verify Host** button. Once
    verification is done, click the **Start Monitoring** button.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了主机的详细信息，请单击**验证主机**按钮。验证完成后，单击**开始监视**按钮。
- en: We have successfully set up MMS and added one host to it that will be monitored.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功设置了MMS并向其添加了一个将被监视的主机。
- en: How it works…
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we set up an MMS agent and monitoring for a standalone MongoDB
    instance. The installation and setup process is pretty simple. We also added a
    standalone instance and all was okay.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们设置了一个MMS代理和监视一个独立的MongoDB实例。安装和设置过程非常简单。我们还添加了一个独立的实例，一切都很好。
- en: 'Suppose we have a replica set up and running (refer to the recipe *Starting
    multiple instances as part of a replica set* in [Chapter 1](ch01.html "Chapter 1. Installing
    and Starting the Server"), *Installing and Starting the Server*, for more details
    on how to start a replica set) and the three members are listening to ports `27000`,
    `27001`, and `27002`. Refer to point number 6 in the *How to do it…* section where
    we set up one standalone host. In the drop-down menu for **Host Type** select
    **Replica Set** and in the **Internal hostname**, give a valid hostname of any
    member of the replica set (in my case **Amol-PC** and port **27001** were given,
    which is a secondary instance); all other instances will be automatically discovered
    and will be visible under the hosts, as shown here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经设置并运行了一个副本集（参考第1章中的教程*作为副本集的一部分启动多个实例*，*安装和启动服务器*，了解如何启动副本集的更多细节），三个成员正在监听端口`27000`，`27001`和`27002`。参考*如何操作...*部分中的第6点，我们设置了一个独立的主机。在**主机类型**的下拉菜单中选择**副本集**，在**内部主机名**中，给出副本集的任何成员的有效主机名（在我的情况下，给出了**Amol-PC**和端口**27001**，这是一个辅助实例）；所有其他实例将被自动发现，并在主机下可见，如下所示：
- en: '![How it works…](img/B04831_06_05.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B04831_06_05.jpg)'
- en: We didn't see what is to be done when security is enabled on the cluster, which
    is pretty common in production environments and we have replica sets or shard
    setup. If authentication is enabled, we need proper credentials for the MMS agent
    to gather the statistics. The **DB Username** and **DB Password** that we give
    while adding a new host (point number 6 in the *How to do it…* section) should
    have a minimum of `clusterAdmin` and `readAnyDatabase` role.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有看到在集群上启用安全性时应该做什么，这在生产环境中非常常见，我们有副本集或分片设置。如果启用了身份验证，我们需要MMS代理收集统计信息的正确凭据。在添加新主机时（*如何操作...*部分的第6点），我们给出的**DB用户名**和**DB密码**应该具有至少`clusterAdmin`和`readAnyDatabase`角色。
- en: There's more…
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: What we saw in this recipe was how to set up MMS agent and create an account
    from the MMS console. However, we can add groups and users for the MMS console
    as an administrator granting various users privileges for performing various operations
    on different groups. In the next recipe, we will throw some light on user and
    group management in the MMS console.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们看到了如何设置MMS代理并从MMS控制台创建帐户。但是，我们可以作为管理员为MMS控制台添加组和用户，授予各种用户在不同组上执行各种操作的权限。在下一个教程中，我们将对MMS控制台中的用户和组管理进行一些解释。
- en: Managing users and groups in MMS console
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在MMS控制台中管理用户和组
- en: In the previous recipe, we saw how to set up an MMS account and set up an MMS
    agent. In this recipe, we will throw some light on how to set up the groups and
    user access to the MMS console.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个教程中，我们看到了如何设置MMS帐户并设置MMS代理。在这个教程中，我们将对如何设置组和用户访问MMS控制台进行一些解释。
- en: Getting ready
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Refer to the previous recipe for setting up the agent and MMS account. This
    is the only prerequisite for this recipe.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有关设置代理和MMS帐户，请参阅上一个教程。这是本教程的唯一先决条件。
- en: How to do it…
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Start by going to **Administration** | **Users** on the left-hand side of the
    screen, as shown here:![How to do it…](img/B04831_06_06.jpg)
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，转到屏幕左侧的**管理** | **用户**，如下所示：![如何操作...](img/B04831_06_06.jpg)
- en: 'Here, you can view the existing users and also add new users. On clicking the
    **Add User** (encircled in the top right corner of the preceding image) button,
    you should see the following popup window that allows you to add a new user:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以查看现有用户并添加新用户。单击前图中右上角的**添加用户**（圈起来的）按钮，您应该看到以下弹出窗口，允许您添加新用户：
- en: '![How to do it…](img/B04831_06_08.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/B04831_06_08.jpg)'
- en: The preceding screen will be used to add users. Take a note of the various available
    roles.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕将用于添加用户。注意各种可用角色。
- en: Similarly, go to **Administration** | **My Groups** to view and add new groups
    by clicking on the **Add Group** button. In the text box, type the name of the
    group. Remember that the name of the group you enter should be available globally.
    The given name of the group should be unique across all users of MMS and not just
    your account.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，转到**管理** | **我的组**，通过单击**添加组**按钮查看和添加新组。在文本框中，输入组的名称。请记住，您输入的组名应该在全球范围内可用。所给组的名称应在MMS的所有用户中是唯一的，而不仅仅是您的帐户。
- en: When a new group is created, it will be visible in the top left corner in a
    drop-down menu for all the groups, as shown here:![How to do it…](img/B04831_06_07.jpg)
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新组后，所有组的顶部左侧将显示一个下拉菜单，如下所示：![如何做…](img/B04831_06_07.jpg)
- en: You can switch between the groups using this drop-down menu, which should show
    all the details and stats relevant to the selected group.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用此下拉菜单在组之间切换，该菜单应显示所选组相关的所有详细信息和统计信息。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that a group once created cannot be deleted. So be careful while creating
    one.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，一旦创建了一个组，就无法删除。因此在创建时要小心。
- en: How it works…
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The tasks we did in the recipe are pretty straightforward and don't need a lot
    of explanation except for one question. When and why do we add a group? It is
    when we want to segregate our MongoDB instances by different environments or applications.
    There will be a different MMS agent running for each group. Creating a new group
    is necessary when we want to have separate monitoring groups for different environments
    of an application (Development, QA, Production, and so on), and each group has
    different privileges for the users. That is, the same agent cannot be used for
    two different groups. While configuring the MMS agent, we give it an API key unique
    to the group. To view the API key for the group, select the appropriate group
    from the drop-down menu at the top of the screen (if your user has access to only
    group, the drop-down menu won't be seen) and go to **Administration** | **Group
    Settings** as shown in the next screenshot. The **Group ID** and the **API Key**
    will both be shown on the top of the page.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在配方中所做的任务非常简单，不需要太多的解释，除了一个问题。何时以及为什么要添加一个组？当我们想要通过不同的环境或应用程序对MongoDB实例进行分隔时。每个组都将运行一个不同的MMS代理。当我们想要为应用程序的不同环境（开发、QA、生产等）创建单独的监控组时，就需要创建一个新组，并且每个组对用户有不同的权限。也就是说，同一个代理不能用于两个不同的组。在配置MMS代理时，我们为其提供一个唯一的API密钥。要查看组的API密钥，请从屏幕顶部的下拉菜单中选择适当的组（如果您的用户只能访问一个组，则看不到下拉菜单），然后转到**管理**
    | **组设置**，如下一个截图所示。**组ID**和**API密钥**都将显示在页面顶部。
- en: '![How it works…](img/B04831_06_09.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/B04831_06_09.jpg)'
- en: Note that not all user roles will see this option. For example, read-only users
    can only personalize their profile and most of the other options will not be visible.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并非所有用户角色都会看到此选项。例如，只读用户只能个性化其个人资料，大多数其他选项将不可见。
- en: Monitoring instances and setting up alerts on MMS
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在MMS上监视实例并设置警报
- en: The previous couple of recipes showed us how to set up an MMS account, set up
    an agent, add hosts, and manage user access to MMS console. The core objective
    of MMS is monitoring the host instances, which has not been discussed yet. In
    this recipe, we will perform some operations on the host that we added to MMS
    in the first recipe and monitor it from the MMS console.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的几个配方向我们展示了如何设置MMS帐户，设置代理，添加主机以及管理用户对MMS控制台的访问。MMS的核心目标是监视主机实例，这一点尚未讨论。在这个配方中，我们将对我们在第一个配方中添加到MMS的主机执行一些操作，并从MMS控制台监视它。
- en: Getting ready
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Follow the recipe *Signing up for MMS and setting up an MMS monitoring agent*,
    and that is pretty much all that is needed for this recipe. You may choose to
    have a standalone instance or a replica set, either way is fine. Also, open a
    mongo shell and connect to the primary instance from it (it is a replica set).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 按照配方*注册MMS并设置MMS监控代理*，这基本上就是这个配方所需的一切。您可以选择独立实例或副本集，两种方式都可以。此外，打开一个mongo shell并从中连接到主实例（它是一个副本集）。
- en: How to do it…
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Start by logging into MMS console and clicking on **Deployment** on the left.
    Then, click on the **Deployment** link in the submenu again, as shown in the following
    screenshot:![How to do it…](img/B04831_06_10.jpg)
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先登录MMS控制台，然后单击左侧的**部署**。然后再次单击子菜单中的**部署**链接，如下截图所示：![如何做…](img/B04831_06_10.jpg)
- en: Click on one of the hostnames to see a large variety of graphs showing various
    statistics. In this recipe, we will analyze the majority of these.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 单击其中一个主机名以查看显示各种统计信息的大量图表。在这个配方中，我们将分析其中大部分。
- en: Open the bundle downloaded for the book. In [Chapter 4](ch04.html "Chapter 4. Administration"),
    *Administration*, we used a JavaScript to keep the server busy with some operations
    named `KeepServerBusy.js`. We will be using the same script this time around.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开为本书下载的捆绑包。在[第4章](ch04.html "第4章。管理")中，*管理*，我们使用了一个JavaScript来使服务器忙于一些操作，名为`KeepServerBusy.js`。这次我们将使用相同的脚本。
- en: 'In the operating system shell, execute the following with the `.js` file in
    current directory. The shell connects to port `27000` in my case for the primary:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在操作系统shell中，使用当前目录中的`.js`文件执行以下操作。在我的情况下，shell连接到主端口`27000`：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once it's started, keep it running and give it some 5 to 10 minutes before you
    start monitoring the graphs on MMS console.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦启动，保持运行并在开始监视MMS控制台上的图表之前给予5到10分钟。
- en: How it works…
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In [Chapter 4](ch04.html "Chapter 4. Administration"), *Administration*, we
    saw a recipe, *The mongostat and mongotop utilities* that demonstrated how these
    utilities can be used to get the current operations and resource utilization.
    That is a fairly basic and helpful way to monitor a particular instance. MMS,
    however, gives us one place to monitor the MongoDB instance with pretty easy-to-understand
    graphs. MMS also gives us historical stats, which `mongostat` and `mongotop` cannot
    give.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。管理")中，*管理*，我们看到了一个配方，*mongostat和mongotop实用程序*，演示了如何使用这些实用程序来获取当前操作和资源利用率。这是一种相当基本和有用的监视特定实例的方法。然而，MMS为我们提供了一个地方来监视MongoDB实例，具有非常易于理解的图表。MMS还为我们提供了`mongostat`和`mongotop`无法提供的历史统计信息。
- en: Before we go ahead with the analysis of the metrics, I would like to mention
    that in the case of MMS monitoring, the data is not queried nor sent out over
    the public network. It is just the statistics that are sent over a secure channel
    by the agent. The source code for the agent is open source and is available for
    examination if needed. The mongod servers need not be accessible from the public
    network as the cloud-based MMS service never communicates with the server instances
    directly. It is the MMS agent that communicates with the MMS service. Typically,
    one agent is enough to monitor several servers unless you plan to segregate them
    into different groups. Also, it is recommended to run the agent on a dedicated
    machine/virtual machine and not share it with any of the mongod or mongos instances
    unless it is a less crucial test instance group you are monitoring.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续分析指标之前，我想提一下，在MMS监控的情况下，数据不会在公共网络上查询或发送。只有统计数据通过代理以安全通道发送。代理的源代码是开源的，如果需要，可以进行检查。mongod服务器不需要从公共网络访问，因为基于云的MMS服务从不直接与服务器实例通信。是MMS代理与MMS服务通信。通常，一个代理足以监视多个服务器，除非您计划将它们分成不同的组。此外，建议在专用机器/虚拟机上运行代理，并且不与任何mongod或mongos实例共享，除非它是您正在监视的不太关键的测试实例组。
- en: Let's see some of these statistics on the console; we start with the memory-related
    ones. The following graph shows the resident, mapped, and virtual memory.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在控制台上查看一些这些统计数据；我们从与内存相关的统计数据开始。下图显示了驻留内存、映射内存和虚拟内存。
- en: '![How it works…](img/B04831_06_11.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B04831_06_11.jpg)'
- en: As we can see, the resident memory for the data set is 82 MB, which is very
    low and it is the actual physical memory used up by the mongod process. This current
    value is significantly below the free memory available and generally this will
    increase over a period of time till it reaches a point where it has used up a
    large chunk of the total physical available memory. This is automatically taken
    care of by the mongod server process, and we can't force it to use up more memory
    even though it is available on the machine it is running on.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，数据集的驻留内存为82 MB，这是非常低的，它是mongod进程实际使用的物理内存。当前值明显低于可用的空闲内存，并且通常会随着时间的推移而增加，直到达到使用了大部分可用物理内存的程度。这由mongod服务器进程自动处理，即使机器上有可用内存，我们也不能强制它使用更多内存。
- en: The mapped memory, on other hand, is about the total size of the database and
    is mapped by MongoDB. This size can be (and usually is) much higher than the physical
    memory available, which enables the mongod process to address the entire dataset
    as it is present in memory even if it isn't. MongoDB offloads the responsibility
    of mapping and loading data to and from disk to the underlying operating system.
    Whenever a memory location is accessed and it is not available in the RAM (that
    is, the resident memory), the operating system fetches the page into memory, evicting
    some pages to make space for the new page if necessary. What exactly is a memory
    mapped file? Let's try to see with a super scaled down version. Suppose we have
    a file of 1 KB (1024 bytes) and the RAM is only 512 bytes, then obviously we cannot
    have the whole file in memory. However, you can ask the operating system to map
    this file to available RAM in pages. Suppose each page is 128 bytes, then the
    total file is 8 pages (128 * 8 = 1024). But the OS can only load four pages, and
    we assume it loaded the first 4 pages (up to 512 bytes) in the memory. When we
    access byte number 200, it is okay and found in the memory as it is in present
    on page 2\. But what if we access byte 800, which is logically on page 7 that
    is not loaded in memory? What OS does is takes one page out from the memory and
    loads this page 7 containing byte number 800\. MongoDB as an application gives
    the impression that everything was loaded in the memory and was accessed by the
    byte index, but actually it wasn't and the OS transparently did the work for us.
    Since the page accessed was not present in the memory and we had to go to the
    disk to load it in the memory it is called a **page fault**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，映射内存大约是数据库的总大小，并由MongoDB进行映射。这个大小可以（通常）比可用的物理内存大得多，这使得mongod进程能够在内存中寻址整个数据集，即使它并不在内存中。MongoDB将映射和加载数据的责任转移到底层操作系统。每当访问一个内存位置并且它在RAM中不可用（即驻留内存），操作系统会将页面加载到内存中，如果需要的话，会驱逐一些页面为新页面腾出空间。什么是内存映射文件？让我们尝试用一个超级精简的版本来看看。假设我们有一个1
    KB（1024字节）的文件，而RAM只有512字节，显然我们无法将整个文件加载到内存中。但是，您可以要求操作系统将此文件映射到可用的RAM页面中。假设每个页面是128字节，那么总文件大小为8页（128
    * 8 = 1024）。但是操作系统只能加载四个页面，我们假设它加载了前4个页面（达到512字节）。当我们访问第200个字节时，它是可以在内存中找到的，因为它在第2页上。但是如果我们访问第800个字节，逻辑上在第7页上，而这一页没有加载到内存中怎么办？操作系统会从内存中取出一页，并加载包含第800个字节的第7页。作为一个应用程序，MongoDB给人的印象是所有东西都加载到了内存中，并且通过字节索引进行访问，但实际上并非如此，操作系统在背后为我们做了透明的工作。由于访问的页面不在内存中，我们必须去磁盘加载它到内存中，这就是所谓的**页面错误**。
- en: Getting back to the stats shown in the graph, the virtual memory contains all
    the memory usage including the mapped memory plus any additional memory used,
    such as the memory associated with the thread stack associated with each connection.
    If journaling is enabled, this size will definitely be more than twice than that
    of the mapped memory as journaling too will have a separate memory mapping for
    the data. Thus, we have two addresses mapping the same memory location. This doesn't
    mean that the page will be loaded twice. It just means that two different memory
    locations can be used to address the same physical memory. Very high virtual memory
    might need some investigation. There is no predetermined definition of a too high
    or low value; generally these values are monitored for your system under normal
    circumstances when you are happy with the performance of your system. These benchmark
    values should then be compared with the figures seen when system performance goes
    down and then appropriate action can be taken.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 回到图表中显示的统计数据，虚拟内存包含所有内存使用，包括映射内存以及任何额外使用的内存，比如与每个连接相关的线程堆栈的内存。如果启用了日志记录，这个大小肯定会比映射内存的两倍还要多，因为日志记录也会有一个单独的内存映射用于数据。因此，我们有两个地址映射相同的内存位置。这并不意味着页面会被加载两次。这只是意味着可以使用两个不同的内存位置来寻址相同的物理内存。非常高的虚拟内存可能需要一些调查。没有预先确定的太高或太低的定义；通常在你对系统的性能感到满意的正常情况下，这些值会被监视。然后应该将这些基准值与系统性能下降时看到的数字进行比较，然后采取适当的行动。
- en: As we saw earlier, page faults are caused when an accessed memory location is
    not present in the resident memory, causing the OS to load the page from memory.
    This IO activity will definitely cause performance to go down and too many page
    faults can bring down database performance dramatically. The following screenshot
    shows quite a few page faults happening per minute. However, if the disk used
    is an SSD instead of spinning disks, the hit in terms of seek time from the drive
    might not be significantly high.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，当访问的内存位置不在常驻内存中时，会导致页面错误，从而使操作系统从内存中加载页面。这种IO活动肯定会导致性能下降，太多的页面错误会严重影响数据库性能。下面的屏幕截图显示了每分钟发生的相当多的页面错误。然而，如果使用的是固态硬盘而不是旋转硬盘，那么来自驱动器的寻道时间的影响可能不会显著。
- en: '![How it works…](img/B04831_06_12.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B04831_06_12.jpg)'
- en: A large number of page faults usually occur when there isn't enough physical
    memory to accommodate the data set and the OS needs to get the data from the disk
    into memory. Note that this stat shown in the preceding screenshot is taken on
    a Windows platform and might seem high for a very trivial operation. This value
    is the sum of hard and soft page faults and doesn't really give a true figure
    of how good (or bad) the system is. These figures would be different on a Unix-based
    OS. There is a JIRA ([https://jira.mongodb.org/browse/SERVER-5799](https://jira.mongodb.org/browse/SERVER-5799))
    open as of the writing of this book which reports this problem.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当物理内存不足以容纳数据集并且操作系统需要将数据从磁盘加载到内存时，通常会发生大量页面错误。请注意，此统计数据显示在Windows平台上，并且对于非常琐碎的操作可能会显得很高。这个值是硬页错误和软页错误的总和，实际上并不能真正反映系统的好坏。在基于Unix的操作系统上，这些数字会有所不同。在撰写本书时，有一个JIRA（[https://jira.mongodb.org/browse/SERVER-5799](https://jira.mongodb.org/browse/SERVER-5799)）正在开放，报告了这个问题。
- en: One thing you might need to remember is that in production systems, MongoDB
    doesn't work well with a NUMA architecture and you might see a lot of page faults
    happening even if the available memory seems to be high enough. Refer to the URL
    [http://docs.mongodb.org/manual/administration/production-notes/](http://docs.mongodb.org/manual/administration/production-notes/)
    for more details.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要记住的一件事是，在生产系统中，MongoDB与NUMA架构不兼容，即使可用内存似乎足够高，你可能会看到大量页面错误发生。有关更多详细信息，请参阅网址[http://docs.mongodb.org/manual/administration/production-notes/](http://docs.mongodb.org/manual/administration/production-notes/)。
- en: 'There is an additional graph which gives some details about non-mapped memory.
    As we saw earlier in this section, there are three types of memory: mapped, resident,
    and virtual. Mapped memory is always less than virtual memory. Virtual memory
    will be more than twice that of mapped memory if journaling is enabled. If we
    look at the image given in this section earlier, we see that the mapped memory
    is 192 MB whereas the virtual memory is 532MB. Since journaling is enabled, the
    memory is more than twice that of the mapped memory. When journaling is enabled,
    the same page of data is mapped twice in memory. Note that the page is physically
    loaded only once, it is just that the same location can be accessed using two
    different addresses. Let''s find the difference between the virtual memory, which
    is 532MB, and twice the mapped memory that is 384 MB (2 * 192 = 384). The difference
    between these figures is 148 MB (532 - 384).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个额外的图表，提供了一些关于未映射内存的细节。正如我们在本节前面看到的，有三种类型的内存：映射内存、常驻内存和虚拟内存。映射内存始终小于虚拟内存。如果启用了日志记录，虚拟内存将是映射内存的两倍以上。如果我们看一下本节前面给出的图像，我们会发现映射内存为192MB，而虚拟内存为532MB。由于启用了日志记录，内存是映射内存的两倍以上。启用日志记录时，相同的数据页在内存中被映射两次。请注意，该页只被物理加载一次，只是可以使用两个不同的地址访问相同的位置。让我们找出虚拟内存（532MB）和两倍映射内存（384MB）之间的差异（2
    * 192 = 384）。这些数字之间的差异是148MB（532-384）。
- en: What we see here is the portion of virtual memory that is not mapped memory.
    This value is the same as what we just calculated.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的是未映射内存的部分。这个值与我们刚刚计算的值相同。
- en: '![How it works…](img/B04831_06_13.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B04831_06_13.jpg)'
- en: 'As mentioned earlier, a high or low value for non-mapped memory is not defined,
    however when the value reaches GBs we might have to investigate; possibly the
    number of open connections is high and we need to check if there is a leak with
    client applications not closing them after using it. There is a graph that gives
    us the number of connections open and it looks as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，非映射内存的高低值并没有明确定义，但是当值达到GB时，我们可能需要进行调查；可能打开的连接数很高，我们需要检查是否有客户端应用程序在使用后没有关闭连接。有一个图表显示了打开的连接数，如下所示：
- en: '![How it works…](img/B04831_06_14.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B04831_06_14.jpg)'
- en: Once we know the number of connections and find it too high as compared to the
    expected count, we will need to find the clients who have opened the connections
    to that instance. We can execute the following JavaScript code from the shell
    to get those details. Unfortunately, at the time of writing this book, MMS doesn't
    have this feature to list out the client connection details.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道连接数，并且发现它与预期计数相比太高，我们将需要找到打开连接到该实例的客户端。我们可以从shell中执行以下JavaScript代码来获取这些详细信息。不幸的是，在撰写本书时，MMS没有这个功能来列出客户端连接的详细信息。
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `db.currentOp` method returns all the idle and system operations in the
    result. We then iterate through all the results and print out the client host
    and the connection details. A typical document in the result of the `currentOp`
    looks like this. You can choose to tweak the preceding code to include more details
    as per your need:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.currentOp`方法返回结果中所有空闲和系统操作。然后我们遍历所有结果并打印出客户端主机和连接详细信息。`currentOp`结果中的典型文档如下。您可以选择调整前面的代码，根据需要包含更多详细信息：'
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In [Chapter 4](ch04.html "Chapter 4. Administration"), *Administration*, we
    saw a recipe, *The mongostat and mongotop utilities* that was used to get some
    details on the percent of time a database was locked and the number of update,
    insert, delete, and getmore operations executed per second. You may refer to these
    recipes and try them out. We had used the same JavaScript that we have used currently
    to keep the server busy.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。管理")中，我们看到了一个名为* mongostat和mongotop实用程序*的配方，用于获取数据库被锁定的时间百分比以及每秒执行的更新、插入、删除和获取操作的数量。您可以参考这些配方并尝试它们。我们使用了与当前用于使服务器繁忙的相同的JavaScript。
- en: 'In MMS console, we have graphs giving these details as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在MMS控制台中，我们有图表显示以下详细信息：
- en: '![How it works…](img/B04831_06_15.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B04831_06_15.jpg)'
- en: The first one, `opcounters`, shows the number of operations executed at a particular
    point in time. This should be similar to what we saw using the `mongostat` utility.
    The one on the right shows us the percentage of time a database was locked. The
    drop-down menu lists the database names. We can select an appropriate database
    that we want to see the stats for. Again, this statistic can be seen using the
    `mongostat` utility. The only difference is that with the command-line utility,
    we see the stats as of the current time, whereas here we see the historical stats
    too.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`opcounters`显示在特定时间点执行的操作数量。这应该类似于我们使用`mongostat`实用程序看到的内容。右侧的内容显示了数据库被锁定的时间百分比。下拉菜单列出了数据库名称。我们可以选择要查看统计信息的适当数据库。同样，这个统计数据可以使用`mongostat`实用程序来查看。唯一的区别是，使用命令行实用程序，我们可以看到当前时间的统计数据，而在这里我们也可以看到历史统计数据。
- en: In MongoDB, indexes are stored in BTrees and the next graph shows the number
    of times the BTree index was accessed, hit, and missed. At the minimum, the RAM
    should be enough to accommodate the indexes for optimum performance. So in this
    metric, the misses should be 0 or very low. A high number of misses results in
    a page fault for the index and possibly additional page faults for the corresponding
    data if the query is not covered, that is, all its data cannot be sourced from
    the index, which is a double blow for performance. One good practice while querying
    is to use projections and fetch only the necessary fields from the document. This
    is helpful whenever we have our selected fields present in an index, in which
    case the query becomes covered and all the necessary data is sourced from the
    index only. To learn more about on covered indexes, refer to the recipe *Creating
    index and viewing plans of queries* in [Chapter 2](ch02.html "Chapter 2. Command-line
    Operations and Indexes"), *Command-line Operations and Indexes*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中，索引存储在B树中，下图显示了B树索引被访问、命中和未命中的次数。最低限度，RAM应该足够容纳索引以实现最佳性能。因此，在这个度量标准中，未命中应该为0或非常低。未命中的次数过高会导致索引的页面错误，如果查询没有被覆盖，可能会导致相应数据的额外页面错误，也就是说，所有数据无法从索引中获取，这对性能来说是一个双重打击。在查询时的一个好的做法是使用投影，并且只从文档中获取必要的字段。每当我们选择的字段存在于索引中时，这对于查询是有帮助的，这种情况下查询变成了覆盖查询，所有必要的数据只从索引中获取。要了解更多关于覆盖索引的信息，请参考[第2章](ch02.html
    "第2章。命令行操作和索引")中的*创建索引和查看查询计划*这个章节。
- en: '![How it works…](img/B04831_06_16.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B04831_06_16.jpg)'
- en: For busy applications if the volumes are very high, with multiple write and
    read operations contending for lock, the operations queue up. Untill Version 2.4
    of MongoDB, the locks are at the database level. Thus, even if the writes are
    happening on another collection, read operations on any collection in that database
    will block. This queuing operation affects the performance of the system and is
    a good indicator that the data might need to be sharded across to scale the system.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于繁忙的应用程序，如果卷非常大，多个写入和读取操作争夺锁定，操作排队。直到MongoDB的2.4版本，锁定是在数据库级别进行的。因此，即使在另一个集合上进行写入，对该数据库中的任何集合进行读取操作也会被阻塞。这种排队操作会影响系统的性能，并且是数据可能需要分片以扩展系统的良好指标。
- en: Tip
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember, no value is defined as high or low; it is the acceptable value on
    an application-to-application basis.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，没有定义高或低的值；它是应用程序到应用程序基础上的可接受值。
- en: '![How it works…](img/B04831_06_18.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B04831_06_18.jpg)'
- en: MongoDB flushes the data from the journal immediately and the data file periodically
    to disk. The following metrics give us the flush time per minute at a given point
    of time. If the flush takes up a significant percentage of the time per minute,
    we can safely say that the write operations are forming a bottleneck for performance.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB立即从日志中刷新数据，并定期将数据文件刷新到磁盘。以下指标给出了在给定时间点每分钟的刷新时间。如果刷新占据了相当大的时间百分比，我们可以安全地说写操作正在形成性能瓶颈。
- en: '![How it works…](img/B04831_06_17.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/B04831_06_17.jpg)'
- en: There's more…
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We have seen monitoring of the MongoDB instances/cluster in this recipe. However,
    setting up alerts to get notifications when certain threshold values are crossed
    is what we still haven't seen. In the next recipe, we will see how to achieve
    this with a sample alert that is sent out over an e-mail when the page faults
    exceed a predetermined value.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我们看到了如何监视MongoDB实例/集群。然而，设置警报以在某些阈值值被超过时收到通知，这是我们还没有看到的。在下一篇文章中，我们将看到如何通过一个示例警报来实现这一点，当页面错误超过预定值时会通过电子邮件发送警报。
- en: See also
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Monitoring the hardware, such as CPU usage, is pretty useful and MMS console
    does support that. However, it needs munin-node to be installed to enable CPU
    monitoring. Refer to the page [http://mms.mongodb.com/help/monitoring/configuring/](http://mms.mongodb.com/help/monitoring/configuring/)
    for setting up munin-node and hardware monitoring.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视硬件，如CPU使用率，非常有用，MMS控制台也支持。然而，需要安装munin-node才能启用CPU监视。请参考页面[http://mms.mongodb.com/help/monitoring/configuring/](http://mms.mongodb.com/help/monitoring/configuring/)设置munin-node和硬件监视。
- en: For updating the monitoring agent, refer to the page [http://mms.mongodb.com/help/monitoring/tutorial/update-mms/](http://mms.mongodb.com/help/monitoring/tutorial/update-mms/).
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要更新监控代理，请参考页面[http://mms.mongodb.com/help/monitoring/tutorial/update-mms/](http://mms.mongodb.com/help/monitoring/tutorial/update-mms/)。
- en: Setting up monitoring alerts in MMS
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在MMS中设置监控警报
- en: In the previous recipe, we saw how to monitor various metrics from MMS console.
    This is a great way to see all the stats in one place and get an overview of the
    health of the MongoDB instances and cluster. However, it is not possible to monitor
    the system continuously, 24/7, for the support personnel and there has to be some
    mechanism to automatically send out alerts in case some threshold is exceeded.
    In this recipe we will set up an alert whenever the page faults exceeds 1000.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一篇文章中，我们看到了如何从MMS控制台监视各种指标。这是一个很好的方式，可以在一个地方看到所有的统计数据，并了解MongoDB实例和集群的健康状况。然而，不可能持续24/7监视系统，对于支持人员来说必须有一些机制在某些阈值超过时自动发送警报。在这篇文章中，我们将设置一个警报，每当页面错误超过1000时就会触发。
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Refer to the previous recipe to set up Monitoring Mongo Instances using MMS.
    That is the only prerequisite for this recipe.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 参考上一篇文章，设置使用MMS监视Mongo实例。这是本篇文章的唯一先决条件。
- en: How to do it…
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: Click on the **Activity** option on the left side menu, and then **Alert Settings**.
    On the **Alert Settings** page, click on **Add Alert**.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击左侧菜单中的**活动**选项，然后单击**警报设置**。在**警报设置**页面上，单击**添加警报**。
- en: Add a new alert for the **Host** that is a primary instance and if the page
    faults exceed a given number, which is 1000 page faults per minute. The notification
    is chosen to be an e-mail in this case and the interval after which the alert
    will be sent is 10 minutes.![How to do it…](img/B04831_06_20.jpg)
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为**主机**添加一个新的警报，如果页面错误超过给定数量，即每分钟1000个页面错误。在这种情况下，通知选择为电子邮件，警报发送间隔为10分钟。![操作步骤...](img/B04831_06_20.jpg)
- en: Click on **Save** to save the alert.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**保存**以保存警报。
- en: How it works…
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The steps were pretty simple and we were successful in setting up MMS alerts
    when the page faults exceeded 1000 per minute. As we saw in the previous recipe,
    no fixed value is classified as high or low. It is something that is acceptable
    for your system, which comes with benchmarking the system during the testing phases
    in your environment. Similar to page faults, there is a vast array of alerts that
    can be set up. Once an alert is raised, it will be sent every 10 minutes, as we
    have set, until the condition for sending the alerts is not met. In this case,
    if the number of page faults falls below 1000 or somebody manually acknowledges
    the alert, no further alerts will be sent further for that incident.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤非常简单，我们成功地设置了当页面错误超过每分钟1000次时的MMS警报。正如我们在上一篇文章中看到的，没有固定值被归类为高或低。这是可以接受的，需要在您的环境中的测试阶段对系统进行基准测试。与页面错误类似，还有大量可以设置的警报。一旦触发警报，将按照我们设置的每10分钟发送一次，直到不满足发送警报的条件为止。在这种情况下，如果页面错误数量低于1000或有人手动确认了警报，那么将不会再发送进一步的警报。
- en: 'As we see in the following screenshot, the alert is open and we can acknowledge
    the alert:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如下面的屏幕截图所示，警报已打开，我们可以确认警报：
- en: '![How it works…](img/B04831_06_21.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/B04831_06_21.jpg)'
- en: 'On clicking on **Acknowledge**, the following popup will let us choose the
    duration for which we will acknowledge:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 单击**确认**后，将弹出以下窗口，让我们选择确认的持续时间：
- en: '![How it works…](img/B04831_06_30.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/B04831_06_30.jpg)'
- en: This means that for this particular incident, no more alerts will be sent out
    until the selected time period elapses.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在这种特定情况下，直到所选时间段过去，将不会再发送警报。
- en: The Open alerts can be viewed by clicking on the **Activities** menu option
    on the left.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 单击左侧的**活动**菜单选项即可查看打开的警报。
- en: See also
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Visit the URL [http://www.mongodb.com/blog/post/five-mms-monitoring-alerts-keep-your-mongodb-deployment-track](http://www.mongodb.com/blog/post/five-mms-monitoring-alerts-keep-your-mongodb-deployment-track)
    for some of the important alerts that you should set up for your deployment
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问网址[http://www.mongodb.com/blog/post/five-mms-monitoring-alerts-keep-your-mongodb-deployment-track](http://www.mongodb.com/blog/post/five-mms-monitoring-alerts-keep-your-mongodb-deployment-track)了解一些应该为您的部署设置的重要警报
- en: Back up and restore data in Mongo using out-of-the-box tools
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用现成的工具备份和恢复Mongo中的数据
- en: In this recipe, we will look at some basic backup and restore operations using
    utilities such as `mongodump` and `mongorestore` to back up and restore files.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将使用`mongodump`和`mongorestore`等实用程序进行一些基本的备份和恢复操作，以备份和恢复文件。
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will start a single instance of mongod. Refer to the recipe *Installing
    single node MongoDB* in [Chapter 1](ch01.html "Chapter 1. Installing and Starting
    the Server"), *Installing and Starting the Server*, to start a mongo instance
    and connect to it from a mongo shell. We will need some data to backup. If you
    already have some data in your test database, that will be fine. If not, create
    some from the `countries.geo.json` file available in the code bundle using the
    following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将启动一个mongod的单个实例。请参阅[第1章](ch01.html "第1章。安装和启动服务器")中的*安装单节点MongoDB*教程，*安装和启动服务器*，以启动一个mongo实例并从mongo
    shell连接到它。我们需要一些要备份的数据。如果您的test数据库中已经有一些数据，那就很好。如果没有，请使用以下命令从代码包中的`countries.geo.json`文件创建一些数据：
- en: '[PRE3]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How to do it…
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'With the data in the `test` database, execute the following (assuming we want
    to export the data to a local directory called `dump` in the current directory):'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了`test`数据库中的数据，执行以下操作（假设我们要将数据导出到当前目录中名为`dump`的本地目录）：
- en: '[PRE4]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Verify that there is data in the `dump` directory. All files will be `.bson`
    files, one per collection in the respective database folder created.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 验证`dump`目录中是否有数据。所有文件将是`.bson`文件，每个文件对应相应数据库文件夹中的一个集合。
- en: 'Now let''s import the data back into the mongo server using the following command.
    This is again with the assumption that we have the directory `dump` in the current
    directory with the required `.bson` files present in it:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们使用以下命令将数据导入mongo服务器。这里假设我们在当前目录中有一个名为`dump`的目录，并且其中有所需的`.bson`文件：
- en: '[PRE5]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Just a couple of steps executed to export and restore the data. Let's now see
    what it exactly does and what the command-line options for this utility are. The
    `mongodump` utility is used to export the database into the `.bson` files, which
    can then be later used to restore the data in the database. The export utility
    exports one folder per database except local database, and then each of them will
    have one `.bson` file per collection. In our case, we used the `-oplog` option
    to export a part of the oplog too and the data will be exported to the `oplog.bson`
    file. Similarly, we import the data back into the database using the `mongorestore`
    utility. We explicitly ask the existing data to be dropped by providing the `--drop`
    option before the import and replay of the contents in the oplog if any.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 只需执行几个步骤即可导出和恢复数据。现在让我们看看它到底是做什么的，以及这个实用程序的命令行选项是什么。`mongodump`实用程序用于将数据库导出到`.bson`文件中，然后可以稍后用于恢复数据库中的数据。导出实用程序为每个数据库导出一个文件夹，除了本地数据库，然后每个文件夹中将有一个`.bson`文件。在我们的情况下，我们使用了`-oplog`选项来导出oplog的一部分，数据将导出到`oplog.bson`文件中。类似地，我们使用`mongorestore`实用程序将数据导入到数据库中。我们在导入和重放内容之前通过提供`--drop`选项显式要求删除现有数据，并重放oplog中的内容（如果有）。
- en: 'The `mongodump` utility simply queries the collection and exports the contents
    to the files. The bigger the collection, the longer it will take to restore the
    contents. It is thus advisable to prevent write operations when the dump is being
    taken. In the case of sharded environments, the balancer should be turned off.
    If the dump is taken while the system is running, export with the `-oplog` option
    to export the contents of the oplog as well. This oplog can then be used to restore
    to the point in time data. The following table shows some of the important options
    available for the `mongodump` and `mongorestore` utility, first for `mongodump`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`mongodump`实用程序简单地查询集合并将内容导出到文件中。集合越大，恢复内容所需的时间就越长。因此，在进行转储时建议防止写操作。在分片环境中，应关闭平衡器。如果在系统运行时进行转储，则使用`-oplog`选项导出oplog的内容。然后可以使用此oplog将数据恢复到特定时间点。以下表格显示了`mongodump`和`mongorestore`实用程序的一些重要选项，首先是`mongodump`：'
- en: '| Option | Description |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `--help` | Shows all the possible, supported options and a brief description
    of these options. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `--help` | 显示所有可能的支持选项以及这些选项的简要描述。 |'
- en: '| `-h` or `--host` | The host to connect to. By default, it is localhost on
    port `27017`. If a standalone instance is to be connected to, we can set the hostname
    as `<hostname>:<port number>`. For a replica set, the format will be `<replica
    set name>/<hostname>:<port>,….<hostname>:<port>` where the comma-separated list
    of hostnames and port is called the **seed list**. It can contain all or a subset
    of hostnames in a replica set. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `-h`或`--host` | 要连接的主机。默认情况下，它是端口`27017`上的localhost。如果要连接到独立实例，则可以将主机名设置为`<主机名>:<端口号>`。对于副本集，格式将是`<副本集名称>/<主机名>:<端口>,….<主机名>:<端口>`，其中逗号分隔的主机名和端口列表称为**种子列表**。它可以包含副本集中所有或部分主机名。
    |'
- en: '| `--port` | The port number of the target MongoDB instance. This is not really
    relevant if the port number is provided in the previous `-h` or `--host` option.
    |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `--port` | 目标MongoDB实例的端口号。如果在之前的`-h`或`--host`选项中提供了端口号，则这并不重要。 |'
- en: '| `-u` or `--username` | Provides the username of the user using which the
    data would be exported. Since the data is read from all databases, the user is
    at least expected to have read privileges in all databases. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `-u`或`--username` | 提供要导出数据的用户的用户名。由于数据是从所有数据库中读取的，因此至少期望用户在所有数据库中具有读取权限。
    |'
- en: '| `-p` or `--password` | The password used in conjunction with the username.
    |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `-p`或`--password` | 与用户名一起使用的密码。 |'
- en: '| `--authenticationDatabase` | The database in which the user credentials are
    kept. If not specified, the database specified in the `--db` option is used. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `--authenticationDatabase` | 存储用户凭据的数据库。如果未指定，则使用`--db`选项中指定的数据库。 |'
- en: '| `-d` or `--db` | The database to back up. If not specified, then all the
    databases are exported. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `-d`或`--db` | 要备份的数据库。如果未指定，则导出所有数据库。 |'
- en: '| `-c` or `--collection` | The collection in the database to be exported. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `-c`或`--collection` | 要导出的数据库中的集合。|'
- en: '| `-o` or `--out` | The directory to which the files will be exported. By default,
    the utility will create a dump folder in the current directory and export the
    contents to that directory. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `-o`或`--out` | 要导出文件的目录。默认情况下，实用程序将在当前目录中创建一个dump文件夹，并将内容导出到该目录。|'
- en: '| `--dbpath` | If we don''t intend to connect to the database server and instead
    directly read from the database file. The value is the path of the directory where
    the database files will be found. The server should not be up and running while
    reading directly from the database files as the export locks the data files, which
    can''t happen if a server is up and running. A lock file will be created in the
    directory while the lock is acquired. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `--dbpath` | 如果我们不打算连接到数据库服务器，而是直接从数据库文件中读取。值是数据库文件所在目录的路径。在直接从数据库文件中读取时，服务器不应该处于运行状态，因为导出会锁定数据文件，如果服务器正在运行，这是不可能的。在获取锁时，将在目录中创建一个锁文件。|'
- en: '| `--oplog` | With the option enabled, the data from the oplog from the time
    the export process started is also exported. Without this option enabled, the
    data in the export will not represent a single point in time if writes are happening
    in parallel as the export process can take few hours and it simply is a query
    operation on all the collections. Exporting the oplog gives an option to restore
    to a point in time data. There is no need to specify this option if you are preventing
    write operations while the export is in progress. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `--oplog` | 启用此选项后，还会导出自导出过程开始时的oplog数据。如果不启用此选项，导出的数据将不会代表一个时间点，如果写操作同时进行，因为导出过程可能需要几个小时，它只是对所有集合进行查询操作。导出oplog可以恢复到某个时间点的数据。如果在导出过程中阻止写操作，则无需指定此选项。|'
- en: Similarly, for the `mongorestore` utility, here are the options. The meaning
    of the options `--help`, `-h`, or `--host`, `--port`, `-u`, or `--username`, `-p`
    or `--password`, `--authenticationDatabase`, `-d`, or `--db`, `-c` or `--collection`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于`mongorestore`实用程序，以下是选项的含义：`--help`，`-h`或`--host`，`--port`，`-u`或`--username`，`-p`或`--password`，`--authenticationDatabase`，`-d`或`--db`，`-c`或`--collection`。
- en: '| Option | Description |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `--dbpath` | If we don''t intend to connect to the database server and instead
    directly write to the database file, use this option. The value is the path of
    the directory where the database files will be found. The server should not be
    up and running while writing directly to the database files as the restore operation
    locks the data files, which can''t happen if a server is up and running. A lock
    file will be created in the directory while the lock is acquired. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `--dbpath` | 如果我们不打算连接到数据库服务器，而是直接写入数据库文件，请使用此选项。值是数据库文件所在目录的路径。在直接写入数据库文件时，服务器不应该处于运行状态，因为恢复操作会锁定数据文件，如果服务器正在运行，这是不可能的。在获取锁时，将在目录中创建一个锁文件。|'
- en: '| `--drop` | Drop the existing data in the collection before restoring the
    data from the exported dumps. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `--drop` | 在从导出的转储数据中恢复数据之前删除集合中的现有数据。|'
- en: '| `--oplogReplay` | If the data was exported while writes to the database were
    allowed and if the `--oplog` option was enabled during export, the oplog exported
    will be replayed on the data to bring all the data in the database to the same
    point in time. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `--oplogReplay` | 如果在允许对数据库进行写操作的情况下导出了数据，并且在导出过程中启用了`--oplog`选项，则将在数据上重放导出的oplog，以使数据库中的所有数据达到相同的时间点。|'
- en: '| `--oplogLimit` | The value of this parameter is a number representing the
    time in seconds. This option is used in conjunction with `oplogReplay` command
    line option, which is used to tell the restore utility to replay the oplog and
    stop just at the limit specified by this option. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `--oplogLimit` | 此参数的值是表示时间的秒数。此选项与`oplogReplay`命令行选项一起使用，用于告诉恢复实用程序重放oplog，并在此选项指定的限制处停止。|'
- en: You might think, *Why not copy the files and take a backup?* That works well
    but there are a few problems associated with it. First, you cannot get a point-in-time
    backup unless write operations are disabled. Secondly, the space used for backups
    is very high as the copy would also copy the 0 padded files of the database as
    against the `mongodump`, which exports just the data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，“为什么不复制文件并备份呢？”这样做效果很好，但与此相关的问题有几个。首先，除非禁用写操作，否则无法获得点时间备份。其次，备份所使用的空间非常大，因为复制还会复制数据库的0填充文件，而`mongodump`只会导出数据。
- en: Having said that, filesystem snapshotting is a commonly used practice for backups.
    One thing to remember is while taking the snapshot the journal files and the data
    files need to come in the same snapshot for consistency.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，文件系统快照是备份的常用做法。需要记住的一件事是，在进行快照时，日志文件和数据文件需要在同一个快照中以保持一致性。
- en: If you were using **Amazon Web Services** (**AWS**), it would be highly recommended
    that you upload your database backups to AWS S3\. As you may be aware, AWS offers
    extremely high data redundancy with a very low storage cost.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用**亚马逊网络服务**（**AWS**），强烈建议您将数据库备份上传到AWS S3。您可能知道，AWS提供极高的数据冗余性，存储成本非常低。
- en: Download the script `generic_mongodb_backup.sh` from the Packt Publishing website
    and use it to automate your backup creation and upload to AWS S3.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从Packt Publishing网站下载脚本`generic_mongodb_backup.sh`，并使用它来自动创建备份并上传到AWS S3。
- en: Configuring MMS Backup service
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置MMS备份服务
- en: MMS Backup is a relatively new offering by MongoDB for real-time incremental
    backup of your MongoDB instances, replica sets, and shards, and offers you point
    in time recovery of your instances. The service is available as on-premise (in
    your data center) or cloud. However, we will demonstrate the on-cloud service
    that is the only option for the Community and Basic subscription. For more details
    on the available options, you can visit different product offerings by MongoDB
    at [https://www.mongodb.com/products/subscriptions](https://www.mongodb.com/products/subscriptions).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: MMS备份是MongoDB的一个相对较新的功能，用于实时增量备份MongoDB实例、副本集和分片，并为您提供实例的时点恢复。该服务可用作本地部署（在您的数据中心）或云端。但是，我们将演示云端服务，这是Community和Basic订阅的唯一选项。有关可用选项的更多详细信息，您可以访问MongoDB在[https://www.mongodb.com/products/subscriptions](https://www.mongodb.com/products/subscriptions)上提供的不同产品。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Mongo MMS Backup service will work only on Mongo 2.0 and above. We will start
    a single server that we will backup. MMS backup relies on the oplog for continuous
    backup and since oplog is available only in replica sets, the server needs to
    be started as a replica set. Refer to the recipe *Connecting to a single node
    using a Python client* in [Chapter 1](ch01.html "Chapter 1. Installing and Starting
    the Server"), *Installing and Starting the Server* to learn more about how to
    install Python and PyMongo, the Python client of Mongo.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Mongo MMS备份服务仅适用于Mongo 2.0及以上版本。我们将启动一个我们将备份的单个服务器。MMS备份依赖于oplog进行连续备份，由于oplog仅在副本集中可用，因此服务器需要作为副本集启动。有关如何安装Python和Mongo的Python客户端PyMongo的更多信息，请参阅[第1章](ch01.html
    "第1章。安装和启动服务器")中的*使用Python客户端连接到单个节点*、*安装和启动服务器*。
- en: How to do it…
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤如下：
- en: If you don't already have a MMS account, then log in to [https://mms.mongodb.com/](https://mms.mongodb.com/)
    and sign up for an account. For screenshots, refer to the recipe *Signing up for
    MMS and setting up an MMS monitoring agent* in this chapter.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有MMS帐户，请登录[https://mms.mongodb.com/](https://mms.mongodb.com/)并注册一个帐户。有关屏幕截图，请参阅本章中的*注册MMS并设置MMS监控代理*。
- en: 'Start a single instance of Mongo and replace the value of the appropriate filesystem
    path on your machine:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Mongo的单个实例，并替换您的机器上适当文件系统路径的值：
- en: '[PRE6]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that the `smallfiles` and `oplogSize` are options only set for testing
    purposes and are not to be used in production.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`smallfiles`和`oplogSize`仅用于测试目的，并且不应在生产中使用。
- en: 'Start a shell, connect to the instance in step 1 and initiate the replica set
    as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个shell，连接到第1步中的实例，并按以下方式启动副本集：
- en: '[PRE7]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The replica set will be up and running in some time.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 副本集将在一段时间内启动并运行。
- en: Go back to the browser to `mms.mongodb.com`. Add a new host by clicking on the
    **+ Add Host** button. Set the type as replica set and the hostname as your hostname
    and the port as the default one `27017` in our case. Refer to the recipe *Signing
    up for MMS and setting up an MMS monitoring agent* for the screenshots of the
    **Add Host** process.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`mms.mongodb.com`的浏览器。点击**+添加主机**按钮添加新主机。将类型设置为副本集，主机名设置为您的主机名，端口设置为默认端口`27017`。有关**添加主机**过程的屏幕截图，请参阅*注册MMS并设置MMS监控代理*。
- en: Once the host is successfully added, register for MMS backup by clicking on
    the **Backup** option the left and then **Begin Setup**.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦成功添加主机，请点击左侧的**备份**选项，然后点击**开始设置**注册MMS备份。
- en: An SMS or Google authenticator can be used for registration. If a smartphone
    is available with Android, iOS, or Blackberry OS, Google authenticator is a good
    option. For countries like India, Google Authenticator is the only option available.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用短信或Google Authenticator进行注册。如果智能手机上有Android、iOS或Blackberry OS，Google Authenticator是一个不错的选择。对于印度等国家，Google
    Authenticator是唯一可用的选项。
- en: Assuming Google Authenticator is not configured already and we are planning
    to use it, we would need the app to be installed on your smartphone. Go to the
    respective app store of your mobile OS platform and install the Google Authenticator
    software.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设Google Authenticator尚未配置，并且我们计划使用它，我们需要在智能手机上安装该应用。转到您的移动操作系统平台的相应应用商店并安装Google
    Authenticator软件。
- en: With the software installed on the phone, come back to the browser. You should
    see the following screen on selecting the Google Authenticator:![How to do it…](img/B04831_06_22.jpg)
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装了手机软件后，返回浏览器。在选择Google Authenticator后，您应该看到以下屏幕：![操作步骤](img/B04831_06_22.jpg)
- en: Begin the setup for a new account by scanning the QR code from the Google Authenticator
    application. If barcode scanning is a problem, you may choose to manually enter
    the key given on the right side of the screen.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过扫描Google Authenticator应用程序中的QR码开始设置新帐户。如果条形码扫描有问题，您可以选择在屏幕右侧手动输入给定的密钥。
- en: Once the scanning or the key is entered successfully, your smartphone should
    show a 6-digit number that changes every 30 seconds. Enter that number in the
    **Authentication Code** box given on the screen.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦成功扫描或输入密钥，您的智能手机应该显示一个每30秒更改一次的6位数字。在屏幕上的**认证代码**框中输入该数字。
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important not to delete this account in Google Authenticator on your phone
    as this will be used in future whenever we wish to change any settings related
    to backup, such as stopping backup, changing exclusion list, and almost any operation
    in MMS backup. The QR code and key will not be visible again once the setup is
    done. You will have to contact MongoDB support to get the configuration reset.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是不要在手机上删除Google Authenticator中的此帐户，因为这将在将来我们希望更改与备份相关的任何设置时使用。一旦设置完成，QR码和密钥将不再可见。您将需要联系MongoDB支持以重置配置。
- en: Once the authentication is done, the next screen you should see is the billing
    address and billing details, such as the card you register. All charges below
    $5 are waived so you should be ok to try out a small test instance before being
    charged.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦认证完成，您应该看到的下一个屏幕是账单地址和账单详细信息，比如您注册的卡。所有低于5美元的费用都将免除，因此在收费之前，您应该可以尝试一个小的测试实例。
- en: Once the credit card details are saved, we move ahead with the setup. We will
    have for installation a backup agent. This is a separate agent from the monitoring
    agent. Choose the appropriate platform and follow the instructions for its installation.
    Take a note of the location where the configuration files of the agent will be
    placed.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦信用卡详细信息保存，我们将继续进行设置。我们将安装一个备份代理。这是一个与监控代理分开的代理。选择适当的平台，并按照其安装说明进行操作。记下代理的配置文件将放置的位置。
- en: A new popup will contain the instruction/link to the archive/installer for the
    platform and the steps to install. It should also contain the `apiKey`. Take a
    note of the API key; we will need it in the next step.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个新的弹出窗口将包含平台的存档/安装程序的指令/链接以及安装步骤。它还应该包含`apiKey`。记下API密钥；我们将在下一步中需要它。
- en: Once the installation is complete, open the `local.config` file placed in the
    `config` directory of the agent installation (the location that was shown/modified
    during installation of the agent) and paste/type in the `apiKey` noted down in
    the previous step.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，打开代理安装的`config`目录中的`local.config`文件（在代理安装期间显示/修改的位置），并粘贴/输入在上一步中记下的`apiKey`。
- en: Once the agent is configured and started, click on the **Verify Agent** button.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦代理配置并启动，点击**验证代理**按钮。
- en: Once the agent is successfully verified, we will start by adding a host to back
    up. The drop-down menu should show us all the replica sets and shards we have
    added. Select the appropriate one and set the **Sync source** as the primary instance,
    as that is the only one we have in our standalone instance. **Sync source** is
    only used for the initial sync process. Whenever we have a proper replica set
    with multiple instances, I prefer using a secondary as a sync process instance.![How
    to do it…](img/B04831_06_23.jpg)
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦代理成功验证，我们将开始添加一个要备份的主机。下拉菜单应该显示我们添加的所有副本集和分片。选择适当的副本集，并将**同步源**设置为主实例，因为这是我们独立实例中唯一的实例。**同步源**仅用于初始同步过程。每当我们有一个合适的副本集和多个实例时，我更喜欢使用次要作为同步过程实例。![如何做…](img/B04831_06_23.jpg)
- en: Since the instance is not started with security, leave the **DB Username** and
    **DB Password** fields blank.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于实例未启动安全性，将**DB用户名**和**DB密码**字段留空。
- en: Click on the button **Manage excluded namespaces** if you wish to skip a particular
    database or collection being backed up. If nothing is provided, by default everything
    will be backed up. The format for the collection name will be `<databasename>.<collection
    name>`. Alternatively, it could be just the database name, in which case all collections
    in that database would not be eligible for backup.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您希望跳过特定数据库或集合的备份，请单击**管理排除的命名空间**按钮。如果没有提供任何内容，默认情况下将备份所有内容。集合名称的格式将是`<数据库名称>.<集合名称>`。或者，它可以只是数据库名称，在这种情况下，该数据库中的所有集合都不符合备份条件。
- en: Once the details are all ok, click on the **Start** button. This should complete
    the setup of the backup process for a replica set on MMS.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦细节都没问题，点击**开始**按钮。这应该完成在MMS上为副本集设置备份过程的设置。
- en: Tip
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The installation steps I performed were on Windows OS and the service needs
    to be started manually in that case. Press Windows + *R* and type `services.msc`.
    The name of the service is MMS Backup Agent.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我执行的安装步骤是在Windows操作系统上，服务在这种情况下需要手动启动。按下Windows + *R*，输入`services.msc`。服务的名称是MMS备份代理。
- en: How it works…
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The steps are pretty simple and this is all we need to do to set up a server
    for Mongo MMS backup. One important thing mentioned earlier is that MMS backup
    uses multifactor authentication for any operation once the backup is set up, and
    the account set up in Google Authenticator for MongoDB should not be deleted.
    There is no way to recover the original key used for setting up the authenticator.
    You will have to clear the Google Authenticator settings and set up a new key.
    To do that, click on the **Help & Support** link in the bottom-left corner of
    the screen and click on **How do I reset my two-factor authentication?**.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤非常简单，这就是我们为Mongo MMS备份设置服务器所需做的一切。之前提到的一个重要事项是，一旦设置了备份，MMS备份在任何操作中都使用多因素身份验证，并且为MongoDB在Google
    Authenticator中设置的帐户不应删除。没有办法恢复用于设置验证器的原始密钥。您将不得不清除Google Authenticator设置并设置一个新密钥。要做到这一点，点击屏幕左下角的**帮助和支持**链接，然后点击**如何重置我的双因素身份验证？**。
- en: On clicking the link, a new window will open up and ask for the username. An
    e-mail will be sent out to the registered e-mail ID which allows you to reset
    the two-factor authentication.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 单击链接后，将打开一个新窗口并要求输入用户名。将向注册的电子邮件ID发送一封电子邮件，该电子邮件允许您重置双因素身份验证。
- en: '![How it works…](img/B04831_06_31.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/B04831_06_31.jpg)'
- en: As mentioned, oplog is used to synchronize the current MongoDB instance with
    the MMS service. However, for the initial sync, an instance's data files are used.
    The instance to use is provided by us when we set up the backup of replica set.
    As this is a resource-heavy operation, I prefer to use a secondary instance for
    this on busy systems so as not to add more querying on the primary instance by
    the MMS backup agent. Once the instance is done with initial synchronization,
    the oplog of the primary instance will be used to get the data on a continuous
    basis. Agent does write to a collection called `mms.backup` in admin database
    periodically.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，oplog用于将当前MongoDB实例与MMS服务同步。但是，对于初始同步，将使用实例的数据文件。在设置副本集的备份时，我们提供要使用的实例。由于这是一个资源密集型操作，在繁忙的系统上，我更喜欢使用次要实例，以便不会通过MMS备份代理向主实例添加更多的查询。一旦实例完成初始同步，主实例的oplog将被用于持续获取数据。代理会定期向admin数据库中的`mms.backup`集合写入数据。
- en: 'The backup agent for MMS backup is different from the MMS monitoring agent.
    Though there is no restriction on having them both running on the same machine,
    you might need to evaluate that before having such a setup in production. The
    safe bet would be to have them running on separate machines. Never run either
    of these agents with a mongod or mongos instance on the same box in production.
    There are a couple of important reasons why it is not recommended to run the agent
    on the same box as the mongod instances:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: MMS备份的备份代理与MMS监控代理不同。虽然在同一台机器上同时运行它们没有限制，但在生产环境中进行这样的设置之前，您可能需要评估一下。最保险的做法是让它们在不同的机器上运行。在生产环境中，不要在同一台机器上运行这两个代理与mongod或mongos实例。不建议在同一台机器上运行代理和mongod实例的原因有几个重要的原因：
- en: The resource utilization of the agent is dependent on the cluster size it monitors.
    We don't want the agent to use a lot of resources affecting the performance of
    the production instance.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理的资源利用率取决于其监视的集群大小。我们不希望代理使用大量资源影响生产实例的性能。
- en: The agent could be monitoring a lot of server instances at a time. Since there
    is only one instance of this agent, we do not want it to go down during database
    server maintenance and restart.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理可能同时监视许多服务器实例。由于只有一个代理实例，我们不希望在数据库服务器维护和重启期间出现故障。
- en: 'The community edition of MongoDB built with SSL or enterprise versions with
    the SSL option used for communication between the client and the mongo server
    must do some additional steps. The first step is to check the **My deployment
    supports SSL for MongoDB connections** flag when we set up the replica set for
    backup (see step 15). Note the check box at the bottom in the screenshot that
    should be checked. Secondly, open the `local.config` file for the MMS configuration
    and look out for these two properties:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SSL构建的MongoDB社区版或使用SSL选项进行通信的企业版必须执行一些额外的步骤。第一步是在为备份设置副本集时检查**我的部署支持MongoDB连接的SSL**标志（见第15步）。请注意截图底部的复选框应该被选中。其次，打开MMS配置的`local.config`文件，并查找以下两个属性：
- en: '[PRE8]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first is the fully qualified path of the certifying authority's certificate
    in PEM format. This certificate will be used to verify the certificate presented
    by the mongod instance running over SSL. The second property can be set to `false`
    if certificate verification is to be disabled, this is however not a recommended
    option. As far as the traffic between the backup agent and MMS backup is concerned,
    data sent from the agent to the MMS service over SSL is secure irrespective of
    whether SSL is enabled on your MongoDB instances or not. The data at rest in the
    data center for the backed up data is not encrypted.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是PEM格式的认证机构证书的完全限定路径。此证书将用于验证通过SSL运行的mongod实例呈现的证书。如果要禁用证书验证，则可以将第二个属性设置为`false`，但这并不是一个推荐的选项。就从代理向MMS服务发送的数据而言，无论您的MongoDB实例是否启用SSL，通过SSL发送的数据都是安全的。备份数据中心中的数据在静态状态下是未加密的。
- en: 'If security is enabled on the mongod instance, a username and password need
    to be provided, which will be used by the MMS backup agent. The username and password
    are provided while setting up backup for the replica set, as in step 15\. Since
    the agent needs to read the oplog, possibly all databases for the initial sync
    and write data to `admin` database the following roles are expected for the user:
    `readAnyDatabase`, `clusterAdmin`, `readWrite` on `admin` and `local` databases,
    and `userAdminAnyDatabase`. This is in case in version 2.4 and above. In versions
    prior to v2.4, we would expect the user to have read access on all the databases
    and read/write access to admin and local databases.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在mongod实例上启用了安全性，则需要提供用户名和密码，这将被MMS备份代理使用。在为副本集设置备份时提供用户名和密码，如第15步所示。由于代理需要读取oplog，可能需要对所有数据库进行初始同步并将数据写入`admin`数据库，因此用户需要具有以下角色：`readAnyDatabase`，`clusterAdmin`，`admin`和`local`数据库上的`readWrite`，以及`userAdminAnyDatabase`。这适用于版本2.4及以上。在v2.4之前的版本中，我们期望用户对所有数据库具有读取权限，并对admin和local数据库具有读/写权限。
- en: 'While setting up a replica set for backup you may get an error like, `Insufficient
    oplog size: The oplog window must be at least 1 hours over the last 24 hours for
    all active replica set members. Please increase the oplog.`. While you may think
    this is always something to do with oplog size, it is also seen when the replica
    set has an instance that is in recovering state. This might feel misleading, so
    do look out for recovering nodes, if any, in the replica set while setting up
    a backup for a replica set. As per the MMS support too, it seems too restrictive
    to not set up a replica set for backup with some recovering nodes, and it might
    be fixed in the future.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '在为备份设置副本集时，您可能会遇到错误，如`Insufficient oplog size: The oplog window must be at
    least 1 hours over the last 24 hours for all active replica set members. Please
    increase the oplog.`。虽然您可能认为这总是与oplog大小有关，但当副本集中有一个处于恢复状态的实例时，也会出现这种情况。这可能会让人感到误导，因此在为副本集设置备份时，请注意查看是否有正在恢复的节点。根据MMS支持，似乎不允许为具有一些正在恢复节点的备份设置副本集，并且这可能会在将来得到修复。'
- en: Managing backups in MMS Backup service
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在MMS备份服务中管理备份
- en: In the previous recipe, we saw how to set up MMS backup service and a simple
    one member replica set was set up for backup. Though a single member replica set
    makes no sense at all, it was needed as a standalone instance cannot be set up
    for backup in MMS. In this recipe, we dive deeper and look at the operations we
    can perform on the server that is set up for backup, such as starting, stopping,
    or terminating a backup; managing exclusion lists; managing backup snapshots and
    retention; and restoring to point in time data.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一篇文章中，我们看到了如何设置MMS备份服务，并为备份设置了一个简单的单成员副本集。尽管单成员副本集根本没有意义，但由于独立实例无法在MMS中设置备份，因此需要它。在本篇文章中，我们将深入探讨在为备份设置的服务器上可以执行的操作，例如启动、停止或终止备份；管理排除列表；管理备份快照和保留；以及恢复到特定时间点的数据。
- en: Getting ready
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The previous recipe is all that is needed for this recipe. The necessary setup
    is expected to be done as we are going to use the same server we had set up for
    backup in this recipe.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤就是这个步骤所需的一切。预计已经完成了必要的设置，因为我们将在这个步骤中使用与备份相同的服务器。
- en: How to do it…
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: With the server up and running, let's import some data to it. It can be anything,
    but we chose to use the `countries.geo.json` file that was used in the last chapter.
    It should be available in the bundle downloaded from the Packt site.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器已经运行，让我们向其导入一些数据。可以是任何数据，但我们选择使用上一章中使用的`countries.geo.json`文件。它应该在从Packt网站下载的捆绑软件中可用。
- en: 'Start by importing the data into a collection called `countries` in the `test`
    database. Use the following command to do it. The following import command was
    executed with the current directory having the `countries.geo.json` file:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将数据导入到`test`数据库中名为`countries`的集合中。使用以下命令来执行。当前目录中有`countries.geo.json`文件时，执行以下导入命令：
- en: '[PRE9]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We have already seen how to exclude namespaces when the replica set backup
    was being set up. We will now see how to exclude namespaces once the backup for
    a replica set is done. Click on the **Backup** menu option on the left and then
    the **Replica Set Status**, which opens by default when **Backup** is clicked.
    Click on the **Gear** button on the right side of the row where the replica set
    is shown. It should look like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了在设置副本集备份时如何排除命名空间。现在我们将看到在为副本集备份完成后如何排除命名空间。点击左侧的**备份**菜单选项，然后点击**副本集状态**，这在点击**备份**时会默认打开。点击显示副本集的行右侧的**齿轮**按钮。它应该看起来像这样：
- en: '![How to do it…](img/B04831_06_24.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](img/B04831_06_24.jpg)'
- en: As we see in the preceding image, click on **Edit Excluded Namespaces** and
    type in the name of the collection that we want to exclude. Suppose we want to
    exclude the `applicationLogs` collection in `test` database, type in `test.applicationLogs`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前面的图片所示，点击**编辑排除的命名空间**，然后输入要排除的集合名称。假设我们要在`test`数据库中排除`applicationLogs`集合，输入`test.applicationLogs`。
- en: On saving, you will be asked to enter the token code that is currently displayed
    on your Google Authenticator.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存后，您将被要求输入当前在您的Google Authenticator上显示的令牌代码。
- en: On successful validation of the code, the namespace `test.applicationLogs` will
    be added to the list of namespaces excluded from being backed up.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功验证代码后，`test.applicationLogs`命名空间将被添加到排除备份的命名空间列表中。
- en: We now shall see how to manage snapshot scheduling. A snapshot is the state
    of the database as of a particular point in time. To manage the snapshot frequency
    and retention policy, click on the **Gear** button shown in the previous screenshot
    and click on **Edit Snapshot Schedule**.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将看到如何管理快照调度。快照是数据库在特定时间点的状态。要管理快照频率和保留策略，请点击前一个截图中显示的**齿轮**按钮，然后点击**编辑快照调度**。
- en: As we can see in the following image, we can set the times when the snapshots
    are taken and their retention period. We will discuss more on this in the next
    section. Any changes to it would need multifactor authentication to save the changes.![How
    to do it…](img/B04831_06_25.jpg)
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们在下一张图片中所看到的，我们可以设置快照的拍摄时间和保留期限。我们将在下一节中更多讨论这个问题。对此的任何更改都需要多因素身份验证来保存更改。![操作步骤...](img/B04831_06_25.jpg)
- en: We will now see how we go about restoring the data using MMS backup. At any
    point in time whenever we want to restore the data, click on **Backup** and **Replica
    Set Status**/**Shard Cluster Status** click on **set/cluster name**.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将看到如何使用MMS备份恢复数据。在任何时候，当我们想要恢复数据时，点击**备份**和**副本集状态**/**分片集群状态**，然后点击**集合/集群名称**。
- en: 'On clicking it, we will see the snapshots that are saved against this set.
    It should look something like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 点击后，我们将看到保存在此集合中的快照。应该看起来像这样：
- en: '![How to do it…](img/B04831_06_26.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](img/B04831_06_26.jpg)'
- en: We have encircled some of the portions on the screen which we will see one by
    one.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经圈出了屏幕上的一些部分，我们将逐一看到。
- en: To restore to the time when the snapshot was taken, click on the **Restore this
    snapshot** link in the **Actions** column of the grid.![How to do it…](img/B04831_06_27.jpg)
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要恢复到快照拍摄时的时间点，请点击网格的**操作**列中的**恢复此快照**链接。![操作步骤...](img/B04831_06_27.jpg)
- en: The preceding image shows us how we can export the data either over HTTPS or
    SCP. We select HTTPS for now, and click **Authenticate**. We will see about SCP
    in the next section.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的图片向我们展示了如何通过HTTPS或SCP导出数据。我们现在选择HTTPS，然后点击**验证**。我们将在下一节中了解SCP。
- en: Enter the token that is received either over SMS or seen on Google Authenticator
    and click **Finalize Request** on entering the auth code.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入通过短信接收或在Google Authenticator上看到的令牌，然后点击**完成请求**以输入认证代码。
- en: On successful authentication, click on **Restore Jobs**. This is a one-time
    download that will let you download the `tar.gz` archive. Click on the **download**
    link to download the `tar.gz` archive.![How to do it…](img/B04831_06_28.jpg)
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功验证后，点击**恢复作业**。这是一次性下载，让您可以下载`tar.gz`存档。点击**下载**链接以下载`tar.gz`存档。![操作步骤...](img/B04831_06_28.jpg)
- en: Once the archive is downloaded, extract it to get the database files within
    it.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载存档后，解压以获取其中的数据库文件。
- en: Stop the mongod instance, replace the database files with the ones that are
    extracted, and restart the server to get the data as of the time when the snapshot
    was taken. Note that the database file will not contain data for the collection
    that was excluded from backup if all.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止mongod实例，用提取出的文件替换数据库文件，并重新启动服务器以获取快照拍摄时的数据。请注意，如果所有数据都被排除在备份之外，数据库文件将不包含该集合的数据。
- en: We will now see how to get point in time data using MMS backup.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将看到如何使用MMS备份获取特定时间点的数据。
- en: Click on **Replica Set Status** / **Shard Cluster Status** and then the cluster/set
    which is to be restored.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**副本集状态**/**分片集群状态**，然后点击要恢复的集群/集合。
- en: On the right-hand side of the screen, click on the **Restore** button.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕右侧，点击**恢复**按钮。
- en: This should give a list of available snapshots or you may enter a custom time.
    Check **Use Custom Point In Time**. Click on the **Date** field and select a date
    and a time to which you want to restore the data in Hours and Minutes and click
    **Next**. Note that the **Point in Time** feature only restores to a point in
    last 24 Hours.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该列出可用的快照，或者您可以输入自定义时间。勾选**使用自定义时间点**。单击**日期**字段，选择日期和时间，以便在小时和分钟中恢复数据，然后单击**下一步**。请注意，**时间点**功能只能恢复到过去24小时的时间点。
- en: Here, you will be asked to specify the format as HTTPS or SCP. The subsequent
    steps are similar to what we did on the previous occasion, from step 14 onwards.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将被要求指定格式为HTTPS或SCP。后续步骤与我们上次做的类似，从第14步开始。
- en: How it works…
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: After setting up the backup for a replica set, we imported random data into
    the database. Backup for this database would be done by MMS and later on we will
    restore the database using this backup. We saw how to exclude namespaces from
    being backed up in steps 2-5.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 设置副本集的备份后，我们向数据库导入了随机数据。这个数据库的备份将由MMS完成，稍后我们将使用这个备份来恢复数据库。我们看到了如何在步骤2-5中排除要备份的命名空间。
- en: Looking at the snapshot and retention policy settings, we can see we have the
    choice of the time interval in which the snapshots are to be taken and the number
    of days they are to be retained (step 9). We can see that by default snapshots
    are taken every 6 hours and they are saved for 2 days. The snapshot that is taken
    at the end of the day gets saved for a week. The snapshot taken at the end of
    the week and month are saved for 4 weeks and 13 months respectively. A snapshot
    can be taken once every 6, 8, 12, and 24 hours. However, you need to understand
    the flip side of taking snapshots after long time duration. Suppose the last snapshot
    is taken at 18 hours; getting the data as of that time for restore is very easy
    as it is stored on the MMS backup servers. However, we need the data as of 21:30
    hours for restoration. Since MMS backup supports point in time backup, it would
    use the base snapshot at 18:00 hours and then just replay the changes on it after
    the snapshot is taken at 21:30 hours. This is similar to how an oplog would be
    replayed on the data. There is a cost for this replay and thus getting point in
    time backup is slightly more expensive than getting the data from a snapshot.
    Here, we had to replay the data for 3.5 hours, from 18:00 hours to 21:30 hours.
    Imagine if the snapshots were set to be taken after 12 hours and our first snapshot
    is taken at 00:00 hours, then we would have snapshots at 00:00 hours and 12:00
    hours every day. To restore the data as of 21:30 hours with 12:00 hours as the
    last snapshot, we will have to replay 9.5 hours of data. This is much more expensive.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 查看快照和保留策略设置，我们可以看到我们可以选择快照拍摄的时间间隔和保留的天数（步骤9）。我们可以看到，默认情况下，快照每6小时拍摄一次，保存2天。在一天结束时拍摄的快照保存一周。在一周和一个月结束时拍摄的快照分别保存4周和13个月。快照可以每6、8、12和24小时拍摄一次。然而，您需要了解长时间间隔后拍摄快照的另一面。假设最后一张快照是在18小时拍摄的；获取那时的数据进行恢复非常容易，因为它存储在MMS备份服务器上。然而，我们需要21:30时的数据进行恢复。由于MMS备份支持时间点备份，它将使用18:00时的基本快照，然后在21:30时拍摄快照后对其进行更改。这类似于如何在数据上重放oplog。这种重放是有成本的，因此获取时间点备份比从快照获取数据略微昂贵。在这里，我们需要重放3.5小时的数据，从18:00时到21:30时。想象一下，如果快照设置为每12小时拍摄一次，我们的第一张快照是在00:00时拍摄的，那么我们每天都会在00:00时和12:00时拍摄快照。要将数据恢复到21:30时，以12:00时为最后一个快照，我们将不得不重放9.5小时的数据。这要昂贵得多。
- en: More frequent snapshots means more storage space usage but less time needed
    to restore a database to a given point in time. At the same time, less frequent
    snapshots require less storage but at the cost of more time to restore the data
    to a point in time. You need to decide and have a trade-off between these two,
    space and time of restoration. For the daily snapshot, we can choose retention
    of between 3 to 180 days. Similarly, for the weekly and monthly snapshots, the
    retention period can be chosen between 1 to 52 weeks and 1 to 36 months, respectively.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 更频繁的快照意味着更多的存储空间使用，但恢复数据库到特定时间点所需的时间更少。与此同时，较少频繁的快照需要更少的存储空间，但以恢复数据到特定时间点为代价的时间更长。您需要在这两者之间做出决定并进行权衡，即空间和恢复时间。对于每日快照，我们可以选择保留3到180天。同样，对于每周和每月的快照，保留期可以分别选择1到52周和1到36个月。
- en: The screenshot in step 9 has a column for the expiry of the snapshot. This,
    for the first snapshot taken, is 1 year, whereas others expire in 2 days. The
    expiration is as per what we discussed in the last paragraph. On changing the
    expiration values, the old snapshots are not affected or adjusted as per the changed
    times. However, the new snapshots taken will be as per the modified settings for
    the retention and frequency.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9步的屏幕截图中，有一个列显示快照的到期时间。对于第一张拍摄的快照，到期时间是1年，而其他快照在2天后到期。到期时间如我们在上一段讨论的那样。更改到期值时，旧的快照不会受到影响或根据更改的时间进行调整。然而，根据修改后的保留和频率设置拍摄的新快照将会受到影响。
- en: 'We saw how to download the dump (step 10 onwards) and then use it to restore
    the data in the database. It was pretty straightforward and doesn''t need a lot
    of explanation except a couple of things. First, if the data is for a shard, there
    will be multiple folders—one for each shard and each of them will have the database
    files as against what we saw here in case of a replica set where we have a single
    folder with database files in it. Finally, let''s look at the screen when we choose
    SCP as the option:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何下载转储（从第10步开始），然后使用它来恢复数据库中的数据。这非常简单，不需要太多解释，除了一些事情。首先，如果数据是用于分片，将会有多个文件夹，每个分片一个文件夹，每个文件夹都有数据库文件，与我们在副本集的情况下看到的不同，那里我们有一个包含数据库文件的单个文件夹。最后，让我们看看当我们选择SCP作为选项时的屏幕：
- en: '![How it works…](img/B04831_06_29.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B04831_06_29.jpg)'
- en: SCP is short for secure copy. The files will be copied over a secure channel
    to a machine's filesystem. The host that is given needs to have a public IP which
    will be used to SCP. This makes a lot of sense when we want the data from MMS
    to be delivered to a machine running on Unix OS on the cloud, for example, one
    of the AWS virtual instances. Rather than getting the file using HTTPS on our
    local machine and then reuploading it to the server on the cloud, you can specify
    the location on which the data needs to be copied in the Target Directory block,
    the hostname, and the credentials. There are a couple of ways of authentication
    too. A password is an easy way with an additional option to SSH key pair. If you
    have to configure host's firewalls on the cloud to allow incoming traffic over
    the SSH port, the public IP addresses are given at the bottom of the screen (`64.70.114.115/32`
    or `4.71.186.0/24` in our screenshot). You should whitelist them to allow incoming
    secure copy requests over port `22`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: SCP是安全复制的缩写。文件将通过安全通道复制到计算机的文件系统中。给定的主机需要具有公共IP，该IP将用于SCP。当我们希望从MMS获取的数据传递到云上运行Unix
    OS的机器时，这是非常有意义的，例如，AWS虚拟实例之一。与其在本地机器上使用HTTPS获取文件，然后重新上传到云上的服务器，不如在目标目录块中指定需要复制数据的位置，主机名和凭据。还有几种身份验证的方式。密码是一种简单的方式，还有一个额外的选项是SSH密钥对。如果您必须配置云上主机的防火墙以允许通过SSH端口的传入流量，公共IP地址将显示在屏幕底部（在我们的截图中为`64.70.114.115/32`或`4.71.186.0/24`）。您应该将它们列入白名单，以允许通过端口`22`进行安全复制请求的传入流量。
- en: See also
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: We have seen running backups using MMS which uses oplogs for this purpose. There
    is a recipe called *Implementing triggers in Mongo using oplog* in [Chapter 5](ch05.html
    "Chapter 5. Advanced Operations"), *Advanced Operations*, which uses oplog to
    implement trigger-like functionalities. This concept is the backbone of the real-time
    backup used by MMS backup service.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了使用MMS运行备份，该备份使用oplogs来实现这一目的。在[第5章](ch05.html "第5章.高级操作") *高级操作*中有一个名为*在Mongo中使用oplog实现触发器*的配方，该配方使用oplog来实现类似触发器的功能。这个概念是MMS备份服务使用的实时备份的基础。
