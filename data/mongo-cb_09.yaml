- en: Chapter 9. Open Source and Proprietary Tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。开源和专有工具
- en: 'In this chapter, we will cover some open source and proprietary tools. The
    following are the recipes that we will go through in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖一些开源和专有工具。以下是本章中将要介绍的配方：
- en: Developing using spring-data-mongodb
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用spring-data-mongodb进行开发
- en: Accessing MongoDB using JPA
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JPA访问MongoDB
- en: Accessing MongoDB over REST
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过REST访问MongoDB
- en: Installing a GUI-based client, MongoVUE, for MongoDB
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为MongoDB安装基于GUI的客户端MongoVUE
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: There is a vast array of tools/frameworks available to ease the development/administration
    process for software that uses MongoDB. We will look at some of these available
    frameworks and tools. For a developer's productivity (Java developers, in this
    case), we will look at spring-data-mongodb, which is a part of the popular spring
    data suite.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有大量的工具/框架可用于简化使用MongoDB的软件的开发/管理过程。我们将看一些这些可用的框架和工具。对于开发人员的生产力（在这种情况下是Java开发人员），我们将看一下spring-data-mongodb，它是流行的spring
    data套件的一部分。
- en: JPA is an ORM specification that is widely used, particularly with relational
    databases. (This was the objective of the ORM frameworks.) However, there are
    a few implementations that let us use it with NoSQL stores—MongoDB, in this case.
    We will look at a provider who provides this implementation and put it to the
    test with a simple use case.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: JPA是一个广泛使用的ORM规范，特别是与关系数据库一起使用。（这是ORM框架的目标。）然而，有一些实现让我们可以将其与NoSQL存储（在这种情况下是MongoDB）一起使用。我们将看一个提供这种实现的提供者，并用一个简单的用例来测试它。
- en: We will use spring-data-rest to expose the CRUD repositories for MongoDB over
    a REST interface for clients to invoke various operations supported by the underlying
    spring-data-mongo repository.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用spring-data-rest来为客户端公开MongoDB的CRUD存储库，以便客户端调用底层spring-data-mongo存储库支持的各种操作。
- en: Querying the database in the shell is okay, but it would be nice to have a good
    GUI to enable us to do all the administrative-related/development-related tasks
    from the GUI rather than execute the commands in the shell to perform these activities.
    We will look at one such tool in this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell中查询数据库是可以的，但最好有一个良好的GUI，使我们能够从GUI中执行所有与管理/开发相关的任务，而不是在shell中执行命令来执行这些活动。我们将在本章中看一个这样的工具。
- en: Developing using spring-data-mongodb
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用spring-data-mongodb进行开发
- en: 'From a developer''s perspective, when a program needs to interact with a MongoDB
    instance, they need to use the respective client APIs for their specific platforms.
    The trouble with doing this is that we need to write a lot of boilerplate code
    and it is not necessarily object-oriented. For instance, we have a class called
    `Person` with various attributes such as `name`, `age`, `address`, and so on.
    The corresponding JSON document shares a similar structure to this `person` class
    as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发人员的角度来看，当程序需要与MongoDB实例交互时，他们需要使用特定平台的相应客户端API。这样做的麻烦在于我们需要编写大量的样板代码，而且不一定是面向对象的。例如，我们有一个名为`Person`的类，具有各种属性，如`name`、`age`、`address`等。相应的JSON文档与这个`person`类的结构类似。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, to store this document, we need to convert the `Person` class to DBObject,
    which is a map with key and value pairs. What is really needed is to let us persist
    this `Person` class itself as an object in the database without having to convert
    it to DBObject.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了存储这个文档，我们需要将`Person`类转换为DBObject，这是一个具有键值对的映射。真正需要的是让我们将这个`Person`类本身作为一个对象持久化到数据库中，而不必将其转换为DBObject。
- en: Additionally, some of the operations such as searching by a particular field
    of a document, saving an entity, deleting an entity, searching by the ID, and
    so on are pretty common operations, and we tend to repeatedly write similar boilerplate
    code. In this recipe, we will see how spring-data-mongodb relieves us of these
    laborious and cumbersome tasks to reduce, not only the development effort, but
    also the possibility of introducing bugs in these commonly written functions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些操作，如按文档的特定字段搜索、保存实体、删除实体、按ID搜索等，都是非常常见的操作，我们往往会反复编写类似的样板代码。在这个配方中，我们将看到spring-data-mongodb如何解除我们这些繁琐和繁重的任务，以减少不仅开发工作量，还减少引入这些常见写函数中的错误的可能性。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `SpringDataMongoTest` project, present in the bundle with the chapter, is
    a Maven project and has to be imported to any IDE of your choice. The required
    maven artifacts will automatically be downloaded. A single MongoDB instance is
    required to be up and running and listening to port `27017`. Refer to the *Installing
    single node MongoDB* recipe from [Chapter 1](ch01.html "Chapter 1. Installing
    and Starting the Server"), *Installing and Starting the Server*, for instructions
    on how to start a standalone instance.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpringDataMongoTest`项目，存在于本章的捆绑包中，是一个Maven项目，必须导入到您选择的任何IDE中。所需的maven构件将自动下载。需要一个单独的MongoDB实例正在运行并监听端口`27017`。有关如何启动独立实例的说明，请参阅[第1章](ch01.html
    "第1章。安装和启动服务器")中的*安装单节点MongoDB*配方，*安装和启动服务器*。'
- en: For the aggregation example, we will use the postal codes data. Refer to the
    *Creating test data* recipe in [Chapter 2](ch02.html "Chapter 2. Command-line
    Operations and Indexes"), *Command-line Operations and Indexes*, for the creation
    of the test data.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于聚合示例，我们将使用邮政编码数据。有关如何创建测试数据，请参阅[第2章](ch02.html "第2章。命令行操作和索引")中的*创建测试数据*配方，*命令行操作和索引*。
- en: How to do it…
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: We will explore the spring-data-mongodb's repository feature first. Open the
    test case's `com.packtpub.mongo.cookbook.MongoCrudRepositoryTest` class from your
    IDE and execute it. If all goes well and the MongoDB server instance is reachable,
    the test case will get executed successfully.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先探索spring-data-mongodb的存储库功能。从您的IDE中打开测试用例的`com.packtpub.mongo.cookbook.MongoCrudRepositoryTest`类并执行它。如果一切顺利，MongoDB服务器实例是可达的，测试用例将成功执行。
- en: Another test case, `com.packtpub.mongo.cookbook.MongoCrudRepositoryTest2`, is
    used to explore more features of the repository support provided by spring-data-mongodb.
    This test case too should get executed successfully.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个测试用例`com.packtpub.mongo.cookbook.MongoCrudRepositoryTest2`，用于探索spring-data-mongodb提供的存储库支持的更多功能。这个测试用例也应该成功执行。
- en: We will see how spring-data-mongodb's `MongoTemplate` can be used to perform
    CRUD operations and other common operations on MongoDB. Open the `com.packtpub.mongo.cookbook.MongoTemplateTest`
    class and execute it.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将看到如何使用spring-data-mongodb的`MongoTemplate`执行CRUD操作和其他常见操作。打开`com.packtpub.mongo.cookbook.MongoTemplateTest`类并执行它。
- en: 'Alternatively, if an IDE is not used, all the tests can be executed using maven
    from the command prompt with the current directory being in the root of the `SpringDataMongoTest`
    project:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，如果不使用IDE，可以在命令提示符中使用maven执行所有测试，当前目录在`SpringDataMongoTest`项目的根目录中：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will first look at what we did in `com.packtpub.mongo.cookbook.MongoCrudRepositoryTest`,
    where we saw the repository support provided by spring-data-mongodb. Just in case
    you didn't notice, we haven't written a single line of code for the repository.
    The magic of implementing the required code for us is done by the spring data
    project.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看一下在`com.packtpub.mongo.cookbook.MongoCrudRepositoryTest`中做了什么，我们在那里看到了spring-data-mongodb提供的存储库支持。以防你没有注意到，我们没有为存储库编写一行代码。实现所需代码的魔力是由spring
    data项目完成的。
- en: 'Let''s start by looking at the relevant portions of the XML configuration file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下XML配置文件的相关部分：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We first look at the last three lines, which are the spring-data-mongodb namespace
    declarations to instantiate `com.mongodb.Mongo`, a factory for the `com.mongodb.DB`
    instances from the client, and `template` instance, which is used to perform various
    operations on MongoDB, respectively. We will see `org.springframework.data.mongodb.core.MongoTemplate`
    in more detail later.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看一下最后三行，这些是spring-data-mongodb命名空间声明，用于实例化`com.mongodb.Mongo`，客户端的`com.mongodb.DB`实例的工厂，以及`template`实例，用于在MongoDB上执行各种操作。稍后我们将更详细地看一下`org.springframework.data.mongodb.core.MongoTemplate`。
- en: 'The first line is a namespace declaration for the base package of all the CRUD
    repositories that we have. In this package, we have an interface with the following
    body:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是所有CRUD存储库的基本包的命名空间声明。在这个包中，我们有一个接口，具有以下内容：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `PagingAndSortingRepository` interface is from the `org.springframework.data.repository`
    package of the spring data core project and extends from `CrudRepository` in the
    same project. These interfaces give us some of the most common methods such as
    searching by the ID/primary key, deleting an entity, and inserting and updating
    an entity. The repository needs an object that it maps to the underlying data
    store. The spring data project supports a large number of data stores not just
    limited to SQL (using JDBC and JPA) or MongoDB, but also to other NoSQL stores
    such as Redis and Hadoop and search engines such as Solr and Elasticsearch. In
    case of spring-data-mongodb, the object is mapped to a document in the collection.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`PagingAndSortingRepository`接口来自spring data核心项目的`org.springframework.data.repository`包，并在同一项目中扩展自`CrudRepository`。这些接口为我们提供了一些最常见的方法，例如按ID/主键搜索、删除实体以及插入和更新实体。存储库需要一个对象，它将其映射到底层数据存储。spring
    data项目支持大量的数据存储，不仅限于SQL（使用JDBC和JPA）或MongoDB，还包括其他NoSQL存储，如Redis和Hadoop，以及Solr和Elasticsearch等搜索引擎。在spring-data-mongodb的情况下，对象被映射到集合中的文档。'
- en: The `PagingAndSortingRepository<Person, Integer>` signature indicates that the
    first one is the entity that the CRUD repository is built for and the second is
    the type of the primary key/ID field.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`PagingAndSortingRepository<Person, Integer>`的签名表示第一个是CRUD存储库构建的实体，第二个是主键/ID字段的类型。'
- en: We added just one `findByLastName` method, which accepts one string value for
    the last name as a parameter. This is an interesting operation that is specific
    to our repository and not even implemented by us, but it will still work just
    as expected. Person is a POJO where we annotated the `id` field with the `org.springframework.data.annotation.Id`
    annotation. Nothing else is really special about this class; it just has some
    plain getters and setters.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只添加了一个`findByLastName`方法，它接受一个字符串值作为姓氏的参数。这是一个特定于我们的存储库的有趣操作，甚至不是我们实现的，但它仍然会按预期工作。Person是一个POJO，我们用`org.springframework.data.annotation.Id`注解标记了`id`字段。这个类没有什么特别之处；它只有一些普通的getter和setter。
- en: 'With all these small details, let''s join these dots together by answering
    some questions that you''ll have in mind. First, we will see which server, database,
    and collection our data goes to. If we look at the XML definition, `mongo:mongo`,
    for the configuration file, we can see that we instantiated the `com.mongodb.Mongo`
    class by connecting to localhost and port `27017`. The `mongo:db-factory` declaration
    is used to denote that the database to be used is `test`. One final question is:
    which collection? The simple name of our class is `Person`. The name of the collection
    is the simple name with the first character in lowercase, and thus, `Person` goes
    to person and something like `BillingAddress` would go to the `billingAddress`
    collection. These are the default values. However, if you need to override this
    value, you can annotate your class with the `org.springframework.data.mongodb.core.mapping.Document`
    annotation and use its collection attribute to give any name of your choice, as
    we will see in a later example.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有这些细节，让我们通过回答一些你心中的问题来把这些点连接起来。首先，我们将看到我们的数据去了哪个服务器、数据库和集合。如果我们查看配置文件的XML定义，`mongo:mongo`，我们可以看到我们通过连接到localhost和端口`27017`来实例化`com.mongodb.Mongo`类。`mongo:db-factory`声明用于表示要使用的数据库是`test`。最后一个问题是：哪个集合？我们类的简单名称是`Person`。集合的名称是简单名称的第一个字符小写，因此`Person`对应到`person`，而`BillingAddress`之类的东西将对应到`billingAddress`集合。这些是默认值。但是，如果您需要覆盖此值，可以使用`org.springframework.data.mongodb.core.mapping.Document`注解注释您的类，并使用其collection属性来给出您选择的任何名称，正如我们将在后面的示例中看到的。
- en: 'To view the document in the collection, execute just one test case `saveAndQueryPerson`
    method from the `com.packtpub.mongo.cookbook.MongoCrudRepositoryTest` class. Now,
    connect to the MongoDB instance in the mongo shell and execute the following query:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 查看集合中的文档，只需执行`com.packtpub.mongo.cookbook.MongoCrudRepositoryTest`类中的一个测试用例`saveAndQueryPerson`方法。现在，连接到mongo
    shell中的MongoDB实例并执行以下查询：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we can see in the preceding result, the contents of the document are similar
    to the object that we persisted using the CRUD repository. The names of the field
    in the document are the same as the names of the respective attributes in the
    Java object with two exceptions. The field annotated with `@Id` is now `_id`,
    irrespective of the name of the field in the Java class and an additional `_class`
    attribute is added to the document whose value is the fully qualified name of
    the Java class itself. This is not of any use to the application but is used by
    spring-data-mongodb as metadata.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的结果中所看到的，文档的内容与我们使用CRUD存储库持久化的对象相似。文档中字段的名称与Java对象中相应属性的名称相同，有两个例外。使用`@Id`注释的字段现在是`_id`，与Java类中字段的名称无关，并且在文档中添加了一个额外的`_class`属性，其值是Java类本身的完全限定名称。这对应用程序没有任何用处，但是spring-data-mongodb用作元数据。
- en: Now it makes more sense and gives us an idea what spring-data-mongodb must be
    doing for all the basic CRUD methods. All the operations that we perform will
    use the `MongoTemplate` (`MongoOperations`, which is an interface that `MongoTemplate`
    implements) class from the spring-data-mongodb project. Using the primary key,
    it will invoke a find by the `_id` field on the collection derived using the `Person`
    entity class. The `save` method simply calls the `save` method on `MongoOperations`,
    which, in turn, calls the `save` method on the `com.mongodb.DBCollection` class.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更有意义了，并且让我们了解spring-data-mongodb必须为所有基本的CRUD方法做些什么。我们执行的所有操作都将使用spring-data-mongodb项目中的`MongoTemplate`（`MongoOperations`，这是`MongoTemplate`实现的接口）类。它将使用主键，在使用`Person`实体类派生的集合上的`_id`字段上调用find。`save`方法简单地调用`MongoOperations`上的`save`方法，而`MongoOperations`又调用`com.mongodb.DBCollection`类上的`save`方法。
- en: 'We still haven''t answered how the `findByLastName` method worked. How does
    spring know what query to invoke in order to return the data? These are the special
    types of methods that begin with `find`, `findBy`, `get`, or `getBy`. There are
    some rules that one needs to follow while naming a method, and the proxy object
    on the repository interface is able to correctly convert this method into an appropriate
    query on the collection. For instance, the `findByLastName` method in the repository
    for the `Person` class will execute a query on the `lastName` field in person''s
    document. Hence, the `findByLastName(String lastName)` method will fire the `db.person.find({''lastName'':
    lastName })` query on the database. Based on the return type of the method defined,
    it will return either `List` or the first result in the returned result from the
    database. We used `findBy` in our queries; however, anything that begins with
    find, has any text in between, and ends with `By`, works. For instance, `findPersonBy`
    is also the same as `findBy`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '我们仍然没有回答`findByLastName`方法是如何工作的。spring如何知道要调用什么查询以返回数据？这些是以`find`、`findBy`、`get`或`getBy`开头的特殊类型的方法。在命名方法时需要遵循一些规则，存储库接口上的代理对象能够正确地将此方法转换为集合上的适当查询。例如，`Person`类的存储库中的`findByLastName`方法将在person文档的`lastName`字段上执行查询。因此，`findByLastName(String
    lastName)`方法将在数据库上触发`db.person.find({''lastName'': lastName })`查询。根据方法定义的返回类型，它将返回来自数据库的结果中的`List`或第一个结果。我们在我们的查询中使用了`findBy`，但是任何以`find`开头，中间有任何文本，并以`By`结尾的都可以工作。例如，`findPersonBy`也与`findBy`相同。'
- en: 'To see more on these `findBy` methods, we have another test `MongoCrudRepositoryTest2`
    class. Open this class in your IDE where it can be read along with this text.
    We already executed this test case; now, let''s see these `findBy` methods used
    and their behavior. This interface has seven `findBy` methods in it, with one
    of the methods being a variant of another method in the same interface. To get
    a clear idea of the queries, we will first look at one of the documents in the
    `personTwo` collection in the test database. Execute the following in the mongo
    shell connected to the MongoDB server running on localhost:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于这些`findBy`方法，我们有另一个测试`MongoCrudRepositoryTest2`类。在您的IDE中打开这个类，可以与本文一起阅读。我们已经执行了这个测试用例；现在，让我们看看这些`findBy`方法的使用和它们的行为。这个接口中有七个`findBy`方法，其中一个方法是同一接口中另一个方法的变体。为了清楚地了解查询，我们将首先查看测试数据库中`personTwo`集合中的一个文档。在连接到运行在localhost上的MongoDB服务器的mongo
    shell中执行以下操作：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that the repository uses the `Person2` class; however, the name of the
    collection used is `personTwo`. This was possible because we used the `@Document(collection="personTwo")`
    annotation on the top of the `Person2` class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，存储库使用`Person2`类；但是使用的集合的名称是`personTwo`。这是可能的，因为我们在`Person2`类的顶部使用了`@Document(collection="personTwo")`注解。
- en: 'Getting back to the seven methods in the `com.packtpub.mongo.cookbook.PersonRepositoryTwo`
    repository class, let''s look at them one by one:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`com.packtpub.mongo.cookbook.PersonRepositoryTwo`存储库类中的七种方法，让我们逐一看看它们：
- en: '| Method | Description |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `findByAgeGreaterThanEqual` | This method will fire a query on the `personTwo`
    collection, `{''age'':{''$gte'':<age>}}`.The secret lies in the name of the method.
    If we break it up, what we have after `findBy` tells us what we want. The `age`
    property (with the first character in lowercase) is the field that would be queried
    on the document with the `$gte` operator because we have `GreaterThanEqual` in
    the name of the method. The value that would be used for the comparison would
    be the value of the parameter passed. The result is a collection of the `Person2`
    entities as we will have multiple matches. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `findByAgeGreaterThanEqual` | 这个方法将在`personTwo`集合上触发一个查询，`{''age'':{''$gte'':<age>}}`。秘密在于方法的名称。如果我们把它分开，`findBy`后面告诉我们我们想要什么。`age`属性（首字母小写）是将在具有`$gte`运算符的文档上查询的字段，因为方法的名称中有`GreaterThanEqual`。用于比较的值将是传递的参数的值。结果是`Person2`实体的集合，因为我们会有多个匹配项。
    |'
- en: '| `findByAgeBetween` | This method will again be queried on age but will be
    using a combination of `$gt` and `$lt` to find the matching result. The query,
    in this case, would be `{''age'' : {''$gt'' : from, ''$lt'' : to}}`. It is important
    to note that both the values from and to are exclusive in the range. There are
    two methods in the test case, `findByAgeBetween` and `findByAgeBetween2`. These
    methods demonstrate the behavior of the between query for different input values.
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `findByAgeBetween` | 这个方法将再次在年龄上进行查询，但将使用`$gt`和`$lt`的组合来找到匹配的结果。在这种情况下，查询将是`{''age''
    : {''$gt'' : from, ''$lt'' : to}}`。重要的是要注意from和to两个值在范围内都是排他的。测试用例中有两种方法，`findByAgeBetween`和`findByAgeBetween2`。这些方法展示了对不同输入值的between查询的行为。
    |'
- en: '| `findByAgeGreaterThan` | This method is a special method that also sorts
    the result because there are two parameters to the method: the first parameter
    is the value against which the age will be compared and the second parameter is
    the field of the `org.springframework.data.domain.So` `rt` type. For more details,
    refer to the Javadocs for spring-data-mongodb. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `findByAgeGreaterThan` | 这个方法是一个特殊的方法，它还会对结果进行排序，因为该方法有两个参数：第一个参数是年龄将要进行比较的值，第二个参数是`org.springframework.data.domain.Sort`类型的字段。有关更多详细信息，请参考spring-data-mongodb的Javadocs。
    |'
- en: '| `findPeopleByLastNameLike` | This method is used to find results by the last
    name matching a pattern. Regular expressions are used for the matching purpose.
    For instance, in this case, the query fired will be `{''lastName'' : <lastName
    as regex>}`. This method''s name begins with `findPeopleBy` instead of `findBy`,
    which works the same as `findBy`. Thus, when we say `findBy` in all the descriptions,
    we actually mean `find…By`.The value provided as the parameter will be used to
    match the last name. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `findPeopleByLastNameLike` | 这个方法用于通过匹配模式查找姓氏匹配的结果。用于匹配目的的是正则表达式。例如，在这种情况下，触发的查询将是`{''lastName''
    : <lastName as regex>}`。这个方法的名称以`findPeopleBy`开头，而不是`findBy`，它的工作方式与`findBy`相同。因此，当我们在所有描述中说`findBy`时，实际上是指`find…By`。提供的值作为参数将用于匹配姓氏。
    |'
- en: '| `findByResidentialAddressCountry` | This is an interesting method to look
    at. Here, we are searching by the country of the residential address. This is,
    in fact, a field in the `Address` class in the `residentialAddress` field of the
    person. Take a look at the document from the `personTwo` collection for how the
    query should be.When spring data finds the name as `ResidentialAddressCountry`,
    it will try to find various combinations using this string. For instance, it can
    look at the `residentialAddressCountry` field in the `Person` class or `residential.addressCountry`,
    `residentialAddress.country`, or `residential.address.country`. If there are no
    conflicting values as in our case the `residentialAddress`.The field ''country''
    is a part of the ''Person2'' document and thus that would be used in the query.However,
    if there are conflicts, then underscores can be used to clearly specify what we
    are looking at. In this case, the method can be renamed `findByResidentialAddress_country`
    to clearly specify what we expect as the result. The test case `findByCountry2`
    method demonstrates this. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `findByResidentialAddressCountry` | 这是一个有趣的方法。在这里，我们通过居住地址的国家进行搜索。实际上，这是`Person`类中`residentialAddress`字段中的`Address`类中的一个字段。查看`personTwo`集合中的文档，以了解查询应该是什么样子。当spring
    data找到名称为`ResidentialAddressCountry`时，它将尝试使用此字符串找到各种组合。例如，它可以查看`Person`类中的`residentialAddressCountry`字段，或者`residential.addressCountry`，`residentialAddress.country`或`residential.address.country`。如果没有冲突的值，如我们的情况下的`residentialAddress`。字段''country''是''Person2''文档的一部分，因此将在查询中使用。但是，如果存在冲突，则可以使用下划线来清楚地指定我们要查看的内容。在这种情况下，方法可以重命名为`findByResidentialAddress_country`，以清楚地指定我们期望的结果。测试用例`findByCountry2`方法演示了这一点。
    |'
- en: '| `findByFirstNameAndCountry` | This is an interesting method. We are not always
    able to use the method names to implement what we actually want to. The name of
    the method required for spring to automatically implement the query might be a
    bit awkward to use as is. For instance, `findByCountryOfResidence` sounds better
    than `findByResidentialAddressCountry`. However, we are stuck with the latter
    as that is how spring-data-mongodb would construct the query. Using `findByCountryOfResidence`
    gives no details on how to construct the query to spring data.There is a solution
    for this. You can choose to use the `@Query` annotation and specify the query
    to be executed when the method is invoked. The following is the annotation that
    we used:`@Query("{''firstName'':?0, ''residentialAddress.country'': ?1}")`We write
    the value as a query that would get executed and bind the parameters of the functions
    to the query as numbered parameters starting from zero. Thus, the first parameter
    of the method will be bound to `?0`, the second to `?1`, and so on. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `findByFirstNameAndCountry` | 这是一个有趣的方法。我们并不总是能够使用方法名来实现我们实际想要的功能。为了让spring自动实现查询，方法的名称可能会有点难以使用。例如，`findByCountryOfResidence`听起来比`findByResidentialAddressCountry`更好。然而，我们只能使用后者，因为这是spring-data-mongodb构造查询的方式。使用`findByCountryOfResidence`并没有提供如何构造查询给spring
    data的细节。但是，有一个解决方法。您可以选择使用`@Query`注解，并在方法调用时指定要执行的查询。以下是我们使用的注解：`@Query("{''firstName'':?0,
    ''residentialAddress.country'': ?1}")`我们将值写成一个将被执行并将函数的参数绑定到查询的查询，作为从零开始的编号参数。因此，方法的第一个参数将绑定到`?0`，第二个参数将绑定到`?1`，依此类推。
    |'
- en: We saw how the `findBy` or `getBy` methods are automatically translated to the
    queries for MongoDB. Similarly, we have the following prefixes for the methods.
    The `countBy` method returns the long number for the count for a given condition,
    which is derived from the rest of the method name similar to `findBy`. We can
    have `deleteBy` or `removeBy` to delete the documents by the derived condition.
    One thing to note about the `com.packtpub.mongo.cookbook.domain.Person2` class
    is that it does not have a no argument constructor or setter to set the values.
    Instead, spring will use reflection to instantiate this object.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了`findBy`或`getBy`方法如何自动转换为MongoDB的查询。同样，我们有以下方法的前缀。`countBy`方法返回给定条件的长数字，该条件是从方法名称的其余部分派生的，类似于`findBy`。我们可以使用`deleteBy`或`removeBy`来根据派生条件删除文档。关于`com.packtpub.mongo.cookbook.domain.Person2`类的一点需要注意的是，它没有无参数构造函数或设置器来设置值。相反，spring将使用反射来实例化此对象。
- en: A lot of the `findBy` methods are supported by spring-data-mongodb and all are
    not covered here. Refer to the spring-data-mongodb reference manual for more details.
    A lot of XML-based or Java-based configuration options are available and can be
    found in the reference manual. The URLs are given in the *See also* section later
    in this recipe.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: spring-data-mongodb支持许多`findBy`方法，这里并未涵盖所有。有关更多详细信息，请参阅spring-data-mongodb参考手册。参考手册中提供了许多基于XML或Java的配置选项。这些URL将在本食谱的*参见*部分中提供。
- en: We are not done yet; we have another test case, `com.packtpub.mongo.cookbook.MongoTemplateTest`,
    which uses `org.springframework.data.mongodb.core.MongoTemplate` to perform various
    operations. You can open the test case class and see what operations are performed
    and which methods of MongoTemplate are invoked.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成；我们还有另一个测试用例`com.packtpub.mongo.cookbook.MongoTemplateTest`，它使用`org.springframework.data.mongodb.core.MongoTemplate`执行各种操作。您可以打开测试用例类，看看执行了哪些操作以及调用了MongoTemplate的哪些方法。
- en: 'Let''s look at some of the important and frequently used methods of the MongoTemplate
    class:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看MongoTemplate类的一些重要和经常使用的方法：
- en: '| Method | Description |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `save` | This method is used to save (insert, if new; or else, update) an
    entity in MongoDB. The method takes one parameter, the entity, and finds the target
    collection based on its name or the `@Document` annotation present on it.There
    is an overloaded version of the save method that also accepts the second parameter,
    the name of the collection to which the data entity passed needs to be persisted.
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `save` | 该方法用于在MongoDB中保存（如果是新的则插入；否则更新）实体。该方法接受一个参数，即实体，并根据其名称或`@Document`注解找到目标集合。save方法有一个重载版本，还接受第二个参数，即需要将数据实体持久化到的集合的名称。
    |'
- en: '| `remove` | This method will be used to remove documents from the collection.
    It has some overloaded methods in this class. All of them accept either an entity
    to be deleted or the `org.springframework.data.mongodb.core.query.Query` instance,
    which is used to determine the document(s) to be deleted. The second parameter
    is the name of the collection from which the document has to be deleted. When
    an entity is provided, the name of the collection can be derived. With a `Query`
    instance provided, we have to give either the name of the collection or the entity
    class name, which, in turn, will be used to derive the name of the collection.
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `remove` | 这个方法用于从集合中删除文档。在这个类中有一些重载的方法。所有这些方法都接受要删除的实体或`org.springframework.data.mongodb.core.query.Query`实例，用于确定要删除的文档。第二个参数是要从中删除文档的集合的名称。当提供实体时，可以推导出集合的名称。如果提供了`Query`实例，我们必须给出集合的名称或实体类的名称，然后将用于推导集合的名称。'
- en: '| `updateMulti` | This is the function invoked to update multiple documents
    with one update call. The first parameter is the query that would be used to match
    the documents. The second parameter is the `org.springframework.data.mongodb.core.query.Updat`
    `e` instance. This is the update that would be executed on the documents selected
    using the first `Query` object. The next parameters are the entity class or collection
    name to execute the update on. Refer to the Javadocs for more details on the method
    and its various overloaded versions. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `updateMulti` | 这是用于一次更新多个文档的函数。第一个参数是用于匹配文档的查询。第二个参数是`org.springframework.data.mongodb.core.query.Updat`
    `e`实例。这是将在使用第一个`Query`对象选择的文档上执行的更新。下一个参数是实体类或集合名称，用于执行更新。有关该方法及其各种重载版本的更多详细信息，请参阅Javadocs。'
- en: '| `updateFirst` | It is the opposite of the `updateMulti` method. This operation
    will update just the first matching document. We have not covered this method
    in our unit test case. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `updateFirst` | 这是`updateMulti`方法的相反操作。此操作将仅更新第一个匹配的文档。我们在单元测试用例中没有涵盖这个方法。'
- en: '| `insert` | We mentioned that the save method can perform insertion and updates.
    The insert method in the template calls the `insert` method of the underlying
    mongo client. If one entity or document is to be inserted, there is no difference
    in calling the `insert` or `save` method.However, as we can see in the `insertMultiple`
    method in the test case, we created a list of three `Person` instances and passed
    them to the insert method. All the three documents for the three `Person` instances
    will go to the server as part of one call. The behavior on what happens whenever
    an insert fails is determined by the continue on error parameter of the Write
    Concern. It will determine whether the bulk insert fails at the first failure
    or continues even after errors while reporting the last error. The URL, [http://docs.mongodb.org/manual/core/bulk-inserts/](http://docs.mongodb.org/manual/core/bulk-inserts/),
    gives more details on bulk inserts and various write concern parameters that can
    alter the behavior. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `insert` | 我们提到save方法可以执行插入和更新。模板中的insert方法调用底层mongo客户端的insert方法。如果要插入一个实体或文档，调用insert或save方法没有区别。然而，如我们在测试用例中看到的insertMultiple方法，我们创建了一个包含三个`Person`实例的列表，并将它们传递给insert方法。三个`Person`实例的所有三个文档将作为一个调用的一部分发送到服务器。无论何时插入失败的行为是由Write
    Concern的continue on error参数确定的。它将确定批量插入在第一次失败时是否失败，或者即使在报告最后一个错误时也会继续。URL [http://docs.mongodb.org/manual/core/bulk-inserts/](http://docs.mongodb.org/manual/core/bulk-inserts/)
    提供了有关批量插入和各种写关注参数的更多详细信息，可以改变行为。'
- en: '| `findAndRemove`/`findAllAndRemove` | Both these operations are used to find
    and then remove the document(s). The first one finds one and then returns the
    deleted document. This operation is atomic. The latter, however, finds all the
    documents and removes them before returning the list of all the entities of all
    the documents deleted. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `findAndRemove`/`findAllAndRemove` | 这两个操作都用于查找然后删除文档。第一个找到一个文档，然后返回被删除的文档。这个操作是原子的。然而，后者在返回所有被删除文档的实体列表之前找到并删除所有文档。'
- en: '| `findAndModify` | This method is functionally similar to `findAndModify`
    that we have with the mongo client library. It will atomically find and modify
    the document. If the query matches more than one document, only the first match
    will be updated. The first two parameters of this method are the query and update
    to execute. The next few parameters are either the entity class or collection
    name to execute the operation on. Additionally, there is a special `org.springframework.data.mongodb.core.FindAndModifyOptions`
    class, which makes sense only for the `findAndModify` operation. This instance
    tells us whether we are looking for the new instance or old instance after the
    operation is performed and whether upsert is to be performed. It is relevant only
    if the document with the matching query doesn''t exist. There is an additional
    Boolean flag to tell the client whether this is a `findAndRemove` operation. In
    fact, the `findAndRemove` operation that we saw earlier is just a convenient function
    that delegates `findAndModify` with this remove flag set. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `findAndModify` | 这个方法在功能上类似于我们在mongo客户端库中拥有的`findAndModify`。它将原子地查找并修改文档。如果查询匹配多个文档，只有第一个匹配项将被更新。该方法的前两个参数是要执行的查询和更新。接下来的几个参数是要在其上执行操作的实体类或集合名称。此外，还有一个特殊的`org.springframework.data.mongodb.core.FindAndModifyOptions`类，它只对`findAndModify`操作有意义。这个实例告诉我们在操作执行后是否要查找新实例或旧实例，以及是否要执行upsert。只有在不存在与匹配查询的文档时才相关。还有一个额外的布尔标志，告诉客户端这是否是一个`findAndRemove`操作。实际上，我们之前看到的`findAndRemove`操作只是一个方便的函数，它使用了这个删除标志来委托`findAndModify`。|'
- en: 'In the preceding table, we mentioned the `Query` and `Update` classes when
    talking about update. These are special convenient classes in spring-data-mongodb,
    which let us build MongoDB queries using a syntax that is easy to understand with
    improved readability. For instance, the query to check whether `lastName` is `Johnson`
    in mongo is `{''lastName'':''Johnson''}`. The same query can be constructed in
    spring-data-mongodb as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表中，当谈到更新时，我们提到了`Query`和`Update`类。这些是spring-data-mongodb中的特殊便捷类，它们让我们使用易于理解且具有改进可读性的语法构建MongoDB查询。例如，在mongo中检查`lastName`是否为`Johnson`的查询是`{'lastName':'Johnson'}`。在spring-data-mongodb中，可以按照以下方式构建相同的查询：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This syntax looks neat compared to giving the query in JSON. Let''s take another
    example where we want to find all the females under 30 years in our database.
    The query would now be built as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与以JSON形式给出查询相比，这种语法看起来更整洁。让我们举另一个例子，我们想要在我们的数据库中找到所有30岁以下的女性。现在查询将构建如下：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Similarly, for update, we want to set a Boolean flag, `youngCustomer`, to `true`
    for some of the customers based on some conditions. To set this flag in the document,
    the MongoDB format would be as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于更新，我们希望根据一些条件为一些客户设置一个布尔标志`youngCustomer`为`true`。要在文档中设置此标志，MongoDB格式如下：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In spring-data-mongodb, this would be achieved in the following way:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在spring-data-mongodb中，可以通过以下方式实现：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Refer to the Javadocs for all the possible methods that are available to build
    the query and updates in spring-data-mongodb to be used with `MongoTemplate`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考Javadocs，了解在spring-data-mongodb中可用于构建查询和更新的所有可能方法。
- en: These methods are by no means the only ones available in the `MongoTemplate`
    class. There are a lot of other methods for geospatial indexes, convenient methods
    to get the count of the documents in a collection, aggregation and MapReduce support,
    and so on. Refer to the Javadocs of `MongoTemplate` for more details and methods.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法绝不是`MongoTemplate`类中唯一可用的方法。还有许多其他方法用于地理空间索引、获取集合中文档数量的便捷方法、聚合和MapReduce支持等。有关更多详细信息和方法，请参考`MongoTemplate`的Javadocs。
- en: 'Speaking of aggregation, we also have a test case `aggregationTest` method
    to perform the aggregation operation on the collection. We have a `postalCodes`
    collection in MongoDB that contains the postal code details of various cities.
    An example document in the collection is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 说到聚合，我们还有一个名为`aggregationTest`的测试用例方法，用于对集合执行聚合操作。我们在MongoDB中有一个`postalCodes`集合，其中包含各个城市的邮政编码详细信息。集合中的一个示例文档如下：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our aggregation operation intends to find the top five states by the number
    of documents in the collection. In mongo, the aggregation pipeline would look
    as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聚合操作意图是找到集合中文档数量前五名的州。在mongo中，聚合管道如下所示：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In spring-data-mongodb, we invoked the aggregation operation using `MongoTemplate`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在spring-data-mongodb中，我们使用`MongoTemplate`调用了聚合操作：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The key is in creating the instance of the `org.springframework.data.mongodb.core.aggregation.Aggregation`
    class. The `newAggregation` method is statically imported from the same class
    and accepts `varargs` for different instances of the `org.springframework.data.mongodb.core.aggregation.AggregationOperation`
    instances corresponding to the one operation in the chain. The `Aggregation` class
    has various static methods to create the instances of `AggregationOperation`.
    We have used a few of them such as `project`, `group`, `sort`, and `limit`. Refer
    to the Javadocs for more details and available methods. The `aggregate` method
    in `MongoTemplate` takes three arguments. The first one is the instance of the
    `Aggregation` class, the second one is the name of the collection, and the third
    one is the return type of the aggregation result. Refer to the aggregation operation
    test case for more details.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于创建`org.springframework.data.mongodb.core.aggregation.Aggregation`类的实例。`newAggregation`方法是从同一类中静态导入的，并接受`varargs`，用于不同的`org.springframework.data.mongodb.core.aggregation.AggregationOperation`实例，对应于链中的一个操作。`Aggregation`类有各种静态方法来创建`AggregationOperation`的实例。我们使用了其中一些，比如`project`、`group`、`sort`和`limit`。有关更多详细信息和可用方法，请参考Javadocs。`MongoTemplate`中的`aggregate`方法接受三个参数。第一个是`Aggregation`类的实例，第二个是集合的名称，第三个是聚合结果的返回类型。有关更多详细信息，请参考聚合操作测试用例。
- en: See also
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Refer to the Javadocs at [http://docs.spring.io/spring-data/mongodb/docs/current/api/](http://docs.spring.io/spring-data/mongodb/docs/current/api/)
    for more details and API documentation
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关更多详细信息和API文档，请参考[http://docs.spring.io/spring-data/mongodb/docs/current/api/](http://docs.spring.io/spring-data/mongodb/docs/current/api/)的Javadocs。
- en: The reference manual for the spring-data-mongodb project can be found at [http://docs.spring.io/spring-data/data-mongodb/docs/current/reference/](http://docs.spring.io/spring-data/data-mongodb/docs/current/reference/)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: spring-data-mongodb项目的参考手册可以在[http://docs.spring.io/spring-data/data-mongodb/docs/current/reference/](http://docs.spring.io/spring-data/data-mongodb/docs/current/reference/)找到
- en: Accessing MongoDB using JPA
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JPA访问MongoDB
- en: In this recipe, we will use a JPA provider that allows us to use JPA entities
    to achieve object-to-document mapping with MongoDB.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用一个JPA提供程序，它允许我们使用JPA实体来实现与MongoDB的对象到文档映射。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Start the standalone server instance listening to port `27017`. This is a Java
    project using JPA. Familiarity with JPA and its annotations is expected, though
    what we will be looking at is fairly basic. Refer to the *Connecting to the single
    node using a Java client* recipe in [Chapter 1](ch01.html "Chapter 1. Installing
    and Starting the Server"), *Installing and Starting the Server*, to see how to
    set up maven if you are not aware of it. Download the `DataNucleusMongoJPA` project
    from the bundle provided with this book. Though we will be executing the test
    cases from the command prompt, you can import the project to your favorite IDE
    to view the source code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 启动独立的服务器实例，监听端口`27017`。这是一个使用JPA的Java项目。我们期望熟悉JPA及其注解，尽管我们将要查看的内容相当基础。如果您不熟悉maven，可以参考[第1章](ch01.html
    "第1章 安装和启动服务器")中的*使用Java客户端连接单节点*部分来设置maven。从提供的捆绑包中下载`DataNucleusMongoJPA`项目。虽然我们将从命令提示符中执行测试用例，但您也可以将项目导入到您喜欢的IDE中查看源代码。
- en: How to do it…
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Go to the root directory of the `DataNucleusMongoJPA` project and execute the
    following in the shell:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`DataNucleusMongoJPA`项目的根目录，并在shell中执行以下操作：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This should download the necessary artifacts needed to build and run the project
    and execute the test cases successfully.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该会下载构建和运行项目所需的必要工件，并成功执行测试用例。
- en: Once the test cases get executed, open a mongo shell and connect to the local
    instance.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦测试用例执行完毕，打开mongo shell并连接到本地实例。
- en: 'Execute the following query in the shell:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在shell中执行以下查询：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works…
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'First, let''s look at a sample document that was created in the `personJPA`
    collection:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下在`personJPA`集合中创建的示例文档：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The steps that we executed are pretty simple; let''s look at the classes that
    are used one by one. We start with the `com.packtpub.mongo.cookbook.domain.Person`
    class. On the top of the class (after the package and imports), we have the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行的步骤非常简单；让我们逐个查看使用的类。我们从`com.packtpub.mongo.cookbook.domain.Person`类开始。在类的顶部（包和导入之后），我们有以下内容：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This denotes that the `Person` class is an entity and the collection to which
    it would persist is `personJPA`. Note that JPA was designed primarily as an **Object
    Relational Mapping** (**ORM**) tool and, so, the terminologies used are more for
    a relational database. A table in RDBMS is synonymous to a collection in MongoDB.
    The rest of the class contains the attributes of person and the columns annotated
    with `@Column` and `@Id` for a primary key. These are simple JPA annotations.
    What is interesting to look at is the `com.packtpub.mongo.cookbook.domain.ResidentialAddress`
    class, which is stored as a `residentialAddress` variable in the `Person` class.
    If we look at the person document that we gave earlier, all the values given in
    the `@Column` annotation are the names of the keys for person; also notice how
    `Enum` gets converted to a string value as well. The `residentialAddress` field
    is the name of the variable in the `Person` class against which the address instance
    is stored. If we look at the `ResidentialAddress` class, we can see the `@Embeddable`
    annotation at the top above the class name. This is again a JPA annotation that
    denotes that this instance is not an entity itself, but is embedded in another
    `Entity` or `Embeddable` class. Note the names of the fields in the document;
    in this case, they have the following format: `<name of the variable in person
    class>_<value of the variable name in ResidentialAddress class>`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示`Person`类是一个实体，它将持久化到`personJPA`集合中。请注意，JPA主要设计为**对象关系映射**（**ORM**）工具，因此使用的术语更多地是针对关系数据库。在RDBMS中，表与MongoDB中的集合是同义词。类的其余部分包含了人的属性，以及用`@Column`和`@Id`注释的列作为主键。这些都是简单的JPA注释。有趣的是看一下`com.packtpub.mongo.cookbook.domain.ResidentialAddress`类，它存储为`Person`类中的`residentialAddress`变量。如果我们看一下之前给出的人员文档，`@Column`注释中给出的所有值都是人员键的名称；还要注意`Enum`如何转换为字符串值。`residentialAddress`字段是`Person`类中的变量名，存储地址实例。如果我们看`ResidentialAddress`类，我们可以看到类名上方的`@Embeddable`注解。这再次是一个JPA注解，表示这个实例本身不是一个实体，而是嵌入在另一个`Entity`或`Embeddable`类中。请注意文档中字段的名称；在这种情况下，它们的格式如下：`<person类中的变量名>_<ResidentialAddress类中的变量名的值>`。
- en: 'There is one problem here. The names of the fields are too long, consuming
    unnecessary space. The solution is to have a shorter value in the `@Column` annotation.
    For instance, the `@Column(name="ln")` annotation instead of `@Column(name="lastName")`,
    will create the key with a `ln` name in the document. Unfortunately, this doesn''t
    work with the embedded `ResidentialAddress` class; in which case, you will have
    to deal with shorter variable names. Now that we have seen the entity classes,
    let''s see `persistence.xml`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个问题。字段的名称太长，占用了不必要的空间。解决方案是在`@Column`注解中使用较短的值。例如，`@Column(name="ln")`注解代替`@Column(name="lastName")`，将在文档中创建一个名为`ln`的键。不幸的是，这在嵌入的`ResidentialAddress`类中不起作用；在这种情况下，您将不得不处理较短的变量名。现在我们已经看到了实体类，让我们看看`persistence.xml`：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have got just the persistence-unit definition here with the name as `DataNucleusMongo`.
    There is one class node that is the entity that we will use. Note that the embedded
    address class is not mentioned here as it is not an independent entity. In the
    properties, we mentioned the URL of the data store to connect to. In this case,
    we connect to the instance on localhost, port `27017`, and database test.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只有一个名为`DataNucleusMongo`的持久性单元定义。有一个类节点，即我们将使用的实体。请注意，嵌入式地址类在这里没有提到，因为它不是一个独立的实体。在属性中，我们提到了要连接的数据存储的URL。在这种情况下，我们连接到本地主机上的实例，端口`27017`，数据库为test。
- en: Now, let's look at the class that queries and inserts the data. This is our
    `com.packtpub.mongo.cookbook.DataNucleusJPATest` test class. We create `javax.persistence.EntityManagerFactory`
    as `Persistence.createEntityManagerFactory("DataNucleusMongo")`. This is a thread-safe
    class and its instance is shared across threads; the string argument is also the
    same as the name of the persistence unit that we used in `persistence.xml`. All
    the other invocations on `javax.persistence.EntityManager` to persist or query
    the collection require us to create an instance using `EntityManagerFactory`—use
    it and then close it once the operation is completed. All the operations performed
    are as per the JPA specifications. The test case class persists entities and also
    queries them.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下查询和插入数据的类。这是我们的`com.packtpub.mongo.cookbook.DataNucleusJPATest`测试类。我们创建`javax.persistence.EntityManagerFactory`作为`Persistence.createEntityManagerFactory("DataNucleusMongo")`。这是一个线程安全的类，其实例在线程之间共享；字符串参数也与我们在`persistence.xml`中使用的持久化单元的名称相同。对`javax.persistence.EntityManager`的所有其他调用，以持久化或查询集合，都要求我们使用`EntityManagerFactory`创建一个实例——使用它，然后在操作完成后关闭它。所有执行的操作都符合JPA规范。测试用例类持久化实体并查询它们。
- en: 'Finally, we look at `pom.xml`, particularly the enhancer plugin that we used,
    which is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一下`pom.xml`，特别是我们使用的增强器插件，如下所示：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The entities that we have written need to be enhanced in order to be used as
    JPA entities using data nucleus. The preceding plugin will be attached to the
    process-class phase and then call the plugin's enhance.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的实体需要增强才能作为JPA实体使用数据核。前面的插件将附加到process-class阶段，然后调用插件的增强。
- en: See also
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: There are various ways to enhance JPA entities using a data nucleus enhancer.
    Refer to [http://www.datanucleus.org/products/datanucleus/jdo/enhancer.html](http://www.datanucleus.org/products/datanucleus/jdo/enhancer.html)
    for possible options. There is even a plugin for Eclipse to allow entity classes
    to be enhanced/instrumented for data nucleus.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多种方法可以使用数据核增强器增强JPA实体。请参考[http://www.datanucleus.org/products/datanucleus/jdo/enhancer.html](http://www.datanucleus.org/products/datanucleus/jdo/enhancer.html)以获取可能的选项。甚至有一个Eclipse插件，允许实体类被增强/仪器化以供数据核使用。
- en: The JPA 2.1 specification can be found at [https://www.jcp.org/aboutJava/communityprocess/final/jsr338/index.html](https://www.jcp.org/aboutJava/communityprocess/final/jsr338/index.html).
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JPA 2.1规范可以在[https://www.jcp.org/aboutJava/communityprocess/final/jsr338/index.html](https://www.jcp.org/aboutJava/communityprocess/final/jsr338/index.html)找到。
- en: Accessing MongoDB over REST
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过REST访问MongoDB
- en: In this recipe, we will see how to access MongoDB and perform CRUD operations
    using REST APIs. We will use spring-data-rest for REST access and spring-data-mongodb
    to perform the CRUD operations. Before you continue with this recipe, it is important
    to know how to implement the CRUD repositories using spring-data-mongodb. Refer
    to the *Developing using spring-data-mongodb* recipe in this chapter to know how
    to use this framework.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何使用REST API访问MongoDB并执行CRUD操作。我们将使用spring-data-rest进行REST访问，使用spring-data-mongodb执行CRUD操作。在继续进行这个示例之前，重要的是要知道如何使用spring-data-mongodb实现CRUD存储库。请参考本章中的*使用spring-data-mongodb进行开发*示例，了解如何使用这个框架。
- en: The question one must be having is, why is a REST API needed? There are scenarios
    where there is a database that is being shared by many applications and is possibly
    written in different languages. Writing JPA DAO or using spring-data-mongodb is
    good enough for Java clients but not for clients in other languages. Having APIs
    locally with the application doesn't even give us a centralized way to access
    the database. This is where REST APIs come into play. We can develop the server-side
    data access layer and the CRUD repository in Java—spring-data-mongodb to be precise—and
    then expose it over a REST interface for a client written in any language to invoke
    them. We not only invoke our API in a platform-independent way, but also provide
    a single point of entry into our database.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个人必须要问的问题是，为什么需要REST API？有些情况下，有一个数据库被许多应用程序共享，并且可能是用不同的语言编写的。编写JPA DAO或使用spring-data-mongodb对于Java客户端来说已经足够好了，但对于其他语言的客户端来说就不够了。在应用程序本地拥有API甚至不能给我们一个集中访问数据库的方式。这就是REST
    API发挥作用的地方。我们可以在Java中开发服务器端数据访问层和CRUD存储库——具体来说是spring-data-mongodb，然后通过REST接口将其暴露给任何语言编写的客户端来调用它们。我们不仅以平台无关的方式调用我们的API，还提供了一个进入我们数据库的单一入口。
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Apart from the prerequisites of the spring-data-mongodb recipe, we have a few
    more requirements for this recipe. The first thing is to download the `SpringDataRestTest`
    project from the Packt website and import it to your IDE as a maven project. Alternatively,
    if you do not wish to import to the IDE, you can run the server servicing the
    requests from the command prompt, which we will see in the next section. There
    is no specific client application used to perform the CRUD operations over REST.
    I will be demonstrating the concepts using the Chrome browser and a special plugin
    of the Advanced REST Client browser to send HTTP POST requests to the server.
    The tools can be found under the **Developer Tools** section of the Chrome web
    store.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 除了spring-data-mongodb示例的先决条件之外，这个示例还有一些其他要求。首先是从Packt网站下载`SpringDataRestTest`项目，并将其作为maven项目导入到您的IDE中。或者，如果您不希望导入到IDE中，您可以从命令提示符中运行服务请求，我们将在下一节中看到。没有特定的客户端应用程序用于通过REST执行CRUD操作。我将使用Chrome浏览器和Advanced
    REST Client浏览器的特殊插件来演示这些概念，以向服务器发送HTTP POST请求。这些工具可以在Chrome网络商店的**开发者工具**部分找到。
- en: How to do it…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: If you have imported the project in your IDE as a maven project, execute the
    `com.packtpub.mongo.cookbook.rest.RestServer` class, which is the bootstrap class
    and starts the server locally that would accept client connections.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您已将项目作为maven项目导入IDE，请执行`com.packtpub.mongo.cookbook.rest.RestServer`类，这是引导类，启动本地服务器，接受客户端连接。
- en: 'If the project is to be executed from the command prompt as a maven project,
    go to the root directory of the project and run the following:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果要从命令提示符中作为maven项目执行该项目，转到项目的根目录并运行以下命令：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following line on the command will be seen on the command prompt if all
    goes well and the server has been started:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，服务器已经启动，命令提示符上将看到以下行：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After starting the server in either way, enter `http://localhost:8080/people`
    in the browser's address bar and we should see the following JSON response. This
    response is seen because the underlying person collection is empty.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论以何种方式启动服务器，都在浏览器的地址栏中输入`http://localhost:8080/people`，我们应该看到以下JSON响应。因为底层的人员集合是空的，所以会看到这个响应。
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will now insert a new document in the person collection using an HTTP POST
    request to `http://localhost:8080/people`. We will be sending a POST request to
    the server using the Advanced REST Client Chrome extension. The document posted
    is:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将使用HTTP POST请求将一个新文档插入到人员集合中，请求将被发送到`http://localhost:8080/people`。我们将使用Chrome浏览器的Advanced
    REST Client扩展来向服务器发送POST请求。发送的文档是：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The request's content type is `application`/`json`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的内容类型是`application/json`。
- en: 'The following image shows the POST request sent to the server and the response
    from the server:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了发送到服务器的POST请求和服务器的响应：
- en: '![How to do it…](img/B04831_09_01.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤…](img/B04831_09_01.jpg)'
- en: We will now query this document from the browser using the `_id` field, which
    is `1` in this case. Enter `http://localhost:8080/people/1` in the browser's address
    bar. You should see the document that we inserted in step 3.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用浏览器中的`_id`字段来查询这个文档，这个字段在这种情况下是`1`。在浏览器的地址栏中输入`http://localhost:8080/people/1`。您应该看到我们在步骤3中插入的文档。
- en: 'Now that we have one document in the collection, (you can try to insert more
    documents for people with different names and, more importantly, a unique ID.)
    we will query the document using the last name. First, type the following URL
    in the browser''s address bar to view the entire search options available: `http://localhost:8080/people/search`.
    We should see one `search` method, `findByLastName`, that accepts a command line
    parameter, `lastName`.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们在集合中有一个文档了（您可以尝试为具有不同名称和更重要的是唯一ID的人插入更多文档），我们将使用姓氏查询文档。首先，在浏览器的地址栏中输入以下URL以查看所有可用的搜索选项：`http://localhost:8080/people/search`。我们应该看到一个`search`方法，`findByLastName`，它接受一个命令行参数`lastName`。
- en: 'To search by the last name, Cruise in our case, enter the following URL in
    the browser''s address bar: `http://localhost:8080/people/search/findByLastName?lastName=Cruise`.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要按姓氏搜索，我们的情况下是Cruise，可以在浏览器的地址栏中输入以下URL：`http://localhost:8080/people/search/findByLastName?lastName=Cruise`。
- en: We will now update the last name and age of the person with the ID `1`, Tom
    Cruise for now. Let's update the last name to Hanks and the age to `58`. To do
    this, we will be using the HTTP PATCH request and the request will be sent to
    `http://localhost:8080/people/1`, which uniquely identifies the document to update.
    The body of the HTTP PATCH request is `{"lastName":"Hanks", "age":58}`. Refer
    to the following image for the request that we sent out for an update:![How to
    do it…](img/B04831_09_02.jpg)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将更新ID为`1`的人的姓氏和年龄，目前是汤姆·克鲁斯。让我们把姓氏更新为汉克斯，年龄更新为`58`。为此，我们将使用HTTP PATCH请求，并且请求将被发送到`http://localhost:8080/people/1`，这个地址唯一标识了要更新的文档。HTTP
    PATCH请求的主体是`{"lastName":"Hanks", "age":58}`。参考以下图片，查看我们发送的更新请求：![操作步骤…](img/B04831_09_02.jpg)
- en: To validate whether our update went through successfully or not (we know it
    did as we got a response status 204 after the PATCH request), enter `http://localhost:8080/people/1`
    again in the browser's address bar.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证我们的更新是否成功（我们知道它成功了，因为在PATCH请求之后我们得到了一个响应状态204），再次在浏览器的地址栏中输入`http://localhost:8080/people/1`。
- en: Finally, we delete the document. This is straightforward, and we simply send
    a DELETE request to `http://localhost:8080/people/1`. Once the DELETE request
    is successful, send an HTTP GET request from the browser to `http://localhost:8080/people/1`
    and we should not get any document in return.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们删除文档。这很简单，我们只需向`http://localhost:8080/people/1`发送一个DELETE请求。一旦DELETE请求成功，从浏览器向`http://localhost:8080/people/1`发送一个HTTP
    GET请求，我们不应该得到任何文档作为返回。
- en: How it works…
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'We will not be reiterating the spring-data-mongodb concepts again in this recipe,
    but will look at some of the annotations that we added specifically for the REST
    interface to the repository class. The first one is on the top of the class name,
    as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这个教程中再次重复spring-data-mongodb的概念，而是将看一些我们专门为REST接口添加的注释。第一个是在类名的顶部，如下所示：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is used to instruct the server that this CRUD repository can be accessed
    using the people resource. This is the reason why we always make HTTP GET and
    POST requests on `http://localhost:8080/people/`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于指示服务器可以使用people资源访问此CRUD存储库。这就是为什么我们总是在`http://localhost:8080/people/`上进行HTTP
    GET和POST请求的原因。
- en: 'The second annotation is in the `findByLastName` method. We have the following
    method signature:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个注释在`findByLastName`方法中。我们有以下方法签名：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, the method's `lastName` parameter is annotated with the `@Param` annotation,
    which is used to annotate the name of the parameter that will have the value of
    the `lastName` parameter that will be passed while invoking this method on the
    repository. If we look at step 6 in the previous section, we can see that `findByLastName`
    is invoked using an HTTP GET request, and the value of the URL `lastName` parameter
    is used as the string value passed while invoking the repository method.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，方法的`lastName`参数使用了`@Param`注释，用于注释将在调用存储库上的此方法时传递的`lastName`参数的参数名称。如果我们看一下上一节的第6步，我们可以看到使用HTTP
    GET请求调用了`findByLastName`，并且URL的`lastName`参数的值被用作在调用存储库方法时传递的字符串值。
- en: Our example here is pretty simple with just one parameter used for the search
    operation. We can have multiple parameters for the repository method and an equal
    number of parameters in the HTTP request that will be mapped to these parameters
    for the method to be invoked on the CRUD repository. For some types, such as dates
    to be sent out, use the `@DateTimeFormat` annotation, which will be used to specify
    the date and time format. Refer to the spring Javadocs at [http://docs.spring.io/spring/docs/current/javadoc-api/](http://docs.spring.io/spring/docs/current/javadoc-api/)
    for more information on this annotation and its usage.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例非常简单，只使用一个参数进行搜索操作。我们可以为存储库方法使用多个参数，并在HTTP请求中使用相同数量的参数，这些参数将映射到存储库上的方法，以便调用CRUD存储库。对于某些类型，例如要发送的日期，请使用`@DateTimeFormat`注释，该注释将用于指定日期和时间格式。有关此注释及其用法的更多信息，请参阅spring
    Javadocs [http://docs.spring.io/spring/docs/current/javadoc-api/](http://docs.spring.io/spring/docs/current/javadoc-api/)
- en: This was all about the GET request that we made to the REST interface to query
    and search data. We initially created a document data sending an HTTP POST request
    to the server. To create new documents, we would always be sending a POST request—with
    the document to be created as the body of the request—to the URL identifying the
    REST endpoint, in our case, `http://localhost:8080/people/`. All documents posted
    to this collection would be making use of `PersonRepository` to persist `Person`
    in the corresponding collection.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们向REST接口发出的GET请求，以查询和搜索数据。我们最初通过向服务器发送HTTP POST请求来创建文档数据。要创建新文档，我们将始终发送POST请求，将要创建的文档作为请求的主体发送到标识REST端点的URL，即`http://localhost:8080/people/`。发送到此集合的所有文档都将使用`PersonRepository`来持久化`Person`在相应的集合中。
- en: Our final two steps were to update person and delete person. The HTTP request
    types to perform these operations are PATCH and DELETE, respectively. In step
    7, we updated the document for the person Tom Cruise and updated his last name
    and age. To achieve this, our PATCH request is sent to a URL identifying a specific
    person instance, which is `http://localhost:8080/people/1`. Note that in case
    of creating a new person, our POST request was always sent to `http://localhost:8080/people`,
    as against the PATCH and DELETE requests, where we sent the HTTP request to a
    URL representing the specific person that we want to update or delete. In the
    case of update, the body of the PATCH request is JSON whose provided fields would
    replace the corresponding fields in the target document to update. All the other
    fields would be left as is. In our case, `lastName` and the age of the target
    document were updated and `firstName` was left untouched. In case of delete, the
    message body was not empty, and the DELETE request itself indicates that the target
    to which the request was sent should be deleted.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后两个步骤是更新人员和删除人员。执行这些操作的HTTP请求类型分别为PATCH和DELETE。在第7步中，我们更新了人员Tom Cruise的文档，并更新了他的姓和年龄。为了实现这一点，我们的PATCH请求被发送到标识特定人员实例的URL，即`http://localhost:8080/people/1`。请注意，在创建新人员的情况下，我们的POST请求总是发送到`http://localhost:8080/people`，而不是发送到PATCH和DELETE请求，其中我们将HTTP请求发送到表示要更新或删除的特定人员的URL。在更新的情况下，PATCH请求的主体是JSON，其提供的字段将替换目标文档中的相应字段以进行更新。所有其他字段将保持不变。在我们的情况下，目标文档的`lastName`和年龄被更新，而`firstName`保持不变。在删除的情况下，消息主体不为空，并且DELETE请求本身指示应删除发送请求的目标。
- en: You can also send a PUT request instead of PATCH to a URL, identifying a specific
    person; in which case, the entire document in the collection would get updated
    or replaced with the document provided as part of the PUT request.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以发送PUT请求，而不是PATCH请求到标识特定人员的URL；在这种情况下，集合中的整个文档将被更新或替换为作为PUT请求的一部分提供的文档。
- en: See also
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The spring-data-rest home is at [http://projects.spring.io/spring-data-rest/](http://projects.spring.io/spring-data-rest/),
    where you can find links to its Git repository, reference manual, and Javadocs
    URL.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: spring-data-rest的主页位于[http://projects.spring.io/spring-data-rest/](http://projects.spring.io/spring-data-rest/)，您可以在那里找到其Git存储库、参考手册和Javadocs
    URL的链接。
- en: Installing a GUI-based client, MongoVUE, for MongoDB
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装基于GUI的MongoDB客户端MongoVUE
- en: 'In this recipe, we will look at a GUI-based client for MongoDB. Throughout
    the book, we have used the mongo shell to perform various operations that we need.
    Its advantages are as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到一个基于GUI的MongoDB客户端。在整本书中，我们一直使用mongo shell来执行我们需要的各种操作。它的优点如下：
- en: It comes packaged with the MongoDB installation
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与MongoDB安装一起打包
- en: Being lightweight, you don't need to worry about it taking up your system's
    resources
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于轻量级，您不必担心它占用系统资源
- en: On servers where GUI-based interfaces are not present, shell is the only option
    to connect, query, and administer the server instance
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有基于GUI的界面的服务器上，shell是连接、查询和管理服务器实例的唯一选项
- en: Having said this, if you are not on a server and want to connect to a database
    instance to query, view the plan of a query, administer, and so on, it is nice
    to have a GUI with these features to let you do things in the click of a button.
    As a developer, we always query our relational database with a GUI-based thick
    client, so why not for MongoDB?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，如果您不在服务器上并且想要连接到数据库实例进行查询、查看查询计划、管理等操作，最好有一个具有这些功能的GUI，让您可以轻松完成任务。作为开发人员，我们总是使用基于GUI的厚客户端查询我们的关系数据库，那么为什么不为MongoDB呢？
- en: In this recipe, we will see how to install some features of a MongoDB client,
    MongoVUE. This client is available only for Windows machines. This product has
    both a paid version (with various levels of licensing per number of users) and
    free version that has some limitations. For this recipe, we'll be looking at the
    free version.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何安装MongoDB客户端MongoVUE的一些功能。该客户端仅适用于Windows机器。该产品既有付费版本（根据用户数量的不同级别进行许可），也有一些限制的免费版本。在这个示例中，我们将看看免费版本。
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, the following steps are necessary:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，以下步骤是必要的：
- en: Start a single instance of MongoDB server. The port on which the connections
    are accepted will be the default one, `27017`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动MongoDB服务器的单个实例。接受连接的端口将是默认端口`27017`。
- en: 'Import the following two collections from the command prompt after the mongod
    server has started:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在mongod服务器启动后，从命令提示符导入以下两个集合：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How to do it…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Download the installer ZIP for the MongoVUE from [http://www.mongovue.com/downloads/](http://www.mongovue.com/downloads/).
    Once downloaded, it is a matter of a few clicks and the software gets installed.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://www.mongovue.com/downloads/](http://www.mongovue.com/downloads/)下载MongoVUE的安装程序ZIP。下载后，只需点击几下，软件就会安装好。
- en: Open the installed application; as this is a free version, we will have all
    the features available for the first 14 days, after which, some of the features
    will not be available. The details of this can be seen at [http://www.mongovue.com/purchase/](http://www.mongovue.com/purchase/).
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开安装的应用程序；由于这是免费版本，在前14天内我们将拥有所有功能，之后，一些功能将不可用。详情请参见[http://www.mongovue.com/purchase/](http://www.mongovue.com/purchase/)。
- en: 'The first thing that we will do is add a database connection:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是添加数据库连接：
- en: Once the following window has opened, click on the (**+**) button to add a new
    connection:![How to do it…](img/B04831_09_03.jpg)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦打开以下窗口，点击（**+**）按钮添加新连接：![如何操作...](img/B04831_09_03.jpg)
- en: Once opened, we will get another window in which we will fill in the server
    connection details. Fill in the following details in the new window and click
    on **Test**. This should succeed if the connection works; finally, click on **Save**.![How
    to do it…](img/B04831_09_04.jpg)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开后，我们将得到另一个窗口，在其中填写服务器连接详细信息。在新窗口中填写以下详细信息，然后单击**测试**。如果连接正常，这应该成功；最后，单击**保存**。![如何操作...](img/B04831_09_04.jpg)
- en: Once added, connect to the instance.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加后，连接到实例。
- en: In the left navigation panel, we will see the instances added and the databases
    in them, as shown in the following image:![How to do it…](img/B04831_09_05.jpg)
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧导航面板中，我们将看到添加的实例和其中的数据库，如下图所示：![如何操作...](img/B04831_09_05.jpg)
- en: As we can see in the preceding image, hovering the mouse over the name of the
    collection shows us the size and count of the documents in the collection.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上图中所看到的，将鼠标悬停在集合名称上会显示集合中的文档大小和计数。
- en: Let's see how to query a collection and get all the documents. We will use the
    `postalCodes` collection for our `test`. Right-click on the collection name, and
    click on **View**. We will see the contents of the collection shown as either
    a Tree View, where we can expand and see the contents, Table View, which shows
    the contents in a tabular grid, and Text View, which shows the contents as normal
    JSON text.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看如何查询一个集合并获取所有文档。我们将使用`test`中的`postalCodes`集合。右键单击集合名称，然后单击**查看**。我们将看到集合的内容显示为树形视图，我们可以展开并查看内容，表格视图，以表格网格显示内容，以及文本视图，以普通JSON文本显示内容。
- en: 'Let''s see what happens when we query a collection with nested documents; `personTwo`
    is a collection with the following sample document in it:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看当我们查询具有嵌套文档的集合时会发生什么；`personTwo`是一个具有以下示例文档的集合：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When we query to see all the documents in the collection, we see the following
    image:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查询以查看集合中的所有文档时，我们会看到以下图像：
- en: '![How to do it…](img/B04831_09_06.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/B04831_09_06.jpg)'
- en: The `residentialAddress` column shows that the value is a nested document with
    the given number of fields present in it. Hovering your mouse over it shows the
    nested document; alternatively, you can click on the column to show the contents
    in this document again as a grid. Once the nested documents are shown, you can
    click on the top of the grid to come back one level.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`residentialAddress`列显示值为嵌套文档，并显示其中的字段数。将鼠标悬停在上面会显示嵌套文档；或者，您可以单击该列以再次以网格形式显示此文档中的内容。显示嵌套文档后，您可以单击网格顶部返回一级。'
- en: 'Let''s see how to write queries to retrieve selected documents:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看如何编写查询以检索所选文档：
- en: Right-click on the **postalCodes** collection, and click on **Find**. We will
    type the following query in the **{Find}** textbox and the **{Sort}** field, and
    click on the **Find** button to the right:![How to do it…](img/B04831_09_07.jpg)
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右键单击**postalCodes**集合，然后单击**查找**。我们将在**{查找}**文本框和**{排序}**字段中输入以下查询，然后单击右侧的**查找**按钮：![如何操作...](img/B04831_09_07.jpg)
- en: 'We can choose the type of view that we want from the tab, which is a **Tree
    View**, **Table View**, or **Text View**. The plan of the query is also shown.
    Whenever any operation is run, the Learn shell at the bottom shows the actual
    Mongo query executed. In this case, we see the following:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以从选项卡中选择所需的视图类型，包括**树形视图**、**表格视图**或**文本视图**。查询计划也会显示。每次运行任何操作时，底部的Learn
    shell会显示实际执行的Mongo查询。在这种情况下，我们看到以下内容：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The plan of a query is also shown every time, and, as of the current version
    1.6.9.0, there is no way to disable the showing of the query plan with the query.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询计划也会显示每次查询，截至当前版本1.6.9.0，没有办法禁用查询计划的显示。
- en: In **Tree View**, right-clicking on a document will give you more options, such
    as expand it, copy the JSON contents, add keys to this document, remove the document,
    and so on. Try to remove a document from this collection using a right-click,
    and try adding any additional keys to the document. You can choose to restore
    the documents by reimporting the data from the `postalCodes` collection.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**树形视图**中，右键单击文档会给出更多选项，例如展开它，复制JSON内容，向该文档添加键，删除文档等。尝试使用右键从集合中删除文档，并尝试向文档添加任何其他键。您可以选择通过重新导入`postalCodes`集合中的数据来恢复文档。
- en: 'To insert a document in the collection, perform the following. We will be inserting
    a document in the `personTwo` collection:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在集合中插入文档，请执行以下操作。我们将在`personTwo`集合中插入一个文档：
- en: Right-click on the **personTwo** collection name, and click on **Insert/Import
    Documents…**, as shown in the following screenshot:![How to do it…](img/B04831_09_08.jpg)
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右键单击**personTwo**集合名称，然后单击**插入/导入文档…**，如下图所示：![如何做…](img/B04831_09_08.jpg)
- en: 'Another pop-up window will appear, where you can choose to enter a single JSON
    document or valid text file with the JSON documents to be imported. We imported
    the following document by importing a single document:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将出现另一个弹出窗口，在那里您可以选择输入单个JSON文档或包含要导入的JSON文档的有效文本文件。我们通过导入单个文档导入了以下文档：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Query the collection once the document has been imported successfully; we will
    view the newly imported document along with the old ones.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功导入文档后，查询集合；我们将查看新导入的文档以及旧文档。
- en: 'Let''s see how to update the document:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看如何更新文档：
- en: You can either right-click on the collection name to the left and click **Update**,
    or select the **Update** option at the top. In either case, we will see the following
    window. Here, we will be updating the age of the person that we inserted in the
    previous step:![How to do it…](img/B04831_09_09.jpg)
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以右键单击左侧的集合名称，然后单击**更新**，或者在顶部选择**更新**选项。在任何一种情况下，我们将看到以下窗口。在这里，我们将更新在上一步中插入的人的年龄：![如何做…](img/B04831_09_09.jpg)
- en: Some things to note in this GUI are the query textbox on the left-hand side
    to find the document to be updated and the update JSON on the right-hand side,
    which will be applied to the selected document(s).
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此GUI中需要注意的一些事项是左侧的查询文本框，用于查找要更新的文档，以及右侧的更新JSON，它将应用于所选的文档。
- en: Before you update, you can choose to hit the **Count** button to see the number
    of documents that can be updated (in this case, one). Clicking on **Find** will
    show you the documents in the Tree form. On the right-hand side, below the update
    JSON text, we have the option to update one document and multiple documents by
    clicking on **Update 1** or **Update All**.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在更新之前，您可以选择点击**计数**按钮，以查看可以更新的文档数量（在本例中为一个）。点击**查找**将以树形式显示文档。在右侧，在更新JSON文本下方，我们可以通过点击**更新1**或**全部更新**来选择更新一个文档和多个文档。
- en: You can choose an **Upsert** operation in case the documents for the given **Find**
    condition are not found.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找不到给定**查找**条件的文档，可以选择**Upsert**操作。
- en: The radio buttons on the bottom right of the preceding screen shows either the
    output of the `getLastError` operation or the result after the update, in which
    case, a query will be executed to find the document(s) updated.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前一屏幕右下角的单选按钮显示`getLastError`操作的输出或更新后的结果，如果是后者，则将执行查询以查找已更新的文档。
- en: The find query, however, is not foolproof and might return different results
    than those truly updated as a separate query, the same as in the **Find** textbox.
    The update and find operations are not atomic.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是，查找查询并不是绝对可靠的，可能会返回与真正更新的结果不同的结果，就像在**查找**文本框中一样。更新和查找操作不是原子的。
- en: 'We have queried on small collections so far. As the size of the collection
    increases, queries performing full collection scans are not acceptable and we
    need to create indexes as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在小集合上进行了查询。随着集合大小的增加，执行完整集合扫描的查询是不可接受的，我们需要创建索引如下：
- en: To create an index by `lastName` in ascending order and age in descending order,
    we will invoke `db.personTwo.ensureIndex({'lastName':1, 'age':-1})`.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要按`lastName`升序和年龄降序创建索引，我们将调用`db.personTwo.ensureIndex({'lastName':1, 'age':-1})`。
- en: Using MongoVUE, there is a way to visually create the same index by right-clicking
    on the collection name on the left-hand side of the screen and selecting **Add
    Index….**
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MongoVUE，有一种方法可以通过右键单击屏幕左侧的集合名称并选择**添加索引…**来可视化创建相同的索引。
- en: In the new pop-up window, enter the name of the index and select the **Visual**
    tab as shown. Select the **lastName** and **age** fields with ascending and descending
    values, respectively:![How to do it…](img/B04831_09_10.jpg)
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新的弹出窗口中，输入索引的名称，并选择**可视**选项卡，如图所示。分别选择**lastName**和**age**字段，以升序和降序的方式：![如何做…](img/B04831_09_10.jpg)
- en: Once these details are filled in, click on **Create**. This should create the
    index for us by firing the `ensureIndex` command.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填写这些细节后，点击**创建**。这应该通过触发`ensureIndex`命令为我们创建索引。
- en: You can choose the index to be **Unique** and **Drop Duplicates** (which will
    be enabled when unique is selected), or even create big, long, and running index
    creations in the background.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以选择将索引设置为**唯一**和**删除重复项**（当选择唯一时将启用），甚至可以在后台创建大型、长时间运行的索引创建。
- en: Note the **Json** tab next to the **Visual** tab. This is the place where you
    can type the `ensureIndex` command as you do in the shell in order to create the
    index.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意**可视**选项卡旁边的**Json**选项卡。这是您可以输入`ensureIndex`命令的地方，就像在shell中一样，以创建索引。
- en: 'We will see how to drop an index:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将看到如何删除索引：
- en: Simply expand the tree on the left-hand side (as shown in the screen shot in
    step 9)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单地展开左侧的树（如第9步的屏幕截图所示）
- en: On expanding the collection, we will see all the indexes created on it
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开集合后，我们将看到在其上创建的所有索引
- en: Except for the default index on the `_id` field, all the other indexes can be
    dropped
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了`_id`字段上的默认索引外，所有其他索引都可以被删除。
- en: Simply right-click on the name and select **Drop index** to drop or click on
    **Properties** to view its properties
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单右键单击名称，选择**删除索引**以删除，或点击**属性**查看其属性
- en: 'After seeing how to do the basic CRUD operations and creating an index, let''s
    look at how to execute the aggregation operations:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在了解了基本的CRUD操作和创建索引之后，让我们看看如何执行聚合操作：
- en: There are no visual tools as in the index creation for aggregation but simply
    a text area where we enter our aggregation pipeline
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在聚合索引的创建中没有可视化工具，只是一个文本区域，我们在其中输入我们的聚合管道
- en: In the following sample, we perform aggregation on the `postalCodes` collection
    to find the top five states by the number of times they appear in the collection
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以下示例中，我们对`postalCodes`集合执行聚合，以找到在集合中出现次数最多的五个州
- en: 'We will have the following aggregation pipeline entered:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将输入以下聚合管道：
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![How to do it…](img/B04831_09_11.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04831_09_11.jpg)'
- en: Once the pipeline is entered, hit the **Aggregate** button to get the aggregation
    results
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦进入管道，点击**聚合**按钮以获取聚合结果
- en: 'Executing MapReduce is even cooler. The use case that we will be executing
    is similar to the preceding one, but we will see how to implement a MapReduce
    operation using MongoVUE:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行MapReduce甚至更酷。我们将执行的用例与前面的用例类似，但我们将看到如何使用MongoVUE实现MapReduce操作：
- en: To execute a map reduce job, right-click on the collection name in the left-hand
    side menu, and click on **Map Reduce**.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要执行map reduce作业，请在左侧菜单中右键单击集合名称，然后单击**Map Reduce**。
- en: This option is right above the **Aggregation** option that we saw in the previous
    image. This gives us a pretty neat GUI to enter the **Map**, **Reduce**, **Finalize**
    and the **In & Out**, as shown in the following image:![How to do it…](img/B04831_09_12.jpg)
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此选项位于我们在上一张图片中看到的**Aggregation**选项正上方。这为我们提供了一个相当整洁的GUI，可以输入**Map**、**Reduce**、**Finalize**和**In
    & Out**，如下图所示：![如何做...](img/B04831_09_12.jpg)
- en: 'The `Map` function is simply the following:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map`函数就是以下内容：'
- en: '[PRE30]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `Reduce` function is the following:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reduce`函数如下：'
- en: '[PRE31]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Leave the `Finalize` method unimplemented, and in the **In & Out** section,
    fill in the following details:![How to do it…](img/B04831_09_13.jpg)
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持`Finalize`方法未实现，并在**In & Out**部分填写以下细节：![如何做...](img/B04831_09_13.jpg)
- en: Click on **Go** to start executing the MapReduce job.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单击**开始**开始执行MapReduce作业。
- en: 'We will print the output to the `mongoVue_mr` collection. Query the `mongoVue_mr`
    collection using the following query:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将输出打印到`mongoVue_mr`集合。使用以下查询查询`mongoVue_mr`集合：
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Check the results against those that we got using aggregation.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查结果是否与使用聚合获得的结果相匹配。
- en: The format of map reduce was chosen as **Reduce**. For more options and their
    behavior, visit [http://docs.mongodb.org/manual/reference/command/mapReduce/#mapreduce-out-cmd](http://docs.mongodb.org/manual/reference/command/mapReduce/#mapreduce-out-cmd).
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择了map reduce的格式作为**Reduce**。有关更多选项及其行为，请访问[http://docs.mongodb.org/manual/reference/command/mapReduce/#mapreduce-out-cmd](http://docs.mongodb.org/manual/reference/command/mapReduce/#mapreduce-out-cmd)。
- en: 'Monitoring the server instances is now possible using `MongoVUE`:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以使用`MongoVUE`监视服务器实例：
- en: To monitor an instance, click on **Tools** | **Monitoring** in the top menu.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要监视一个实例，请点击顶部菜单中的**工具** | **监视**。
- en: By default, no server will be added, and we will have to click on **+ Add Server**
    to add a server instance.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，不会添加任何服务器，我们必须点击**+添加服务器**来添加服务器实例。
- en: Select the Local Instance added or any server that you want to monitor, and
    click on **Connect**.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择添加的本地实例或任何要监视的服务器，然后单击**连接**。
- en: 'We will see quite a lot of monitoring details. MongoVUE uses the `db.serverStatus`
    command to serve these stats and limit the frequency at which we execute this
    command on busy server instances, we can choose the **Refresh Interval** at the
    top of the screen, as shown in the following image:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将看到相当多的监控细节。MongoVUE使用`db.serverStatus`命令来提供这些统计信息，并限制我们在繁忙的服务器实例上执行此命令的频率，我们可以在屏幕顶部选择**刷新间隔**，如下图所示：
- en: '![How to do it…](img/B04831_09_14.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04831_09_14.jpg)'
- en: How it works…
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: What we covered in the previous sections was pretty straightforward for us to
    perform the majority of our activities as a developer and administrator.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的部分中所涵盖的内容对于我们作为开发人员和管理员来执行大部分活动都是非常简单的。
- en: There's more…
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Refer to [Chapter 4](ch04.html "Chapter 4. Administration"), *Administration*
    and [Chapter 6](ch06.html "Chapter 6. Monitoring and Backups"), *Monitoring and
    Backups*, for recipes on the administration and monitoring of the MongoDB instances.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有关管理和监控MongoDB实例的管理和监控的详细信息，请参阅[第4章](ch04.html "第4章。管理")、*管理*和[第6章](ch06.html
    "第6章。监控和备份")、*监控和备份*。
- en: See also
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Refer to [http://www.mongovue.com/tutorials/](http://www.mongovue.com/tutorials/)
    for various tutorials on MongoVUE
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[http://www.mongovue.com/tutorials/](http://www.mongovue.com/tutorials/)，了解有关MongoVUE的各种教程
- en: Note
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While writing this book, MongoDB was planning to release a similar data visualisation
    and manipulation product called **Compass**. You should check it out [https://www.mongodb.com/products/compass](https://www.mongodb.com/products/compass).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本书时，MongoDB计划发布一个名为**Compass**的类似数据可视化和操作产品。您应该查看[https://www.mongodb.com/products/compass](https://www.mongodb.com/products/compass)。
