- en: 4\. Querying Documents
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 查询文档
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter discusses how to prepare and execute queries in MongoDB. You will
    learn how to find documents from a collection and limit the fields shown in the
    output. You will use various conditional and logical operators, as well as combinations
    of them, in a query and use regular expressions to find documents in a collection.
    By the end of this chapter, you will be able to run queries on arrays and nested
    objects, as well as limit, skip, and sort the records in the result set.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了如何在MongoDB中准备和执行查询。你将学习如何从集合中查找文档并限制输出中显示的字段。你将在查询中使用各种条件和逻辑运算符，以及它们的组合，并使用正则表达式在集合中查找文档。通过本章结束时，你将能够在数组和嵌套对象上运行查询，以及限制、跳过和对结果集中的记录进行排序。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapters, we covered the basics of MongoDB, its document-based
    data model, data types, clients, and the MongoDB server. We created an Atlas cluster
    on the cloud, loaded sample datasets, and connected using different clients. Now
    that we have the data, we can start writing queries to retrieve documents from
    the collections. Queries are used to retrieve meaningful data from the database.
    We will begin by learning about query syntax, how to use operators, and the techniques
    we can use to format the result sets. Practicing and mastering the query language
    will help you find any required document quickly and efficiently.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们介绍了MongoDB的基础知识，它的基于文档的数据模型、数据类型、客户端和MongoDB服务器。我们在云上创建了一个Atlas集群，加载了示例数据集，并使用不同的客户端进行了连接。现在我们有了数据，可以开始编写查询以从集合中检索文档。查询用于从数据库中检索有意义的数据。我们将首先学习查询语法，如何使用运算符以及我们可以使用的技术来格式化结果集。练习和掌握查询语言将帮助你快速高效地找到任何所需的文档。
- en: For any database management system, having a powerful query language is as important
    as its storage model, or its scalability. Consider that you are working on a database
    platform that offers an excellent storage model or an extremely high-performance
    database engine. However, it has very poor query language support, because of
    which you cannot easily retrieve the required pieces of information. Clearly,
    such a database is not going to be very useful. One of the primary purposes of
    storing information in a database is to be able to retrieve it as and when required.
    MongoDB provides a lightweight query language, which is totally different from
    the SQL queries that are used in relational databases. Let's start by taking a
    look at its query structure.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何数据库管理系统来说，拥有强大的查询语言和存储模型或可扩展性一样重要。考虑一下，你正在使用一个数据库平台，它提供了优秀的存储模型或极高性能的数据库引擎。然而，它的查询语言支持非常差，因此你无法轻松地检索所需的信息。显然，这样的数据库将毫无用处。在数据库中存储信息的主要目的之一是能够在需要时检索它。MongoDB提供了一种轻量级的查询语言，与关系数据库中使用的SQL查询完全不同。让我们首先来看一下它的查询结构。
- en: MongoDB Query Structure
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB查询结构
- en: 'MongoDB queries are based on JSON documents in which you write your criteria
    in the form of valid documents. With the data stored in the form of JSON-like
    documents, the queries seem more natural and readable. The following diagram is
    an example of a simple MongoDB query that finds all the documents where the `name`
    field contains the value `David`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB查询基于JSON文档，你可以在其中以有效文档的形式编写你的条件。随着数据以类似JSON的文档形式存储，查询看起来更加自然和可读。下图是一个简单的MongoDB查询示例，它查找所有`name`字段包含值`David`的文档：
- en: '![Figure 4.1: MongoDB Query Syntax'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1：MongoDB查询语法'
- en: '](img/B15507_04_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_01.jpg)'
- en: 'Figure 4.1: MongoDB Query Syntax'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：MongoDB查询语法
- en: 'To draw a comparison with SQL, let''s rewrite the same query in SQL format.
    This query finds all the rows from the `USERS` table that contain the `name` column
    where the value of `name` is `David`, as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与SQL进行比较，让我们用SQL格式重写相同的查询。该查询查找`USERS`表中包含`name`列值为`David`的所有行，如下所示：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The most notable difference between the preceding queries is that the MongoDB
    queries do not have keywords such as `SELECT`, `FROM`, and `WHERE`. Thus, you
    need not remember a lot of keywords and their uses.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 前述查询之间最显著的区别是，MongoDB查询没有诸如`SELECT`、`FROM`和`WHERE`之类的关键字。因此，你不需要记住很多关键字及其用法。
- en: The absence of keywords makes the queries less wordy and hence more focused,
    and less error-prone. When you are reading or writing MongoDB queries, you can
    easily focus on the most important parts of the query; that is, the conditions
    and the logic. Also, because of fewer keywords, the chances of introducing syntactical
    errors are smaller.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字的缺失使得查询更加简洁，因此更加专注，也更少出错。当你阅读或编写MongoDB查询时，你可以更容易地专注于查询的最重要部分，即条件和逻辑。此外，由于关键字更少，引入语法错误的机会更小。
- en: As the queries are represented in a document format, they can be easily mapped
    with the object structure of the respective programming language. When you write
    the query in your application, the MongoDB driver maps the objects provided by
    the application's programming language into the MongoDB query. Hence, to build
    a MongoDB query, all you need to do is prepare an object that represents the query conditions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于查询以文档格式表示，它们可以很容易地与相应编程语言的对象结构进行映射。当你在应用程序中编写查询时，MongoDB驱动程序将应用程序编程语言提供的对象映射到MongoDB查询中。因此，要构建一个MongoDB查询，你只需要准备一个表示查询条件的对象。
- en: In contrast, SQL queries are written in the form of plain strings. To build
    a SQL query, you will have to join the keywords, field and table names. and variables
    together into a string. Such string concatenations are prone to errors. Even a
    missing space between two joining keywords can introduce syntactical errors. Now
    that we have explored the basic advantages of MongoDB's query structure, let's
    start writing and executing basic queries against a collection.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，SQL查询是以普通字符串的形式编写的。要构建SQL查询，您将不得不将关键字、字段和表名以及变量连接成一个字符串。这种字��串连接容易出错。即使在两个连接关键字之间缺少空格也可能引入语法错误。现在我们已经探讨了MongoDB查询结构的基本优势，让我们开始编写并执行针对集合的基本查询。
- en: Basic MongoDB Queries
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的MongoDB查询
- en: All the queries in this section are top-level queries; that is, they are based
    on the top-level (also known as root-level) fields in the documents. We will learn
    about the basic query operators by writing queries against the root fields.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的所有查询都是顶级查询；也就是说，它们是基于文档中的顶级（也称为根级）字段的。我们将通过针对根字段编写查询来学习基本的查询运算符。
- en: Finding Documents
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找文档
- en: 'The most basic query in MongoDB is performed with the `find()` function on
    the collection. When this function is executed without any argument, it returns
    all the documents in a collection. For example, consider the following query:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中最基本的查询是在集合上使用`find()`函数执行的。当此函数在没有任何参数的情况下执行时，它会返回集合中的所有文档。例如，考虑以下查询：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This query calls the `find()` function on the collection named `comments`. When
    executed on a mongo shell, it will return all the documents from the collection.
    To return only specific documents, a condition can be provided to the `find()`
    function. When this is done, the `find()` function evaluates it against each and
    every document in the collection and returns the documents that match the condition.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询在名为`comments`的集合上调用`find()`函数。在mongo shell上执行时，它将返回集合中的所有文档。要仅返回特定文档，可以向`find()`函数提供条件。这样做时，`find()`函数会对集合中的每个文档进行评估，并返回与条件匹配的文档。
- en: 'For example, consider that instead of retrieving all the comments, we only
    want to find comments that have been added by a specific user, `Lauren Carr`.
    In short, we want to find all the documents in which the `name` field has the
    value `Lauren Carr`. We will connect to the MongoDB Atlas cluster and use the
    `sample_mflix` database. The query should be written as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们不是检索所有评论，而是只想找到由特定用户`Lauren Carr`添加的评论。简而言之，我们想要找到所有`name`字段的值为`Lauren
    Carr`的文档。我们将连接到MongoDB Atlas集群并使用`sample_mflix`数据库。查询应该写成如下形式：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will result in the following output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下输出：
- en: '![Figure 4.2: Resulting comments after using the find() function'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2：使用find()函数后的评论结果'
- en: '](img/B15507_04_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_02.jpg)'
- en: 'Figure 4.2: Resulting comments after using the find() function'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：使用find()函数后的评论结果
- en: 'The query returned three comments that were added by `Lauren Carr`. However,
    the output is unformatted, which makes it difficult to read and interpret. To
    overcome this, the `pretty()` function can be used to print a well-formatted result,
    as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该查询返回了由`Lauren Carr`添加的三条评论。然而，输出格式不规范，这使得阅读和解释变得困难。为了克服这一点，可以使用`pretty()`函数打印格式良好的结果，如下所示：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When this query is executed on a mongo shell, the output will look like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当此查询在mongo shell上执行时，输出将如下所示：
- en: '![Figure 4.3: Structured result after using find() with pretty()'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3：使用pretty()后的结构化结果'
- en: '](img/B15507_04_03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_03.jpg)'
- en: 'Figure 4.3: Structured result after using find() with pretty()'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：使用pretty()后的结构化结果
- en: As you can see, the output is the same as in the previous example, but the documents
    are well formatted and easily readable.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，输出与前面的示例相同，但文档格式良好且易于阅读。
- en: Using findOne()
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用findOne()
- en: 'MongoDB provides another function, called `findOne()`, that returns only one
    matching record. This function is very useful when you are looking to isolate
    a specific record. The syntax of this function is similar to the syntax of the
    `find()` function, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB提供了另一个函数，称为`findOne()`，它只返回一个匹配的记录。当您想要隔离特定记录时，这个函数非常有用。该函数的语法与`find()`函数的语法类似，如下所示：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This query is executed without any condition and matches all the documents
    in the `comments` collection, returning only the first:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询在没有任何条件的情况下执行，并匹配`comments`集合中的所有文档，仅返回第一个：
- en: '![Figure 4.4: Finding a single document with the findOne() function'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4：使用findOne()函数找到单个文档'
- en: '](img/B15507_04_04.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_04.jpg)'
- en: 'Figure 4.4: Finding a single document with the findOne() function'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：使用findOne()函数找到单个文档
- en: As you can see, the output of `findOne()` is always well formatted because it
    returns a document. Compare this with the `find()` function, which is designed
    to return multiple documents. The results of `find()` are enclosed in a collection,
    and a cursor to that collection is returned from the function. A cursor is an
    iterator for a collection that is used to iterate or traverse through the collection's
    elements.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`findOne()`的输出始终格式良好，因为它返回一个文档。将其与旨在返回多个文档的`find()`函数进行比较。`find()`的结果被封装在一个集合中，并且从函数返回该集合的游标。游标是用于迭代或遍历集合元素的集合迭代器。
- en: Note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When you execute the `find()` query on the mongo shell, the shell automatically
    iterates through the cursor and shows the first 20 records. When you are using
    `find()` from a programming language, you will always have to iterate through
    the result set on your own.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在mongo shell上执行`find()`查询时，shell会自动迭代游标并显示前20条记录。当您从编程语言使用`find()`时，您将始终需要自己迭代结果集。
- en: 'On a mongo shell, you can capture the cursor returned by the `find()` function
    in a variable. By using the variable, we can iterate through the elements. In
    the following snippet, we are executing a `find()` query and capturing the resulting
    cursor in a variable named `comments`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在mongo shell上，您可以将`find()`函数返回的光标捕获在一个变量中。通过使用该变量，我们可以遍历元素。在下面的代码段中，我们正在执行一个`find()`查询，并将结果光标捕获在一个名为`comments`的变量中：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can use the `next()` function on the cursor, which moves the cursor to
    the next index position and returns the document from there. By default, the cursor
    is set at the beginning of the collection. When called for the first time, the
    `next()` function moves the cursor to the first document in the collection, and
    that document is returned. When called again, the cursor will be moved to the
    second position and the second document will be returned. The following is the
    syntax for calling the `next()` function on our comments cursor:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在光标上使用`next()`函数，它将光标移动到下一个索引位置并从那里返回文档。默认情况下，光标设置在集合的开头。第一次调用`next()`函数时，光标将移动到集合中的第一个文档，并返回该文档。再次调用时，光标将移动到第二个位置，并返回第二个文档。以下是在我们的评论光标上调用`next()`函数的语法：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When the cursor reaches the last document in the collection, calling `next()`
    will result in an error. To avoid this, the `hasNext()` function can be used before
    calling `next()`. The `hasNext()` function returns `true` if the collection has
    a document at the next index position, and false if not. The following snippet
    shows the syntax for calling the `hasNext()` function on the cursor:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当光标到达集合中的最后一个文档时，调用`next()`将导致错误。为了避免这种情况，在调用`next()`之前可以使用`hasNext()`函数。`hasNext()`函数在下一个索引位置有文档时返回`true`，否则返回`false`。以下代码段显示了在光标上调用`hasNext()`函数的语法：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following screenshot shows the result of using this function on a mongo
    shell:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在mongo shell上使用此函数的结果：
- en: '![Figure 4.5: Iterating through a cursor'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5：遍历光标'
- en: '](img/B15507_04_05.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_05.jpg)'
- en: 'Figure 4.5: Iterating through a cursor'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：遍历光标
- en: As we can see, first, we captured the cursor in a variable. Then, we verified
    whether the cursor had a document at the next position, which resulted in `true`.
    Finally, we printed the first document using the `next()` function.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，首先，我们将光标捕获在一个变量中。然后，我们验证光标在下一个位置是否有文档，结果为`true`。最后，我们使用`next()`函数打印第一个文档。
- en: 'Exercise 4.01: Using find() and findOne() Without a Condition'
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.01：在没有条件的情况下使用find()和findOne()
- en: 'In this exercise, you will use `find()` and `findOne()` without any conditions
    on a mongo shell by connecting to the `sample_mflix` database on MongoDB Atlas.
    Follow these steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将在MongoDB Atlas上连接到`sample_mflix`数据库，并在mongo shell上使用`find()`和`findOne()`而不带任何条件。按照以下步骤进行：
- en: 'First, use `find()` without a condition. So, here, do not pass any document
    or pass an empty document to the `find()` function. We will also execute the `find()`
    function to query for a non-existent field in our documents. All the queries shown
    here have the same behavior:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用没有条件的`find()`。因此，在这里，不要传递任何文档或传递一个空文档给`find()`函数。我们还将执行`find()`函数来查询我们的文档中不存在的字段。这里显示的所有查询都具有相同的行为：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When executing any of these queries, all the documents are matched and returned
    in a cursor. The following screenshot shows the first 20 documents from the mongo
    shell, printed along with a `Type "it" for more` message at the end. Typing `it`
    every time will return the next set of 20 documents until the collection contains
    more elements:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行任何这些查询时，所有文档都将匹配并在光标中返回。以下屏幕截图显示了从mongo shell中打印的前20个文档，最后还有一条`键入"it"以获取更多`的消息。每次键入`it`都将返回下一组20个文档，直到集合包含更多元素为止：
- en: '![Figure 4.6: First 20 documents in the mongo shell'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6：mongo shell中的前20个文档'
- en: '](img/B15507_04_06.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_06.jpg)'
- en: 'Figure 4.6: First 20 documents in the mongo shell'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：mongo shell中的前20个文档
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Did you wonder why `{"a_non_existent_field" : null}` matches all documents?'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '你是否想知道为什么`{"a_non_existent_field" : null}`匹配所有文档？'
- en: This is because, in MongoDB, a non-existent field is always considered to have
    a null value. The `"a_non_existent_field"` field does not exist in any document
    in our collection. Hence, the null check of the field stands true for all the
    documents and they are returned.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在MongoDB中，一个不存在的字段总是被认为具有空值。`"a_non_existent_field"`字段在我们的集合中不存在。因此，该字段的空值检查对所有文档都成立，并且它们都被返回。
- en: 'Next, use the `findOne()` function without any document, with an empty document,
    and with a document querying on a non-existing field:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用没有任何文档的`findOne()`函数，使用一个空文档，以及使用一个查询不存在字段的文档：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Similar to the previous step, all the preceding queries will have the same effect,
    except `findOne()` will output only the first document from the collection.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的步骤类似，所有先前的查询都将产生相同的效果，只是`findOne()`将仅输出集合中的第一个文档。
- en: In the next section, we will explore how we can project only some fields in
    the output.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何仅在输出中投影一些字段。
- en: Choosing the Fields for the Output
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择输出的字段
- en: So far, we have observed many queries and their outputs. You might have noticed
    that every time a document is returned, it contained all the fields by default.
    However, in most real-life applications, you may only want a few fields in the
    resulting documents. In MongoDB queries, you can either include or exclude specific
    fields from the result. This technique is called `find()` or `findOne()` functions.
    In the projection expression, you can explicitly exclude a field by setting it
    to `0` or include one by setting it to `1`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们观察了许多查询及其输出。您可能已经注意到，每次返回一个文档时，默认情况下它包含所有字段。然而，在大多数实际应用程序中，您可能只希望在结果文档中包含一些字段。在MongoDB查询中，您可以从结果中包含或排除特定字段。这种技术称为`find()`或`findOne()`函数。在投影表达式中，您可以通过将其设置为`0`来显式排除一个字段，或者通过将其设置为`1`来包含一个字段。
- en: 'For example, the user `Lauren Carr` may only want to know the dates on which
    she posted comments and may not be interested in the comment text. The following
    query finds all the comments posted by the user and returns only the `name` and
    `date` fields:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，用户`Lauren Carr`可能只想知道她发布评论的日期，而不关心评论文本。以下查询找到用户发布的所有评论，并仅返回`name`和`date`字段：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Upon executing the query, the following result can be seen:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 执行查询后，可以看到以下结果：
- en: '![Figure 4.7: Output showing only the name and date fields'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.7：仅显示名称和日期字段的输出'
- en: '](img/B15507_04_07.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_07.jpg)'
- en: 'Figure 4.7: Output showing only the name and date fields'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：仅显示名称和日期字段的输出
- en: 'Here, we have only specific fields in the result. However, the `_id` field
    is still visible, even though it was not specified. That is because the `_id`
    field is included by default in the resulting documents. If you do not want it
    to be present in the result, you must exclude it explicitly:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，结果中只有特定字段。但是，即使没有指定，_id字段仍然可见。这是因为_id字段默认包括在结果文档中。如果不希望它出现在结果中，必须明确排除它：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding query specifies that the `_id` field should be excluded from
    the result. When executed on a mongo shell, we get the following output, which
    shows that the `_id` field is absent from all documents:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询指定应从结果中排除_id字段。在mongo shell上执行时，我们得到以下输出，显示所有文档中都没有_id字段：
- en: '![Figure 4.8: _id field excluded from the output'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.8：输出中排除了_id字段'
- en: '](img/B15507_04_08.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_08.jpg)'
- en: 'Figure 4.8: _id field excluded from the output'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：输出中排除了_id字段
- en: 'It is important to note the three behaviors of field projections, listed as
    follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意字段投影的三种行为，如下所列：
- en: The `_id` field will always be included, unless excluded explicitly
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _id字段将始终包括在内，除非明确排除
- en: When one or more fields are explicitly included, the other fields (except `_id)`
    get excluded automatically
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当明确包括一个或多个字段时，其他字段（除了_id）将自动排除
- en: Explicitly excluding one or more fields will automatically include the rest
    of the fields, along with `_id`
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确排除一个或多个字段将自动包括其余字段，以及_id
- en: Note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Projection helps to compact the result set and focus on specific fields. The
    documents from the `sample_mflix` collections that we will query are quite big.
    Therefore, for most of our sample outputs, we will use projection to include only
    the specific fields of documents, which are required to demonstrate the query's
    behavior.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 投影有助于压缩结果集并专注于特定字段。我们将查询的`sample_mflix`集合中的文档非常庞大。因此，对于我们大部分的示例输出，我们将使用投影来仅包括文档的特定字段，以展示查询的行为。
- en: Finding the Distinct Fields
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找不同的字段
- en: 'The `distinct()` function is used to get the distinct or unique values of a
    field with or without query criteria. For the purpose of this example, we will
    use the `movies` collection. Each movie is assigned an audience suitability rating
    that is based on the content and viewers'' age. Let''s find the unique ratings
    that exist in our collection with the help of the following query:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`distinct()`函数用于获取字段的不同或唯一值，带有或不带有查询条件。在本例中，我们将使用`movies`集合。每部电影都被分配了一个基于内容和观众年龄的观众适宜性评级。让我们通过以下查询找到我们集合中存在的唯一评级：'
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Executing the preceding query gives us all the unique ratings from the `movies` collection:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述查询会给我们返回`movies`集合中的所有唯一评级：
- en: '![Figure 4.9: List of all movie ratings'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.9：所有电影评分列表'
- en: '](img/B15507_04_09.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_09.jpg)'
- en: 'Figure 4.9: List of all movie ratings'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：所有电影评分列表
- en: 'The `distinct()` function can also be used along with a query condition. The
    following example finds all the unique ratings the films that were released in
    1994 have received:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`distinct()`函数也可以与查询条件一起使用。以下示例查找了1994年发布的电影所获得的所有唯一评分：'
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The first argument to the function is the name of the required field, while
    the second is the query expressed in the document format. Upon executing the query,
    we get the following output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第一个参数是所需字段的名称，而第二个参数是以文档格式表示的查询。执行查询后，我们得到以下输出：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It is important to note that the result of `distinct` is always returned as
    an array.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意`distinct`的结果始终以数组形式返回。
- en: Counting the Documents
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 统计文档
- en: In some cases, we may not be interested in the actual documents but just the
    number of documents in a collection, or documents that match some query criteria.
    MongoDB collections have three functions that return the count of documents in
    the collection. Let's take a look at them one by one.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能对实际文档不感兴趣，而只对集合中的文档数量或匹配��些查询条件的文档感兴趣。MongoDB集合有三个返回集合中文档数量的函数。让我们依次看一下它们。
- en: count()
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: count()
- en: 'This function is used to return the count of the documents within a collection
    or a count of the documents that match the given query. When executed without
    any query argument, it returns the total count of documents in the collection,
    as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于返回集合中文档的数量，或返回与给定查询匹配的文档的数量。在没有任何查询参数的情况下执行时，它返回集合中文档的总数，如下所示：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Without a query, this function will not physically count the documents. Instead,
    it will read through the collection's metadata and return the count. The MongoDB
    specification does not guarantee that the metadata count will always be accurate.
    Cases such as the abrupt shutdown of a database or an incomplete chunk migration
    in sharded collections can lead to such inaccuracy. A sharded collection in MongoDB
    is partitioned and distributed across the different nodes of a database. We will
    not be going into details here as this is outside the scope of this book.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 没有查询时，此函数不会实际计算文档的数量。相反，它将通过集合的元数据进行读取并返回计数。MongoDB规范不能保证元数据计数始终准确。例如，数据库突然关闭或分片集合中不完整的块迁移等情况可能导致不准确性。MongoDB中的分片集合被分区并分布在数据库的不同节点上。我们不会在这里详细介绍，因为这超出了本书的范围。
- en: 'When the function is provided with a query, the count of documents that match
    the given query is returned. For example, the following query will return the
    count of movies that have exactly six comments:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数提供查询时，返回与给定查询匹配的文档数量。例如，以下查询将返回具有确切六条评论的电影的数量：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Upon executing this query, the actual count of documents is internally calculated
    by executing an aggregation pipeline with the same query. You will learn more
    about aggregation pipelines in *Chapter 7*, *Aggregations*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此查询时，实际文档数量是通过执行具有相同查询的聚合管道来内部计算的。您将在*第7章* *聚合*中了解有关聚合管道的更多信息。
- en: 'In MongoDB v4.0, these two behaviors are separated into different functions:
    `countDocuments()` and `estimatedDocumentCount()`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB v4.0中，这两种行为被分成不同的函数：`countDocuments()`和`estimatedDocumentCount()`。
- en: countDocuments()
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: countDocuments()
- en: 'This function returns the count of documents that are matched by the given
    condition. The following is an example query that returns the count of movies
    released in 1999:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回满足给定条件的文档的数量。以下是一个返回1999年上映的电影数量的示例查询：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Unlike the `count()` function, a query argument is mandatory for `countDocuments()`.
    Hence, the following query is invalid, and it will fail:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与`count()`函数不同，`countDocuments()`需要查询参数。因此，以下查询是无效的，它将失败：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To count all the documents in the collections, we can pass an empty query to
    the function, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算集合中的所有文档，我们可以将一个空查询传递给函数，如下所示：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: An important thing to note about `countDocuments()` is that it never uses collection
    metadata to find the count. It executes the given query on the collection and
    calculates the count of matched documents. This provides accurate results but
    may take longer than the metadata-based counts. Even when an empty query is provided,
    it is matched against all documents.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`countDocuments()`的一个重要事项是，它从不使用集合元数据来查找计数。它在集合上执行给定的查询并计算匹配文档的数量。这提供了准确的结果，但可能比基于元数据的计数需要更长的时间。即使提供了空查询，它也会与所有文档匹配。
- en: estimatedDocumentCount()
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: estimatedDocumentCount()
- en: 'This function returns the approximate or estimated count of documents in a
    collection. It does not accept any query and always returns the count of all documents
    in the collection. The count is always based on the collection''s metadata. The
    syntax for this is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回集合中文档的近似或估计数量。它不接受任何查询，并始终返回集合中所有文档的数量。计数始终基于集合的元数据。其语法如下：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As the count is based on metadata, the results are less accurate, but the performance
    is better. The function should be used when performance is more important than accuracy.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计数是基于元数据的，结果不太准确，但性能更好。当性能比准确性更重要时，应使用该函数。
- en: Conditional Operators
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件运算符
- en: Now that you have learned how to query MongoDB collections, as well as how to
    use projection to return only specific fields in the output, it is time to learn
    more advanced ways of querying. So far, you've tried to query the `comments` collection
    using the value of a field. However, there are more ways to query documents. MongoDB
    provides conditional operators that can be used to represent various conditions,
    such as equality, and whether a value is less than or greater than some specified
    value. In this section, we will explore these operators and learn how to use them
    in queries.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何查询MongoDB集合，以及如何使用投影仅返回输出中的特定字段，是时候学习更高级的查询方式了。到目前为止，您已经尝试使用字段值查询`comments`集合。但是，还有更多查询文档的方法。MongoDB提供了条件运算符，可用于表示各种条件，例如相等性，以及值是否小于或大于某个指定值。在本节中，我们将探索这些运算符，并学习如何在查询中使用它们。
- en: Equals ($eq)
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等于($eq)
- en: 'In the preceding section, you saw examples of equality checking where the queries
    used a key-value pair. However, queries can also use a dedicated operator (`$eq`)
    to find documents with fields that match a given value. For example, the following
    queries find and return movies that have exactly `5` comments. Both queries have
    the same effect:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，您看到了相等检查的示例，其中查询使用了键值对。但是，查询也可以使用专用运算符(`$eq`)来查找具有与给定值匹配的字段的文档。例如，以下查询查找并返回具有`5`条评论的电影。这两个查询具有相同的效果：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Not Equal To ($ne)
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不等于($ne)
- en: 'This operator stands for **Not Equal To** and has the reverse effect of using
    an equality check. It selects all the documents where the value of the field doesn''t
    match with the given value. For example, the following query can be used to return
    movies whose count for comments is not equal to 5:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此运算符代表**不等于**，与使用相等检查的效果相反。它选择所有字段值与给定值不匹配的文档。例如，以下查询可用于返回评论计数不等于5的电影：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Greater Than ($gt) and Greater Than or Equal To ($gte)
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大于($gt)和大于或等于($gte)
- en: 'The `$gt` keyword can be used to find documents where the value of the field
    is greater than the value in the query. Similarly, the `$gte` keyword is used
    to find documents where the value of the field is the same as or greater than
    the given value. Let''s find the number of movies released after `2015`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`$gt`关键字可用于查找字段值大于查询中的值的文档。类似地，`$gte`关键字用于查找字段值与或大于给定值的文档。让我们找出2015年后发布的电影数量：'
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To find the movies that had been released in or after `2015`, the following
    line of code can be used:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找在2015年或之后发布的电影，可以使用以下代码行：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With these operators, we can also count movies that were released in the 21st
    century. For this query, we also want to include the movies that have been released
    since January 1, 2000, so we will use `$gte`, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些运算符，我们还可以计算21世纪发布的电影数量。对于此查询，我们还希望包括自2000年1月1日以来发布的电影，因此我们将使用`$gte`，如下所示：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Less Than ($lt) and Less Than or Equal To ($lte)
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小于($lt)和小于或等于($lte)
- en: The `$lt` operator matches the documents with the value of the field that's
    less than the given value. Similarly, the `$lte` operator selects the documents
    where the value of the field is the same as or less than the given value.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`$lt`运算符匹配字段值小于给定值的文档。同样地，`$lte`运算符选择字段值与给定值相同或小于给定值的文档。'
- en: 'To find how many movies have less than two comments, enter the following query:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出有少于两条评论的电影数量，输入以下查询：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Similarly, to find the number of movies that have a maximum of two comments,
    enter the following query:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，要找出最多有两条评论的电影数量，输入以下查询：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Again, to count the movies that were released in the previous century, simply
    use `$lt`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，要计算上个世纪发行的电影数量，只需使用`$lt`：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In ($in) and Not In ($nin)
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在($in)和不在($nin)
- en: 'What if a user wants a list of all movies that have been rated G, PG, or PG-13?
    In this case, we can use the `$in` operator, along with multiple values given
    in the form of an array. Such queries find all the documents where the value of
    the field matches at least one of the given values. Prepare a query that returns
    movies rated as either of G, PG, or PG-13 by entering the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户想要列出所有被评为G、PG或PG-13的电影，该怎么办？在这种情况下，我们可以使用`$in`运算符，以及以数组形式给出的多个值。这样的查询可以找到所有字段值至少与给定值中的一个匹配的文档。通过输入以下内容准备一个查询，返回被评为G、PG或PG-13的电影：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `$nin` operator stands for **Not In** and matches all the documents where
    the value of the field does not match with any of the array elements:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`$nin`运算符代表**不在**，匹配所有字段值与数组元素都不匹配的文档：'
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding query returns movies that are not rated as `G`, `PG`, or `PG-13`,
    including the ones that do not have the `rated` field.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前述查询返回的是未被评为`G`、`PG`或`PG-13`的电影，包括那些没有`rated`字段的电影。
- en: 'To see what happens when you use `$nin` with a non-existent field, first, find
    the total documents you have, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，找到你拥有的总文档数量，看看当你使用`$nin`与一个不存在的字段时会发生什么：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, use `$nin` with some values, except null, on a non-existent object. This
    means that all the documents are matched, as shown in the following snippet:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`$nin`与一些值（除了null）在一个不存在的对象上。这意味着所有文档都匹配，如下片段所示：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the following example, add a `null` value to the `$nin` array:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，将`null`值添加到`$nin`数组中：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This time, it did not match any document. This is because, in MongoDB, a non-existent
    field always has a value of null, hence why the `$nin` condition did not stand
    true for any of the documents.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，没有匹配到任何文档。这是因为在MongoDB中，不存在的字段总是具有null值，因此`$nin`条件对任何文档都不成立。
- en: 'Exercise 4.02: Querying for Movies of an Actor'
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.02：查询演员的电影
- en: 'Imagine that you''re working for a popular entertainment magazine and their
    upcoming issue is dedicated to Leonardo DiCaprio. The issue will contain a special
    article, and you quickly need some data, such as the number of movies he has acted
    in, the genre of each, and more. In this exercise, you will write queries to count
    documents by given conditions, find distinct documents, and project different
    fields in the documents. Query on the `sample_mflix` movies collection for the
    following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在一家知名娱乐杂志工作，他们即将出版一期专门介绍莱昂纳多·迪卡普里奥的杂志。这期杂志将包含一篇特别文章，你迫切需要一些数据，比如他出演的电影数量、每部电影的类型等。在这个练习中，你将编写查询，按给定条件计算文档数量，找到不同的文档，并投影文档中的不同字段。在`sample_mflix`电影集合上进行以下查询：
- en: The number of movies the actor has acted in
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员出演的电影数量
- en: the genre of these movies
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些电影的类型
- en: Movie titles and their respective years of release
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电影标题及其相应的发行年份
- en: The number of movies he has directed
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他执导的电影数量
- en: 'Find the movies in which Leonardo DiCaprio appears by using the `cast` field.
    Enter the following query to do so:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`cast`字段找到莱昂纳多·迪卡普里奥出演的电影。输入以下查询来执行：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following output states that Leonardo has acted in 25 movies:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出表明，莱昂纳多出演了25部电影：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The genres of the movies in the collection are represented by the `genres`
    field. Use the `distinct()` function to find the unique genres:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集合中电影的类型由`genres`字段表示。使用`distinct()`函数找到唯一的类型：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Upon executing the preceding code, you will receive the following output. As
    we can see, he has acted in movies of 14 different genres:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码后，将收到以下输出。正如我们所看到的，他出演了14种不同类型的电影：
- en: '![Figure 4.10: Genres of movies Leonardo DiCaprio has starred in'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.10：莱昂纳多·迪卡普里奥主演的电影类型'
- en: '](img/B15507_04_10.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_10.jpg)'
- en: 'Figure 4.10: Genres of movies Leonardo DiCaprio has starred in'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10：莱昂纳多·迪卡普里奥主演的电影类型
- en: 'Using movie titles, you can now find the year of release for each of the actor''s
    movies. As you are only interested in the titles and release years of his movies,
    add a projection clause to the query:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，可以使用电影标题找到演员每部电影的发行年份。由于只对他的电影标题和发行年份感兴趣，因此在查询中添加一个投影子句：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output will be generated as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下生成：
- en: '![Figure 4.11: Titles and release years of Leonardo DiCaprio’s movies'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.11：莱昂纳多·迪卡普里奥的电影标题和发行年份'
- en: '](img/B15507_04_11.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_11.jpg)'
- en: 'Figure 4.11: Titles and release years of Leonardo DiCaprio''s movies'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11：莱昂纳多·迪卡普里奥的电影标题和发行年份
- en: 'Next, you need to find the number of movies Leonardo has directed. To gather
    this information, count the number of movies he directed once again, this time
    using the director''s field instead of the actor''s field. The query document
    for this question should be as follows:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要找到莱昂纳多执导的电影数量。为了收集这些信息，再次计算他执导的电影数量，这次使用导演字段而不是演员字段。这个问题的查询文档应该如下所示：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Write a query that counts the movies that match the preceding query:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个查询，计算与前述查询匹配的电影数量：
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Execute the query. This shows that Leonardo DiCaprio has directed `0` movies:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 执行查询。结果显示，莱昂纳多·迪卡普里奥执导了`0`部电影：
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this exercise, you found and counted documents based on some conditions,
    found distinct values of a field, and projected specific fields in the output.
    In the next section, we will learn about logical operators.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您根据一些条件找到并计算了文档，找到了字段的不同值，并在输出中投影了特定字段。在下一节中，我们将学习逻辑运算符。
- en: Logical Operators
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: So far, we have learned about various operators used for writing comparison-based
    queries. The queries we have written so far had only one criterion at a time.
    But in practical scenarios, you may need to write more complex queries. MongoDB
    provides four logical operators to help you build logical combinations of multiple
    criteria in the same query. Let's have a look at them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了用于编写基于比较的查询的各种运算符。到目前为止，我们编写的查询一次只有一个标准。但在实际场景中，您可能需要编写更复杂的查询。MongoDB提供了四个逻辑运算符，以帮助您在同一查询中构建多个条件的逻辑组合。让我们来看看它们。
- en: $and operator
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $and运算符
- en: 'Using the `$and` operator, you can have any number of conditions wrapped in
    an array and the operator will return only the documents that satisfy all the
    conditions. When a document fails a condition check, the next conditions are skipped.
    That is why the operator is called a short-circuit operator. For example, say
    you want to determine the count of unrated movies that were released in 2008\.
    This query must have two conditions:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`$and`运算符，您可以将任意数量的条件包装在数组中，该运算符将仅返回满足所有条件的文档。当文档未通过条件检查时，将跳过下一个条件。这就是为什么该运算符被称为短路运算符的原因。例如，假设您想确定2008年发布的未评级电影的数量。此查询必须具有两个条件：
- en: The field rated should have a value of `UNRATED`
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段rated应该有一个值为`UNRATED`
- en: The field year must be equal to `2008`
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段year必须等于`2008`
- en: 'In the document format, both queries can be written as `{"rated" : "UNRATED"}`
    and `{"year" : 2008}`. Put them in an array using the `$and` operator:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '在文档格式中，这两个查询可以写为`{"rated" : "UNRATED"}`和`{"year" : 2008}`。使用`$and`运算符将它们放在一个数组中：'
- en: '[PRE41]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preceding output shows that in 2008, there were 37 unrated movies. In MongoDB
    queries, the `$and` operator is implicit and included by default if a query document
    has more than one condition. For example, the following query can be rewritten
    without using the `$and` operator and gives the same result:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示，2008年有37部未评级的电影。在MongoDB查询中，如果查询文档具有多个条件，则`$and`运算符是隐式的并且默认包含在内。例如，以下查询可以在不使用`$and`运算符的情况下重写，并且给出相同的结果：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The output is exactly the same, so you do not have to use the `$and` operator
    explicitly, unless you want to make your code more readable.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 输出完全相同，因此您不必显式使用`$and`运算符，除非您想使您的代码更易读。
- en: $or Operator
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $or运算符
- en: With the `$or` operator, you can pass multiple conditions wrapped in an array
    and the documents satisfying either of the conditions will be returned. This operator
    is used when we have multiple conditions and we want to find documents that match
    at least one condition.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`$or`运算符，您��以将多个条件包装在一个数组中，并返回满足任一条件的文档。当我们有多个条件并且希望找到至少一个条件匹配的文档时，就会使用此运算符。
- en: 'In the example we used in the *In ($in) and Not In ($nin)* section, you wrote
    a query to count movies that are rated either G, PG, or PG-13\. With the `$or`
    operator, rewrite the same query, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在*In ($in) and Not In ($nin)*部分中使用的示例中，您编写了一个查询，用于计算评级为G、PG或PG-13的电影的数量。使用`$or`运算符，重写相同的查询，如下所示：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Both operators are different and are used in different scenarios. The `$in`
    operator is used to determine whether a given field has at least one of the values
    provided in an array, whereas the `$or` operator is not bound to any specific
    fields and accepts multiple expressions. To understand this better, write a query
    that will find movies that are either rated `G`, were released in `2005`, or have
    at least `5` comments. There are three conditions in this query, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个运算符是不同的，并且用于不同的场景。`$in`运算符用于确定给定字段是否至少具有数组中提供的一个值，而`$or`运算符不限于任何特定字段，并接受多个表达式。为了更好地理解这一点，请编写一个查询，找到评级为`G`、发布于`2005`年或至少有`5`条评论的电影。此查询中有三个条件，如下所示：
- en: '`{"rated" : "G"}`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{"rated" : "G"}`'
- en: '`{"year" : 2005}`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{"year" : 2005}`'
- en: '`{"num_mflix_comments" : {$gte : 5}}`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{"num_mflix_comments" : {$gte : 5}}`'
- en: 'To use these expressions in an `$or` query, combine these expressions in an
    array:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`$or`查询中使用这些表达式，请将这些表达式组合在一个数组中：
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: $nor Operator
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $nor运算符
- en: The `$nor` operator is syntactically like `$or` but behaves in the opposite
    way. The `$nor` operator accepts multiple conditional expressions in the form
    of an array and returns the documents that do not satisfy any of the given conditions.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`$nor`运算符在语法上类似于`$or`，但行为方式相反。`$nor`运算符接受数组形式的多个条件表达式，并返回不满足任何给定条件的文档。'
- en: 'The following is the same query you wrote in the previous section, except that
    the `$or` operator is replaced with `$nor`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您在上一节中编写的相同查询，只是将`$or`运算符替换为`$nor`：
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This query will match and return all the movies that are not rated `G`, were
    not released in `2005`, and do not have more than `5` comments.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询将匹配并返回所有未评级为`G`、未发布于`2005`年且没有超过`5`条评论的电影。
- en: $not Operator
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $not运算符
- en: The `$not` operator represents the logical NOT operation that negates the given
    condition. Simply put, the `$not` operator accepts a conditional expression and
    matches all the documents that do not satisfy it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`$not`运算符表示逻辑NOT操作，否定给定条件。简而言之，`$not`运算符接受一个条件表达式，并匹配所有不满足该条件的文档。'
- en: 'The following query finds movies with `5` or more comments:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询找到了具有`5`条或更多评论的电影：
- en: '[PRE46]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Use the `$not` operator in the same query and negate the given condition:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的查询中使用`$not`运算符并否定给定条件：
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This query will return all the movies that do not have 5 or more comments and
    the movies that do not contain the `num_mflix_comments` field. You will now use
    the operators you have learned about so far in a simple exercise.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询将返回所有没有5条或更多评论以及不包含`num_mflix_comments`字段的电影。现在，您将在一个简单的练习中使用到目前为止学到的运算符。
- en: 'Exercise 4.03: Combining Multiple Queries'
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.03：组合多个查询
- en: 'The upcoming edition of the magazine has a special focus on Leonardo''s collaborations
    with director Martin Scorsese. Your task for this exercise is to find the titles
    and release years of drama or crime movies in the production of which Leonardo
    DiCaprio and Martin Scorsese have collaborated. To complete this exercise, you
    will need to use a combination of multiple queries, as detailed in the following steps:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 即将出版的杂志专注于莱昂纳多与导演马丁·斯科塞斯的合作。您的任务是找到戏剧或犯罪电影的标题和发行年，这些电影是莱昂纳多·迪卡普里奥和马丁·斯科塞斯合作制作的。要完成此练习，您需要使用多个查询的组合，如下所述：
- en: 'The first condition is that Leonardo DiCaprio must be one of the actors and
    that Martin Scorsese must be the director. So, you have two conditions that need
    to have an *AND* relationship. As you have seen earlier, the *AND* relationship
    is the default relationship when two queries are combined. Enter the following
    query:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个条件是莱昂纳多·迪卡普里奥必须是其中一位演员，马丁·斯科塞斯必须是导演。因此，您有两个条件需要具有*AND*关系。正如您之前所见，当两个查询组合时，*AND*关系是默认关系。输入以下查询：
- en: '[PRE48]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, there is one more *AND* condition to be added, which is that the movies
    should be of the drama or crime genres. You can easily prepare two filters for
    the genre field: `{"genres" : "Drama"}` and `{"genres" : "Crime"}`. Bring them
    together in an *OR* relationship, as follows:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，还有一个*AND*条件需要添加，即电影应该是戏剧或犯罪类型。您可以轻松地为genre字段准备两个过滤器：`{"genres" : "Drama"}`和`{"genres"
    : "Crime"}`。将它们组合在*OR*关系中，如下所示：'
- en: '[PRE49]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Add the genre filter to the main query:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将genre过滤器添加到主查询中：
- en: '[PRE50]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The preceding query contains all the expected conditions, but you are only
    interested in the title and release year. For this, add the projection part:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前述查询包含所有预期条件，但您只对标题和发行年感兴趣。为此，添加投影部分：
- en: '[PRE51]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Execute the query on a mongo shell. The output should look as follows:![Figure
    4.12: Movies in which Leonardo DiCaprio and Martin Scorsese collaborated'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在mongo shell上执行查询。输出应如下所示：![图4.12：莱昂纳多·迪卡普里奥和马丁·斯科塞斯合作的电影
- en: '](img/B15507_04_12.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_12.jpg)'
- en: 'Figure 4.12: Movies in which Leonardo DiCaprio and Martin Scorsese collaborated'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12：莱昂纳多·迪卡普里奥和马丁·斯科塞斯合作的电影
- en: This output provides the required information; there are four movies that match
    our criteria. The actor and the director last worked together in 2013 on the movie
    *The Wolf of Wall Street*. With that, you have practiced using multiple query
    conditions together with different logical relationships. In the next section,
    you will learn how to query text fields using regular expressions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出提供了所需的信息；有四部符合我们条件的电影。演员和导演最后一次合作是在2013年的电影《华尔街之狼》上。通过这样，您已经练习了如何使用不同的逻辑关系一起使用多个查询条件。在下一节中，您将学习如何使用正则表达式查询文本字段。
- en: Regular Expressions
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: In a real-world movie service, you will want to provide auto-completion search
    boxes where, as soon as the user types in a few characters of the movie title,
    the search box suggests all the movies whose titles match the character sequence
    typed in. This is implemented using regular expressions. A regular expression
    is a special string that defines a character pattern. When such a regular expression
    is used to find string fields, all the strings that have the matching pattern
    are found and returned.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的电影服务中，您会希望提供自动完成搜索框，当用户输入电影标题的几个字符时，搜索框会建议所有标题与输入的字符序列匹配的电影。这是使用正则表达式实现的。正则表达式是一个特殊的字符串，定义了一个字符模式。当这样的正则表达式用于查找字符串字段时，找到并返回所有具有匹配模式的字符串。
- en: 'In MongoDB queries, regular expressions can be used with the `$regex` operator.
    Imagine you have typed the word `Opera` into the search box and want to find all
    the movies whose titles contain this character pattern. The regular expression
    query for this will be as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB查询中，正则表达式可以与`$regex`运算符一起使用。想象一下，你在搜索框中输入了单词`Opera`，想要找到所有标题中包含这个字符模式的电影。这个正则表达式查询将如下所示：
- en: '[PRE52]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Upon executing this query and using projection to print only the titles, the
    result will appear as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此查询并使用投影仅打印标题时，结果将如下所示：
- en: '![Figure 4.13: Movies with titles containing the word “Opera”'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.13：标题中包含单词“Opera”的电影'
- en: '](img/B15507_04_13.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_13.jpg)'
- en: 'Figure 4.13: Movies with titles containing the word "Opera"'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13：标题中包含单词“Opera”的电影
- en: The output from a mongo shell indicates that the regular expression correctly
    returned movies whose title contains the word `Opera`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 来自mongo shell的输出表明，正则表达式正确返回了标题中包含单词`Opera`的电影。
- en: Using the caret (^) operator
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用插入符（^）运算符
- en: 'In the previous example of regular expressions, the titles in the output contained
    the given word `Opera` at any position. To find only the strings that start with
    the given regular expression, the caret operator (`^`) can be used. In the following
    example, you are using it to find only those movies whose titles start with the
    word `Opera`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的正则表达式示例中，输出的标题中包含给定单词`Opera`的任何位置。要仅查找以给定正则表达式开头的字符串，可以使用插入符运算符(`^`)。在下面的示例中，您将使用它来仅查找那些标题以单词`Opera`开头的电影：
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When you execute the preceding query and project the `title` field, you will
    get the following output:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行前述查询并投影`title`字段时，将得到以下输出：
- en: '![Figure 4.14: Projecting only the title field for the preceding query'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.14：仅投影出前述查询的标题字段'
- en: '](img/B15507_04_14.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_14.jpg)'
- en: 'Figure 4.14: Projecting only the title field for the preceding query'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14：仅投影出前述查询的标题字段
- en: The preceding output from a Mongo shell shows that only the movie titles that
    start with the word "Opera" are returned.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Mongo shell的前述输出显示，仅返回了以单词"Opera"开头的电影标题。
- en: Using the dollar ($) operator
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用美元符号（$）运算符
- en: 'Similar to the caret operator, you can also match the strings that end with
    the given regular expression. To do this, use a dollar operator (`$`). In the
    following example, you are trying to find movie titles that end with the word
    "Opera":'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于插入符运算符，您还可以匹配以给定正则表达式结尾的字符串。为此，使用美元运算符（`$`）。在以下示例中，您正在尝试查找以单词“Opera”结尾的电影标题：
- en: '[PRE54]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The preceding query uses the dollar (`$`) operator after the regular expression
    text. When you execute and project the title fields, you will receive the following
    output:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询在正则表达式文本之后使用了美元（`$`）运算符。当您执行并投影标题字段时，您将收到以下输出：
- en: '![Figure 4.15: Movies whose titles end with “Opera”'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.15：标题以“Opera”结尾的电影'
- en: '](img/B15507_04_15.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_15.jpg)'
- en: 'Figure 4.15: Movies whose titles end with "Opera"'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15：标题以“Opera”结尾的电影
- en: Thus, by using the dollar (`$`) operator, we have found all the movie titles
    that end with the word `Opera`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过使用美元（`$`）运算符，我们已经找到了所有以单词`Opera`结尾的电影标题。
- en: Case-Insensitive Search
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不区分大小写搜索
- en: Searching with regular expressions is case-sensitive by default. The casing
    of the characters in the provided search pattern is matched exactly. However,
    quite often, you will want to provide a word or pattern to the regular expression
    and find documents irrespective of their casing. MongoDB provides the `$options`
    operator for this, which can be used for case-insensitive regular expression searches.
    For example, say you want to find all the movies whose titles contain the word
    "the", first in a case-sensitive way and then in a case-insensitive way.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，使用正则表达式进行搜索是区分大小写的。提供的搜索模式中的字符大小写会被精确匹配。然而，通常情况下，您希望提供一个单词或模式给正则表达式，并且不考虑它们的大小写来查找文档。MongoDB为此提供了`$options`运算符，可用于不区分大小写的正则表达式搜索。例如，假设您想要找到所有标题中包含单词“the”的电影，首先是区分大小写的方式，然后是不区分大小写的方式。
- en: 'The following query retrieves the titles containing the word `the` in lowercase:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询检索包含小写单词`the`的标题：
- en: '[PRE55]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The following output in mongo shell shows that this query returns the titles
    containing the word `the` in lowercase:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在mongo shell中的以下输出显示，此查询返回包含小写单词`the`的标题：
- en: '![Figure 4.16: Titles containing the word “the” in lowercase'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.16：包含小写单词“the”的标题'
- en: '](img/B15507_04_16.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_16.jpg)'
- en: 'Figure 4.16: Titles containing the word "the" in lowercase'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16：包含小写单词“the”的标题
- en: 'Now, try the same query with case-insensitive search. To do so, provide the
    `$options` argument with a value of `i`, where `i` stands for case-insensitive:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试使用不区分大小写的搜索进行相同的查询。为此，使用值为`i`的`$options`参数，其中`i`代表不区分大小写：
- en: '[PRE56]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The preceding query uses the same regular expression pattern (`the`) but with
    an additional argument; that is, `$options`. Execute the query along with projection
    on the `title` field:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询使用相同的正则表达式模式（`the`），但带有额外的参数；也就是`$options`。在`title`字段上执行查询并投影：
- en: '![Figure 4.17: Querying for case-insensitive results'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.17：查询不区分大小写的结果'
- en: '](img/B15507_04_17.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_17.jpg)'
- en: 'Figure 4.17: Querying for case-insensitive results'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17：查询不区分大小写的结果
- en: Executing the query and printing the titles shows that the regular expression
    is matched, irrespective of casing. So far, we have learned about querying on
    basic objects. In the next section, we will learn how to query arrays and embedded documents.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 执行查询并打印标题显示，正则表达式匹配，不考虑大小写。到目前为止，我们已经了解了在基本对象上进行查询。在下一节中，我们将学习如何查询数组和嵌套文档。
- en: Query Arrays and Nested Documents
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询数组和嵌套文档
- en: In *Chapter 2*, *Documents and Data Types*, we learned that MongoDB documents
    support complex object structures such as arrays, nested objects, arrays of objects,
    and more. The arrays and nested documents help store self-contained information.
    It is extremely important to have a mechanism to easily search for and retrieve
    the information stored in such complex structures. The MongoDB query language
    allows us to query such complex structures in the most intuitive manner. First,
    we will learn how to run queries on the array elements, and then we will learn
    how to run them on nested object fields.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2章*，*文档和数据类型*中，我们了解到MongoDB文档支持复杂的对象结构，如数组，嵌套对象，对象数组等。数组和嵌套文档有助于存储独立的信息。非常重要的是要有一种机制来轻松搜索和检索存储在这些复杂结构中的信息。MongoDB查询语言允许我们以最直观的方式查询这些复杂结构。首先，我们将学习如何在数组元素上运行查询，然后我们将学习如何在嵌套对象字段上运行查询。
- en: Finding an Array by an Element
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过元素查找数组
- en: 'Querying over an array is similar to querying any other field. In the `movies`
    collection, there are several arrays, and the `cast` field is one of them. Consider
    that, in your movies service, the user wants to find movies starring the actor
    `Charles Chaplin`. To create the query for this search, use an equality check
    on the field, as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组上进行查询类似于查询任何其他字段。在`movies`集合中，有几个数组，`cast`字段是其中之一。考虑到，在您的电影服务中，用户想要查找由演员`查理卓别林`主演的电影。为此搜索创建查询，使用字段上的相等检查，如下所示：
- en: '[PRE57]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'When you execute this query and project only the `cast` field, you''ll get
    the following output:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行此查询并仅投影`cast`字段时，您将获得以下输出：
- en: '![Figure 4.18: Finding movies starring Charles Chaplin'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.18：查找查理卓别林主演的电影'
- en: '](img/B15507_04_18.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_18.jpg)'
- en: 'Figure 4.18: Finding movies starring Charles Chaplin'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18：查找查理卓别林主演的电影
- en: 'Now, imagine the user wants to search for movies with the actors `Charles Chaplin`
    and `Edna Purviance` together. For this query, you will use the `$and` operator:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设��户想要搜索由演员`查理卓别林`和`埃德娜·普尔维亚斯`一起出演的电影。对于此查询，您将使用`$and`运算符：
- en: '[PRE58]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Executing and projecting only the array fields produces the following output:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 执行并仅投影数组字段会产生以下输出：
- en: '![Figure 4.19: Finding movies starring Charles Chaplin and Edna Purviance'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.19：查找查理卓别林和埃德娜·普尔维亚斯主演的电影'
- en: '](img/B15507_04_19.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_19.jpg)'
- en: 'Figure 4.19: Finding movies starring Charles Chaplin and Edna Purviance'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19：查找查理卓别林和埃德娜·普尔维亚斯主演的电影
- en: We can conclude that when an array field is queried using a value, all those
    documents are returned where the array field contains at least one element that
    satisfies the query.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出结论，当使用值查询数组字段时，只要数组字段包含至少一个满足查询条件的元素，就会返回所有这些文档。
- en: Finding an Array by an Array
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过数组查找数组
- en: In the previous examples, we were searching for arrays using the value of an
    element. Similarly, array fields can also be searched using array values. However,
    when you search an array field using an array value, the elements and their order
    must match. Let's try a few examples to demonstrate this.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们使用元素的值搜索数组。同样，也可以使用数组值搜索数组字段。但是，当您使用数组值搜索数组字段时，元素及其顺序必须匹配。让我们尝试一些例子来证明这一点。
- en: 'The documents in the `movies` collection have an array to indicate how many
    languages the movie is available in. Let''s assume that your user wants to find
    movies that are available in both `English` and `German`. Prepare an array of
    both values and query the `languages` field:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`movies` 集合中的文档有一个数组，表示电影可用的语言数量。假设您的用户想要查找可用于`英语`和`德语`的电影。准备一个包含这两个值的数组，并查询`languages`字段：'
- en: '[PRE59]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Print the results while projecting the `languages` and `_id` fields:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在投影`languages`和`_id`字段的同时打印结果：
- en: '![Figure 4.20: Movies available in English and German'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.20：可用英语和德语的电影'
- en: '](img/B15507_04_20.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_20.jpg)'
- en: 'Figure 4.20: Movies available in English and German'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.20：可用英语和德语的电影
- en: The preceding output shows that when we search by using an array, the value
    is matched exactly.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示，当我们使用数组进行搜索时，值会被精确匹配。
- en: 'Now, let''s change the order of the array elements and search again:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们改变数组元素的顺序并再次搜索：
- en: '[PRE60]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Note that this query is the same as the previous one except for the order of
    array elements, which is reversed. You should see the following output:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个查询与之前的查询相同，只是数组元素的顺序不同。您应该看到以下输出：
- en: '![Figure 4.21: Query to demonstrate the impact of the order of array elements'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.21：演示数组元素顺序影响的查询'
- en: '](img/B15507_04_21.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_21.jpg)'
- en: 'Figure 4.21: Query to demonstrate the impact of the order of array elements'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.21：演示数组元素顺序影响的查询
- en: The preceding output shows that by changing the order of the elements in the
    array, different records have been matched.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示，通过改变数组中元素的顺序，不同的记录已经被匹配。
- en: 'This has happened because, when array fields are searched using an array value,
    the value is matched using an equality check. Any two arrays only pass the equality
    check if they have the same elements in the same order. Hence, the following two
    queries are not the same and will return different results:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当使用数组值搜索数组字段时，该值会使用相等检查进行匹配。只有当两个数组具有相同顺序的相同元素时，它们才能通过相等检查。因此，以下两个查询不同，并且将返回不同的结果：
- en: '[PRE61]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The only difference between these two queries is that the second query doesn''t
    contain the last element; that is, `German`. Now, execute both queries in a mongo
    shell and view the output:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个查询之间唯一的区别是第二个查询不包含最后一个元素，即`德语`。现在，在mongo shell中执行这两个查询并查看输出：
- en: '![Figure 4.22: Different queries to demonstrate that array values are matched
    exactly'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.22：不同的查询，演示数组值的精确匹配'
- en: '](img/B15507_04_22.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_22.jpg)'
- en: 'Figure 4.22: Different queries to demonstrate that array values are matched
    exactly'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.22：不同的查询，演示数组值的精确匹配
- en: The preceding output shows both queries executed one after the other and proves
    that the array values are matched exactly.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示，这两个查询依次执行，并证明了数组值的精确匹配。
- en: Searching an Array with the $all Operator
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用$all运算符搜索数组
- en: 'The `$all` operator finds all those documents where the value of the field
    contains all the elements, irrespective of their order or size:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`$all`运算符找到所有那些字段值包含所有元素的文档，无论它们的顺序或大小如何：'
- en: '[PRE62]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The preceding query uses `$all` to find all the movies available in `English`,
    `French`, and `Cantonese`. You will execute this query, along with projection,
    to display only the `languages` field:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的查询使用`$all`来查找所有可用`英语`、`法语`和`粤语`的电影。您将执行此查询，并进行投影，仅显示`languages`字段：
- en: '![Figure 4.23: Query using the $all operator on the languages field'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.23：在`languages`字段上使用$all运算符的查询'
- en: '](img/B15507_04_23.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_23.jpg)'
- en: 'Figure 4.23: Query using the $all operator on the languages field'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.23：在`languages`字段上使用$all运算符的查询
- en: The preceding output indicates that the `$all` operator has matched arrays,
    irrespective of the order and size of the elements.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出表明，`$all`运算符已经匹配了数组，无论元素的顺序和大小如何。
- en: Projecting Array Elements
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 投影数组元素
- en: So far, we have seen that whenever we search an array field, the output always
    contains the complete array. There are a few ways to limit how many elements of
    an array are returned in the query output. We have already practiced projecting
    fields in the resulting documents. Similar to this, elements in an array can also
    be projected. In this section, we will learn how to limit the result set when
    we search with an array field. After this, we will learn how to return specific
    elements from an array based on their index position.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到每当搜索数组字段时，输出总是包含完整的数组。有几种方法可以限制查询输出中返回的数组元素数量。我们已经练习了在结果文档中投影字段。与此类似，数组中的元素也可以被投影。在本节中，我们将学习如何在搜索数组字段时限制结果集。之后，我们将学习如何根据它们的索引位置从数组中返回特定元素。
- en: Projecting Matching Elements Using ($)
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用($)投影匹配的元素
- en: 'You can search an array by an element value and use projection to exclude all
    but the first matching element of the array using the `$` operator. To do this,
    execute a query without the `$` operator first, and then execute it with this
    operator. Prepare a simple element search query, as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过元素值搜索数组，并使用`$`运算符排除数组的除第一个匹配元素之外的所有元素。为此，首先执行一个不带`$`运算符的查询，然后再执行带有此运算符的查询。准备一个简单的元素搜索查询，如下所示：
- en: '[PRE63]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This query uses element search on the `languages` array and projects the field
    to produce the following output:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 该查询在`languages`数组上使用元素搜索，并投影字段以产生以下输出：
- en: '![Figure 4.24: Movies available in the Syriac language'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.24：以叙利亚语提供的电影'
- en: '](img/B15507_04_24.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_24.jpg)'
- en: 'Figure 4.24: Movies available in the Syriac language'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.24：以叙利亚语提供的电影
- en: 'Although the query is intended to find Syriac-language movies, the output array
    contains other languages as well. Now, see what happens when you use the `$` operator:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管查询旨在查找叙利亚语电影，但输出数组中还包含其他语言。现在，看看当您使用`$`运算符时会发生什么：
- en: '[PRE64]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You have modified the query to add the `$` operator in the projection part.
    Now, execute the query, as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经修改了查询，以在投影部分添加`$`运算符。现在，执行查询，如下所示：
- en: '![Figure 4.25: Movies available only in the Syriac language'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.25：仅以叙利亚语提供的电影'
- en: '](img/B15507_04_25.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_25.jpg)'
- en: 'Figure 4.25: Movies available only in the Syriac language'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.25：仅以叙利亚语提供的电影
- en: The array field in the output only contains the matching element; the rest of
    the elements are skipped. Thus, the `languages` array in the output only contains
    the `Syriac` element. The most important thing to remember is that if more than
    one element is matched, the `$` operator projects only the first matching element.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的数组字段仅包含匹配的元素；其余元素被跳过。因此，输出中的`languages`数组仅包含`Syriac`元素。最重要的是要记住，如果匹配了多个元素，`$`运算符只投影第一个匹配的元素。
- en: Projecting Matching Elements by their Index Position ($slice)
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过它们的索引位置投影匹配的元素（$slice）
- en: The `$slice` operator is used to limit the array elements based on their index
    position. This operator can be used with any array field, irrespective of the
    field being queried or not. This means that you may query a different field and
    still use this operator to limit the elements of the array fields.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`$slice`运算符用于基于其索引位置限制数组元素。该运算符可以与任何数组字段一起使用，无论是否正在查询该字段。这意味着您可以查询不同的字段，仍然可以使用该运算符来限制数组字段的元素。'
- en: 'To see this, we will use the movie `Youth Without Youth` as an example, which
    has 11 elements in the `languages` array. The following output from the mongo
    shell shows what the array field looks like in the movie record:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这一点，我们将以电影《青春无敌》为例，该电影的`languages`数组中有11个元素。来自mongo shell的以下输出显示了电影记录中的数组字段的样子：
- en: '![Figure 4.26: List of languages for the movie Youth Without Youth'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.26：电影《青春无敌》的语言列表'
- en: '](img/B15507_04_26.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_26.jpg)'
- en: 'Figure 4.26: List of languages for the movie Youth Without Youth'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.26：电影《青春无敌》的语言列表
- en: 'In the following query, use `$slice` to print only the first three elements
    of the array:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的查询中，使用`$slice`仅打印数组的前三个元素：
- en: '[PRE65]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The output for the preceding query shows that the `languages` field only contains
    the first three elements, as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 前面查询的输出显示，`languages`字段仅包含前三个元素。
- en: '[PRE66]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `$slice` operator can be used in a few more ways. The following projection
    expression will return the last two elements of the array:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`$slice`运算符可以以更多方式使用。以下投影表达式将返回数组的最后两个元素：'
- en: '[PRE67]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The following output shows that the array has been sliced down to the last
    two elements only:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示数组已被切片为仅包含最后两个元素：
- en: '[PRE68]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `$slice` operator can also be passed with two arguments, where the first
    argument indicates the number of elements to be skipped and the second one indicates
    the number of elements to be returned. For example, the following projection expression
    will skip the first two elements of the array and return the next four elements
    after it:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`$slice`运算符也可以传递两个参数，其中第一个参数表示要跳过的元素数，第二个参数表示要返回的元素数。例如，以下投影表达式将跳过数组的前两个元素，并返回其后的四个元素：'
- en: '[PRE69]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'When we execute this query, we get the following output:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此查询时，我们得到以下输出：
- en: '[PRE70]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The two-argument slice can also be used with a negative value for skip. For
    example, in the following projection expression, the first number is negative.
    If the value of skip is negative, the counting starts from the end. So, in the
    following expression, five elements counting from the last index will be skipped
    and four elements starting from that index will be returned:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 两参数切片也可以使用负值进行跳过。例如，在以下投影表达式中，第一个数字是负数。如果跳过的值是负数，则计数从末尾开始。因此，在以下表达式中，将跳过从最后一个索引开始的五个元素，并返回从该索引开始的四个元素：
- en: '[PRE71]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Note that because of the negative skip value, the skip index will be calculated
    from the last index. Skipping five elements from the last index gives us `Romanian`
    and from this index position, the next four elements will be returned, as shown
    here:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于负的跳过值，跳过索引将从最后一个索引计算。从最后一个索引跳过五个元素得到`Romanian`，并且从该索引位置开始，将返回接下来的四个元素，如下所示：
- en: '[PRE72]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In this section, we have covered how to query array fields and how to project
    the results in various ways. In the next section, we will learn how to query nested
    objects.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经介绍了如何查询数组字段以及如何以各种方式投影结果。在下一节中，我们将学习如何查询嵌套对象。
- en: Querying Nested Objects
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询嵌套对象
- en: 'Similar to arrays, nested or embedded objects can also be represented as values
    of a field. Hence, fields that have other objects as their values can be searched
    using the complete object as a value. In the `movies` collection, there is a field
    named `awards` whose value is a nested object. The following snippet shows the
    `awards` object for a random movie in the collection:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组类似，嵌套或嵌入式对象也可以表示为字段的值。因此，具有其他对象作为其值的字段可以使用完整对象作为值进行搜索。在`movies`集合中，有一个名为`awards`的字段，其值是一个嵌套对象。以下片段显示了集合中某个随机电影的`awards`对象：
- en: '[PRE73]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The following query finds the `awards` object by providing the complete object
    as its value:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询通过提供完整对象作为其值来查找`awards`对象：
- en: '[PRE74]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The following output shows that there are several movies whose `awards` field
    has an exact value of `{"wins": 1, "nominations": 0, "text": "1 win."}`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '以下输出显示，有几部电影的`awards`字段的确切值为`{"wins": 1, "nominations": 0, "text": "1 win."}`：'
- en: '![Figure 4.27: List of movies without a nomination and one award'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.27：没有提名和一项奖项的电影列表'
- en: '](img/B15507_04_27.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_27.jpg)'
- en: 'Figure 4.27: List of movies without a nomination and one award'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.27：没有提名和一项奖项的电影列表
- en: 'When nested object fields are searched with object values, there must be an
    exact match. This means that all the field-value pairs, along with the order of
    the fields, must match exactly. For example, consider the following query:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用对象值搜索嵌套对象字段时，必须有精确匹配。这意味着所有字段-值对以及字段的顺序必须完全匹配。例如，请考虑以下查询：
- en: '[PRE75]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This query has a change in order regarding the query object; hence, it will
    return an empty result.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询在查询对象方面有一个顺序变化；因此，它将返回一个空结果。
- en: Querying Nested Object Fields
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询嵌套对象字段
- en: 'In *Chapter 2*, *Documents and Data Types*, we saw that fields of nested objects
    can be accessed using dot (`.`) notation. Similarly, dot notation can be used
    to search nested objects by providing the values of its fields. For example, to
    find movies that have won four awards, you can use dot notation like so:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2章*，*文档和数据类型*中，我们看到可以使用点（`.`）表示法访问嵌套对象的字段。类似地，可以使用点表示法通过提供其字段的值来搜索嵌套对象。例如，要查找获得四项奖项的电影，可以使用点表示法如下：
- en: '[PRE76]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The preceding query uses dot (`.`) notation on the `awards` field and refers
    to the nested field named `wins`. When you execute the query and project only
    the `awards` field, you get the following output:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询在`awards`字段上使用点（`.`）表示法，并引用名为`wins`的嵌套字段。当您执行查询并仅投影`awards`字段时，您将获得以下输出：
- en: '![Figure 4.28: Projecting only the awards field for preceding snippet'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.28：仅为上述片段投影奖项字段'
- en: '](img/B15507_04_28.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_28.jpg)'
- en: 'Figure 4.28: Projecting only the awards field for preceding snippet'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.28：仅为上述片段投影奖项字段
- en: The preceding output indicates that the filter has been correctly applied to
    `wins` and that all the movies that have exactly four awards are returned.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出表明筛选已正确应用于`wins`，并返回了所有获得四项奖项的电影。
- en: 'The nested field search is performed independently on the given fields, irrespective
    of the order of the elements. You can search by multiple fields and use any of
    the conditional or logical query operators. For example, refer to the following
    query:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套字段搜索是独立执行的，不考虑元素的顺序。您可以通过多个字段进行搜索，并使用任何条件或逻辑查询运算符。例如，请参考以下查询：
- en: '[PRE77]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This query uses a combination of two conditions on two different nested fields.
    Upon executing the query while excluding the rest of the fields, you should see
    the following output:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询在两个不同的嵌套字段上组合了两个条件。在执行查询时排除其他字段，您应该看到以下输出：
- en: '![Figure 4.29: Movies with six nominations and a minimum of five awards'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.29：获得六项提名和至少五项奖项的电影'
- en: '](img/B15507_04_29.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_29.jpg)'
- en: 'Figure 4.29: Movies with six nominations and a minimum of five awards'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.29：获得六项提名和至少五项奖项的电影
- en: This query performs a search on two fields using conditional operators and returns
    movies that have six nominations and have won at least five awards. Like array
    elements or any field in a document, nested object fields can also be projected
    as we want. We will explore this in detail in the next exercise.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询使用条件运算符在两个字段上进行搜索，并返回了获得六项提名并至少获得五项奖项的电影。与数组元素或文档中的任何字段一样，嵌套对象字段也可以按我们的要求进行投影。我们将在下一个练习中详细探讨这一点。
- en: 'Exercise 4.04: Projecting Nested Object Fields'
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.04：投影嵌套对象字段
- en: 'In this exercise, you will learn how to project only certain fields from nested
    objects. The following steps will help you implement this exercise:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将学习如何仅从嵌套对象中投影特定字段。以下步骤将帮助您实施这个练习：
- en: 'Open a mongo shell and connect to the `sample_mflix` database on Mongo Atlas.
    Enter the following query to return all the records and project only the `awards`
    field, which is an embedded object:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开mongo shell并连接到Mongo Atlas上的`sample_mflix`数据库。输入以下查询以返回所有记录并仅投影`awards`字段，这是一个嵌入对象：
- en: '[PRE78]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The following output shows that only the `awards` field has been included in
    the result, while the rest of the fields (including `_id`) have been excluded:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示，结果中仅包括`awards`字段，而其他字段（包括`_id`）已被排除：
- en: '![Figure 4.30: Projecting only the awards field for a query'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.30：仅为查询投影奖项字段'
- en: '](img/B15507_04_30.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_30.jpg)'
- en: 'Figure 4.30: Projecting only the awards field for a query'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.30：仅为查询投影奖项字段
- en: 'To project only specific fields from embedded objects, you can refer to a field
    of an embedded object using dot notation. Type in the following query:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要仅从嵌入对象中投影特定字段，可以使用点表示法引用嵌入对象的字段。输入以下查询：
- en: '[PRE79]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'When you execute this query on a mongo shell, the output will look like this:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在mongo shell上执行此查询时，输出将如下所示：
- en: '![Figure 4.31: Projecting only the awards object, without the text field'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.31：仅投影奖项对象，不包括文本字段'
- en: '](img/B15507_04_31.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_31.jpg)'
- en: 'Figure 4.31: Projecting only the awards object, without the text field'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.31：仅投影奖项对象，不包括文本字段
- en: The preceding output shows that only two of the nested fields are included in
    the response. The `awards` object in the output is still a nested object, but
    the `text` field has been excluded.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出显示响应中仅包括两个嵌套字段。输出中的`awards`对象仍然是一个嵌套对象，但已排除了`text`字段。
- en: So far, we have seen how nested objects and their fields can be limited in the
    output. This concludes our discussion on querying arrays and nested objects in
    MongoDB. In the next section, we will learn how to skip, limit, and sort documents.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何在输��中限制嵌套对象及其字段。这结束了我们对在MongoDB中查询数组和嵌套对象的讨论。在下一节中，我们将学习如何跳过、限制和排序文档。
- en: Limiting, Skipping, and Sorting Documents
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制、跳过和排序文档
- en: So far, we have learned how to write basic and complex queries and to project
    fields in the resulting documents. In this section, you will learn how to control
    the number and order of documents returned by a query.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学会了如何编写基本和复杂的查询，并在结果文档中投影字段。在本节中，您将学习如何控制查询返回的文档数量和顺序。
- en: Let's talk about why the amount of data a query returns needs to be controlled.
    In most real-world cases, you won't be using all the documents your query matches
    to. Imagine that a user of our movie service is planning to watch a drama movie
    tonight. They will visit the movie store and search for drama movies and find
    that there are more than 13,000 of these in the collection. With such a large
    search result, they might spend the entire night just looking through the various
    movies and deciding which one to watch.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈为什么需要控制查询返回的数据量。在大多数实际情况下，您不会使用查询匹配的所有文档。想象一下，我们电影服务的用户计划今晚观看一部戏剧电影。他们将访问电影商店，搜索戏剧电影，并发现收藏中有超过13,000部这样的电影。有了如此庞大的搜索结果，他们可能会花费整个晚上浏览各种电影，并决定要观看哪一部。
- en: For a better user experience, you may want to show the 10 most popular movies
    in the drama category at a time, followed by the next 10 in the sequence, and
    so on. This technique of serving data is known as pagination. This is where a
    large result is divided into small chunks (also known as pages) and only one page
    is served at a time. Pagination not only improves the user experience, but also
    the overall performance of the system, and reduces the overhead on a database,
    network, or a user's browser or mobile application. To implement pagination, you
    must be able to limit the size of result, skip the already served records, and
    have them served in a definite order. In this section, we will practice all three
    of these techniques.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供更好的用户体验，您可能希望一次显示戏剧类别中最受欢迎的10部电影，然后是序列中的下一个10部电影，依此类推。这种提供数据的技术称为分页。这是将大量结果分成小块（也称为页面），并一次只提供一页的技术。分页不仅提高了用户体验，还提高了系统的整体性能，并减少了对数据库、网络或用户的浏览器或移动应用程序的开销。要实现分页，您必须能够限制结果的大小，跳过已提供的记录，并以明确的顺序提供它们。在本节中，我们将练习这三种技术。
- en: Limiting the Result
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制结果
- en: To limit the number of records a query returns, the resulting cursor provides
    a function called `limit()`. This function accepts an integer and returns the
    same number of records, if available. MongoDB recommends the use of this function
    as it reduces the number of records that result from the cursor and improves the
    speed.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 为了限制查询返回的记录数量，结果游标提供了一个名为`limit()`的函数。如果可用，此函数接受一个整数并返回相同数量的记录。MongoDB建议使用此函数，因为它减少了游标产生的记录数量，并提高了速度。
- en: 'To print the titles of movies starring `Charles Chaplin`, enter the following
    query, which finds the actor''s name in the `cast` field:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印出主演`查理·卓别林`的电影的标题，请输入以下查询，在`cast`字段中查找演员的姓名：
- en: '[PRE80]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The query is also adding a projection to the `title` field. When you execute
    the query, you will see the following output:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 该查询还向`title`字段添加了投影。当您执行查询时，将看到以下输出：
- en: '![Figure 4.32: Output showing movies starring Charles Chaplin'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.32：显示查理·卓别林主演电影的输出'
- en: '](img/B15507_04_32.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_32.jpg)'
- en: 'Figure 4.32: Output showing movies starring Charles Chaplin'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.32：显示查理·卓别林主演电影的输出
- en: 'As can be seen, there are a total of eight movies that `Charles Chaplin` has
    acted in. Next, you will use the limit function to restrict the result size to
    `3`, as follows:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，查理·卓别林一共出演了八部电影。接下来，您将使用limit函数将结果大小限制为`3`，如下所示：
- en: '[PRE81]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'When this query is executed, only three records are returned:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此查询时，只返回三条记录：
- en: '![Figure 4.33: Using limit() to show only three movies starring Charles Chaplin'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.33：使用limit()仅显示查理·卓别林主演的三部电影'
- en: '](img/B15507_04_33.jpg)'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_33.jpg)'
- en: 'Figure 4.33: Using limit() to show only three movies starring Charles Chaplin'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.33：使用limit()仅显示查理·卓别林主演的三部电影
- en: Let's look at the behavior of the `limit()` function when it's used with different values.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当与不同值一起使用时，`limit()`函数的行为。
- en: 'When the limit size is larger than the actual records within the cursor, all
    the records will be returned, irrespective of the set limit. For example, the
    following query will return `8` records, even when the limit is set to `14`, as
    there are only `8` records present in the cursor:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 当限制大小大于游标内实际记录时，将返回所有记录，而不管设置的限制如何。例如，以下查询将返回`8`条记录，即使将限制设置为`14`，因为游标中只有`8`条记录：
- en: '[PRE82]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The preceding query results in the following output, which shows that the query
    has returned all eight records:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询的结果如下，显示查询已返回所有八条记录：
- en: '![Figure 4.34: Output when limit is set to 14'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.34：当限制设置为14时的输出'
- en: '](img/B15507_04_34.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_34.jpg)'
- en: 'Figure 4.34: Output when limit is set to 14'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.34：当限制设置为14时的输出
- en: 'Note that setting the limit to zero is equivalent to not setting any limit
    at all. The following query will therefore return all eight records that match
    the criteria:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，将限制设置为零相当于根本不设置任何限制。因此，以下查询将返回符合条件的所有八条记录：
- en: '[PRE83]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The output of the preceding query is as follows:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询的输出如下：
- en: '![Figure 4.35: Output when limit is set to 0'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.35：当限制设置为0时的输出'
- en: '](img/B15507_04_35.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_35.jpg)'
- en: 'Figure 4.35: Output when limit is set to 0'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.35：当限制设置为0时的输出
- en: 'Now, are you wondering what will happen if the limit size is set to a negative
    number? For queries returning smaller records, as in our case, a negative size
    limit is considered equivalent to the limit of a positive number. The following
    query demonstrates this:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您是否想知道如果将限制大小设置为负数会发生什么？对于返回较小记录的查询，如我们的情况，负大小限制被视为等同于正数限制。以下查询演示了这一点：
- en: '[PRE84]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'When you execute this query (which has a negative limit of -`2` on a mongo
    shell), you should get the following output:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行此查询（在mongo shell上具有负限制-`2`），您应该获得以下输出：
- en: '![Figure 4.36: Output when limit is -2'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.36：当限制设置为-2时的输出'
- en: '](img/B15507_04_36.jpg)'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_36.jpg)'
- en: 'Figure 4.36: Output when limit is -2'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.36：限制为-2时的输出
- en: The output shows that the query returned two documents and the behavior is equivalent
    to using `limit` of size `2`. However, the result set's batch size can affect
    this behavior. The next section will explore this in detail.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，查询返回了两个文档，行为等同于使用大小为`2`的`limit`。然而，结果集的批处理大小可能会影响这种行为。下一节将详细探讨这一点。
- en: Limit and Batch Size
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制和批处理大小
- en: When a query is executed in MongoDB, the results are processed and returned
    in the form of one or more batches. The batches are allotted internally, and the
    results will be displayed all at once. One of the main purposes of batching is
    to avoid high resource utilization, which may happen while processing a large
    number of record sets.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中执行查询时，结果以一个或多个批次的形式进行处理和返回。批次在内部分配，结果将一次性显示。批处理的主要目的之一是避免在处理大量记录集时发生高资源利用。
- en: Also, it keeps the connection between the client and server active, because
    of which timeout errors are avoided. For large queries, when the database takes
    longer to find and return the result, the client just keeps on waiting. After
    a certain threshold value for waiting is reached, the connection between the client
    and server is broken and the query is failed with a timeout exception. Using batching
    avoids such timeouts as the server keeps retuning the individual batches continuously.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它保持了客户端和服务器之间的连接活动，因此避免了超时错误。对于大型查询，当数据库需要更长时间来查找和返回结果时，客户端会一直等待。当等待的阈值达到一定值时，客户端和服务器之间的连接会断开，并且查询将因超时异常而失败。使用批处理可以避免这种超时，因为服务器会持续返回单个批次。
- en: 'Different MongoDB drivers can have different batch sizes. However, for a single
    query, the batch size can be set, as shown in the following snippet:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的MongoDB驱动程序可以有不同的批处理大小。然而，对于单个查询，可以设置批处理大小，如下面的代码片段所示：
- en: '[PRE85]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This query uses the `batchSize()` function on the cursor to provide a batch
    size of `5`. The output of executing this query is as follows:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询在游标上使用了`batchSize()`函数，提供了批处理大小为`5`。执行此查询的输出如下：
- en: '![Figure 4.37: Output when batch size is 5'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.37：批处理大小为5时的输出'
- en: '](img/B15507_04_37.jpg)'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_37.jpg)'
- en: 'Figure 4.37: Output when batch size is 5'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.37：批处理大小为5时的输出
- en: The query in the preceding output adds a batch size of `5`, but it has no effect
    on the output. However, there was a difference in how the results were prepared
    internally.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出中的查询添加了批处理大小为`5`，但对输出没有影响。然而，结果的内部准备方式有所不同。
- en: Positive Limit with Batch Size
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 批处理大小的正限制
- en: When the preceding query is executed, which specifies a batch size of `5`, the
    database starts finding the documents that match the given condition. As soon
    as the first five documents are found, they are returned to the client as the
    first batch. Next, the remaining three records are found and returned as the next
    batch. However, for the users, the results are printed at once and the change
    is unnoticeable.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行上述查询时，指定了批处理大小为`5`，数据库开始查找符合给定条件的文档。一旦找到前五个文档，它们作为第一个批次返回给客户端。接下来，剩下的三条记录被找到并作为下一个批次返回。然而，对于用户来说，结果一次性打印出来，变化是不可察觉的。
- en: 'The same thing happens when a query is executed with a positive limit that
    is larger than the batch size and the records are internally fetched in multiple
    batches:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用大于批处理大小的正限制执行查询时，记录在内部被分批获取时也会发生同样的情况：
- en: '[PRE86]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This query uses a limit of `7`, which is larger than the provided batch size
    of `5`. When the query is executed, we get the expected `7` records, without any
    noticeable changes. The following screenshot shows the output:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询使用了大于提供的批处理大小`5`的限制`7`。当执行查询时，我们得到了预期的`7`条记录，没有任何显著变化。以下截图显示了输出：
- en: '![Figure 4.38: Output when limit is 7 and batch size is 5'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.38：当限制为7且批处理大小为5时的输出'
- en: '](img/B15507_04_38.jpg)'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_38.jpg)'
- en: 'Figure 4.38: Output when limit is 7 and batch size is 5'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.38：当限制为7且批处理大小为5时的输出
- en: So far, we have learned how to perform batching without specifying a limit,
    and then specifying a positive limit value. Now, we will see what happens when
    we use a negative limit value, whose positive equivalent is larger than the given
    batch size.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学会了如何在不指定限制的情况下执行批处理，然后指定正限制值。现在，我们将看看当使用负限制值时会发生什么，其正等效值大于给定的批处理大小。
- en: Negative Limits and Batch Size
  id: totrans-464
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 负限制和批处理大小
- en: As we learned in the previous examples, MongoDB uses batches if the total number
    of records in the result exceeds the batch size. However, when we use a negative
    number to specify the limit size, only the first batch is returned and the next
    batch, even if it is required, will not be processed.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的例子中学到的，如果结果中的记录总数超过批处理大小，MongoDB会使用批处理。然而，当我们使用负数来指定限制大小时，只有第一个批次会被返回，即使需要下一个批次也不会被处理。
- en: 'We will demonstrate this by using the following query:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下查询来演示这一点：
- en: '[PRE87]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This query uses a limit of negative `7` and batch of `5`, which means it should
    take two batches to return the results. To observe this behavior, execute this
    query on a mongo shell:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询使用了负数`7`的限制和`5`的批处理大小，这意味着返回结果需要两个批次。为了观察这种行为，在mongo shell上执行此查询：
- en: '![Figure 4.39: Output when limit is -7 and batch size is 5'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.39：当限制为-7且批处理大小为5时的输出'
- en: '](img/B15507_04_39.jpg)'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_39.jpg)'
- en: 'Figure 4.39: Output when limit is -7 and batch size is 5'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.39：当限制为-7且批处理大小为5时的输出
- en: The output indicates that the query returned only the first five records instead
    of the expected seven records. This is because the database returned only the
    first batch and the next batch was not processed.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明，查询只返回了前五条记录，而不是预期的七条记录。这是因为数据库只返回了第一个批次，而下一个批次没有被处理。
- en: This proves that the negative limit is not exactly equivalent to providing the
    number in positive form. The results will be the same if the number of records
    returned by the query is smaller than the specified batch size. In general, you
    should avoid using a negative limit, but if you do, make sure to use an appropriate
    batch size so that such scenarios can be avoided.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了负限制并不完全等同于以正数形式提供数字。如果查询返回的记录数小于指定的批量大小，结果将是相同的。一般来说，应避免使用负限制，但如果使用了负限制，确保使用适当的批量大小，以避免这种情况。
- en: Skipping Documents
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳过文档
- en: 'Skipping is used to exclude some documents in the result set and return the
    rest. The MongoDB cursor provides the `skip()` function, which accepts an integer
    and skips the specified number of documents from the cursor, returning the rest.
    In the previous examples, you prepared queries to find the titles of movies starring
    Charles Chaplin. The following example uses the same query with the `skip()` function:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过用于排除结果集中的一些文档并返回其余文档。MongoDB游标提供了`skip()`函数，它接受一个整数，并从游标中跳过指定数量的文档，然后返回其余文档。在前面的示例中，您准备了查询，以查找查尔斯·卓别林主演的电影的标题。以下示例使用相同的查询和`skip()`函数：
- en: '[PRE88]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Since the `skip()` function has been provided with the value `2`, the first
    two documents will be excluded from the output, as shown in the following screenshot:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`skip()`函数已经提供了值`2`，所以前两个文档将被排除在输出之外，如下面的屏幕截图所示：
- en: '![Figure 4.40: Output with a skip value of 2'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.40：带有跳过值2的输出'
- en: '](img/B15507_04_40.jpg)'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_40.jpg)'
- en: 'Figure 4.40: Output with a skip value of 2'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.40：带有跳过值2的输出
- en: 'Similar to `limit()`, passing zero to `skip()` is equivalent to not calling
    the function at all, and the entire result set is returned. However, `skip()`
    has a different behavior for negative numbers; it does not allow the use of negative
    numbers. Thus, the following query is invalid:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 与`limit()`类似，将零传递给`skip()`等同于根本不调用该函数，并且返回整个结果集。但是，`skip()`对于负数有不同的行为；它不允许使用负数。因此，以下查询是无效的：
- en: '[PRE89]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'When you execute this query, you''ll get an error, as shown in the following screenshot:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此查询时，将会收到错误提示，如下图所示：
- en: '![Figure 4.41: Output with a skip value of -3'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.41：带有跳过值-3的输出'
- en: '](img/B15507_04_41.jpg)'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_41.jpg)'
- en: 'Figure 4.41: Output with a skip value of -3'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.41：带有跳过值-3的输出
- en: The `skip()` operation does not make use of any indexes, so it performs nicely
    on a smaller collection but may lag noticeably on larger collections. We will
    cover the topic of indexing in detail in *Chapter 9*, *Performance*.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '`skip()`操作不使用任何索引，因此在较小的集合上表现良好，但在较大的集合上可能明显滞后。我们将在*第9章* *性能*中详细介绍索引的主题。'
- en: Sorting Documents
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序文档
- en: Sorting is used to return documents in a specified order. Without using explicit
    sorting, MongoDB does not guarantee the order in which the documents will be returned,
    which may vary, even if the same query is executed twice. Having a specific sort
    order is important, especially during pagination. During pagination, we execute
    the query with a specified limit and serve. For the next query, the previous records
    are skipped, and the next limit is returned. During this process, if the order
    of the records changes, some movies may appear on multiple pages and some movies
    may not appear at all.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 排序用于按指定顺序返回文档。如果不使用显式排序，MongoDB不保证以何种顺序返回文档，即使执行相同的查询两次，结果也可能不同。具有特定排序顺序在分页期间尤为重要。在分页期间，我们执行带有指定限制和服务的查询。对于下一个查询，跳过之前的记录，并返回下一个限制。在此过程中，如果记录的顺序发生变化，一些电影可能会出现在多个页面上，而一些电影可能根本不会出现。
- en: 'The MongoDB cursor provides a `sort()` function that accepts an argument of
    the document type, where the document defines a sort order for specific fields.
    See the following query, which prints Charles Chaplin''s movie titles with a sort
    option:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB游标提供了一个`sort()`函数，接受一个文档类型的参数，其中文档定义了特定字段的排序顺序。请参见以下查询，它打印出了查尔斯·卓别林的电影标题和排序选项：
- en: '[PRE90]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In the preceding query, you are calling the `sort()` function on the resulting
    cursor. The argument to the function is a document where the `title` field has
    a value of `1`. This specifies that the given field should be sorted in ascending
    order. When the query is executed after it''s been sorted, the results are evident,
    as follows:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述查询中，您正在对结果游标调用`sort()`函数。函数的参数是一个文档，其中`title`字段的值为`1`。这指定给定字段应按升序排序。当查询在排序后执行时，结果如下所示：
- en: '![Figure 4.42: Sorting in ascending order'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.42：按升序排序'
- en: '](img/B15507_04_42.jpg)'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_42.jpg)'
- en: 'Figure 4.42: Sorting in ascending order'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.42：按升序排序
- en: 'Now, pass `-1` to the `sort` argument, which represents sorting in descending
    order:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将`-1`传递给`sort`参数，表示按降序排序：
- en: '[PRE91]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The output for this is as follows:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 其输出如下：
- en: '![Figure 4.43: Sorting in descending order'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.43：按降序排序'
- en: '](img/B15507_04_43.jpg)'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_43.jpg)'
- en: 'Figure 4.43: Sorting in descending order'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.43：按降序排序
- en: 'Sorting can be performed on multiple fields, and each field can have a different
    sorting order. Let''s look at an example that sorts the IMDb ratings of movies
    in descending order, and the year by ascending order. The query should return
    50 movies where the movie with the highest IMDb rating appearing at the top. If
    two movies have the same ratings, then the older movie should take precedence.
    The following query can be used to implement this:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 排序可以在多个字段上执行，并且每个字段可以有不同的排序顺序。让我们看一个例子，按照降序对电影的IMDb评分进行排序，按照升序对年份进行排序。查询应该返回50部电影，其中IMDb评分最高的电影出现在顶部。如果两部电影的评分相同，那么年份较早的电影应该优先。可以使用以下查询来实现这一点：
- en: '[PRE92]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Before we conclude this section, it is worth noting that any number other than
    a positive or negative integer, including zero, is considered invalid for sorting
    in MongoDB. If such a value is used, the query fails and we see the message `"bad
    sort specification error"`, shown as follows:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本节之前，值得注意的是，在MongoDB中，除了正整数或负整数之外的任何数字，包括零，都被视为无效的排序值。如果使用这样的值，查询将失败，我们会看到消息“bad
    sort specification error”，如下所示：
- en: '[PRE93]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: In the next activity, we will use everything we've learned in this chapter to
    implement pagination for a genre-based movie search.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个活动中，我们将运用本章学到的一切知识来实现基于流派的电影搜索的分页。
- en: 'Activity 4.01: Finding Movies by Genre and Paginating Results'
  id: totrans-507
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动4.01：按流派查找电影并分页显示结果
- en: Your organization is planning to provide a new feature to its users where they
    will be able to find movies in their favorite genre. Since the movies database
    is huge, there's a lot of movies from each genre, and returning all the matching
    movie titles is not very useful. The requirement is to serve the results in small
    chunks.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 您的组织计划为用户提供一个新功能，他们将能够在他们喜爱的流派中找到电影。由于电影数据库庞大，每个流派都有大量电影，返回所有匹配的电影标题并不是非常有用。要求是以小块的方式提供结果。
- en: 'Your task for this activity is to create a JavaScript function on the mongo
    shell. The function should accept a genre of the user''s choice and print all
    the matching titles, where the titles with the highest IMDb ratings should appear
    at the top. Along with the genre, the function will accept two more parameters
    for the page size and page number. The page size defines how many records need
    to be displayed on one page, while the page number indicates which page the user
    is currently on. The following steps will help you complete this activity:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 您在此活动中的任务是在mongo shell上创建一个JavaScript函数。该函数应接受用户选择的流派，并打印所有匹配的标题，其中具有最高IMDb评分的标题应出现在顶部。除了流派，该函数还将接受另外两个参数，用于页面大小和页面编号。页面大小定义了一页上需要显示多少条记录，而页面编号表示用户当前所在的页面。以下步骤将帮助您完成此活动：
- en: 'Write a `findMoviesByGenre` function that accepts three arguments: `genre`,
    `pageNumber`, and `pageSize`:'
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`findMoviesByGenre`函数，接受三个参数：`genre`、`pageNumber`和`pageSize`：
- en: '[PRE94]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Write a query to filter the result based on `genre` and return the titles.
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个查询，根据`genre`过滤结果并返回标题。
- en: Sort the results to show the highest rated movies at the top.
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对结果进行排序，以显示评分最高的电影。
- en: Use the logic of skipping and limiting the results using the `pageNumber` and
    `pageSize` parameters.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pageNumber`和`pageSize`参数跳过和限制结果的逻辑。
- en: Convert the result cursor into an array using the `toArray()` method.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`toArray()`方法将结果游标转换为数组。
- en: Iterate through the resulting array and print all the titles.
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历结果数组并打印所有标题。
- en: Create the function in the mongo shell by copying and pasting it into the shell
    and executing it.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将其复制粘贴到shell并执行，可以在mongo shell中创建该函数。
- en: 'Consider that the genre provided by the user is `Action`. Here, as shown in
    the following output, the function is executed and shows the first page of results,
    showing the top five action movies:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑用户提供的流派是`动作`。在这里，如下所示，执行函数并显示结果的第一页，显示前五部动作电影：
- en: '![Figure 4.44: First page showing the top five action movies'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.44：显示前五部动作电影的第一页'
- en: '](img/B15507_04_44.jpg)'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_44.jpg)'
- en: 'Figure 4.44: First page showing the top five action movies'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.44：显示前五部动作电影的第一页
- en: 'Similarly, the following output shows the function returning the second page
    of five action movies:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，下面的输出显示函数返回了第二页的五部动作电影：
- en: '![Figure 4.45: Second page of action movies'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.45：动作电影的第二页'
- en: '](img/B15507_04_45.jpg)'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_04_45.jpg)'
- en: 'Figure 4.45: Second page of action movies'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.45：动作电影的第二页
- en: Note
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15507_Solution_Final_SZ_ePub.xhtml#_idTextAnchor467).
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以通过[此链接](B15507_Solution_Final_SZ_ePub.xhtml#_idTextAnchor467)找到。
- en: Summary
  id: totrans-528
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter with a detailed study of the structure of MongoDB queries
    and how different they are from SQL queries. Then, we implemented these queries
    to find and count the documents and limit the number of fields returned in the
    result using various examples. We also learned about the various conditional and
    logical operators and practiced using them in combination to notice the difference
    in results.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从详细研究了MongoDB查询的结构以及它们与SQL查询的不同之处开始了本章。然后，我们实现了这些查询来查找和计算文档，并使用各种示例限制返回结果中的字段数量。我们还学习了各种条件和逻辑运算符，并练习将它们结合使用以注意结果的差异。
- en: We then learned how to provide a text pattern using regular expressions to filter
    our search results, and covered how to query arrays and nested objects and include
    their specific fields in the results. Finally, we learned how to paginate large
    result sets by using limiting, sorting, and skipping on the documents in the result.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了如何使用正则表达式提供文本模式来过滤我们的搜索结果，并介绍了如何查询数组和嵌套对象，并在结果中包含它们的特定字段。最后，我们学习了如何通过在结果中对文档进行限制、排序和跳过来分页大型结果集。
- en: In the next chapter, we will learn how to insert, update, and delete documents
    from MongoDB collections.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何向MongoDB集合中插入、更新和删除文档。
