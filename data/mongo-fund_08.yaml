- en: 8\. Coding JavaScript in MongoDB
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. 在MongoDB中编写JavaScript代码
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn how to read, understand, and create simple MongoDB
    applications using the Node.js driver. These applications will help you to programmatically
    fetch, update, and create data in your MongoDB collections, as well as to handle
    errors and user inputs. By the end of this chapter, you will be able to create
    a simple application built on top of MongoDB.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用Node.js驱动程序阅读、理解和创建简单的MongoDB应用程序。这些应用程序将帮助您以编程方式获取、更新和创建MongoDB集合中的数据，以及处理错误和用户输入。在本章结束时，您将能够创建一个简单的基于MongoDB的应用程序。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: So far, we have interacted directly with the MongoDB database using the mongo
    shell. These direct interactions are quick, easy, and a fantastic way to learn
    or experiment with MongoDB features. However, in many production situations, it
    will be software that connects with the database in place of the user. MongoDB
    is a great place to store and query your data, but often, it's most essential
    use is to serve as a backend for large-scale applications. These applications
    write, read, and update data programmatically, usually after being triggered by
    some condition or user interface.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们直接使用mongo shell与MongoDB数据库进行了交互。这些直接的交互快速、简单，是学习或实验MongoDB功能的绝佳方式。然而，在许多生产情况下，将是软件代替用户连接到数据库。MongoDB是一个很好的存储和查询数据的地方，但通常，它最重要的用途是作为大规模应用程序的后端。这些应用程序通常在某些条件或用户界面触发后以编程方式写入、读取和更新数据。
- en: To connect your software with a database, you will typically use a library (often
    provided by the database creator) known as a driver. This driver will help you
    connect, analyze, read, and write to your database without having to write multiple
    lines of code for simple actions. It provides functions and abstractions for common
    use cases, as well as frameworks for working with data extracted from the database.
    MongoDB provides several different drivers for different programming languages,
    one of the most popular (and the one we will explore in this chapter) being the
    Node.js driver (sometimes known as Node).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要将您的软件与数据库连接，通常会使用一个库（通常由数据库创建者提供）称为驱动程序。这个驱动程序将帮助您连接、分析、读取和写入数据库，而无需为简单操作编写多行代码。它提供了常见用例的函数和抽象，以及用于处理从数据库中提取的数据的框架。MongoDB为不同的编程语言提供了几种不同的驱动程序，其中最流行的（也是我们将在本章中探讨的）是Node.js驱动程序（有时称为Node）。
- en: To relate this to real life, think about your online shopping experience. The
    first time you purchase products from a website, you have to enter all your billing
    and shipping details. If you have signed up for an account, however, the second
    time you go to the checkout, all your details are already saved on the website.
    This is a great experience, and, with many websites, this is accomplished by the
    web application querying a backend database. One such database that can support
    these applications is MongoDB.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这与现实生活联系起来，想想您的在线购物体验。第一次从网站购买产品时，您必须输入所有的账单和送货细节。然而，如果您已经注册了一个账户，第二次去结账时，所有的细节都已经保存在网站上。这是一个很好的体验，而且在许多网站上，这是通过Web应用程序查询后端数据库来实现的。MongoDB是可以支持这些应用程序的一个这样的数据库。
- en: One of the primary reasons why MongoDB has achieved such excellent growth and
    adoption is its success in persuading software developers to choose it as the
    database for their applications. Much of this persuasion is derived from how well
    MongoDB integrates with Node.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB取得如此出色的增长和采用的主要原因之一是其成功说服软件开发人员选择它作为其应用程序的数据库。其中很大一部分说服力来自于MongoDB与Node的良好集成。
- en: Node.js has become one of the primary languages for web-based applications,
    which we will learn about later in this chapter. However, for now, it is sufficient
    to know that the ease of integrating Node and MongoDB has proved highly beneficial
    for both technologies. This symbiotic relationship has also led to the creation
    of a large numbers of successful Node/MongoDB implementations, from small mobile
    apps to large-scale web applications. When deciding which programming language
    to choose when demonstrating MongoDB drivers, Node.js is the preferred choice.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js已经成为基于Web的应用程序的主要语言之一，我们将在本章后面学习。然而，现在知道Node和MongoDB集成的便利性对两种技术都非常有益就足够了。这种共生关系还导致了大量成功的Node/MongoDB实现，从小型移动应用到大规模Web应用。在展示MongoDB驱动程序时，选择Node.js是首选。
- en: Depending on your job role, you may either be responsible for writing applications
    that will run against MongoDB or expected to write the occasional line of code.
    However, regardless of your programming level or professional responsibilities,
    an understanding of how applications use drivers to integrate with MongoDB will
    be highly valuable. Most of the MongoDB production queries are run by applications,
    not by people. Whether you are a data analyst, a frontend developer, or a database
    administrator, it is highly possible that your production environment will be
    using one of the MongoDB drivers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的工作角色，您可能负责编写针对MongoDB运行的应用程序，或者期望偶尔编写一行代码。然而，无论您的编程水平或专业责任如何，了解应用程序如何使用驱动程序与MongoDB集成将非常有价值。大多数MongoDB生产查询是由应用程序而不是人运行的。无论您是数据分析师、前端开发人员还是数据库管理员，您的生产环境很可能会使用MongoDB驱动程序之一。
- en: Note
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For the duration of this chapter, the exercises and activities included are
    iterations on a single scenario. The data and examples are based on the MongoDB
    Atlas sample database entitled `sample_mflix`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个持续时间内，包括的练习和活动都是对一个情景的迭代。数据和示例都基于名为`sample_mflix`的MongoDB Atlas示例数据库。
- en: For the duration of this chapter, we will follow a set of exercises based on
    a theoretical scenario. This is an expansion of the scenario we covered in *Chapter
    7*, *Aggregations*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个持续时间内，我们将按照一个基于理论情景的一系列练习。这是我们在第7章“聚合”中涵盖的情景的扩展。
- en: Building upon the scenario from *Chapter 7*, *Aggregations*, where a cinema
    company is running its annual classic movie marathon and wants to decide what
    their lineup should be, they need a variety of popular movies that meet specific
    criteria to satisfy their customer base. After exploring the data and assisting
    them in making business decisions, you have provided them with new insights. The
    cinema company is pleased with your suggestions and have decided to engage you
    as part of their next project. This project involves creating a simple Node.js
    application that will allow their employees to query the film database, without
    them having to know MongoDB and place votes on which movies should be screened
    at the cinemas. Over the course of this chapter, you will create this application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第7章*“聚合”中构建场景的基础上，一个电影公司正在举办年度经典电影马拉松，并希望决定他们的放映计划应该是什么，他们需要满足特定标准的各种受欢迎的电影来满足他们的客户群。在探索数据并协助他们做出业务决策后，您为他们提供了新的见解。电影公司对您的建议感到满意，并决定让您参与他们的下一个项目。该项目涉及创建一个简单的Node.js应用程序，允许他们的员工查询电影数据库，而无需了解MongoDB并对应该在电影院放映哪些电影进行投票。在本章的过程中，您将创建此应用程序。
- en: Connecting to the Driver
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到驱动程序
- en: At a high level, the process of using the Node.js driver with MongoDB is similar
    to connecting directly with the shell. You will specify a MongoDB server URI,
    several connection parameters, and you can execute queries against collections.
    This should all be quite familiar; the main difference will be that these instructions
    will be written in JavaScript instead of Bash or PowerShell.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，使用Node.js驱动程序与MongoDB的过程类似于直接连接shell。您将指定MongoDB服务器URI、几个连接参数，并且可以对集合执行查询。这应该都很熟悉；主要区别在于这些指令将以JavaScript而不是Bash或PowerShell编写。
- en: Introduction to Node.js
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js简介
- en: Since the objective of this chapter is not to learn Node.js programming, we
    will briefly cover the fundamentals to ensure that we can create our MongoDB application.
    The **js** in Node.js stands for **JavaScript** because JavaScript is the programming
    language that Node.js understands. JavaScript typically runs in a browser. However,
    you can think of Node.js as an engine that executes the JavaScript files on your
    computer.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章的目标不是学习Node.js编程，我们将简要介绍基础知识，以确保我们可以创建我们的MongoDB应用程序。Node.js中的**js**代表**JavaScript**，因为JavaScript是Node.js理解的编程语言。JavaScript通常在浏览器中运行。但是，您可以将Node.js视为在计算机上执行JavaScript文件的引擎。
- en: Over the course of this chapter, you will write JavaScript (`.js`) syntax and
    execute it with Node.js. Although you can write JavaScript files with any text
    editor, it is recommended to use an application that will help you with syntax
    highlighting and formatting, such as **Visual Studio Code** or **Sublime**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的过程中，您将编写JavaScript（`.js`）语法，并使用Node.js执行它。虽然您可以使用任何文本编辑器编写JavaScript文件，但建议使用可以帮助您进行语法高亮和格式化的应用程序，例如**Visual
    Studio Code**或**Sublime**。
- en: 'To begin with, let''s look at some sample code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一些示例代码：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s define each term from the preceding syntax, in detail:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细定义前面语法中的每个术语：
- en: The `var` keyword is used to declare a new variable; in this case, the variable
    name is `message`.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var`关键字用于声明一个新变量；在本例中，变量名为`message`。'
- en: The `=` symbol sets the value of this variable to a string called `Hello, Node!`.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`=`符号将此变量的值设置为一个名为`Hello, Node!`的字符串。'
- en: A semi-colon (`;`) is used at the end of each statement.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个语句的末尾使用分号（`;`）。
- en: '`console.log(message)` is a function used to output the value of `message`.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`console.log(message)`是用于输出`message`值的函数。'
- en: If you're familiar with programming fundamentals, you may have noticed that
    we did not have to explicitly declare the `message` variable as `string`. This
    is because JavaScript is **dynamically typed**, meaning that you don't have to
    explicitly specify the variable type (number, string, Boolean, and so on).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉编程基础知识，您可能已经注意到我们不必将`message`变量显式声明为`string`。这是因为JavaScript是**动态类型**的，这意味着您不必显式指定变量类型（数字、字符串、布尔值等）。
- en: If you're less familiar with programming fundamentals, some of the terminology
    in this chapter might confuse you. Because this is not a JavaScript programming
    book, these concepts will not be covered in depth. The objective of this chapter
    is to understand how drivers interact with MongoDB; the specifics of Node.js are
    not important. Although this chapter attempts to keep the programming concepts
    simple, don't worry if something seems complex.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对编程基础知识不太熟悉，本章中的一些术语可能会使您感到困惑。因为这不是一本JavaScript编程书，这些概念不会被深入讨论。本章的目标是了解驱动程序如何与MongoDB交互；Node.js的具体内容并不重要。尽管本章试图保持编程概念简单，但如果有什么复杂的地方，不要担心。
- en: 'Let''s try running the code sample, saving that code to a file called `1_Hello_World.js`
    in our current directory, and then running the command in our Terminal or Command
    Prompt using the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试运行代码示例，将该代码保存到名为`1_Hello_World.js`的文件中，保存到我们当前的目录中，然后使用以下命令在我们的终端或命令提示符中运行该命令：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You''ll see an output that looks like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个看起来像这样的输出：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, it is straightforward to run Node.js scripts since without building
    or compiling, you can write your code and call it with `node`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，运行Node.js脚本非常简单，因为无需构建或编译，您可以编写代码并使用`node`调用它。
- en: 'The `var` keyword stores information in a variable and changes it later in
    the code. However, there is another keyword, `const`, that is used to store information
    that isn''t going to change. So, in our example, we could replace our `var` keyword
    with the `const` keyword. As a best practice, you can declare anything that won''t
    change as `const`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`关键字将信息存储在变量中，并在代码中稍后更改。但是，还有另一个关键字`const`，用于存储不会更改的信息。因此，在我们的示例中，我们可以用`const`关键字替换我们的`var`关键字。作为最佳实践，您可以将任何不会更改的内容声明为`const`：'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s consider the structure of functions and parameters. It is like
    the structure from previous chapters'' queries in the mongo shell. To begin, let''s
    consider the following example of defining a function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑函数和参数的结构。就像在mongo shell中的前几章查询的结构一样。首先，让我们考虑定义函数的以下示例：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And here is a preview of some of the types of code we will encounter later
    in this chapter. You may notice that although it is a much more complex code snippet,
    there are some common elements from the CRUD operations you have learned in earlier
    chapters (*Chapter 4*, *Querying Documents*, in particular), such as the syntax
    of a `find` command and the MongoDB URI:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在本章后面遇到的一些代码类型的预览。您可能会注意到，尽管这是一个更复杂的代码片段，但与您在早期章节（*第4章*，*查询文档*，特别是）学到的CRUD操作有一些共同的元素，例如`find`命令的语法和MongoDB
    URI：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This may be a little intimidating to begin with, but as we dive deeper into
    this chapter, this will become more familiar. As we mentioned earlier, there should
    be some elements that you recognize from the mongo shell, even if they look a
    little different. Some of the elements in the code that map to mongo shell elements
    are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时可能有点令人生畏，但随着我们深入探讨本章，这将变得更加熟悉。正如我们之前提到的，即使它们看起来有些不同，您应该能够从mongo shell中识别出一些元素。代码中映射到mongo
    shell元素的一些元素如下：
- en: The `collection` object, like `db.collection` in the shell.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collection`对象，就像shell中的`db.collection`。'
- en: The `find` command after our `collection`, like the shell.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的`collection`之后使用`find`命令，就像在shell中一样。
- en: The parameter in our `find` command is a document filter, which is precisely
    what we would use in the shell.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们`find`命令中的参数是一个文档过滤器，这正是我们在shell中使用的。
- en: The function declaration in Node.js is done using the `function(parameter){…}`
    function and it allows us to create smaller, reusable bits of code that can be
    run multiple times, such as the `find()` or `insertOne()` functions. Defining
    a function is easy; you simply use the `function` keyword, followed by the name
    of the function, its parameters in brackets, and curly braces to define the actual
    logic for this function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，函数声明是使用`function(parameter){…}`函数完成的，它允许我们创建可以多次运行的较小、可重用的代码片段，例如`find()`或`insertOne()`函数。定义函数很容易；您只需使用`function`关键字，后跟函数的名称、括号中的参数和大括号来定义此函数的实际逻辑。
- en: 'Here''s the code that defines a function. Note that there are two ways to do
    this: you can declare a function as a variable or pass a function as a parameter
    to another function. We''ll cover this in detail later in this chapter:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是定义函数的代码。请注意，有两种方法可以做到这一点：您可以将函数声明为变量，也可以将函数作为参数传递给另一个函数。我们将在本章后面详细介绍这一点：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Getting the MongoDB Driver for Node.js
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取Node.js的MongoDB驱动程序
- en: 'The easiest way to install the MongoDB driver for Node.js is to use `npm`.
    `npm`, or the node package manager, is a package management tool used to add,
    update, and manage different packages used in Node.js programs. In this case,
    the package you want to add is the MongoDB driver, so, in the directory where
    the scripts are stored, run the following command in your Terminal or Command
    Prompt:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Node.js的MongoDB驱动程序最简单的方法是使用`npm`。`npm`，或node包管理器，是一个用于添加、更新和管理Node.js程序中使用的不同包的包管理工具。在这种情况下，您要添加的包是MongoDB驱动程序，因此在存储脚本的目录中，在您的终端或命令提示符中运行以下命令：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You may see some output once the package is installed, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 安装包后可能会看到一些输出，如下所示：
- en: '![Figure 8.1: Installing the MongoDB driver with npm'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1：使用npm安装MongoDB驱动程序'
- en: '](img/B15507_08_01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_08_01.jpg)'
- en: 'Figure 8.1: Installing the MongoDB driver with npm'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：使用npm安装MongoDB驱动程序
- en: It's as easy as that. Now, let's begin programming against MongoDB.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单。现在，让我们开始针对MongoDB进行编程。
- en: The Database and Collection Objects
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库和集合对象
- en: When using the MongoDB driver, there are three main components that you can
    use for most operations. In the later exercises, we'll see how they all fit together,
    but before that, let's briefly cover each of them and their purpose.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用MongoDB驱动程序时，您可以使用三个主要组件进行大多数操作。在后面的练习中，我们将看到它们如何组合在一起，但在那之前，让我们简要介绍每个组件及其目的。
- en: '`MongoClient` is the first object you must create in your code. This represents
    your connection to the MongoDB server. Think of this as the equivalent of your
    mongo shell; you pass in the URL and connection parameters for your database,
    and it will create a connection for you to use. To use `MongoClient`, you must
    import the module at the top of your script:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`MongoClient`是您在代码中必须创建的第一个对象。这代表您与MongoDB服务器的连接。将其视为mongo shell的等价物；您传入数据库的URL和连接参数，它将为您创建一个连接供您使用。要使用`MongoClient`，您必须在脚本顶部导入模块：'
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next is the `database` object. Like the mongo shell, once the connection is
    established, run your commands against a specific database in your server. This
    database object will also determine which collections you may run the queries against:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`database`对象。就像mongo shell一样，一旦建立连接，您可以针对服务器中的特定数据库运行命令。这个数据库对象还将确定您可以针对哪些集合运行查询：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The third essential object to use in (almost) every MongoDB-based application
    is the `collection` object. As you may have guessed, a `collection` object is
    used to send queries. As with the mongo shell, most common operations will run
    against a single collection:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在（几乎）每个基于MongoDB的应用程序中使用的第三个基本对象是`collection`对象。正如在mongo shell中一样，大多数常见操作将针对单个集合运行：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `database` and `collection` objects express the same concept as if you were
    connecting directly with the mongo shell. For the purposes of this chapter, `MongoClient`
    is only used to create and store connections to the server.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`database`和`collection`对象表达了与直接连接mongo shell相同的概念。在本章中，`MongoClient`仅用于创建和存储与服务器的连接。'
- en: 'It''s important to note that the relationship between these objects is `MongoClient`
    object can create multiple `database` objects, and a `database` object can create
    many `collection` objects for running queries against:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这些对象之间的关系是`MongoClient`对象可以创建多个`database`对象，而`database`对象可以创建多个用于运行查询的`collection`对象：
- en: '![Figure 8.2: Driver entity relationships'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2：驱动程序实体关系'
- en: '](img/B15507_08_02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_08_02.jpg)'
- en: 'Figure 8.2: Driver entity relationships'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：驱动程序实体关系
- en: The preceding diagram is a visual representation of the entity relationships
    described in the previous paragraph. Here, there's one `MongoClient` object to
    multiple `database` objects, each of which may have multiple `collection` objects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上图是对前面段落中描述的实体关系的可视化表示。这里有一个`MongoClient`对象对应多个`database`对象，每个`database`对象可能有多个用于运行查询的`collection`对象。
- en: Connection Parameters
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接参数
- en: 'Before we write our code, it''s important to know how to establish the connection
    to `MongoClient`. There are only two parameters when creating a new client: the
    URL for your server and any additional connection options. The connection options
    are optional in case you need to create your client, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码之前，了解如何建立到`MongoClient`的连接是很重要的。创建新客户端时只有两个参数：服务器的URL和任何额外的连接选项。如果需要创建客户端，连接选项是可选的，如下所示：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Just like the mongo shell, `serverURL` supports all the MongoDB URI options,
    meaning you can specify a configuration in this connection string itself, rather
    than in the second optional parameter; for example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与mongo shell一样，`serverURL`支持所有MongoDB URI选项，这意味着您可以在连接字符串本身中指定配置，而不是在第二个可选参数中；例如：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To simplify this string, many of these URI options (and additional options,
    such as the SSL settings) can be specified in the second parameter when creating
    the client; for example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这个字符串，可以在创建客户端时在第二个参数中指定许多这些URI选项（以及其他选项，例如SSL设置）；例如：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As with the mongo shell, there are many options for configuration, including
    SSL, Authentication, and Write Concern options. However, most of them are beyond
    the scope of this chapter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与mongo shell一样，有许多配置选项，包括SSL、身份验证和写入关注选项。然而，大部分超出了本章的范围。
- en: Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, you can find a full connection string for Atlas in the user interface
    at cloud.mongodb.com. You may want to copy this connection string and use it in
    all your scripts for `serverURL`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您可以在cloud.mongodb.com的用户界面中找到Atlas的完整连接字符串。您可能希望复制此连接字符串，并在所有脚本中使用它作为`serverURL`。
- en: Let's learn how to establish a connection with the Node.js driver through an
    exercise.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过练习学习如何与Node.js驱动程序建立连接。
- en: 'Exercise 8.01: Creating a Connection with the Node.js Driver'
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.01：使用Node.js驱动程序创建连接
- en: 'Before you begin this exercise, revisit the movie company from the scenario
    outlined in the *Introduction* section. You may recall that the cinema company
    wants a Node.js application that allows users to query and update records in the
    movies database. To accomplish this, the first thing your application will need
    to do is establish a connection to your server. This can be done by executing
    the following steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始这个练习之前，回顾一下*介绍*部分中概述的电影公司。您可能还记得电影公司希望有一个Node.js应用程序，允许用户查询和更新电影数据库中的记录。为了实现这一点，您的应用程序首先需要建立与服务器的连接。可以通过执行以下步骤来完成：
- en: 'First, in your current working directory, create a new JavaScript file called
    `Exercise8.01.js` and open it in your chosen text editor (Visual Studio Code,
    Sublime, and so on):'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在您当前的工作目录中，创建一个名为`Exercise8.01.js`的新JavaScript文件，并在您选择的文本编辑器（Visual Studio
    Code、Sublime等）中打开它：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Import the MongoDB driver library (as described earlier in this chapter) into
    your script file by adding the following line to the top of the file:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将以下行添加到文件顶部，将MongoDB驱动程序库（如本章前面所述）导入到您的脚本文件中：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you did not install the npm MongoDB library earlier in this chapter, you
    should do so now by running `npm install mongo --save` in your Command Prompt
    or Terminal. Run this command in the same directory as your script.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在本章早期没有安装npm MongoDB库，现在应该运行`npm install mongo --save`在命令提示符或终端中进行安装。在与您的脚本相同的目录中运行此命令。
- en: 'Create a new variable containing the URL for your MongoDB server:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含您的MongoDB服务器的URL的新变量：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a new `MongoClient` object called `client` using the `url` variable:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`client`的新`MongoClient`对象，使用`url`变量：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Open a connection to MongoDB using the `connect` function, as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下方式打开到MongoDB的连接`connect`函数：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add a `console.log()` message within the connection block to confirm that the
    connection is open:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在连接块中添加一个`console.log()`消息，以确认连接已打开：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, at the end of the connection block, close the connection using the
    following syntax:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在连接块的末尾，使用以下语法关闭连接：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Your complete script should look like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您的完整脚本应如下所示：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following output is generated once you execute the code using `node Exercise8.01.js`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`node Exercise8.01.js`执行代码后，将生成以下输出：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this exercise, you established a connection to the server using Node.js driver.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您使用Node.js驱动程序建立了与服务器的连接。
- en: Executing Simple Queries
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行简单查询
- en: 'Now that we have connected to MongoDB, we can run some simple queries against
    the database. Running queries in the Node.js driver is very similar to running
    queries in the shell. By now, you should be familiar with the `find` command in
    the shell:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经连接到MongoDB，可以对数据库运行一些简单的查询。在Node.js驱动程序中运行查询与在shell中运行查询非常相似。到目前为止，您应该熟悉shell中的`find`命令：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here is the syntax for the `find` command in the driver:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是驱动程序中`find`命令的语法：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, the general structure is the same as the `find` command you
    would execute in the mongo shell. Here, we get a collection from the database
    object, and then we run the find command against that collection with a query
    document. The process itself is straightforward. The main differences concern
    how we structure our commands and how we handle the results returned from the
    driver.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，一般结构与您在mongo shell中执行的`find`命令相同。在这里，我们从数据库对象中获取一个集合，然后针对该集合运行带有查询文档的`find`命令。这个过程本身很简单。主要的区别在于我们如何构造我们的命令以及如何处理驱动程序返回的结果。
- en: When writing Node.js applications, one of the critical concerns is to ensure
    that your code is written in such a way that it can be modified, extended, or
    understood easily, either by yourself in the future or by other professionals
    who may need to work on the application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写Node.js应用程序时，一个关键的问题是确保您的代码以一种易于修改、扩展或理解的方式编写，无论是将来您自己还是其他专业人士可能需要在应用程序上工作。
- en: Creating and Executing find Queries
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和执行find查询
- en: 'Consider the code from *Exercise 8.01*, *Creating a Connection with the Node.js
    Driver*, as a reference as it already contains the connection:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将*Exercise 8.01*中的代码，*使用Node.js驱动程序创建连接*，作为参考，因为它已经包含了连接：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The logic of our query will be added here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的查询逻辑将在这里添加：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we have a connection to the MongoDB server. However, there are two other
    important objects – `db` and `collection`. Let''s create our database object (for
    the `sample_mflix` database), as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经连接到了MongoDB服务器。但是，还有两个重要的对象——`db`和`collection`。让我们创建我们的数据库对象（用于`sample_mflix`数据库），如下所示：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We now have our `database` object. When sending queries in the mongo shell,
    you must pass a document to the command as a filter for your documents. This is
    the same in the Node.js driver. You can pass the document directly. However, it
    is advisable to define the filter as a variable separately and then assign a value.
    You can see the difference in the following code snippet:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的`database`对象。在mongo shell中发送查询时，您必须将文档作为命令的过滤器传递给您的文档。这在Node.js驱动程序中也是一样的。您可以直接传递文档。但是，建议将过滤器单独定义为变量，然后再分配一个值。您可以在以下代码片段中看到差异：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As with the mongo shell, you may pass an empty document as a parameter to find
    all the documents. You may have also noticed `toArray` at the end of our `find`
    command. This is added because, by default, the `find` command will return a cursor.
    We''ll cover cursors in the next section, but in the meantime, let''s look at
    what this full script would look like:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与mongo shell一样，您可以将空文档作为参数传递以查找所有文档。您可能还注意到我们的`find`命令末尾有`toArray`。这是因为，默认情况下，`find`命令将返回一个游标。我们将在下一节中介绍游标，但与此同时，让我们看看这个完整脚本会是什么样子：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you were to save this modified script as `2_Simple_Find.js` and run it with
    the command `node 2_Simple_Find.js`, the following output would result:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将此修改后的脚本保存为`2_Simple_Find.js`并使用命令`node 2_Simple_Find.js`运行它，将会得到以下输出：
- en: '![Figure 8.3: Output for the preceding snippet (truncated for brevity)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3：上述片段的输出（为简洁起见而截断）'
- en: '](img/B15507_08_03.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_08_03.jpg)'
- en: 'Figure 8.3: Output for the preceding snippet (truncated for brevity)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：上述片段的输出（为简洁起见而截断）
- en: The preceding output is very similar to the output from a MongoDB query executed
    through the mongo shell rather than the driver. When executing queries through
    the driver, we have learned that although the syntax may differ from the mongo
    shell, the fundamental elements in a query and its output are the same.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出与通过mongo shell而不是驱动程序执行的MongoDB查询的输出非常相似。在通过驱动程序执行查询时，我们已经了解到，尽管语法可能与mongo
    shell不同，但查询及其输出中的基本元素是相同的。
- en: Using Cursors and Query Results
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用游标和查询结果
- en: 'In the previous examples, we used the `toArray` function to transform our query
    output into an array we could output with `console.log`. When working with small
    amounts of data, this is a simple way to work with the results; however, with
    larger result sets, you should use cursors. You should be somewhat familiar with
    cursors from your mongo shell queries in *Chapter 5*, *Inserting, Updating, and
    Deleting Documents*. In the mongo shell, you could use the `it` command to iterate
    through your cursor. In Node.js, there are many ways to access your cursor, of
    which three are more common patterns, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用`toArray`函数将我们的查询输出转换为一个可以用`console.log`输出的数组。当处理少量数据时，这是一种简单的处理结果的方法；然而，对于较大的结果集，您应该使用游标。您应该对游标有一定的了解，这是从*第5章*，*插入、更新和删除文档*中的mongo
    shell查询中得到的。在mongo shell中，您可以使用`it`命令来遍历游标。在Node.js中，有许多访问游标的方式，其中三种更常见的模式如下：
- en: '`toArray`: This will take all the results of the query and place them in a
    single array. This is easy to use but not very efficient when you are expecting
    a large result from your query. In the following code, we''re running a `find`
    command against the movies collection and then using `toArray` to log the first
    element in the array to the console:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toArray`：这将获取查询的所有结果并将它们放入一个单一的数组中。这很容易使用，但当您期望从查询中获得大量结果时，效率不是很高。在以下代码中，我们针对电影集合运行`find`命令，然后使用`toArray`将数组中的第一个元素记录到控制台中：'
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`each`: This will iterate through each document in the result set, one at a
    time. This is a good pattern if you want to inspect or use each document in the
    result. In the following code snippet, we''re running a `find` command against
    the movies collection, using `each` to log every document that''s returned until
    there are no documents left:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`each`：这将逐个遍历结果集中的每个文档。如果您想要检查或使用结果中的每个文档，这是一个很好的模式。在以下代码片段中，我们针对电影集合运行`find`命令，使用`each`记录返回的每个文档，直到没有文档为止：'
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When there are no more documents to return, the document will be equal to `null`.
    Hence, it is important to check whether the document exists (using `if(doc)`)
    every time we inspect a new document.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有更多文档返回时，文档将等于`null`。因此，每次检查新文档时，检查文档是否存在（使用`if(doc)`）是很重要的。
- en: '`next`: This will allow you to access the next document in the result set.
    This is the best pattern to use if you are only looking for a single document
    or a subset of your results without having to iterate through the entire result.
    In the following code snippet, we''re running a `find` command against the movies
    collection, using `next` to get the first document returned, and then outputting
    that document to the console:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next`：这将允许你访问结果集中的下一个文档。如果你只想要一个单独的文档或结果的子集，而不必遍历整个结果，这是最好的模式。在下面的代码片段中，我们对电影集合运行了一个`find`命令，使用`next`获取返回的第一个文档，然后将该文档输出到控制台：'
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Because `next` only returns one document at a time, in this example, we run
    it three times to inspect the first three documents.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`next`一次只返回一个文档，在这个例子中，我们运行了三次来检查前三个文档。
- en: In the examples, exercises, and activities in this chapter, we will learn how
    all three methods are being used. However, it is essential to note that there
    are other, more advanced, patterns.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例、练习和活动中，我们将学习这三种方法是如何被使用的。然而，需要注意的是还有其他更高级的模式。
- en: 'You can also accomplish the same `sort` and `limit` functionality from the
    mongo shell by placing these commands after `find(…)`; this should be familiar
    to you from your previous queries in the shell:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过在`find(…)`之后放置这些命令来实现相同的`sort`和`limit`功能，这应该是你在shell中以前查询时熟悉的：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Exercise 8.02: Building a Node.js Driver Query'
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.02：构建一个Node.js Driver查询
- en: 'In this exercise, you will build upon the scenario in *Exercise 8.01*, *Creating
    a Connection with the Node.js Driver*, which allows you to connect to the mongo
    server. If you are going to deliver a Node.js application that allows cinema employees
    to query and vote on movies, your script will need to query the database with
    given criteria and return the results in an easily readable format. For this scenario,
    the query you must get results for is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将在*练习8.01*的场景上进行构建，*使用Node.js Driver创建连接*，这允许你连接到mongo服务器。如果你要交付一个Node.js应用程序，允许电影院员工查询和对电影投票，你的脚本将需要根据给定的条件查询数据库，并以易于阅读的格式返回结果。对于这种情况，你必须获取以下查询的结果：
- en: '*Find two movies in the romance category, projecting only the title for each.*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*查找两部浪漫类电影，只投影每部电影的标题。*'
- en: 'You can accomplish this in Node.js by executing the following steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过执行以下步骤在Node.js中实现这一点：
- en: Create a new JavaScript file called `Exercise8.02.js`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Exercise8.02.js`的新的JavaScript文件。
- en: So that you don't have to rewrite everything from scratch, copy the content
    of `Exercise8.01.js` into your new script. Otherwise, rewrite the connection code
    in your new file.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了不必从头开始重写所有内容，将`Exercise8.01.js`的内容复制到你的新脚本中。否则，在你的新文件中重写连接代码。
- en: 'To keep the code clean, create new variables to store `databaseName` and `collectionName`.
    Remember, since these won''t change throughout our script, you must declare them
    as constants using the `const` keyword:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保持代码整洁，创建新的变量来存储`databaseName`和`collectionName`。记住，由于这些在整个脚本中不会改变，你必须使用`const`关键字将它们声明为常量：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, create a new `const` to store our query document; you should be familiar
    with creating these from the previous chapters:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个新的`const`来存储我们的查询文档；你应该熟悉从之前的章节中创建这些：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With all your variables defined, create our database object:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义好所有的变量后，创建我们的数据库对象：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, you can send your query with the following syntax. Use the `each` pattern,
    passing in a callback function to handle each document. Don''t worry if this appears
    strange; you will learn about this in detail in the upcoming section. Remember
    to use `limit` to only return two documents and `project` to output only `title`,
    as they are requirements for our scenario:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用以下语法发送你的查询。使用`each`模式，传递一个回调函数来处理每个文档。如果这看起来奇怪，不要担心；你将在接下来的部分中详细了解这个。记得使用`limit`只返回两个文档和`project`只输出`title`，因为它们是我们场景的要求：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Inside your callback function, use `console.log` to output each of the documents
    that was returned by our query:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的回调函数中，使用`console.log`输出我们的查询返回的每个文档：
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Your final code should look like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你的最终代码应该像这样：
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, run the script using `node Exercise8.02.js`. You should get the following
    output:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`node Exercise8.02.js`运行脚本。你应该得到以下输出：
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this exercise, you built a Node.js program that executes a query against
    MongoDB and returns the results to us in the console. Although this is a small
    step that we could easily accomplish in the mongo shell, this script will serve
    as a foundation for more advanced and interactive Node.js applications for MongoDB.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你构建了一个Node.js程序，对MongoDB执行查询，并将结果返回到控制台。虽然这是一个小步骤，我们可以很容易地在mongo shell中完成，但这个脚本将作为更高级和交互式的Node.js应用程序的基础。
- en: Callbacks and Error Handling in Node.js
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Node.js中的回调和错误处理
- en: 'So, we have managed to open a connection to MongoDB and run some simple queries,
    but there were probably a couple of elements of the code that seemed unfamiliar;
    for example, the syntax here:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们已经成功打开了与MongoDB的连接并运行了一些简单的查询，但可能有一些代码元素看起来不太熟悉；例如，这里的语法：
- en: '[PRE42]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is what is known as a `MongoClient` that once it completes its own internal
    logic, it should execute the code in the function we passed in as a second parameter.
    That second parameter is known as a callback. Callbacks are extra functions (blocks
    of code) that are passed as parameters to another function that executes first.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所谓的`MongoClient`，一旦它完成了自己的内部逻辑，它应该执行我们作为第二个参数传递的函数中的代码。第二个参数被称为回调。回调是额外的函数（代码块），作为参数传递给另一个首先执行的函数。
- en: 'Callbacks allow you to specify the logic to execute only after a function has
    completed. The reason we have to use callbacks in Node.js instead of simply having
    the statements be in order is that Node.js is asynchronous, meaning that when
    we call functions such as `connect`, it doesn''t block execution. Whatever is
    next in the script will be executed. That''s why we use callbacks: to ensure that
    our next steps wait for the connection to complete. There are other modern patterns
    that can be used instead of callbacks, such as **promises** and **await/async**.
    However, considering the scope of this book, we will only cover callbacks in this
    chapter and learn how to handle errors returned from the driver.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 回调允许您指定仅在函数完成后执行的逻辑。我们必须在Node.js中使用回调的原因是Node.js是异步的，这意味着当我们调用诸如`connect`之类的函数时，它不会阻塞执行。脚本中的下一个内容将被执行。这就是为什么我们使用回调的原因：确保我们的下一步等待连接完成。除了回调之外，还有其他现代模式可以用来替代回调，例如**promises**和**await/async**。但是，考虑到本书的范围，我们将只在本章中涵盖回调，并学习如何处理驱动程序返回的错误。
- en: Callbacks in Node.js
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js中的回调
- en: Callbacks can often be visually confusing and hard to conceptualize; however,
    fundamentally, they are quite simple. A callback is a function provided as a parameter
    to a second function, which allows both functions to be run in order.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 回调通常在视觉上令人困惑且难以概念化；但是，从根本上讲，它们非常简单。回调是作为第二个函数的参数提供的函数，这允许两个函数按顺序运行。
- en: 'Without using callbacks (or any other synchronization pattern), both functions
    would start executing right after the other. When using a driver, this would create
    errors, because the second function may be dependent on the first function finishing
    before it begins. For example, you cannot query your data until the connection
    is established. Let''s look at a breakdown of a callback:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用回调函数（或任何其他同步模式），两个函数将在彼此之后立即开始执行。使用驱动程序时，这会创建错误，因为第二个函数可能依赖于第一个函数在开始之前完成。例如，在连接建立之前，您无法查询数据。让我们来看一下回调的分解：
- en: '![Figure 8.4: Breakdown of a callback'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4：回调的分解'
- en: '](img/B15507_08_04.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_08_04.jpg)'
- en: 'Figure 8.4: Breakdown of a callback'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：回调的分解
- en: 'And now, compare this to our `find` query code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将此与我们的`find`查询代码进行比较：
- en: '![Figure 8.5: Breakdown of a MongoDB callback'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5：MongoDB回调的分解'
- en: '](img/B15507_08_05.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_08_05.jpg)'
- en: 'Figure 8.5: Breakdown of a MongoDB callback'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：MongoDB回调的分解
- en: 'As you can see, the same structure exists, just with different parameters to
    the callback function. You may be wondering how we know which parameters to use
    in a specific callback. The answer is that the parameters passed into our callback
    function are determined by the first function that we provide our callback function
    to. That''s perhaps a confusing sentence, but what it means is this: when passing
    a function, fA, as a parameter to a second function, fB, the parameters of fA
    are provided by fB. Let''s examine our practical example again to make sure we
    understand this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，相同的结构存在，只是回调函数的参数不同。您可能想知道我们如何知道在特定回调中使用哪些参数。答案是，我们传递给回调函数的参数由我们提供回调函数的第一个函数确定。也许这是一个令人困惑的句子，但它的意思是：当将函数fA作为参数传递给第二个函数fB时，fA的参数由fB提供。让我们再次检查我们的实际示例，以确保我们理解这一点：
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'So, our callback function, `function(err, doc) { … }`, is provided as a parameter
    to the driver function, `each`. This means that `each` will run our callback function
    for each document in the result set, passing the `err` (error) and `doc` (document)
    parameters in for each execution. Here''s the same code, but with some logging
    to demonstrate the order of execution:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的回调函数`function(err, doc) { … }`作为参数提供给驱动程序函数`each`。这意味着`each`将为结果集中的每个文档运行我们的回调函数，为每次执行传递`err`（错误）和`doc`（文档）参数。以下是相同的代码，但添加了一些日志以演示执行顺序：
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And if we run this code using `node 3_Callbacks.js`, we can see the order of
    execution in the output:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`node 3_Callbacks.js`运行此代码，我们可以在输出中看到执行顺序：
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Callbacks are sometimes complicated patterns to become familiar with and are
    increasingly being replaced by more advanced Node.js patterns, such as `promises`
    and `async/await`. The best way to become more familiar with these patterns is
    by using them, so if you don't feel 100% comfortable with them yet, don't worry.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 回调有时是复杂的模式，需要熟悉，并且越来越多地被更高级的Node.js模式（例如`promises`和`async/await`）所取代。熟悉这些模式的最佳方法是使用它们，因此如果您对它们还不太熟悉，不用担心。
- en: Basic Error Handling in Node.js
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js中的基本错误处理
- en: 'As we''ve been examining our callbacks, you may have noticed that there was
    a parameter we have not described yet: `err`. In the MongoDB driver, most commands
    that can return an error in the mongo shell can also return an error in the driver.
    In the case of callbacks, the `err` parameter will always exist; however, if there
    is no error, the value of `err` is `null`. This "error-first" pattern to catch
    errors in asynchronous code is standard practice in NodeJS.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查回调时，您可能已经注意到我们尚未描述的参数：`err`。在MongoDB驱动程序中，大多数在mongo shell中可能返回错误的命令也可以在驱动程序中返回错误。在回调的情况下，`err`参数将始终存在；但是，如果没有错误，则`err`的值为`null`。在NodeJS中捕获异步代码中的错误的“错误优先”模式是标准做法。
- en: 'For example, imagine you have created an application that enters users'' phone
    numbers into a customer database, and two different users enter the same phone
    number. MongoDB will return a duplicate key error when you attempt to run the
    insert. At this point, it is your responsibility, as the creator of the Node.js
    application, to properly handle that error. To check any errors in our query,
    we can check whether `err` is not `null`. You can easily check this by using the
    following syntax:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您创建了一个应用程序，将用户的电话号码输入客户数据库，两个不同的用户输入相同的电话号码。当您尝试运行插入时，MongoDB将返回重复键错误。此时，作为Node.js应用程序的创建者，您有责任正确处理该错误。要检查查询中的任何错误，我们可以检查`err`是否不为`null`。您可以使用以下语法轻松检查：
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You may recognize that this was the same syntax we used to check whether we
    have more documents when using `each`. Similar to how we''re checking the error
    for a query, the `connect` function in our client also provides an error to our
    `callback` function, which should be checked before we run any further logic:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，这与我们在使用`each`时检查是否有更多文档时使用的语法相同。类似于我们检查查询的错误，我们的客户端中的`connect`函数也会向我们的`callback`函数提供一个错误，这在运行任何进一步的逻辑之前应该进行检查：
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is advisable to use callbacks to check the parameters that are passed in
    before we try to use them. In the case of a `find` command, this would mean checking
    whether there is an error and checking that a document was returned. When writing
    code against MongoDB, it is good practice to validate everything that was returned
    from the database and log errors for debugging purposes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试使用参数之前，最好使用回调来检查传递的参数。在`find`命令的情况下，这意味着检查是否有错误并检查是否返回了文档。在针对MongoDB编写代码时，最好验证从数据库返回的所有内容，并记录错误以进行调试。
- en: 'But it''s not just in callbacks that we can validate the accuracy of our code.
    We can also check non-callback functions to make sure everything worked out, for
    example, when we create our `database` object:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不仅可以在回调中验证代码的准确性。我们还可以检查非回调函数，以确保一切顺利，例如当我们创建我们的`database`对象时：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Depending on what you are trying to accomplish with MongoDB, your error handling
    might be as simple as the preceding examples, or you may need much more advanced
    logic. However, for the scope of this chapter, we'll only be looking at basic
    error handling.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您尝试使用MongoDB实现的目标，您的错误处理可能像前面的示例那样简单，或者您可能需要更复杂的逻辑。但是，在本章的范围内，我们只会看一下基本的错误处理。
- en: 'Exercise 8.03: Error Handling and Callbacks with the Node.js Driver'
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.03：使用Node.js驱动程序进行错误处理和回调
- en: 'In *Exercise 8.02*, *Building a Node.js Driver Query*, you created a script
    that successfully connected to a MongoDB server and resulted a query. In this
    exercise, you will add error handling to your code—meaning that if anything goes
    wrong, it allows you to identify or fix the issue. You will test this handling
    by modifying your query so that it fails. You can accomplish this in Node.js by
    going through the following steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Exercise 8.02*中，*构建Node.js驱动程序查询*，您创建了一个成功连接到MongoDB服务器并生成查询结果的脚本。在这个练习中，您将向您的代码添加错误处理——这意味着如果出现任何问题，它可以帮助您识别或修复问题。您将通过修改查询来测试此处理，以使其失败。您可以通过以下步骤在Node.js中实现这一点：
- en: Create a new JavaScript file called `Exercise8.03.js`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Exercise8.03.js`的新JavaScript文件。
- en: So that you don't have to rewrite everything from scratch, copy the content
    of `Exercise8.02.js` into your new script. Otherwise, rewrite the connection and
    query code in your new file.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了不必从头开始重写所有内容，将`Exercise8.02.js`的内容复制到您的新脚本中。否则，在新文件中重写连接和查询代码。
- en: 'Within the connect callback, check the `err` parameter. If you do have an error,
    make sure to output it using `console.log`:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在连接回调中，检查`err`参数。如果您有错误，请确保使用`console.log`输出它：
- en: '[PRE49]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Add some error checks before running the query to ensure that the database
    object was created successfully. If you do have an error, output it using `console.log`.
    Use the `!` syntax to check whether something does not exist:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行查询之前添加一些错误检查，以确保数据库对象已成功创建。如果您有错误，请使用`console.log`输出它。使用`!`语法来检查某些东西是否不存在：
- en: '[PRE50]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the `each` callback, check the `err` parameter to make sure each document
    was returned without error:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`each`回调中，检查`err`参数，确保每个文档都没有错误地返回：
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'At this point, your entire code should look like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您的整个代码应该如下所示：
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Before adding an error, run the script using node `Exercise8.03.js`. You should
    get the following output:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加错误之前，使用node `Exercise8.03.js`运行脚本。您应该会得到以下输出：
- en: '[PRE53]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Modify the query to ensure that you produce an error:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改查询以确保产生错误：
- en: '[PRE54]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Run the script using node `Exercise8.03.js`. You should get the following output:![Figure
    8.6: Output after the script is run (truncated for brevity)'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用node `Exercise8.03.js`运行脚本。您应该会得到以下输出：![图8.6：脚本运行后的输出（为简洁起见进行了截断）
- en: '](img/B15507_08_06.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_08_06.jpg)'
- en: 'Figure 8.6: Output after the script is run (truncated for brevity)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：脚本运行后的输出（为简洁起见进行了截断）
- en: In this exercise, you extended your Node.js application so that it catches and
    handles errors that you may run into when running MongoDB queries in a Node.js
    environment. This will allow you to create more robust, error-tolerant, and scalable
    applications.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您扩展了您的Node.js应用程序，以便在Node.js环境中运行MongoDB查询时捕获和处理可能遇到的错误。这将使您能够创建更健壮、容错和可扩展的应用程序。
- en: Advanced Queries
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级查询
- en: In the previous section, we connected to a MongoDB server, queried some data,
    outputted it, and handled any errors we encountered. However, an application or
    script would have limited utility if it could only perform read operations. In
    this section, we will apply `write` and `update` operations in the MongoDB driver.
    Furthermore, we will examine how we can use the function syntax to create reusable
    code blocks for our final application.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们连接到了MongoDB服务器，查询了一些数据，输出了它，并处理了我们遇到的任何错误。但是，如果应用程序或脚本只能执行读取操作，那么它的实用性将受到限制。在本节中，我们将在MongoDB驱动程序中应用`write`和`update`操作。此外，我们将研究如何使用函数语法为我们的最终应用程序创建可重用的代码块。
- en: Inserting Data with the Node.js Driver
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Node.js驱动程序插入数据
- en: 'Similar to the mongo shell, we can use either the `insertOne` or `insertMany`
    function to write data into our collection. These functions are called on the
    collection object. The only parameter we need to pass into these functions is
    a single document in the case of `insertOne`, or an array of documents in the
    case of `insertMany`. The following is a code snippet that includes how to use
    `insertOne` and `insertMany` with callbacks. By now, you should be able to recognize
    that this is an incomplete snippet. To execute the following code, you will need
    to add the basic connection logic we learned about earlier in this chapter. This
    should look very familiar by now:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 与mongo shell类似，我们可以使用`insertOne`或`insertMany`函数将数据写入我们的集合。这些函数在集合对象上调用。我们需要将单个文档传递给这些函数，或者在`insertMany`的情况下，需要传递文档数组。以下是一个包含如何使用带有回调的`insertOne`和`insertMany`的代码片段。到目前为止，您应该能够认识到这是一个不完整的代码片段。要执行以下代码，您需要添加我们在本章前面学到的基本连接逻辑。现在这应该看起来非常熟悉：
- en: '[PRE55]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As with `find`, we pass a callback to these functions to handle the result
    of the operation. Insert operations will return an error (which may be `null`)
    and a result, which details how the insert operation executed. For example, if
    we were to build on top of the result of the previous exercise and log the result
    of an `insertMany` operation, this would produce the following output:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 与`find`一样，我们将回调传递给这些函数以处理操作的结果。插入操作将返回一个错误（可能为`null`）和一个结果，其中详细说明了插入操作的执行方式。例如，如果我们要构建在先前练习的结果之上，并记录`insertMany`操作的结果，那么将产生以下输出：
- en: '[PRE56]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We may see a `result` object like *Figure 8.7* in the output.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会在输出中看到一个像*图8.7*那样的`result`对象。
- en: Note
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'We are only outputting a subset of the overall `result` object, which contains
    much more information about our operation. For example, we are logging `result.result`,
    which is a sub-document within the entire `result` object. This is just for the
    scope of this example. In other use cases, you may want more information about
    the result of your operation:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只输出了整个`result`对象的一个子集，其中包含有关我们操作的更多信息。例如，我们正在记录`result.result`，这是整个`result`对象中的一个子文档。这仅适用于本示例的范围。在其他用例中，您可能需要更多关于操作结果的信息：
- en: '![Figure 8.7: Output showing a subset of the overall result object'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7：显示整个结果对象的子集的输出'
- en: '](img/B15507_08_07.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_08_07.jpg)'
- en: 'Figure 8.7: Output showing a subset of the overall result object'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：显示整个结果对象的子集的输出
- en: Updating and Deleting Data with the Node.js Driver
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Node.js驱动程序更新和删除数据
- en: Updating and deleting documents with the driver follows the same pattern as
    the `insert` function, where the `collection` object passes through a callback,
    checks for errors, and analyzes the results of the operation. All these functions
    will return a results document. However, between the three operations, the format
    and information contained within a result document may differ. Let's look at some examples.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用驱动程序更新和删除文档遵循与`insert`函数相同的模式，其中`collection`对象通过回调传递，检查错误，并分析操作的结果。所有这些函数都将返回一个结果文档。但是，在这三个操作之间，结果文档中包含的格式和信息可能会有所不同。让我们看一些示例。
- en: 'Here is an example of some sample code (also built on top of our earlier connection
    code) that updates a document. We can use either `updateOne` or `updateMany`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例代码的示例（也建立在我们之前的连接代码之上），用于更新文档。我们可以使用`updateOne`或`updateMany`：
- en: '[PRE57]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'And if we were to run this code, our resulting output may look something like
    this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，我们的输出结果可能如下所示：
- en: '[PRE58]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, let''s look at an example of deleting a document. As with our other functions,
    we can use either `deleteOne` or `deleteMany`. Remember that this snippet exists
    as part of the larger code we created for *Exercise 8.03*, *Error Handling and
    Callbacks with the Node.js Driver*:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个删除文档的示例。与我们的其他函数一样，我们可以使用`deleteOne`或`deleteMany`。请记住，此代码片段作为我们为*Exercise
    8.03*创建的较大代码的一部分存在，*Node.js驱动程序中的错误处理和回调*：
- en: '[PRE59]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And if we were to run this code, our output would be as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，我们的输出将如下所示：
- en: '[PRE60]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As you can see, all these operations follow similar patterns and are very close
    in structure to the same commands you would send to the mongo shell. The main
    difference comes in the callback, where we can run our custom logic on the results
    of our operations.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，所有这些操作都遵循类似的模式，并且在结构上非常接近您将发送到mongo shell的相同命令。主要区别在于回调，我们可以在操作结果上运行自定义逻辑。
- en: Writing Reusable Functions
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写可重用的函数
- en: In our examples and exercises so far, we have always executed a single operation
    and outputted the result. However, in larger, more complex applications, you will
    want to run many different operations in the same program, depending on the context.
    For example, in your application, you may want to run the same query multiple
    times and compare the respective results, or you may want the second query to
    be modified depending on the output of the first.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的示例和练习中，我们总是执行单个操作并输出结果。但是，在更大，更复杂的应用程序中，您将希望在同一程序中运行许多不同的操作，具体取决于上下文。例如，在您的应用程序中，您可能希望多次运行相同的查询并比较各自的结果，或者您可能希望根据第一个查询的输出修改第二个查询。
- en: This is where we will create our own functions. You have already written a few
    functions to use as callbacks, but in this case, we are going to write functions
    we can call at any time, either for utility or to keep our code clean and separated.
    Let's look at an example.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将创建自己的函数的地方。您已经编写了一些函数用作回调，但在这种情况下，我们将编写可以随时调用的函数，无论是用于实用程序还是保持代码清晰和分离。让我们看一个例子。
- en: 'Let''s understand this better through the following code snippet, which runs
    three very similar queries. The only difference between these queries is a single
    parameter (rating) in each of the queries:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下代码片段更好地理解这一点，该代码片段运行了三个非常相似的查询。这些查询之间唯一的区别是每个查询中的一个参数（评分）：
- en: '[PRE61]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let''s try to simplify and clean up this code with a function. We declare a
    new function using the same syntax we would use for a variable. Because this function
    does not change, we can declare it as `const`. For the value of the function,
    we can use the syntax we have become familiar with from callbacks in previous
    examples (examples from the *Callbacks* section, earlier in this chapter):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用一个函数简化和清理这段代码。我们使用与变量相同的语法声明一个新函数。因为这个函数不会改变，我们可以将它声明为`const`。对于函数的值，我们可以使用我们在之前的示例中（本章早期的*回调*部分的示例）已经熟悉的语法：
- en: '[PRE62]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, let''s add our logic to this function, between the curly braces:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在花括号之间为这个函数添加逻辑：
- en: '[PRE63]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'But something isn''t quite right. We''re referencing the database object before
    we have created one. We will have to pass that object into this function as a
    parameter, so let''s adjust our function to do that:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有些地方不太对。我们在创建数据库对象之前引用了数据库对象。我们将不得不将该对象作为参数传递给这个函数，所以让我们调整我们的函数来做到这一点：
- en: '[PRE64]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can now replace our three queries with three function calls:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以用三个函数调用来替换我们的三个查询：
- en: '[PRE65]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this chapter, we won't be going too far into creating modular, functional
    code for the sake of simplicity. However, if you wanted to improve this code even
    further, you could use an array and a `for` loop to run the function for each
    value, without having to call it three times.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，为了简单起见，我们不会过多地讨论创建模块化、功能性的代码。但是，如果您想进一步改进这段代码，您可以使用数组和`for`循环来为每个值运行函数，而不必调用它三次。
- en: 'Exercise 8.04: Updating Data with the Node.js Driver'
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.04：使用Node.js驱动程序更新数据
- en: 'Considering the scenario from the *Introduction* section, you have made considerable
    progress from where you started. Your final application for the cinema company
    will need to be able to add votes to movies by running update operations. You''re
    not quite ready to add this logic yet. However, to prove that you can accomplish
    this, write a script that updates several different documents in the database,
    and create a reusable function to do this. In this exercise, you will need to
    update the following names in the `chapter8_Exercise4` collection. You will use
    this unique collection to ensure that data is not corrupted for other activities
    during the updates:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑*介绍*部分的情景，您已经从起点取得了相当大的进展。您的最终应用程序需要能够通过运行更新操作向电影添加投票。但是，您还没有准备好添加这个逻辑。不过，为了证明您能够做到这一点，编写一个脚本，更新数据库中的几个不同文档，并创建一个可重用的函数来实现这一点。在这个练习中，您需要更新`chapter8_Exercise4`集合中的以下名称。您将使用这个唯一的集合来确保在更新期间不会损坏其他活动的数据：
- en: '*Ned Stark to Greg Stark, Robb Stark to Bob Stark, and Bran Stark to Brad Stark.*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ned Stark to Greg Stark, Robb Stark to Bob Stark, and Bran Stark to Brad Stark.*'
- en: 'You can accomplish this in Node.js by executing the following steps:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过执行以下步骤在Node.js中实现这一点：
- en: 'First, make sure the correct documents exist to update. Connect to the server
    directly with the mongo shell and execute the following code snippet to check
    for these documents:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，确保正确的文档存在以进行更新。直接使用mongo shell连接到服务器，并执行以下代码片段来检查这些文档：
- en: '[PRE66]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If the result of the preceding query is empty, use this snippet to add the
    documents for updating:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果前面查询的结果为空，请使用此片段添加要更新的文档：
- en: '[PRE67]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now, to create the script, exit the mongo shell connection and create a new
    JavaScript file called `Exercise8.04.js`. So that you don't have to rewrite everything
    from scratch, copy the content of `Exercise8.03.js` into your new script. Otherwise,
    rewrite the connection code in your new file. If you copied your code from *Exercise
    8.03*, *Error Handling and Callbacks with the Node.js Driver*, then remove the
    code for the find query.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要创建脚本，请退出mongo shell连接，并创建一个名为`Exercise8.04.js`的新JavaScript文件。这样您就不必从头开始重写所有内容，只需将`Exercise8.03.js`的内容复制到新脚本中。否则，请在新文件中重写连接代码。如果您从*Exercise
    8.03*，*使用Node.js驱动程序处理错误和回调*中复制了代码，则删除查找查询的代码。
- en: 'Change the collection from movies to `chapter8_Exercise4`:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将集合从电影更改为`chapter8_Exercise4`：
- en: '[PRE68]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'At the start of your script, before you connect, create a new function called
    `updateName`. This function will take the database object, the client object,
    and `oldName` and `newName` as parameters:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本开始之前，在连接之前，创建一个名为`updateName`的新函数。这个函数将以数据库对象、客户端对象以及`oldName`和`newName`作为参数：
- en: '[PRE69]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Within the `updateName` function, add the code for running an update command
    that will update a document containing a name field of `oldName` and update the
    value to `newName`:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`updateName`函数中，添加运行更新命令的代码，该命令将更新包含名为`oldName`的字段的文档，并将该值更新为`newName`：
- en: '[PRE70]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, within the connect callback, run your new function three times, one for
    each of the three names you are updating:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在连接回调中，运行您的新函数三次，分别为要更新的三个名称运行一次：
- en: '[PRE71]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'At this point, your entire code should look like this:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，您的整个代码应该如下所示：
- en: '[PRE72]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Run the script using `node Exercise8.04.js`. You should get the following output:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`node Exercise8.04.js`运行脚本。您应该会得到以下输出：
- en: '[PRE73]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Over the last four sections, you have learned how to create a Node.js script
    that connects to MongoDB, run queries in easy-to-use functions, and handle any
    errors we might encounter. This serves as a foundation upon which you can build
    many scripts to perform complex logic using your MongoDB database. However, in
    our examples so far, our query parameters have always been hardcoded into our
    scripts, meaning each of our scripts can only satisfy a specific use case.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的四个部分中，您已经学会了如何创建一个连接到MongoDB的Node.js脚本，运行易于使用的函数进行查询，并处理我们可能遇到的任何错误。这为您搭建了一个基础，可以用它来构建许多脚本，以使用您的MongoDB数据库执行复杂的逻辑。然而，在我们迄今为止的示例中，我们的查询参数总是硬编码到我们的脚本中，这意味着我们的每个脚本只能满足特定的用例。
- en: This is not ideal. One of the great strengths of using something like the Node.js
    driver is the ability to have a single application that solves a vast number of
    problems. To expand the scope of our scripts, we will take user input to create
    dynamic queries, capable of solving users' questions, without us having to rewrite
    and distribute a new version of our program. In this section, we will learn how
    to accept user input, handle it, and build dynamic queries from it.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不理想。像 Node.js 驱动程序这样的强大之处之一是能够拥有一个解决大量问题的单个应用程序。为了扩大我们脚本的范围，我们将接受用户输入来创建动态查询，能够解决用户的问题，而无需重写和分发我们程序的新版本。在本节中，我们将学习如何接受用户输入、处理它，并从中构建动态查询。
- en: Note
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In most large, production-ready applications, user input will come in the form
    of a **Graphical User Interface** (**GUI**). These GUIs transform simple user
    selections into complex, relevant queries. However, building GUIs is quite tricky,
    and beyond the scope of this book.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数大型、生产就绪的应用程序中，用户输入将以**图形用户界面**（**GUI**）的形式出现。这些 GUI 将简单的用户选择转换为复杂的、相关的查询。然而，构建
    GUI 是非常棘手的，超出了本书的范围。
- en: Reading Input from the Command Line
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从命令行读取输入
- en: 'In this section, we will be obtaining inputs from the command line for our
    application. Fortunately, Node.js provides some simple ways for us to read input
    from the command line and use it in our code. Node.js provides a module called
    `readline` that will allow us to ask the user for input, accept that input, and
    then use it. You can load `readline` into your script by adding the following
    lines at the top of your file. You must always create an interface when using
    `readline`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从命令行获取输入。幸运的是，Node.js 为我们提供了一些简单的方法来从命令行读取输入并在我们的代码中使用它。Node.js 提供了一个名为
    `readline` 的模块，它允许我们向用户请求输入、接受输入，然后使用它。您可以通过在文件顶部添加以下行来将 `readline` 加载到您的脚本中。在使用
    `readline` 时，您必须始终创建一个接口：
- en: '[PRE74]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, we can ask the user for some input. `readline` provides us with multiple
    ways to handle input. However, the simplest way, for now, is to use the `question`
    function, as in the example here:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以要求用户输入一些内容。 `readline` 为我们提供了多种处理输入的方式。然而，现在最简单的方法是使用 `question` 函数，就像这里的例子一样：
- en: '[PRE75]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `${input}` syntax allows us to embed a variable within a string. When using
    this, make sure to use backticks, [PRE76]
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`${input}` 语法允许我们在字符串中嵌入一个变量。在使用时，请确保使用反引号，[PRE76]'
- en: Chapter_8> node example.js
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter_8> node example.js
- en: Hello, what is your name? Michael
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，你叫什么名字？ 迈克尔
- en: Hello, Michael
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，迈克尔
- en: '[PRE77]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: const question = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed
    do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim
    veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
    consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum
    dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident,
    sunt in culpa qui officia deserunt mollit anim id est laborum?"
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: const question = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed
    do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim
    veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
    consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum
    dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident,
    sunt in culpa qui officia deserunt mollit anim id est laborum?"
- en: interface.question(question, (input) => {
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: interface.question(question, (input) => {
- en: console.log(`Hello, ${input}`);
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: console.log(`你好， ${input}`);
- en: interface.close();
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: interface.close();
- en: '});'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE78]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: const askName = function() {
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: const askName = function() {
- en: interface.question("Hello, what is your name?", (input) => {
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: interface.question("你好，你叫什么名字？", (input) => {
- en: if(input === "exit") {
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: if(input === "exit") {
- en: return interface.close(); // Will kill the loop.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: return interface.close(); // 将终止循环。
- en: '}'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: console.log(`Hello, ${input}`);
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: console.log(`你好，${input}`);
- en: askName();
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: askName();
- en: '});'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '}'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: askName(); // First Run.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: askName(); // 第一次运行。
- en: '[PRE79]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: if(input === "exit") {
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: if(input === "exit") {
- en: return interface.close(); // Will kill the loop.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: return interface.close(); // 将终止循环。
- en: '}'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE80]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Chapter_8> node examples.js
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter_8> node examples.js
- en: Hello, what is your name?Mike
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，你叫什么名字？迈克
- en: Hello, Mike
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，迈克
- en: Hello, what is your name?John
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，你叫什么名字？约翰
- en: Hello, John
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，约翰
- en: Hello, what is your name?Ed
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，你叫什么名字？埃德
- en: Hello, Ed
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，埃德
- en: Hello, what is your name?exit
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，你叫什么名字？退出
- en: '[PRE81]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: const readline = require('readline');
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: const readline = require('readline');
- en: const interface = readline.createInterface({
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: const interface = readline.createInterface({
- en: input: process.stdin,
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 'input: process.stdin,'
- en: output: process.stdout,
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 'output: process.stdout,'
- en: '});'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE82]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: const login = function() {
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: const login = function() {
- en: interface.question("Hello, what is your name?", (name) => {
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: interface.question("你好，你叫什么名字？", (name) => {
- en: user = name;
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: user = name;
- en: prompt();
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: prompt();
- en: '});'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '}'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE83]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: const who = function () {
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: const who = function () {
- en: console.log(`User is ${user}`);
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: console.log(`用户是 ${user}`);
- en: prompt();
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: prompt();
- en: '}'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE84]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: const prompt = function() {
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: const prompt = function() {
- en: interface.question("login, who OR exit?", (input) => {
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: interface.question("登录，who 或 退出？", (input) => {
- en: if(input === "exit") {
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: if(input === "exit") {
- en: return interface.close(); // Will kill the loop.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: return interface.close(); // 将终止循环。
- en: '}'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: prompt();
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 提示();
- en: '});'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '}'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE85]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: if(input === "login") {
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: if(input === "login") {
- en: login();
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: login();
- en: '}'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE86]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: if(input === "who") {
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: if(input === "who") {
- en: who();
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: who();
- en: '}'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE87]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: const readline = require('readline');
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: const readline = require('readline');
- en: const interface = readline.createInterface({
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: const interface = readline.createInterface({
- en: 'input: process.stdin,'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 'input: process.stdin,'
- en: 'output: process.stdout,'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 'output: process.stdout,'
- en: '});'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: var choice;
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: var choice;
- en: var user;
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: var user;
- en: var cinema;
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: var cinema;
- en: const login = function() {
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: const login = function() {
- en: interface.question("Hello, what is your name?", (name) => {
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: interface.question("你好，你叫什么名字？", (name) => {
- en: user = name;
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: user = name;
- en: prompt();
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: prompt();
- en: '});'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '}'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: const who = function () {
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: const who = function () {
- en: console.log(`User is ${user}`)
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: console.log(`用户是 ${user}`)
- en: prompt();
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: prompt();
- en: '}'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: const prompt = function() {
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: const prompt = function() {
- en: interface.question("login, who OR exit?", (input) => {
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: interface.question("登录，who 或 退出？", (input) => {
- en: if(input === "exit") {
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: if(input === "exit") {
- en: return interface.close(); // Will kill the loop.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: return interface.close(); // 将终止循环。
- en: '}'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if(input === "login") {
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: if(input === "login") {
- en: login();
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: login();
- en: '}'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if(input === "who") {
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: if(input === "who") {
- en: who();
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: who();
- en: '}'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '}'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: prompt();
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: prompt();
- en: '[PRE88]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Chapter_8> node .\Exercise8.06.js
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter_8> node .\Exercise8.06.js
- en: login, who OR exit?login
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 登录，who 或 退出？登录
- en: Hello, what is your name?Michael
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，你叫什么名字？迈克尔
- en: login, who OR exit?who
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 登录，who 或 退出？who
- en: User is Michael
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 用户是Michael
- en: login, who OR exit?exit
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 登录，是谁还是退出？退出
- en: '```'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In this exercise, you created a basic interactive application using Node.js
    that lets the user choose from three inputs and outputs the result accordingly.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您创建了一个基本的交互式应用程序，使用Node.js让用户从三个输入中进行选择，并相应地输出结果。
- en: 'Activity 8.01: Creating a Simple Node.js Application'
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动8.01：创建一个简单的Node.js应用程序
- en: 'You have been engaged by a cinema company to create an application that allows
    customers to list the highest rated movies in a selected category. Customers should
    be able to provide a category and the responses within a named command-line list.
    They also need to provide details of their favorite movie to be captured within
    the favorite field. Finally, once all this is done, the customer should be able
    to `exit` the application, as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 您已被一家电影公司聘请，创建一个应用程序，允许客户列出所选类别中评分最高的电影。客户应该能够提供一个类别，并在命名的命令行列表中提供响应。他们还需要提供他们最喜欢的电影的详细信息，以便在收藏字段中捕获。最后，完成所有这些后，客户应该能够`退出`应用程序，如下所示：
- en: '`"list"`: Ask the user for a genre, and then query the database for the top
    five movies in that genre, outputting the `ID`, `title`, and `favourite` fields.'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"列表"`：询问用户一个流派，然后查询该流派中排名前五的电影，输出`ID`、`标题`和`favourite`字段。'
- en: '`"favourite"`: Ask the user for a film ID, and then update that film with a
    favorite field.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"favourite"`：询问用户一个电影ID，然后更新该电影的收藏字段。'
- en: '`"exit"`: Quit the interactive loop and the application.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"退出"`：退出交互循环和应用程序。'
- en: This activity aims to create a small Node.js application that exposes an interactive
    input loop to the user. Within this loop, users can query information in the database
    by genre, as well as update records by ID. You will need to ensure that you also
    handle any errors that may occur from users' input.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动旨在创建一个小型的Node.js应用程序，向用户公开一个交互式输入循环。在此循环中，用户可以通过流派查询数据库中的信息，并通过ID更新记录。您还需要确保处理可能出现的用户输入错误。
- en: You may complete this objective in several ways, but remember what we have learned
    throughout this chapter and attempt to create simple, easy-to-use code.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过多种方式完成此目标，但请记住我们在本章中学到的内容，并尝试创建简单、易于使用的代码。
- en: 'The following high-level steps will help you to complete this task:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 以下高级步骤将帮助您完成此任务：
- en: Import the `readline` and MongoDB libraries.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`readline`和MongoDB库。
- en: Create your `readline` interface.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建您的`readline`接口。
- en: Declare any variables you will need.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明您将需要的任何变量。
- en: Create a function called list that will fetch the top five highest rated films
    for a given genre, returning the `title`, `favorite`, and `ID` fields.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为列表的函数，它将为给定流派获取排名前五的最高评分电影，返回`标题`、`收藏`和`ID`字段。
- en: Note
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You will need to ask for the category in this function. Look at the login method
    in *Exercise 8.05*, *Handling Inputs in Node.js*, for more information.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要在此函数中询问类别。查看*练习8.05*，*在Node.js中处理输入*中的登录方法，以获取更多信息。
- en: 'Create a function called `favourite` that will update a document by title and
    add a key called `favourite` with a value of `true` to the document. (*Hint: You
    will need to ask for the title in this function using the same method you used
    for your list function.*)'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`favourite`的函数，它将通过标题更新文档，并向文档添加一个名为`favourite`的键，其值为`true`。（提示：在此函数中，您将需要使用与列表函数相同的方法询问标题。）
- en: Create the MongoDB connection, database, and collection.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建MongoDB连接、数据库和集合。
- en: Create an interactive while loop based on the user's input. If you're unsure
    how to do this, refer to our prompt function from *Exercise 8.05*, *Handling Inputs
    in Node.js*.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于用户输入创建一个交互式while循环。如果您不确定如何做到这一点，请参考我们在*练习8.05*，*在Node.js中处理输入*中的提示函数。
- en: Inside the interactive loop, use if conditions to check for the input. If a
    valid input is found, run the relevant function.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在交互循环中，使用if条件来检查输入。如果找到有效输入，则运行相关函数。
- en: 'Remember, you will need to pass the database and client objects through to
    each of your functions, including any time you call `prompt()`. To test your output,
    run the following commands:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请记住，您需要通过每个函数传递数据库和客户端对象，包括每次调用`prompt()`。要测试您的输出，请运行以下命令：
- en: '`list`'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`列表`'
- en: '`Horror`'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`恐怖`'
- en: '`favourite`'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`favourite`'
- en: '`list`'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`列表`'
- en: '`exit`'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`退出`'
- en: 'The expected output is as follows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: Note
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may notice that the title `Nosferatu` appears twice in the output. If you
    look at the `_id` values, you will see that these are actually two separate films
    with the same title. In MongoDB, you may have many different documents that share
    the same values in their fields.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到输出中标题`Nosferatu`出现了两次。如果查看`_id`值，您会发现这实际上是两部具有相同标题的不同电影。在MongoDB中，您可能有许多不同的文档，它们在字段中共享相同的值。
- en: '![Figure 8.8: Final output (truncated for brevity)'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8：最终输出（为简洁起见截断）'
- en: '](img/B15507_08_08.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_08_08.jpg)'
- en: 'Figure 8.8: Final output (truncated for brevity)'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：最终输出（为简洁起见截断）
- en: Note
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15507_Solution_Final_SZ_ePub.xhtml#_idTextAnchor475).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可通过[此链接](B15507_Solution_Final_SZ_ePub.xhtml#_idTextAnchor475)找到。
- en: Summary
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have covered the basic concepts that are essential to the
    creation of a MongoDB-powered application using the Node.js driver. Using these
    fundamentals, a vast number of scripts can be created to perform queries and operations
    on your database. We even learned to handle errors and create interactive applications.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经介绍了创建使用Node.js驱动程序的MongoDB应用程序所必需的基本概念。使用这些基础知识，可以创建大量脚本来执行对数据库的查询和操作。我们甚至学会了处理错误和创建交互式应用程序。
- en: Although you may not be required to write or read applications like these as
    part of your day-to-day responsibilities, having a thorough understanding of how
    these applications are built gives you a unique insight into MongoDB development
    and how your peers may interact with your MongoDB data.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您可能不需要在日常工作职责中编写或阅读这些应用程序，但对这些应用程序是如何构建的有深入的理解，可以让您独特地了解MongoDB开发以及您的同行可能如何与您的MongoDB数据交互。
- en: However, if you are looking to increase your expertise with regards to the Node.js
    driver for MongoDB, this is just the beginning. There are many different patterns,
    libraries, and best practices you can use to develop Node.js applications against
    MongoDB. This is just the beginning of your Node.js journey.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想增加对于 MongoDB 的 Node.js 驱动的专业知识，这只是个开始。有许多不同的模式、库和最佳实践可以用来开发针对 MongoDB
    的 Node.js 应用程序。这只是你 Node.js 之旅的开始。
- en: In the next chapter, we will dive deeper into improving the performance of your
    MongoDB interactions and create efficient indexes that will speed up your queries.
    Another useful feature we will cover is the use of `explain` and how to best interpret
    its output.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨如何提高 MongoDB 交互的性能，并创建高效的索引来加快查询速度。我们还将介绍另一个有用的功能，即使用 `explain`
    并且如何最好地解释其输出。
