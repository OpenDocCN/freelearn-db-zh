- en: 9\. Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9\. 性能
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces you to the concepts of query optimization and performance
    improvement in MongoDB. You will first explore the internal workings of query
    execution and identify the factors that can affect query performance, before moving
    on to database indexes and how indexes can reduce query execution time. You will
    also learn how to create, list, and delete indexes, and study the various types
    of indexes and their benefits. In the final sections, you will be introduced to
    various query optimization techniques that can help you use indexes effectively.
    By the end of this chapter, you will be able to analyze queries and use indexes
    and optimization techniques to improve query performance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了MongoDB中查询优化和性能改进的概念。您将首先探索查询执行的内部工作原理，并确定可能影响查询性能的因素，然后转向数据库索引以及索引如何减少查询执行时间。您还将学习如何创建、列出和删除索引，并研究各种类型的索引及其好处。在最后几节中，您将了解各种查询优化技术，帮助您有效地使用索引。通过本章的学习，您将能够分析查询并使用索引和优化技术来提高查询性能。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapters, we learned about the MongoDB query language and various
    query operators. We learned how to write queries to retrieve data. We also learned
    about various commands used to add and delete data and also to update or modify
    a piece of data. We ensured that the queries bring us the desired output; however,
    we did not pay much attention to their execution time and their efficiency. In
    this chapter, we will focus on how to analyze a query's performance and optimize
    its performance further, if needed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们学习了MongoDB查询语言和各种查询操作符。我们学会了如何编写查询来检索数据。我们还学习了用于添加和删除数据以及更新或修改数据的各种命令。我们确保查询带来了我们期望的输出；然而，我们并没有过多关注它们的执行时间和效率。在本章中，我们将专注于如何分析查询的性能，并在需要时进一步优化其性能。
- en: Real-world applications are made up of multiple components, such as a user interface,
    processing components, databases, and more. The responsiveness of an application
    is dependent on the efficiency of each of these components. The database component
    performs different operations, such as saving, reading, and updating data. The
    amount of data a database table or collection stores, or the amount of data being
    pushed into or retrieved from a database, can affect the performance of the entire
    system. Therefore, it is important to know how efficiently database operations
    are executed and whether further optimization is possible to improve the speed
    of those operations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界的应用程序由多个组件组成，如用户界面、处理组件、数据库等。应用程序的响应性取决于每个组件的效率。数据库组件执行不同的操作，如保存、读取和更新数据。数据库表或集合存储的数据量，或者从数据库中推送或检索的数据量，都可能影响整个系统的性能。因此，重要的是要知道数据库操作的执行效率如何，以及是否可能进一步优化以提高这些操作的速度。
- en: In the next section, you will learn how to analyze queries based on the detailed
    statistics provided by the database and use them to identify problems.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何根据数据库提供的详细统计信息来分析查询，并用它们来识别问题。
- en: Query Analysis
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询分析
- en: In order to write efficient queries, it is important to analyze them, find any
    possible performance issues, and fix them. This technique is called performance
    optimization. There are many factors that can negatively affect the performance
    of a query, such as incorrect scaling, incorrectly structured collections, and
    inadequate resources such as RAM and CPU. However, the biggest and most common
    factor is the difference between the number of records scanned and the number
    of records returned during the query execution. The greater the difference is,
    the slower the query will be. Thankfully, in MongoDB, this factor is the easiest
    to address and is done using indexes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写高效的查询，重要的是分析它们，找出可能的性能问题，并加以修复。这种技术称为性能优化。有许多因素可能会对查询的性能产生负面影响，比如不正确的缩放、结构不正确的集合，以及RAM和CPU等资源不足。然而，最大和最常见的因素是在查询执行过程中扫描的记录数和返回的记录数之间的差异。差异越大，查询就会越慢。幸运的是，在MongoDB中，这个因素是最容易解决的，可以使用索引来解决。
- en: Creating and using indexes on a collection narrows down the number of records
    being scanned and improves the query performance noticeably. Before we delve further
    into indexes, though, we first need to cover the details of query execution.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合上创建和使用索引可以缩小扫描的记录数，并显著提高查询性能。然而，在深入研究索引之前，我们首先需要了解查询执行的细节。
- en: 'Say you want to find a list of the movies released in the year 2015\. The following
    snippet shows the command for this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要查找2015年上映的电影列表。以下代码片段显示了此命令：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The query filters the `movies` collection based on the `year` field, projects
    the movie title and awards won in the output, and sorts the results so that the
    movies with the greatest number of wins appear at the top. If we execute this
    query by connecting to the MongoDB Atlas `sample_mflix` database, it returns **484**
    records.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 该查询根据`year`字段过滤`movies`集合，将电影标题和获奖情况投影到输出中，并对结果进行排序，以便获得获奖次数最多的电影出现在顶部。如果我们连接到MongoDB
    Atlas的`sample_mflix`数据库执行此查询，它将返回**484**条记录。
- en: 'To execute any such query, the MongoDB query execution engine prepares one
    or more query execution plans. The database has an inbuilt query optimizer that
    chooses the most efficient plan for the execution. A plan is usually composed
    of multiple processing stages that are executed in sequence to produce the final
    output. The previous query we created has a query condition, a projection expression,
    and a sort specification. For the queries with similar shapes, a typical execution
    plan will look as shown in *Figure 9.1*:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行任何这样的查询，MongoDB查询执行引擎会准备一个或多个查询执行计划。数据库具有内置的查询优化器，选择执行效率最高的计划。计划通常由多个处理阶段组成，按顺序执行以产生最终输出。我们之前创建的查询具有查询条件、投影表达式和排序规范。对于形状相似的查询，典型的执行计划将如*图9.1*所示：
- en: '![Figure 9.1: Query execution stages'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1：查询执行阶段'
- en: '](img/B15507_09_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_09_01.jpg)'
- en: 'Figure 9.1: Query execution stages'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：查询执行阶段
- en: At first, if there is a supporting index for the given query condition, the
    index is scanned to identify the matching records. In our case, the `year` field
    does not have an index, and so the index scan stage will be ignored. In the next
    stage, the full collection is scanned to find the matching records. The matched
    records are then passed to the sort stage, where the records are sorted in memory.
    Finally, projection is applied to the sorted records and the final output is delivered
    to the client.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果给定的查询条件有支持的索引，索引将被扫描以识别匹配的记录。在我们的案例中，`year`字段没有索引，因此索引扫描阶段将被忽略。在下一个阶段，将扫描整个集合以找到匹配的记录。匹配的记录然后传递到排序阶段，在那里记录在内存中排序。最后，投影应用于排序的记录，并将最终输出传递给客户端。
- en: MongoDB provides a query analysis mechanism with which we can fetch some useful
    stats about query execution. In the next section, we will learn how to use query
    analysis and stats to identify performance issues in the previous query.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB提供了一个查询分析机制，我们可以从中获取有关查询执行的一些有用统计信息。在下一节中，我们将学习如何使用查询分析和统计信息来识别先前查询中的性能问题。
- en: Explaining the Query
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释查询
- en: 'The `explain()` function is extremely useful for exploring the internal workings
    of a query. The function can be used along with a query or a command to print
    detailed statistics pertinent to their execution. The most important metrics it
    can give us are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`explain()`函数非常有用，可以用于探索查询的内部工作原理。该函数可以与查询或命令一起使用，以打印与它们的执行相关的详细统计信息。它可以给我们的最重要的指标如下：'
- en: Query execution time
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询执行时间
- en: Number of documents scanned
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描的文档数量
- en: Number of documents returned
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回的文档数量
- en: The index that was used
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的索引
- en: 'The following code snippet shows an example of using the `explain` function
    on a query using the same query that you created previously:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了在先前创建的相同查询上使用`explain`函数的示例：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note that the `explain` function can also be used with the following commands:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`explain`函数也可以与以下命令一起使用：
- en: '`remove()`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove()`'
- en: '`update()`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update()`'
- en: '`count()`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count()`'
- en: '`aggregate()`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aggregate()`'
- en: '`distinct()`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distinct()`'
- en: '`findAndModify()`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findAndModify()`'
- en: 'By default, the `explain` function prints the query planner details—that is,
    details of various execution stages. This can be seen in the following snippet:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`explain`函数打印查询规划器的详细信息，即各种执行阶段的详细信息。可以在以下片段中看到：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The output shows the winning plan and a list of rejected plans. In the case
    of the preceding query, the execution began with `COLLSCAN` as there was no suitable
    index. Thus, the query does not have any rejected plans, and the only plan available
    was the winning plan. In the winning plan, there are multiple nested `inputStage`
    objects, which clearly shows the execution sequence of different stages.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了获胜计划和一系列被拒绝的计划。在前面的查询中，执行从`COLLSCAN`开始，因为没有合适的索引。因此，查询没有任何被拒绝的计划，唯一可用的计划是获胜计划。在获胜计划中，有多个嵌套的`inputStage`对象，清楚地显示了不同阶段的执行顺序。
- en: The first stage is `COLLSCAN`, where a filter is applied to the `year` field.
    The next stage, `SORT`, performs the sorting based on the `awards.wins` field—that
    is, the number of awards won. Finally. in the `PROJECTION_DEFAULT` stage, the
    `title` and `awards.wins` fields are selected and returned in the output.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个阶段是`COLLSCAN`，在这个阶段对`year`字段应用了过滤器。接下来的阶段`SORT`，根据`awards.wins`字段进行排序，即获奖数量。最后，在`PROJECTION_DEFAULT`阶段，选择并返回了`title`和`awards.wins`字段。
- en: 'The `explain` function can take an optional argument called verbosity mode,
    which controls what information is returned by the function. The following list
    details the three different verbosity levels:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`explain`函数可以接受一个名为详细模式的可选参数，该参数控制函数返回的信息。以下列表详细说明了三种不同的详细模式：'
- en: '`queryPlanner`: This is the default option and prints query planner details
    such as rejected plans, the winning plan, and the execution stages of the winning
    plan.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`queryPlanner`：这是默认选项，打印查询规划器的详细信息，例如被拒绝的计划、获胜计划以及获胜计划的执行阶段。'
- en: '`executionStats`: This option prints all the information provided by `queryPlanner`
    along with detailed execution statistics for the query execution. This option
    is useful for finding any performance-related problems in queries.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`executionStats`：此选项打印`queryPlanner`提供的所有信息，以及查询执行的详细执行统计信息。此选项对于查找查询中的任何与性能相关的问题非常有用。'
- en: '`allPlansExecution`: This option outputs the details provided by `executionStats`
    along with the details of the rejected execution plans.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`allPlansExecution`：此选项输出`executionStats`提供的详细信息，以及被拒绝的执行计划的详细信息。'
- en: Viewing Execution Stats
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看执行统计信息
- en: 'In order to view the execution stats, you need to pass `executionStats` as
    an argument to the `explain()` function. The following snippet shows `executionStats`
    for your query:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看执行统计信息，您需要将`executionStats`作为`explain()`函数的参数传递。以下片段显示了您的查询的`executionStats`：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The execution stats provide useful metrics pertinent to each execution phase,
    along with some top-level fields where some metrics are aggregated over the total
    execution of the query. The following are some of the most important metrics from
    the execution stats:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 执行统计信息提供了与每个执行阶段相关的有用指标，以及一些顶层字段，其中一些指标在查询的总执行过程中进行了聚合。以下是执行统计信息中一些最重要的指标：
- en: '`executionTimeMillis`: This is the total time (in milliseconds) taken for query execution.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`executionTimeMillis`：这是查询执行所花费的总时间（以毫秒为单位）。'
- en: '`totalKeysExamined`: This indicates the number of indexed keys that were scanned.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`totalKeysExamined`：这表示扫描的索引键的数量。'
- en: '`totalDocsExamined`: This indicates the number of documents examined against
    the given query condition.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`totalDocsExamined`：这表示针对给定查询条件检查的文档数量。'
- en: '`nReturned`: This is the total number of records returned in the query output.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nReturned`：这是查询输出中返回的记录总数。'
- en: Now, let's analyze the execution stats in the next section.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在下一节中分析执行统计信息。
- en: Identifying Problems
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别问题
- en: The execution stats (as seen from the preceding snippet) tell us that there
    are a few problems with the querying process. To return `484` matching records,
    the query examined `23539` documents, which is also the total number of documents
    in the collection. Having to scan a large number of documents slows down the query
    execution. Looking at the query execution time of `85` milliseconds, it seems
    like it is fast enough. However, the query execution time can vary based on the
    network traffic, the RAM and CPU loads on the server, and the number of records
    getting scanned. The reason the number of scanned documents slows down the performance
    is explained in the following section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 执行统计数据（如前面片段所示）告诉我们查询过程中存在一些问题。为了返回`484`条匹配记录，查询检查了`23539`个文档，这也是集合中的文档总数。扫描大量文档会减慢查询执行速度。看到查询执行时间为`85`毫秒，似乎很快。然而，查询执行时间可能会根据网络流量、服务器上的RAM和CPU负载以及扫描的记录数量而变化。扫描文档数量减慢性能的原因将在下一节中解释。
- en: Linear Search
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性搜索
- en: When we execute a `find` query with a search criterion on a collection, the
    database search engine picks the first record in the collection and checks whether
    it matches the given criteria. If no match is found, the search engine moves on
    to the next record to find a match, and the process is repeated till a search
    is found.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在集合上执行一个带有搜索条件的`find`查询时，数据库搜索引擎会选择集合中的第一条记录，并检查它是否符合给定的条件。如果没有找到匹配项，搜索引擎会继续查找下一条记录，直到找到匹配项为止。
- en: This search technique is called a sequential or linear search. Linear searches
    perform better when they are applied to a small amount of data, or in the best-case
    scenarios, where the required term is found within the first search. Thus, the
    search performance will be good when searching for a document in a small collection.
    However, it will be noticeably poorer if there is a large amount of data, or in
    the worst-case scenario, when the required term exists at the end of the collection.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种搜索技术称为顺序或线性搜索。线性搜索在应用于少量数据或在最佳情况下，即所需项在第一次搜索中找到时表现更好。因此，在小集合中搜索文档时，搜索性能会很好。然而，如果数据量很大，或者在最坏的情况下，即所需项存在于集合的末尾时，性能将明显较差。
- en: Most of the time, when a newly built system goes live, the collections are either
    empty or they hold a very small amount of data. Thus, all the database operations
    are instant. But, over time, as the collections grow in size, the same operations
    start taking longer. The primary reason for the slowness is linear search, which
    is the default search algorithm used by most databases, including MongoDB. Linear
    searches can be avoided or at least limited by creating indexes on specific fields
    of a collection. In the next section, we will explore this concept in detail.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，当新建的系统投入使用时，集合要么是空的，要么包含非常少量的数据。因此，所有数据库操作都是瞬时的。但随着时间的推移，随着集合的增长，相同的操作开始花费更长的时间。缓慢的主要原因是线性搜索，这是大多数数据库（包括MongoDB）使用的默认搜索算法。可以通过在集合的特定字段上创建索引来避免或至少限制线性搜索。在下一节中，我们将详细探讨这个概念。
- en: Introduction to Indexes
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引简介
- en: Databases can maintain and use indexes to make searches more efficient. In MongoDB,
    indexes are created on a field or a combination of fields. The database maintains
    a special registry of indexed fields and some of their data. The registry is easily
    searchable, as it maintains a logical link between the value of an indexed field
    and the respective documents in the collection. During a search operation, the
    database first locates the value in the registry and identifies the matching documents
    in the collection accordingly. The values in a registry are always sorted in ascending
    or descending order of the values, which helps during a range search and also
    while sorting the results.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库可以维护和使用索引以使搜索更加高效。在MongoDB中，索引可以创建在一个字段或多个字段上。数据库维护一个索引字段的特殊注册表和一些它们的数据。注册表易于搜索，因为它维护了索引字段值和集合中相应文档之间的逻辑链接。在搜索操作期间，数据库首先在注册表中定位值，并相应地识别集合中的匹配文档。注册表中的值总是按值的升序或降序排序，这有助于范围搜索以及对结果进行排序。
- en: 'To better understand how the index registry helps during searches, imagine
    you are searching for a theater by its ID, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解索引注册表在搜索过程中的帮助，想象一下你正在按照其ID搜索剧院：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When the query is executed on the `sample_mflix` database, it returns a single
    record. Note that the total number of theaters in the collection is 1,564\. The
    following diagram depicts the difference between document searches with and without
    an index:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`sample_mflix`数据库上执行查询时，返回一条记录。请注意，集合中的剧院总数为1,564。以下图示了带有和不带有索引的文档搜索之间的差异：
- en: '![Figure 9.2: Data search with and without an index'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2：带有索引和不带索引的数据搜索'
- en: '](img/B15507_09_02.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_09_02.jpg)'
- en: 'Figure 9.2: Data search with and without an index'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：带有索引和不带索引的数据搜索
- en: The following table represents the number of documents scanned against the number
    of documents returned in these two different scenarios.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格代表了在这两种不同情况下扫描的文档数量与返回的文档数量。
- en: '![Figure 9.3: Details about the documents scanned and the documents returned'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3：扫描的文档和返回的文档的详细信息'
- en: '](img/B15507_09_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_09_03.jpg)'
- en: 'Figure 9.3: Details about the documents scanned and the documents returned'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：扫描的文档和返回的文档的详细信息
- en: Looking at the preceding table, it is clear that searching with an index is
    preferable to searching without one. In this section, we learned that databases
    support indexes for the faster retrieval of data and how the index registry helps
    avoid complete collection scans. We will now learn how to create an index and
    find indexes in a collection.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从上表可以看出，使用索引进行搜索比不使用索引更可取。在本节中，我们了解到数据库支持索引以更快地检索数据，以及索引注册表如何帮助避免完全扫描集合。现在我们将学习如何创建索引并在集合中查找索引。
- en: Creating and Listing Indexes
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和列出索引
- en: 'Indexes can be created by executing a `createIndex()` command on a collection,
    as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在集合上执行`createIndex()`命令来创建索引，如下所示：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first argument to the command is a list of key-value pairs, where each pair
    consists of a field name and sort order, and the optional second argument is a
    set of options to control the indexes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的第一个参数是一个键值对列表，其中每对由字段名和排序顺序组成，可选的第二个参数是一组控制索引的选项。
- en: 'In a previous section, you wrote the following query to find all the movies
    released in 2015, sort them in descending order of the number of awards won, and
    print the title and number of wins:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您编写了以下查询，以查找所有在2015年发布的电影，按获奖数量降序排序，并打印标题和获奖次数：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As the query uses a filter on the `year` field, you need to create an index
    on that field. The next command creates an index on the `year` field by passing
    a sort order of `1`, which indicates ascending order:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于查询在`year`字段上使用了过滤器，因此需要在该字段上创建一个索引。下一个命令通过传递`1`的排序顺序在`year`字段上创建一个索引，表示升序：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The next snippet shows the output after executing the command on the mongo
    shell:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的片段显示了在mongo shell上执行命令后的输出：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The output indicates that the index was successfully created. It also mentions
    the number of indexes present before and after the execution of this command (see
    the highlighted part in the code) and the time the index was created.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明索引已成功创建。它还提到了在执行此命令之前和之后存在的索引数量（请参阅代码中的突出部分）以及索引创建的时间。
- en: Listing Indexes on a Collection
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在集合上列出索引
- en: You can list the indexes of a collection by using the `getIndexes()` command.
    This command does not take any parameters. It simply returns an array of indexes
    with some basic details.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`getIndexes()`命令列出集合的索引。此命令不带任何参数。它只是返回一组带有一些基本详细信息的索引数组。
- en: 'Executing the following command will list all the indexes present in the `movies` collection:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令将列出`movies`集合中存在的所有索引：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output for this will be as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出将如下所示：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The output indicates that there are three indexes on the collection, including
    the one you just created. For each index, it displays the version, indexed fields
    and their sort order, the index name, and a namespace made up of the index name
    and database name. Note that, while creating the index on the `year` field, you
    did not specify its name. You will see how index names are derived in the next
    section.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明集合中有三个索引，包括您刚刚创建的索引。对于每个索引，它显示了版本、索引字段及其排序顺序、索引名称和由索引名称和数据库名称组成的命名空间。请注意，当在`year`字段上创建索引时，您没有指定其名称。您将在下一节中了解索引名称是如何派生的。
- en: Index Names
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引名称
- en: MongoDB assigns a default name to an index if a name is not provided explicitly.
    The default name of an index consists of the field name and the sort order, separated
    by underscores. If there is more than one key in the index (known as a compound
    index), all the keys are concatenated in the same manner.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未明确提供名称，MongoDB会为索引分配一个默认名称。索引的默认名称由字段名称和排序顺序以下划线分隔组成。如果索引中有多个键（称为复合索引），则所有键都以相同的方式连接。
- en: 'The following command creates an index for the `theaterId` field without providing
    a name:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令为`theaterId`字段创建一个索引，而不提供名称：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This command will result in the creation of an index with the default name `theaterId_1`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将导致创建一个名为`theaterId_1`的索引。
- en: 'However, you can also create an index with a specific name. To do so, you can
    use the `name` attribute to provide a custom name to the index, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您也可以使用特定名称创建索引。为此，您可以使用`name`属性为索引提供自定义名称，如下所示：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding command will create an index with the name `myTheaterIdIndex`.
    In the next exercise, you will use MongoDB Atlas to create an index.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将创建一个名为`myTheaterIdIndex`的索引。在下一个练习中，您将使用MongoDB Atlas创建一个索引。
- en: 'Exercise 9.01: Creating an Index Using MongoDB Atlas'
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.01：使用MongoDB Atlas创建索引
- en: 'In the previous section, you learned how to create an index using the mongo
    shell. In this exercise, you will use the MongoDB Atlas portal to create an index
    on the `accounts` collection, which is present in the `sample_analytics` database.
    Perform the following steps to complete this exercise:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您学习了如何使用mongo shell创建索引。在本练习中，您将使用MongoDB Atlas门户在`sample_analytics`数据库中的`accounts`集合上创建一个索引。执行以下步骤完成此练习：
- en: Sign in to your account at [https://www.mongodb.com/cloud/atlas](https://www.mongodb.com/cloud/atlas).
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到您的帐户[https://www.mongodb.com/cloud/atlas](https://www.mongodb.com/cloud/atlas)。
- en: 'Go to the `sample_analytics` database and select the `accounts` collection.
    On the collection screen, select the `Indexes` tab, and you should see one index.![Figure
    9.4: The Indexes tab in the accounts collection in the sample_analytics database'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`sample_analytics`数据库并选择`accounts`集合。在集合屏幕上，选择`Indexes`选项卡，您应该看到一个索引。![图9.4：`sample_analytics`数据库中`accounts`集合中的索引选项卡
- en: '](img/B15507_09_04.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_09_04.jpg)'
- en: 'Figure 9.4: The Indexes tab in the accounts collection in the sample_analytics
    database'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：`sample_analytics`数据库中`accounts`集合中的索引选项卡
- en: 'Click on the `CREATE INDEX` button in the top-right corner. You should be presented
    with a modal, as shown in the following figure:![Figure 9.5: The Create Index
    page'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击右上角的`CREATE INDEX`按钮。您应该会看到一个模态框，如下图所示：![图9.5：创建索引页面
- en: '](img/B15507_09_05.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_09_05.jpg)'
- en: 'Figure 9.5: The Create Index page'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：创建索引页面
- en: 'To create an index on `account_id`, remove the default field and type entries
    from the `FIELDS` section. Introduce `account_id` as the field and type with value
    `1` for ascending index order. The following is a screenshot showing the updated
    `FIELDS` section:![Figure 9.6: Updated FIELDS section'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在`account_id`上创建一个索引，从`FIELDS`部分中删除默认字段和类型条目。将`account_id`作为字段引入，并将值为`1`的类型作为升序索引顺序。以下是显示更新后的`FIELDS`部分的屏幕截图：![图9.6：更新的FIELDS部分
- en: '](img/B15507_09_06.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_09_06.jpg)'
- en: 'Figure 9.6: Updated FIELDS section'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：更新的FIELDS部分
- en: 'Pass the `name` parameter to provide a custom name for this index in the `OPTIONS`
    section, as shown here:![Figure 9.7: Passing the name parameter in the OPTIONS
    section'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传递`name`参数以在`OPTIONS`部分提供自定义索引名称，如下所示：![图9.7：在OPTIONS部分传递name参数
- en: '](img/B15507_09_07.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_09_07.jpg)'
- en: 'Figure 9.7: Passing the name parameter in the OPTIONS section'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7：在OPTIONS部分传递name参数
- en: Once you update the fields section, the `Review` button should turn green. Click
    on it to go to the next step:![Figure 9.8 The Review button
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦更新字段部分，`Review`按钮应该变成绿色。单击它以进行下一步：![图9.8 评论按钮
- en: '](img/B15507_09_08.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_09_08.jpg)'
- en: Figure 9.8 The Review button
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 评论按钮
- en: 'A confirmation screen will be presented to you. Click the `Confirm` button
    on the following screen to finish creating the index:![Figure 9.9: Confirmation
    screen'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将向您呈现确认屏幕。在下一个屏幕上单击“确认”按钮以完成创建索引：![图9.9：确认屏幕
- en: '](img/B15507_09_09.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_09_09.jpg)'
- en: 'Figure 9.9: Confirmation screen'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9：确认屏幕
- en: 'Once the index creation is finished, the index list will be updated, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 索引创建完成后，索引列表将更新如下：
- en: '![Figure 9.10: Updated index list'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.10：更新的索引列表'
- en: '](img/B15507_09_10.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_09_10.jpg)'
- en: 'Figure 9.10: Updated index list'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10：更新的索引列表
- en: In this exercise, you have successfully created indexes using the MongoDB Atlas portal.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您已成功使用MongoDB Atlas门户创建了索引。
- en: You have now learned how to create an index on a collection. Next, you will
    see how an indexed field improves query performance.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经学会了如何在集合上创建索引。接下来，您将看到索引字段如何提高查询性能。
- en: Query Analysis after Indexes
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引后的查询分析
- en: In the *Query Analysis* section, you analyzed the performance of a query that
    did not have suitable indexes to support its query condition. Because of this,
    the query scanned all `23539` documents in the collection to return `484` matching
    documents. Now that you have added an index on the `year` field, let's see how
    the query execution stats have changed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在*查询分析*部分，您分析了一个没有合适的索引来支持其查询条件的查询的性能。因此，查询扫描了集合中的所有`23539`个文档，返回了`484`个匹配的文档。现在您已经在`year`字段上添加了一个索引，让我们看看查询执行统计数据如何改变。
- en: 'The following query prints the execution statistics for the same query:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询打印了相同查询的执行统计信息：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output for this is slightly different than the previous one, as shown in
    the following snippet:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这次的输出与之前的略有不同，如下所示：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first difference is that the first stage (that is, `COLLSCAN`) is now replaced
    by `IXSCAN` and `FETCH` stages. This means that first, an index scan stage was
    performed, and then, based on the retrieved index references, the data was fetched
    from the collection. Also, the top-level fields indicate that only `484` documents
    were examined, and the same number of documents were returned.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个不同之处在于第一个阶段（即`COLLSCAN`）现在被`IXSCAN`和`FETCH`阶段所取代。这意味着首先执行了索引扫描阶段，然后根据检索到的索引引用，从集合中获取了数据。此外，顶层字段表明只检查了`484`个文档，并返回了相同数量的文档。
- en: Thus, we see that query performance is greatly improved by reducing the number
    of documents being scanned. This is evident here as the query execution time is
    now reduced to `7` milliseconds from `85` milliseconds. Even as more and more
    documents are pushed into the collection every year, the performance of the query
    will remain consistent.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们看到通过减少扫描的文档数量，查询性能得到了极大的改善。正如在这里所表现的那样，查询执行时间现在从`85`毫秒减少到了`7`毫秒。即使每年向集合中推入更多的文档，查询的性能也将保持一致。
- en: We have seen how to create indexes and also how to list the indexes from a collection.
    MongoDB also provides a way to remove or drop an index. The following section
    will explore this in detail.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何创建索引，以及如何列出集合中的索引。MongoDB还提供了一种删除索引的方法。接下来的部分将详细探讨这一点。
- en: Hiding and Dropping Indexes
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐藏和删除索引
- en: Dropping an index means removing the values of the fields from the index registry.
    Thus, any searches on the related fields will be performed in a linear fashion,
    provided there are no other indexes present on the field.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 删除索引意味着从索引注册表中删除字段的值。因此，对相关字段的任何搜索都将以线性方式执行，前提是该字段上没有其他索引。
- en: It is important to note that MongoDB does not allow updating an existing index.
    Thus, to fix an incorrectly created index, we need to drop it and recreate it
    correctly.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，MongoDB不允许更新现有的索引。因此，要修复错误创建的索引，我们需要删除它并正确地重新创建它。
- en: 'An index is deleted using the `dropIndex` function. It takes a single parameter,
    which can either be the index name or the index specification document, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dropIndex`函数删除索引。它接受一个参数，可以是索引名称或索引规范文档，如下所示：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The index specification document is the definition of the index that is used
    to create it (like the following snippet, for example):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 索引规范文档是用于创建索引的索引定义（例如以下代码片段）：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Consider the following snippet:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This command drops the index on the `title` field of the `movies` collection:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令删除了`movies`集合中`title`字段上的索引：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The output contains `nIndexesWas` (highlighted), which refers to the index count
    before the command was executed. The `ok` field shows the status as `1`, which
    indicates the command was successful.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 输出包含`nIndexesWas`（已突出显示），它指的是在执行命令之前的索引计数。`ok`字段显示状态为`1`，表示命令执行成功。
- en: Dropping Multiple Indexes
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除多个索引
- en: 'You can also drop multiple indexes using the `dropIndexes` command. The command
    syntax is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`dropIndexes`命令删除多个索引。命令语法如下：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This command can be used to drop all the indexes on a collection except the
    default `_id` index. You can use the command to drop a single index by passing
    either the index name or the index specification document. You can also use the
    command to delete a group of indexes by passing an array of index names. The following
    is an example of the `dropIndexes` command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令可用于删除集合上的所有索引，除了默认的`_id`索引。您可以通过传递索引名称或索引规范文档来使用该命令删除单个索引。您还可以通过传递索引名称数组来使用该命令删除一组索引。以下是`dropIndexes`命令的示例：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding command generates the following output:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令生成以下输出：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: All the indexes except the default `_id` index were dropped, as confirmed in
    the `msg` attribute (highlighted).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 除了默认的`_id`索引之外，所有索引都已删除，如`msg`属性（已突出显示）中所确认的那样。
- en: Hiding an Index
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏索引
- en: MongoDB provides a way to hide indexes from the query planner. Creating and
    deleting indexes are expensive operations in terms of time. For large collections,
    these operations take longer to finish. So, before you decide to remove an index,
    you can first hide it to analyze the performance impact and then decide accordingly.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB提供了一种方法来隐藏查询规划器中的索引。创建和删除索引在时间上是昂贵的操作。对于大型集合，这些操作需要更长的时间才能完成。因此，在决定删除索引之前，您可以首先隐藏它以分析性能影响，然后据此决定。
- en: 'To hide an index, the `hideIndex()` command can be used on the collection,
    as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要隐藏索引，可以在集合上使用`hideIndex()`命令，如下所示：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The argument to the command is similar to that for the `dropIndex()` function.
    It takes either the name of the index or an index specification document.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的参数与`dropIndex()`函数类似。它接受索引的名称或索引规范文档。
- en: An important thing to note is that hidden indexes appear only on the `getIndexes()`
    function call. They are updated after every write operation on the collection.
    However, the query planner won't see these indexes, and so they cannot be used
    for executing queries.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，隐藏的索引只出现在`getIndexes()`函数调用中。它们在集合上的每次写操作后更新。但是，查询规划器看不到这些索引，因此不能用于执行查询。
- en: 'Once an index is hidden, you can analyze the impact on the queries and drop
    the indexes if they are truly unneeded. However, if hiding an index has an adverse
    effect on performance, you can restore or unhide them by using the `unhideIndex()`
    function, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦索引被隐藏，您可以分析对查询的影响，并在确实不需要时删除索引。但是，如果隐藏索引对性能产生不利影响，您可以使用`unhideIndex()`函数来恢复或取消隐藏它们，如下所示：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `unhideIndex()` function takes a single argument, which can either be the
    index name or an index specification document. Since hidden indexes are always
    updated after write operations, they are always in a ready state. Unhiding them
    can immediately put them back in operation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`unhideIndex()`函数接受一个参数，可以是索引名称或索引规范文档。由于隐藏的索引始终在写操作后更新，因此它们始终处于就绪状态。取消隐藏它们可以立即使它们恢复运行。'
- en: 'Exercise 9.02: Dropping an Index Using Mongo Atlas'
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.02：使用Mongo Atlas删除索引
- en: 'In this exercise, you will remove an index from the `accounts` collection of
    the `sample_analytics` database using the Atlas portal. The following steps will
    help you complete this exercise:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用Atlas门户从`sample_analytics`数据库的`accounts`集合中删除一个索引。以下步骤将帮助您完成这个练习：
- en: Sign in to your account at [https://www.mongodb.com/cloud/atlas](https://www.mongodb.com/cloud/atlas).
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到您的帐户[https://www.mongodb.com/cloud/atlas](https://www.mongodb.com/cloud/atlas)。
- en: 'Go to the `sample_ analytics` database and select the `accounts` collection.
    On the collection screen, select the `Indexes` tab and you should see the existing
    indexes. Click on the `Drop Index` button next to the index that you want to remove:![Figure
    9.11: The Indexes tab for the accounts collection of the sample_analytics database'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`sample_ analytics`数据库并选择`accounts`集合。在集合屏幕上，选择`Indexes`选项卡，您应该看到现有的索引。单击要删除的索引旁边的`删除索引`按钮：![图9.11：sample_analytics数据库的accounts集合的索引选项卡
- en: '](img/B15507_09_11.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_09_11.jpg)'
- en: 'Figure 9.11: The Indexes tab for the accounts collection of the sample_analytics
    database'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11：sample_analytics数据库的accounts集合的索引选项卡
- en: 'A confirmation dialog box should be presented as shown in the following figure.
    Enter the index name, which is also displayed in bold in the dialog message:![Figure
    9.12: Entering the name of the index to be dropped'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该显示一个确认对话框，如下图所示。输入索引名称，该名称也以粗体显示在对话框消息中：![图9.12：输入要删除的索引名称
- en: '](img/B15507_09_12.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_09_12.jpg)'
- en: 'Figure 9.12: Entering the name of the index to be dropped'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12：输入要删除的索引名称
- en: 'The index should be removed from the list of indexes, as indicated by the following
    screen. Note the absence of the `accountIdIndex` index:![Figure 9.13: The Indexes
    tab indicating that accountIdIndex was successfully removed'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下屏幕所示，索引应该从索引列表中删除。请注意`accountIdIndex`索引的缺失：![图9.13：索引选项卡指示成功删除了accountIdIndex
- en: '](img/B15507_09_13.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_09_13.jpg)'
- en: 'Figure 9.13: The Indexes tab indicating that accountIdIndex was successfully
    removed'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13：索引选项卡指示成功删除了accountIdIndex
- en: In this exercise, you practiced dropping an index on the collection by using
    the MongoDB Atlas portal. In the next section, we will look at the types of indexes
    available in MongoDB.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您通过使用MongoDB Atlas门户删除了集合上的一个索引。在下一节中，我们将看一下MongoDB中可用的索引类型。
- en: Type of Indexes
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引类型
- en: We have seen how indexes help with query performance and how we can create,
    drop, and list indexes in the collection. MongoDB supports different types of
    indexes, such as single key, multikey, and compound indexes. Each of these indexes
    has different advantages that you will need to know before deciding which type
    is suitable for your collection. Let's start with a brief overview of default
    indexes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到索引如何帮助查询性能，以及我们如何在集合中创建、删除和列出索引。MongoDB支持不同类型的索引，如单键、多键和复合索引。在决定哪种类型适合您的集合之前，您需要了解每种索引的不同优势。让我们从默认索引的简要概述开始。
- en: Default Indexes
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认索引
- en: As seen in the previous chapters, each document in a collection has a primary
    key (namely, the `_id` field) and is indexed by default. MongoDB uses this index
    to maintain the uniqueness of the `_id` field, and it is available on all the
    collections.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所示，集合中的每个文档都有一个主键（即`_id`字段）并且默认情况下已建立索引。MongoDB使用此索引来维护`_id`字段的唯一性，并且它在所有集合上都可用。
- en: Single-Key Indexes
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单键索引
- en: 'An index created using a single field from a collection is called a single-key
    index. You used a single-key index earlier in this chapter. The syntax is as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集合中的单个字段创建的索引称为单键索引。在本章的前面部分，您使用了单键索引。语法如下：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Compound Indexes
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复合索引
- en: Single-key indexes are preferable when using the key in a search significantly
    reduces the number of documents to be scanned. However, in some scenarios, single-key
    indexes are not sufficient to reduce the collection scans. This typically happens
    when the query is based on more than one field.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用关键字显着减少要扫描的文档数量时，单键索引是首选的。但是，在某些情况下，单键索引不足以减少集合扫描。当查询基于多个字段时，通常会发生这种情况。
- en: 'Consider the query you wrote to find movies released in 2015\. You saw that
    adding a single-key index on the `year` field improved the query performance.
    You will now modify the query and add a filter based on the `rated` field, as
    follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑您编写的用于查找2015年上映电影的查询。您看到在`year`字段上添加单键索引可以提高查询性能。现在，您将修改查询并添加基于`rated`字段的过滤器，如下所示：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Use `explain("executionStats")` on this query and analyze the execution stats:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在此查询上使用`explain("executionStats")`并分析执行统计信息：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding snippet is from the execution stats of the query. The following
    are important observations from these stats:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段来自查询的执行统计信息。以下是这些统计信息的重要观察结果：
- en: Because of the indexes, only `484` documents were scanned.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于索引，只扫描了`484`个文档。
- en: Indexes helped locate the `484` documents and the second filter, based on the
    `rated` field, was applied by doing the collection scan.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引帮助定位了`484`个文档，并且基于`rated`字段的第二个过滤器是通过集合扫描应用的。
- en: 'From these points, it is clear that we have again widened the difference between
    the number of documents to be scanned and the number of documents returned. This
    could be a potential performance issue when the same query is used with some other
    year that has thousands of records. For such cases, the database allows you to
    create an index based on more than one field (called compound indexes). The `createIndex`
    command can be used to create a compound index using the following syntax:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些观点来看，很明显我们再次扩大了要扫描的文档数量和返回的文档数量之间的差异。当使用具有数千条记录的其他年份的相同查询时，这可能会成为潜在的性能问题。对于这种情况，数据库允许您基于多个字段创建索引（称为复合索引）。`createIndex`命令可用于使用以下语法创建复合索引：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This syntax is similar to that of a single-field index, except that it accepts
    multiple pairs of fields and their respective sort orders. Note that a compound
    index can consist of a maximum of `32` fields.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此语法与单字段索引的语法类似，只是它接受多对字段及其相应的排序顺序。请注意，复合索引最多可以包含`32`个字段。
- en: 'Now, create a compound index on both the `year` and `rated` fields:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`year`和`rated`字段上创建一个复合索引：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This command generates the following output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令生成以下输出：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The default name of a compound index contains the field names and their sort
    order, separated by an underscore. The index name for the index created by the
    last index will be `year_1_rated_1`. You can give a custom name to the compound
    indexes as well.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 复合索引的默认名称包含字段名称及其排序顺序，用下划线分隔。最后一个索引创建的索引的索引名称将是`year_1_rated_1`。您也可以为复合索引指定自定义名称。
- en: 'Now that you have created an additional index on the two fields, observe what
    execution stats the query gives:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已在两个字段上创建了额外的索引，请观察查询给出的执行统计信息：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding snippet indicates that the compound index is used to execute this
    query and not the single-key index you created earlier. The number of documents
    scanned, and the number of documents returned are the same. Since only `3` documents
    are scanned, the query execution time is reduced as well.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段表明，复合索引用于执行此查询，而不是您之前创建的单键索引。扫描的文档数量和返回的文档数量相同。由于只扫描了`3`个文档，查询执行时间也减少了。
- en: Multikey Indexes
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多键索引
- en: 'An index created on the fields of an array type is called a multikey index.
    When an array field is passed as an argument to the `createIndex` function, MongoDB
    creates an index entry for each element of the array. The syntax of the `createIndex`
    element is the same as that for creating an index of a regular (non-array) field:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组类型字段上创建的索引称为多键索引。当数组字段作为`createIndex`函数的参数传递时，MongoDB为数组的每个元素创建一个索引条目。`createIndex`元素的语法与创建常规（非数组）字段的索引的语法相同：
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'MongoDB inspects the input field, and if it is an array, a multikey index will
    be created. For example, consider the following command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB检查输入字段，如果是数组，则将创建多键索引。例如，考虑以下命令：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This query adds an index on the `languages` field, which is an array. In MongoDB,
    you can find documents based on an element of their array fields. Multikey indexes
    help accelerate such queries:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询在`languages`字段上添加了一个索引，该字段是一个数组。在MongoDB中，您可以根据其数组字段的元素查找文档。多键索引有助于加速此类查询：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s see how the preceding query performs:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面的查询的执行情况：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The snippet of the execution stats shows `361` documents are returned and the
    same number of documents were scanned. It proves that the multikey index is correctly
    created and used.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 执行统计信息的片段显示返回了`361`个文档，并且扫描了相同数量的文档。这证明了多键索引被正确创建和使用。
- en: Text Indexes
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本索引
- en: 'An index defined on a string field or an array of string elements is called
    a text index. Text indexes are not sorted, meaning that they are faster than normal
    indexes. The syntax to create a text index is as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串字段或字符串元素数组上定义的索引称为文本索引。文本索引未排序，这意味着它们比普通索引更快。创建文本索引的语法如下：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following is an example of a text index to be created on the `users` collection
    on the `name` field:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是要在`users`集合的`name`字段上创建的文本索引的示例：
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The command should generate output as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应生成以下输出：
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You cannot drop a text index by passing the index specification document, and
    such indexes can only be deleted by passing the name of the index in the `dropIndex`
    function.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能通过传递索引规范文档来删除文本索引，此类索引只能通过传递`dropIndex`函数中的索引名称来删除。
- en: Indexes on Nested Documents
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套文档上的索引
- en: 'A document can contain nested objects to group a few attributes. For example,
    the `theaters` collection in the `sample_mflix` database contains the `location`
    field, which has a nested object:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一个文档可以包含嵌套对象来组合一些属性。例如，在`sample_mflix`数据库的`theaters`集合中包含了`location`字段，其中包含了一个嵌套对象：
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Using a dot (`.`) notation, you can create an index on any of the nested document
    fields, just like any other field in the collection, as in the following example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用点（`.`）表示法，您可以在嵌套文档字段上创建索引，就像在集合中的任何其他字段一样，如下面的示例所示：
- en: '[PRE39]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can also create an index on the embedded document. For example, you can
    create an index on the `location` field instead of its attributes, as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在嵌入式文档上创建索引。例如，您可以在`location`字段上创建索引，而不是它的属性，如下所示：
- en: '[PRE40]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Such indexes can be used when searching for a location by passing the entire
    nested document.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过传递整个嵌套文档搜索位置时，可以使用此类索引。
- en: Wildcard Indexes
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通配符索引
- en: MongoDB supports flexible schema, and different documents can have fields of
    varying types and quantities. It can be difficult to create and maintain indexes
    on non-uniform fields that are not present in all documents. Also, when a new
    field is introduced into a document, it remains unindexed.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB支持灵活的模式，不同的文档可以具有不同类型和数量的字段。在不统一的字段上创建和维护索引可能会很困难，因为这些字段并非所有文档都具有。此外，当向文档中引入新字段时，它仍然未被索引。
- en: 'To put this in perspective, consider the following documents from a hypothetical
    `products` collection. The following table displays two different product documents:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，考虑来自假设的`products`集合的以下文档。下表显示了两个不同的产品文档：
- en: '![Figure 9.14: Two different product specification documents'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.14：两个不同的产品规格文档'
- en: '](img/B15507_09_14.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_09_14.jpg)'
- en: 'Figure 9.14: Two different product specification documents'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14：两个不同的产品规格文档
- en: 'As you can see, the fields under `specifications` are dynamic in nature. Different
    products can have different specifications. Defining an index on each of these
    fields will result in too many index definitions. As new products with new fields
    get added all the time, the idea of creating an index on all fields is not practical.
    MongoDB provides wildcard indexes to resolve this problem. For instance, consider
    the following query:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`specifications` 下的字段是动态的。不同的产品可以有不同的规格。在每个字段上定义索引将导致太多的索引定义。随着不断添加具有新字段的新产品，创建索引的想法并不实际。MongoDB提供通配符索引来解决这个问题。例如，考虑以下查询：
- en: '[PRE41]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This query uses special wildcard characters (`$**`) to create indexes on the
    `specifications` field. It will create indexes on all the fields under `specifications`.
    If new nested fields are added in the future, they will be automatically indexed.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询使用特殊的通配符字符（`$**`）在`specifications`字段上创建索引。它将在`specifications`下的所有字段上创建索引。如果将来添加了新的嵌套字段，它们将自动被索引。
- en: 'Similarly, wildcard indexes can be created on the top-level fields of a collection
    as well:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，通配符索引也可以在集合的顶级字段上创建。
- en: '[PRE42]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The preceding command creates indexes on all fields of all documents. Thus,
    all the new fields added to the documents will be indexed by default.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令在所有文档的所有字段上创建索引。因此，所有添加到文档中的新字段将默认被索引。
- en: 'You can also select or omit specific fields from the wildcard indexes by passing
    a `wildcardProjection` option and one or more field names, as shown in the following
    snippet:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过传递`wildcardProjection`选项和一个或多个字段名称来选择或省略通配符索引中的特定字段，如下面的代码片段所示：
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The preceding query creates a wildcard index on all the fields of a collection,
    excluding the `name` field. To explicitly include the `name` field, excluding
    all the others, you can pass it with a value of `1`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询在集合的所有字段上创建了一个通配符索引，但排除了`name`字段。要显式包含`name`字段，排除所有其他字段，您可以将其传递为`1`的值。
- en: Note
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'MongoDB provides a couple of indexes to support the geometric fields: `2dsphere`
    and `2d`. It is beyond the scope of this book to cover these indexes but interested
    readers can find out more about them at [https://docs.mongodb.com/manual/geospatial-queries/#geospatial-indexes](https://docs.mongodb.com/manual/geospatial-queries/#geospatial-indexes).'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB提供了一对索引来支持几何字段：`2dsphere`和`2d`。本书不涵盖这些索引的范围，但感兴趣的读者可以在[https://docs.mongodb.com/manual/geospatial-queries/#geospatial-indexes](https://docs.mongodb.com/manual/geospatial-queries/#geospatial-indexes)找到更多信息。
- en: Now that we have covered the types of indexes, we will explore index properties
    in the next section.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了索引的类型，接下来我们将在下一节中探讨索引的属性。
- en: Properties of Indexes
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引的属性
- en: In this section, we will cover different properties of indexes in MongoDB. An
    index property can influence the usage of an index and can also enforce some behavior
    on the collection. Index properties are passed as an option to the `createdIndex`
    function. We will be looking at unique indexes, TTL (time to live) indexes, sparse
    indexes, and finally, partial indexes.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍MongoDB中索引的不同属性。索引属性可以影响索引的使用，并且还可以对集合施加一些行为。索引属性作为选项传递给`createdIndex`函数。我们将研究唯一索引、TTL（生存时间）索引、稀疏索引，最后是部分索引。
- en: Unique Indexes
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 唯一索引
- en: 'A unique index property restricts the duplication of the index key. This is
    useful if you want to maintain the uniqueness of a field in a collection. The
    unique fields are useful for avoiding any ambiguity in identifying documents precisely.
    For example, in a `license` collection, a unique field such as `license_number`
    can help identify each document individually. This property enforces the behavior
    on the collection to reject duplicate entries. Unique indexes can be created on
    a single field or on a combination of fields. The following is the syntax to create
    a unique index on a single file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一索引属性限制了索引键的重复。如果您想要在集合中保持字段的唯一性，这是很有用的。唯一字段对于避免在准确识别文档时产生任何歧义是有用的。例如，在`license`集合中，像`license_number`这样的唯一字段可以帮助单独识别每个文档。此属性强制集合拒绝重复条目。唯一索引可以在单个字段或一组字段上创建。以下是在单个文件上创建唯一索引的语法：
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `{ unique: true }` option is used to create a unique index.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`{ unique: true }`选项用于创建唯一索引。'
- en: 'In some cases, you may want a combination of fields to be unique. For such
    cases, you can define a unique compound index by passing the `unique: true` flag
    while creating a compound index, as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '在某些情况下，您可能希望一些字段的组合是唯一的。对于这种情况，您可以在创建复合索引时传递`unique: true`标志来定义一个唯一的复合索引，如下所示：'
- en: '[PRE45]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Exercise 9.03: Creating a Unique Index'
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.03：创建唯一索引
- en: 'In this exercise, you will enforce the uniqueness of the `theaterId` field
    in the `theaters` collection in the `sample_mflix` database:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将强制`sample_mflix`数据库中`theaters`集合中`theaterId`字段的唯一性：
- en: Connect your shell to the Atlas cluster and choose the `sample_mflix` database.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的shell连接到Atlas集群，并选择`sample_mflix`数据库。
- en: 'Confirm whether the `theaters` collection enforces any uniqueness of the `theaterId`
    field. To do so, find a record and try to insert another record using the same
    `theaterId` present in the fetched record. The following is the command to retrieve
    a document from the `theaters` collection:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认`theaters`集合是否强制`theaterId`字段的唯一性。为此，找到一条记录，并尝试使用与获取的记录中相同的`theaterId`插入另一条记录。以下是从`theaters`集合中检索文档的命令：
- en: '[PRE46]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This results in the following output, though you may get a different record:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出，尽管您可能会得到不同的记录：
- en: '![Figure 9.15: The result of retrieving a document from the theaters collection'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.15：从剧院集合中检索文档的结果'
- en: '](img/B15507_09_15.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_09_15.jpg)'
- en: 'Figure 9.15: The result of retrieving a document from the theaters collection'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15：从剧院集合中检索文档的结果
- en: 'Now, insert a record with the same `theaterId` (that is, `1012`):'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，插入一个具有相同`theaterId`（即`1012`）的记录：
- en: '[PRE47]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The document is inserted successfully, which proves that `theaterId` is not
    a unique field.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 文档成功插入，证明`theaterId`不是一个唯一字段。
- en: 'Now, create a unique index on the `theaterId` field using the following command:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令在`theaterId`字段上创建一个唯一索引：
- en: '[PRE48]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The preceding command will return an error response as it is a prerequisite
    that there should be no duplicate records existing in the collection. The following
    is the output, confirming this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将返回错误响应，因为有一个先决条件，即集合中不应该存在重复的记录。以下是确认此事实的输出：
- en: '[PRE49]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, remove the duplicate record that was inserted in *step 3* using its `_id`
    value:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用其`_id`值删除在*步骤3*中插入的重复记录：
- en: '[PRE50]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Try creating the unique index once again, as follows:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试再次创建唯一索引，如下所示：
- en: '[PRE51]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This time, you should receive a successful response, as shown here:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，您应该收到一个成功的响应，如下所示：
- en: '[PRE52]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now that the field has a unique index, try inserting a duplicate record, as
    follows:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在字段有了唯一索引，尝试插入一个重复记录，如下所示：
- en: '[PRE53]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This command will fail due to the duplicate key error:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 由于重复键错误，此命令将失败：
- en: '[PRE54]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this exercise, you enforced the property of uniqueness on an index.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您对索引强制了唯一性属性。
- en: TTL Indexes
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TTL索引
- en: '`expireAfterSeconds` attribute. The following snippet shows the syntax for
    creating a TTL index:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`expireAfterSeconds`属性。以下代码显示了创建TTL索引的语法：'
- en: '[PRE55]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here, the `{ expireAfterSeconds: seconds }` option is used to create a TTL
    index. MongoDB removes the documents that have passed the threshold of the `expireAfterSeconds`
    value.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，`{ expireAfterSeconds: seconds }`选项用于创建TTL索引。MongoDB会删除已经过了`expireAfterSeconds`值的文档。'
- en: 'Exercise 9.04: Creating a TTL index using Mongo Shell'
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.04：使用Mongo Shell创建TTL索引
- en: 'In this exercise, you will create a TTL index on a collection called `reviews`.
    A field called `reviewDate` will be used to capture the current date and time
    of the review. You will introduce a TTL index to check whether the records that
    have passed the thresholds are removed:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将在一个名为`reviews`的集合上创建一个TTL索引。一个名为`reviewDate`的字段将用于捕获评论的当前日期和时间。您将引入一个TTL索引来检查是否删除了已经过去阈值的记录：
- en: Connect the mongo shell to the Atlas cluster and switch to the `sample_mflix`
    database.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将mongo shell连接到Atlas集群，并切换到`sample_mflix`数据库。
- en: 'Create the `reviews` collection by inserting two documents, as follows:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过插入两个文档来创建`reviews`集合，如下所示：
- en: '[PRE56]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Fetch these documents from the `reviews` collection to confirm they exist in
    the collection:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`reviews`集合中获取这些文档，以确认它们存在于集合中：
- en: '[PRE57]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This command results in the following output:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令导致以下输出：
- en: '[PRE58]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Introduce a TTL index to expire documents older than 60 seconds, using the
    following command:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令引入TTL索引，使60秒后过期的文档：
- en: '[PRE59]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This results in the following output:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '[PRE60]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'After 60 seconds, execute the `find` query again:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 60秒后，再次执行`find`查询：
- en: '[PRE61]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The query will not return any records, and it proves both documents are deleted
    after 60 seconds.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 查询不会返回任何记录，并且证明两个文档在60秒后被删除。
- en: In this exercise, you created a TTL index on a collection and saw that the documents
    expired after the specified time—that is, 60 seconds.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您在一个集合上创建了一个TTL索引，并看到文档在指定时间后过期。
- en: Sparse Indexes
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 稀疏索引
- en: When an index is created on a field, all the values of that field from all documents
    are maintained in the index registry. If the field does not exist in a document,
    a `null` value is registered for that document. Conversely, if an index is marked
    as `sparse`, then only those documents are registered in which the given field
    exists with some value including `null`. A sparse index will not have entries
    from the collection where the indexed field does not exist, and that is why this
    type of index is called sparse.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当在字段上创建索引时，来自所有文档的该字段的所有值都会在索引注册表中维护。如果文档中不存在该字段，则会为该文档注册一个`null`值。相反，如果索引标记为`sparse`，则只有那些存在某个值的给定字段的文档会被注册，包括`null`。稀疏索引不会包含集合中不存在索引字段的条目，这就是为什么这种类型的索引被称为稀疏索引。
- en: 'Compound indexes can also be marked as sparse. For a compound sparse index,
    only those documents are registered where the combination of fields exists. Sparse
    indexes are created by passing a flag of `{ sparse: true }` to the `createIndex`
    command, as shown in the following snippet:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '复合索引也可以标记为稀疏。对于复合稀疏索引，只有存在字段组合的文档才会被注册。通过向`createIndex`命令传递`{ sparse: true
    }`标志来创建稀疏索引，如下面的片段所示：'
- en: '[PRE62]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: MongoDB does not provide any command to list the documents that are maintained
    by an index. This makes it difficult to analyze the behavior of a sparse index.
    This is where the `db.collection.stats()` function can be really useful, as you
    will observe in the next exercise.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB没有提供任何列出由索引维护的文档的命令。这使得分析稀疏索引的行为变得困难。这就是`db.collection.stats()`函数可以真正有用的地方，您将在下一个练习中观察到。
- en: 'Exercise 9.05: Creating a Sparse Index Using Mongo Shell'
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.05：使用Mongo Shell创建稀疏索引
- en: 'In this exercise, you will create a sparse index on the `review` field in the
    `reviews` collection. You will verify that the index maintains entries only for
    those documents that have the `review` field present. To do so, you will use the
    `db.collection.stats()` command to check the size of the index by first inserting
    the documents with the indexed field, and then again without the field. The size
    of the index should remain the same when a document is inserted without the `review`
    field:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将在`reviews`集合的`review`字段上创建一个稀疏索引。您将验证索引仅维护具有`review`字段的文档的条目。为此，您将使用`db.collection.stats()`命令来检查索引的大小，首先插入具有索引字段的文档，然后再次插入不带字段的文档。当插入不带`review`字段的文档时，索引的大小应保持不变：
- en: Connect the mongo shell to the Atlas cluster and switch to the `sample_mflix`
    database.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将mongo shell连接到Atlas集群，并切换到`sample_mflix`数据库。
- en: 'Create a sparse index on the `review` field:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`review`字段上创建一个稀疏索引：
- en: '[PRE63]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Check the size of the index on the current collection:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查当前集合上索引的大小：
- en: '[PRE64]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This command results in the following output:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的结果如下：
- en: '[PRE65]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Insert a document that does not have the `review` field, as follows:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入一个不包含`review`字段的文档，如下所示：
- en: '[PRE66]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Check the size of the index using the `stats()` function:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`stats()`函数检查索引的大小：
- en: '[PRE67]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The output for this is as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE68]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, insert a document that contains the `review` field:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，插入一个包含`review`字段的文档：
- en: '[PRE69]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Check the size of the index after a couple of minutes using the `stats()` function
    once again:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用`stats()`函数检查索引的大小经过几分钟：
- en: '[PRE70]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `indexSizes` portion from the output is as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的`indexSizes`部分如下：
- en: '[PRE71]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In this exercise, you created a sparse index and proved that documents without
    the indexed fields are not indexed.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您创建了一个稀疏索引，并证明了没有索引字段的文档不会被索引。
- en: Partial Indexes
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分索引
- en: 'An index can be created to maintain documents that match a given filter expression.
    Such an index is called a partial index. As the documents are filtered depending
    on the input expression, the size of the index is smaller than a normal index.
    The syntax to create a partial index is as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建一个索引来维护与给定过滤器表达式匹配的文档。这样的索引称为部分索引。由于根据输入表达式过滤文档，因此索引的大小比普通索引要小。创建部分索引的语法如下：
- en: '[PRE72]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In the preceding snippet, the `{ partialFilterExpression: filterExpression
    }` option is used to create a partial index. `partialFilterExpression` can only
    accept an expression document that contains operations from the following list:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '在上面的片段中，使用`{ partialFilterExpression: filterExpression }`选项创建了一个部分索引。`partialFilterExpression`只能接受包含以下列表中的操作的表达式文档：'
- en: 'Equality expressions (that is, `field: value` or using the `$eq` operator)'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '相等表达式（即`field: value`或使用`$eq`运算符）'
- en: 'The `$exists: true` expression'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$exists: true`表达式'
- en: '`$gt`, `$gte`, `$lt`, and `$lte` expressions'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$gt`，`$gte`，`$lt`和`$lte`表达式'
- en: '`$type` expressions'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$type`表达式'
- en: The `$and` operator at the top level only
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶层的`$and`运算符
- en: To get a better idea of how partial indexes work, let's perform a simple exercise.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解部分索引的工作原理，让我们进行一个简单的练习。
- en: 'Exercise 9.06: Creating a Partial Index Using the Mongo Shell'
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.06：使用Mongo Shell创建部分索引
- en: 'In this exercise, you will introduce a compound index on `title` and `type`
    fields for all the movies released after 1950\. You will then verify whether the
    index contains the desired entries, using `partialFilterExpression`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将为1950年后发布的所有电影的`title`和`type`字段引入一个复合索引。然后，您将使用`partialFilterExpression`验证索引是否包含所需的条目：
- en: Connect the mongo shell to the Atlas cluster and switch to the `sample_mflix`
    database.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将mongo shell连接到Atlas集群，并切换到`sample_mflix`数据库。
- en: 'Introduce a partial index on the `title` and `type` fields in the `movies`
    collection, using `partialFilterExpression`, as follows:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`movies`集合中的`title`和`type`字段上使用`partialFilterExpression`引入一个部分索引，如下所示：
- en: '[PRE73]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The preceding command creates a partial compound index on the given fields
    for all the movies released after 1950\. The following snippet shows the output
    of this command:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令为所有在1950年后发布的电影的给定字段创建了一个部分复合索引。以下片段显示了此命令的输出：
- en: '[PRE74]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Check and note down the index size on the collection using the `stats()` function:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`stats()`函数检查并记录集合上的索引大小：
- en: '[PRE75]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The following is the `indexSizes` section of the resulting output:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是结果输出的`indexSizes`部分：
- en: '[PRE76]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Insert a movie that was released before 1950:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入一部1950年之前发布的电影：
- en: '[PRE77]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Check the index size and ensure it is unchanged using the `stats()` function:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`stats()`函数检查索引大小，并确保它没有变化：
- en: '[PRE78]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The next snippet shows the `indexSizes` portion of the output:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 下一段显示了输出的`indexSizes`部分：
- en: '[PRE79]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The output snippet proves that the index size remained unchanged, as can be
    seen from the highlighted part.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 输出片段证明了索引大小保持不变，可以从突出显示的部分看出。
- en: 'Now, insert a movie that was released after 1950:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，插入一部1950年之后发布的电影：
- en: '[PRE80]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Check the index size again, with the help of the `stats()` function:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`stats()`函数再次检查索引大小：
- en: '[PRE81]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The following is the `indexSizes` portion from the output of the preceding command:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述命令输出的`indexSizes`部分：
- en: '[PRE82]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: In this exercise, you introduced a partial index and verified that it worked
    as desired.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您引入了一个部分索引，并验证了它是否按预期工作。
- en: Case-Insensitive Indexes
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不区分大小写的索引
- en: Case-insensitive indexes allow you to find data using indexes in a case-insensitive
    manner. This means that the index will match the documents even if the values
    of a field are written in a different case from the values in the search expression.
    This is possible due to the collation feature in MongoDB, which allows the input
    of language-specific rules, such as case and accent marks, to match documents.
    To create the case-insensitive index, you need to pass the field details and the
    `collation` parameter.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 不区分大小写的索引允许您以不区分大小写的方式使用索引查找数据。这意味着即使字段的值以与搜索表达式中的值不同的大小写写入，索引也会匹配文档。这是由于MongoDB中的排序功能，它允许输入语言特定的规则，比如大小写和重音符号，以匹配文档。要创建不区分大小写的索引，您需要传递字段详细信息和`collation`参数。
- en: 'The syntax to create a case-insensitive index is as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 创建不区分大小写索引的语法如下：
- en: '[PRE83]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Note that `collation` is made up of `locale` and `strength` parameters:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`collation`由`locale`和`strength`参数组成：
- en: '`locale`: This refers to the language to be used, such as `en` (English), `fr`
    (French), and more. The full list of locales can be found at [https://docs.mongodb.com/manual/reference/collation-locales-defaults/#collation-languages-locales](https://docs.mongodb.com/manual/reference/collation-locales-defaults/#collation-languages-locales).'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`locale`：这指的是要使用的语言，比如`en`（英语），`fr`（法语）等。完整的区域设置列表可以在[https://docs.mongodb.com/manual/reference/collation-locales-defaults/#collation-languages-locales](https://docs.mongodb.com/manual/reference/collation-locales-defaults/#collation-languages-locales)找到。'
- en: '`strength`: A value of 1 or 2 indicates a case-level collation. You can find
    the details about collation **International Components for Unicode** (**ICU**)
    levels at [http://userguide.icu-project.org/collation/concepts#TOC-Comparison-Levels](http://userguide.icu-project.org/collation/concepts#TOC-Comparison-Levels).'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strength`：值为1或2表示大小写级别的排序。您可以在[http://userguide.icu-project.org/collation/concepts#TOC-Comparison-Levels](http://userguide.icu-project.org/collation/concepts#TOC-Comparison-Levels)找到有关排序**国际Unicode组件**（**ICU**）级别的详细信息。'
- en: To use an index that specifies a collation, the query and the sort specification
    must have the same collation as the index.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用指定排序规则的索引，查询和排序规范必须与索引具有相同的排序规则。
- en: 'Exercise 9.07: Creating a Case-Insensitive Index Using the Mongo Shell'
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.07：使用Mongo Shell创建不区分大小写的索引
- en: 'In this exercise, you will create a case-insensitive index by connecting the
    mongo shell to the Atlas cluster. This feature is immensely useful for web-based
    applications because database querying is executed in a case-sensitive manner
    in the backend. On the frontend though, the user will not necessarily use the
    same case for searches as the one used in the backend. Therefore, it is important
    to make sure that searches are case-insensitive. Perform the following steps to
    complete this exercise:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将通过连接mongo shell到Atlas集群创建一个不区分大小写的索引。这个功能对于基于Web的应用程序非常有用，因为数据库查询在后端是以区分大小写的方式执行的。但在前端，用户不一定会使用与后端相同的大小写进行搜索。因此，确保搜索不区分大小写是很重要的。执行以下步骤来完成这个练习：
- en: Connect the mongo shell to the Atlas cluster and switch to the `sample_mflix`
    database.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将mongo shell连接到Atlas集群，并切换到`sample_mflix`数据库。
- en: 'Perform a case-insensitive search and verify that the expected document is
    not returned:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一个不区分大小写的搜索，并验证预期的文档没有返回：
- en: '[PRE84]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The preceding query returns no result.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 前述查询没有返回结果。
- en: 'To solve this problem, create a case-insensitive index on the `title` attribute
    of the `movies` collection, as follows:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，在`movies`集合的`title`属性上创建一个不区分大小写的索引，如下所示：
- en: '[PRE85]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This command results in the following output:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的结果如下：
- en: '[PRE86]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Rerun the command in *step 2* to confirm that the correct movie is returned:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行*步骤2*中的命令，确认返回正确的电影：
- en: '[PRE87]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The command returns the correct movie, as shown in the next snippet:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令返回了正确的电影，如下一段所示：
- en: '[PRE88]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: In this exercise, you created a case-insensitive index and verified that it
    worked as desired.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您创建了一个不区分大小写的索引，并验证它是否按预期工作。
- en: Note
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `collation` option allows us to perform case-insensitive searches on unindexed
    fields as well. The only difference is that such queries will do a full collection
    scan.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`collation`选项允许我们在未索引字段上执行不区分大小写的搜索。唯一的区别是这样的查询将进行完整的集合扫描。'
- en: In this section, you reviewed different index properties and learned how to
    create indexes with each of these properties. In the next section, you will explore
    some query optimization techniques that can be used along with indexes.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您回顾了不同的索引属性，并学习了如何使用每个属性创建索引。在下一节中，您将探索一些可以与索引一起使用的查询优化技术。
- en: Other Query Optimization Techniques
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他查询优化技术
- en: So far, we have seen the internal workings of queries and how indexes help limit
    the number of documents to be scanned. We have also explored various types of
    indexes and their properties and learned how we can use the correct index and
    correct index properties in specific use cases. Creating the right index can improve
    query performance, but there are a few more techniques that are required to fine-tune
    the query performance. We will cover those techniques in this section.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了查询的内部工作原理以及索引如何帮助限制需要扫描的文档数量。我们还探讨了各种类型的索引及其属性，并学习了如何在特定用例中使用正确的索引和正确的索引属性。创建正确的索引可以提高查询性能，但还有一些技术需要用来微调查询性能。我们将在本节中介绍这些技术。
- en: Fetch Only What You Need
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 只获取所需的数据
- en: The performance of a query is also affected by the amount of data it returns.
    The database server and client communicate over a network. If a query produces
    a large amount of data, it will take longer to transfer it over a network. Moreover,
    to transfer the data over the network, it needs to be transformed and serialized
    by the server and deserialized by the receiving client. This means that the database
    client will have to wait longer to get the final output of the query.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 查询的性能也受到其返回的数据量的影响。数据库服务器和客户端通过网络进行通信。如果一个查询产生大量数据，传输到网络上将需要更长的时间。此外，为了将数据传输到网络上，它需要被服务器转换和序列化，然后由接收客户端进行反序列化。这意味着数据库客户端将不得不等待更长的时间才能获得查询的最终输出。
- en: To improve the overall performance, consider the following factors.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高整体性能，请考虑以下因素。
- en: '**Correct Query Condition and Projection**'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**正确的查询条件和投影**'
- en: An application can have a variety of use cases, and each of them may need a
    different subset of data. Therefore, it is important to analyze all such use cases
    and to make sure we have optimal queries or commands to satisfy each of them.
    This can be done by using optimal query conditions and correctly using projections
    to return only the essential fields pertinent to the use case.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序可能有各种用例，每个用例可能需要不同的数据子集。因此，分析所有这些用例并确保我们有满足每个用例的最佳查询或命令是很重要的。这可以通过使用最佳的查询条件和正确使用投影来返回与用例相关的基本字段来实现。
- en: '**Pagination**'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '**分页**'
- en: Pagination is about serving only a small subset of data to the client in each
    subsequent request. It is also the best method of performance optimization, especially
    when serving a large amount of data to the client. It improves user experience
    by limiting the amount of data being returned and serving faster results.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 分页是指在每个后续请求中仅向客户端提供一小部分数据。这是性能优化的最佳方法，特别是在向客户端提供大量数据时。它通过限制返回的数据量并提供更快的结果来改善用户体验。
- en: Sorting Using Indexes
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用索引进行排序
- en: Queries often need to return the data in some order. For example, if the user
    chooses an option to view the latest movies, the resulting movies can be sorted
    on the basis of the release date. Similarly, if the user wants to view popular
    movies, we may sort the movies based on their ratings.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 查询通常需要以某种顺序返回数据。例如，如果用户选择查看最新电影的选项，结果电影可以根据发布日期进行排序。同样，如果用户想要查看热门电影，我们可以根据它们的评分对电影进行排序。
- en: By default, sort operations for a query are carried out in memory. First, all
    the matching results are loaded in memory, and then the sort specification is
    applied to them. For a large dataset, such a process requires a lot of memory.
    MongoDB reserves only `allowDiskUse` flag, so that when the memory limit is reached
    the records are written on the disk and then sorted. However, writing records
    on disk and reading them back slows down the query.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，查询的排序操作是在内存中进行的。首先，所有匹配的结果都加载到内存中，然后对它们应用排序规范。对于大型数据集，这样的过程需要大量内存。MongoDB仅保留`allowDiskUse`标志，因此当达到内存限制时，记录将被写入磁盘，然后进行排序。然而，将记录写入磁盘并读取它们会减慢查询速度。
- en: To avoid this, you can use indexes for sorting, since indexes are created and
    maintained with a specific sort order. This means that for an indexed field, the
    index registry is always sorted based on the values of that field. When a sort
    specification is based on such an index field, MongoDB refers to the indexes to
    retrieve an already sorted dataset and returns it.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，您可以使用用于排序的索引，因为索引是根据特定的排序顺序创建和维护的。这意味着对于索引字段，索引注册表始终根据该字段的值进行排序。当排序规范基于这样一个索引字段时，MongoDB会引用索引来检索已经排序的数据集并返回它。
- en: Fitting Indexes in the RAM
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将索引适配到RAM中
- en: 'Indexes are much more efficient when they are fit in memory. If they exceed
    the available memory, they are written to the disk. As you already know, disk
    operations are slower than in-memory ones. MongoDB intelligently makes use of
    both disk and memory by keeping the most recently added records in the memory
    and older ones on the disk. This logic assumes that the most recent records will
    be queried more than the old ones. To fit indexes in memory, you can use the `totalIndexSize`
    function on a collection, as follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 当索引适配到内存中时，它们的效率要高得多。如果它们超过了可用的内存，它们将被写入磁盘。正如您已经知道的那样，磁盘操作比内存操作要慢。MongoDB通过在内存中保留最近添加的记录并将旧记录保存在磁盘上来智能地利用磁盘和内存。这个逻辑假设最近的记录将被查询得更多。为了将索引适配到内存中，您可以在集合上使用`totalIndexSize`函数，如下所示：
- en: '[PRE89]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: If the size exceeds the available memory on the server, you can choose to increase
    the memory or optimize the indexes. This way, you ensure that all the indexes
    always remain in memory.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 如果大小超过服务器上可用的内存，您可以选择增加内存或优化索引。这样，您可以确保所有索引始终保持在内存中。
- en: Index Selectivity
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引选择性
- en: 'Indexes are more effective when they can considerably narrow down the actual
    collection scans. This depends on the `isRunning` field holds a Boolean value,
    which means it will have either `true` or `false` as its value:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 当索引可以大大缩小实际集合扫描时，索引的效果更好。这取决于`isRunning`字段是否持有布尔值，这意味着它的值将是`true`或`false`：
- en: '[PRE90]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now, add an index on the `isRunning` field and execute the following query
    to find a running device by its name:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`isRunning`字段上添加一个索引，并执行以下查询以通过其名称找到正在运行的设备：
- en: '[PRE91]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: MongoDB will first use the `isRunning` index to locate all the running devices
    before the collection scan to find documents with a matching `name` value. Since
    `isRunning` can have only `true` or `false` values, a significant part of the
    collection will have to be scanned.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB将首先使用`isRunning`索引来定位所有正在运行的设备，然后才进行集合扫描以查找具有匹配`name`值的文档。由于`isRunning`只能有`true`或`false`值，因此必须扫描集合的大部分内容。
- en: Hence, to make the preceding query more efficient, we should put an index on
    the `name` field as there will not be too many documents with the same name. Indexes
    are more efficient on fields that have a broader range of values or unique values.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了使上述查询更有效，我们应该在`name`字段上放置一个索引，因为相同名称的文档不会太多。对于具有更广泛值或唯一值的字段，索引更有效。
- en: Providing Hints
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供提示
- en: 'MongoDB query planner picks an index for a query depending on its own internal
    logic. When there are multiple indexes available to perform a query execution,
    the query planner uses its default query optimization technique to select and
    use the most appropriate index. However, we can use a `hint()` function to specify
    which index should be used for the execution:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB查询规划器根据自己的内部逻辑为查询选择索引。当有多个索引可用于执行查询时，查询规划器使用其默认的查询优化技术来选择和使用最合适的索引。但是，我们可以使用`hint()`函数来指定应该用于执行的索引：
- en: '[PRE92]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This command shows a syntax for providing an index hint. The argument to the
    `hint` function can simply be an index name or an index specification document.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令显示了提供索引提示的语法。`hint`函数的参数可以简单地是一个索引名称或一个索引规范文档。
- en: Optimal Indexes
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳索引
- en: After learning about the benefits of indexes, you might be wondering if we can
    create indexes on all fields and their various combinations. However, indexes
    have some overheads as well. Each index requires a dedicated index registry, which
    stores a subset of data in memory or on the disk. Too many indexes consume a lot
    of space. Hence, before adding indexes to the collection, we should first analyze
    the requirements, listing the use cases and the possible queries our application
    will be executing. Then, based on this information, a minimal number of indexes
    should be created.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了索引的好处之后，您可能会想知道我们是否可以在所有字段及其各种组合上创建索引。然而，索引也有一些开销。每个索引都需要一个专用的索引注册表，它在内存或磁盘上存储数据的子集。太多的索引会占用大量空间。因此，在向集合添加索引之前，我们应该首先分析需求，列出应用程序将执行的用例和可能的查询。然后，根据这些信息，应创建最少数量的索引。
- en: Although indexes make queries faster, they slow down every write operation on
    the collection. Because of indexes, every write operation on the collection involves
    the overhead of updating the respective index registries. Whenever documents are
    added, removed, or updated in a collection, all the respective index registries
    need to be updated, rescanned, and resorted, which takes longer than the actual
    collection write operations. Hence, before deciding to use indexes, it is recommended
    to check whether the database operations are read-heavy or write-heavy. For write-heavy
    collections, indexes are an overhead, hence they should be created only after
    a careful evaluation.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管索引可以加快查询速度，但它们会减慢集合上的每个写操作。由于索引，集合上的每个写操作都涉及更新相应的索引注册表的开销。每当在集合中添加、删除或更新文档时，都需要更新、重新扫描和重新排序所有相应的索引注册表，这比实际的集合写操作需要更长的时间。因此，在决定使用索引之前，建议检查数据库操作是读密集还是写密集。对于写密集的集合，索引是一种开销，因此应该在经过仔细评估后才创建。
- en: In short, indexes have their benefits as well as overheads. A higher number
    of indexes generally means faster read operations and slower write operations.
    Hence, we should always use indexes in an optimal fashion.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，索引既有好处又有开销。更多的索引通常意味着更快的读操作和更慢的写操作。因此，我们应该始终以最佳方式使用索引。
- en: 'Activity 9.01: Optimizing a Query'
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动9.01：优化查询
- en: 'Imagine your organization has retail stores throughout the world. Details about
    all the items sold are stored in a MongoDB database. The data analytics team uses
    the sales data to identify the purchase trends of different customers based on
    their age and location. Recently, one of the team members has complained about
    the performance of a query they wrote. The query, which is shown in the following
    snippet, queries the `sales` collection to find the email address and age of the
    customers who have purchased one or more backpacks in the Denver store. Then,
    it sorts the results in descending order of the customers'' ages:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您的组织在世界各地都有零售店。关于所有出售商品的详细信息都存储在一个MongoDB数据库中。数据分析团队使用销售数据来识别不同客户的购买趋势，这些客户的年龄和位置。最近，团队中的一名成员抱怨了他们编写的查询的性能。下面的代码片段显示了查询`sales`集合，以查找在丹佛商店购买了一个或多个背包的客户的电子邮件地址和年龄。然后，它按客户年龄降序排序结果：
- en: '[PRE93]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Your task for this activity is to analyze the given query, identify the problems,
    and create correct indexes to make it faster. The following steps will help you
    complete this activity:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 您在这个活动中的任务是分析给定的查询，识别问题，并创建正确的索引以使其更快。以下步骤将帮助您完成这个活动：
- en: Connect to the `sample_supplies` dataset using mongo shell.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用mongo shell连接到`sample_supplies`数据集。
- en: Find the query execution stats and identify the problems.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找查询执行统计信息并识别问题。
- en: Create correct indexes on the collection.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在集合上创建正确的索引。
- en: Analyze the query performance again to see if the problems are fixed.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次分析查询性能，看看问题是否得到解决。
- en: Note
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15507_Solution_Final_SZ_ePub.xhtml#_idTextAnchor477).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以通过[此链接](B15507_Solution_Final_SZ_ePub.xhtml#_idTextAnchor477)找到。
- en: Summary
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you practiced improving query performance. You first explored
    the internal workings of query execution and the query execution stages. You then
    learned how to analyze a query's performance and identify any existing problems
    based on the execution statistics. Next, you reviewed the concept of indexes;
    how they solve performance issues for a query; various ways to create, list, and
    delete indexes; different types of indexes; and their properties. In the final
    sections of this chapter, you studied query optimization techniques and got a
    brief look at the overheads associated with indexes. In the next chapter, you
    will learn about the concept of replication and how it is implemented in Mongo.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您练习了改善查询性能。您首先探索了查询执行的内部工作和查询执行阶段。然后，您学习了如何分析查询的性能，并根据执行统计数据识别任何现有问题。接下来，您复习了索引的概念；它们如何解决查询的性能问题；创建、列出和删除索引的各种方法；不同类型的索引；以及它们的属性。在本章的最后部分，您学习了查询优化技术，并简要了解了与索引相关的开销。在下一章中，您将了解复制的概念以及它在Mongo中的实现方式。
