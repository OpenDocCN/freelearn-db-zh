- en: Schema Design and Data Modeling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式设计和数据建模
- en: This chapter will focus on schema design for schema less databases such as MongoDB.
    Although this may sound counter-intuitive, there are considerations that we should
    take into account when we develop for MongoDB. We will learn about the schema
    considerations and the data types supported by MongoDB. We will also learn about
    preparing data for text searches in MongoDB by connecting Ruby, Python, and PHP.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点讨论无模式数据库（如MongoDB）的模式设计。尽管这听起来有些违反直觉，但在开发MongoDB时，我们应该考虑一些因素。我们将了解MongoDB支持的模式考虑因素和数据类型。我们还将学习如何通过连接Ruby、Python和PHP来为MongoDB准备文本搜索的数据。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Relational schema design
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系模式设计
- en: Data modeling
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据建模
- en: Modeling data for atomic operations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为原子操作建模数据
- en: Modeling relationships
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建模关系
- en: Connecting to MongoDB
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到MongoDB
- en: Relational schema design
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系模式设计
- en: In relational databases, we design with the goal of avoiding anomalies and redundancy.
    Anomalies can happen when we have the same information stored in multiple columns;
    we update one of them but not the rest and so end up with conflicting information
    for the same column of information. An anomaly can also happen when we cannot
    delete a row without losing information that we need, possibly in other rows referenced
    by it. Data redundancy can happen when our data is not in a normal form, but has
    duplicate data across different tables. This can lead to data inconsistency and
    is difficult to maintain.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系数据库中，我们的设计目标是避免异常和冗余。当我们在多个列中存储相同的信息时，异常可能会发生；我们更新其中一个列，但没有更新其他列，因此最终得到相互冲突的信息。当我们无法删除一行而不丢失我们可能需要的信息时，异常也可能发生，可能是在其他引用它的行中。数据冗余可能发生在我们的数据不在正常形式中，但在不同的表中具有重复数据。这可能导致数据不一致，并且难以维护。
- en: In relational databases, we use normal forms to normalize our data. Starting
    from the basic **First Normal Form** (**1NF**), onto the 2NF, 3NF, and BCNF, we
    model our data, taking functional dependencies into account and, if we follow
    the rules, we can end up with many more tables than domain model objects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系数据库中，我们使用正常形式来规范化我们的数据。从基本的**第一正常形式**（**1NF**）开始，到2NF、3NF和BCNF，我们根据功能依赖关系对我们的数据进行建模，如果我们遵循规则，我们最终可能会得到比领域模型对象更多的表。
- en: In practice, relational database modeling is often driven by the structure of
    the data that we have. In web applications following some sort of **Model-View-Controller**
    (**MVC**) model pattern, we will model our database according to our models, which
    are modeled after the **Unified Modeling Language** (**UML**) diagram conventions.
    Abstractions such as the ORM for **Django** or the **Active Record** for Rails
    help application developers abstract database structure to object models. Ultimately,
    many times, we end up designing our database based on the structure of the available
    data. Thus, we are designing around the answers that we can have.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，关系数据库建模通常是由我们拥有的数据结构驱动的。在遵循某种**模型-视图-控制器**（**MVC**）模式的Web应用程序中，我们将根据我们的模型来设计我们的数据库，这些模型是根据**统一建模语言**（**UML**）图表约定进行建模的。像**Django**的ORM或Rails的**Active
    Record**这样的抽象帮助应用程序开发人员将数据库结构抽象为对象模型。最终，很多时候，我们最终设计我们的数据库是基于可用数据的结构。因此，我们是根据我们可以得到的答案来设计的。
- en: MongoDB schema design
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB模式设计
- en: In contrast to relational databases, in MongoDB we have to base our modeling
    on our application-specific data access patterns. Finding out the questions that
    our users will have is paramount to designing our entities. In contrast to an
    RDBMS, data duplication and denormalization are used far more frequently and with
    solid reason.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与关系数据库相比，在MongoDB中，我们必须基于我们特定于应用程序的数据访问模式进行建模。找出我们的用户将会有的问题对于设计我们的实体至关重要。与RDBMS相比，数据重复和去规范化更频繁地使用，并且有充分的理由。
- en: The document model that MongoDB uses means that every document can hold substantially
    more or less information than the next one, even within the same collection. Coupled
    with rich and detailed queries being possible in MongoDB in the embedded document
    level, this means that we are free to design our documents in any way that we
    want. When we know our data access patterns, we can estimate which fields need
    to be embedded and which can be split out to different collections.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB使用的文档模型意味着每个文档可以容纳的信息量远远多于或少于下一个文档，即使在同一个集合中也是如此。再加上在嵌入文档级别上MongoDB可以进行丰富和详细的查询，这意味着我们可以自由设计我们的文档。当我们了解我们的数据访问模式时，我们可以估计哪些字段需要被嵌入，哪些可以拆分到不同的集合中。
- en: Read-write ratio
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读写比
- en: The read to write ratio is often an important design consideration for MongoDB
    modeling. When reading data, we want to avoid scatter/gather situations, where
    we have to hit several shards with random I/O requests to get the data our application
    needs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 读写比通常是MongoDB建模的重要考虑因素。在读取数据时，我们希望避免散布/聚集的情况，即我们必须向多个分片发出随机I/O请求才能获取应用程序所需的数据。
- en: When writing data, on the other hand, we want to spread out writes to as many
    servers as possible, to avoid overloading any single one of them. These goals
    appear to be conflicting on the surface, but they can be combined once we know
    our access patterns, coupled with application design considerations, such as using
    a replica set to read from secondary nodes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在写入数据时，我们希望将写入分散到尽可能多的服务器上，以避免过载任何一个服务器。这些目标表面上看起来是相互冲突的，但一旦我们了解我们的访问模式，并结合应用程序设计考虑，比如使用副本集从辅助节点读取，它们可以结合起来。
- en: Data modeling
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据建模
- en: In this section, we will discuss the different data types MongoDB uses, how
    they map to the data types that programming languages use, and how we can model
    data relationships in MongoDB using Ruby, Python, and PHP.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论MongoDB使用的不同数据类型，它们如何映射到编程语言使用的数据类型，以及我们如何使用Ruby、Python和PHP在MongoDB中建模数据关系。
- en: Data types
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: MongoDB uses BSON, a binary-encoded serialization for JSON documents. BSON extends the
    JSON data types, offering, for example, native data and binary data types.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB使用BSON，这是一种用于JSON文档的二进制编码序列化。 BSON扩展了JSON数据类型，例如提供了原生数据和二进制数据类型。
- en: 'BSON, compared to protocol buffers, allows for more flexible schemas that come
    at the cost of space efficiency. In general, BSON is space-efficient, easy to
    traverse, and time-efficient in encoding/decoding operations, as can be seen in
    the following table. (See the MongoDB documentation at [https://docs.mongodb.com/manual/reference/bson-types/](https://docs.mongodb.com/manual/reference/bson-types/)):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与协议缓冲区相比，BSON允许更灵活的模式，但以空间效率为代价。总的来说，BSON在编码/解码操作中是空间高效、易于遍历和时间高效的，如下表所示。（请参阅MongoDB文档[https://docs.mongodb.com/manual/reference/bson-types/](https://docs.mongodb.com/manual/reference/bson-types/)）：
- en: '| **Type** | **Number** | **Alias** | **Notes** |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **数字** | **别名** | **备注** |'
- en: '| Double | 1 | `double` |  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 双精度 | 1 | `double` |  |'
- en: '| String | 2 | `string` |  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| String | 2 | `string` |  |'
- en: '| Object | 3 | `object` |  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 对象 | 3 | `object` |  |'
- en: '| Array | 4 | `array` |  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 数组 | 4 | `array` |  |'
- en: '| Binary data | 5 | `binData` |  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 二进制数据 | 5 | `binData` |  |'
- en: '| ObjectID | 7 | `objectId` |  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| ObjectID | 7 | `objectId` |  |'
- en: '| Boolean | 8 | `bool` |  |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 布尔 | 8 | `bool` |  |'
- en: '| Date | 9 | `date` |  |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 日期 | 9 | `date` |  |'
- en: '| Null | 10 | `null` |  |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 空 | 10 | `null` |  |'
- en: '| Regular expression | 11 | `regex` |  |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 正则表达式 | 11 | `regex` |  |'
- en: '| JavaScript | 13 | `javascript` |  |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| JavaScript | 13 | `javascript` |  |'
- en: '| JavaScript (with scope) | 15 | `javascriptWithScope` |  |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| JavaScript（带作用域） | 15 | `javascriptWithScope` |  |'
- en: '| 32-bit integer | 16 | `int` |  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 32位整数 | 16 | `int` |  |'
- en: '| Timestamp | 17 | `timestamp` |  |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 时间戳 | 17 | `timestamp` |  |'
- en: '| 64-bit integer | 18 | `long` |  |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 64位整数 | 18 | `long` |  |'
- en: '| Decimal128 | 19 | `decimal` | New in version 3.4 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| Decimal128 | 19 | `decimal` | 3.4版中的新功能 |'
- en: '| Min key | -1 | `minKey` |  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 最小键 | -1 | `minKey` |  |'
- en: '| Max key | 127 | `maxKey` |  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 最大键 | 127 | `maxKey` |  |'
- en: '| Undefined | 6 | `undefined` | Deprecated |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 未定义 | 6 | `undefined` | 已弃用 |'
- en: '| DBPointer | 12 | `dbPointer` | Deprecated |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| DBPointer | 12 | `dbPointer` | 已弃用 |'
- en: '| Symbol | 14 | `symbol` | Deprecated |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | 14 | `symbol` | 已弃用 |'
- en: In MongoDB, we can have documents with different value types for a given field
    and we  distinguish among them when querying using the `$type` operator.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中，我们可以在给定字段的文档中具有不同值类型，并且在使用`$type`运算符进行查询时，我们对它们进行区分。
- en: 'For example, if we have a `balance` field in GBP with 32-bit integers and `double`
    data types, if `balance` has pennies in it or not, we can easily query for all
    accounts that have a rounded `balance` with any of the following queries shown
    in the example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们在GBP中有一个32位整数和`double`数据类型的`balance`字段，如果`balance`中有便士或没有，我们可以轻松查询所有帐户，这些帐户具有任何以下查询中显示的四舍五入的`balance`：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will compare the different data types in the following section.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下部分比较不同的数据类型。
- en: Comparing different data types
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较不同的数据类型
- en: Due to the nature of MongoDB, it's perfectly acceptable to have different data
    type objects in the same field. This may happen by accident or on purpose (that
    is, null and actual values in a field).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于MongoDB的性质，在同一字段中具有不同数据类型的对象是完全可以接受的。这可能是意外发生的，也可能是有意为之（即，在字段中有空值和实际值）。
- en: 'The sorting order of different types of data, from highest to lowest, is as
    follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类型数据的排序顺序，从高到低，如下所示：
- en: Max key (internal type)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内部类型的最大键
- en: Regular expression
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Timestamp
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 时间戳
- en: Date
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 日期
- en: Boolean
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布尔值
- en: ObjectID
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ObjectID
- en: Binary data
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二进制数据
- en: Array
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数组
- en: Object
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象
- en: Symbol, string
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 符号，字符串
- en: Numbers (`int`, `long`, `double`)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数字（`int`，`long`，`double`）
- en: 'Null'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 空
- en: Min key (internal type)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内部类型的最小键
- en: Non-existent fields get sorted as if they have `null` in the respective field.
    Comparing arrays is a bit more complex than fields. An ascending order of comparison
    (or `<`) will compare the smallest element of each array. A descending order of
    comparison (or `>`) will compare the largest element of each array.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不存在的字段会按照在相应字段中具有`null`的方式进行排序。比较数组比较字段更复杂。比较的升序（或`<`）将比较每个数组的最小元素。比较的降序（或`>`）将比较每个数组的最大元素。
- en: 'For example, see the following scenario:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，查看以下情景：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In ascending order, this is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 按升序排列，如下所示：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'However, in descending order, it is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，按降序排列，如下所示：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The same applies when comparing an array with a single number value, as illustrated
    in the following example. Inserting a new document with an integer value of `4`
    is done as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当比较数组与单个数字值时，也是如下示例所示。插入一个整数值为`4`的新文档的操作如下：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following example shows the code snippet for a descending `sort`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了降序`sort`的代码片段：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And the following example is the code snippet for an ascending `sort`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是升序`sort`的代码片段：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In each case, we highlighted the values being compared in bold.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，我们都突出显示了要比较的值。
- en: We will learn about the data type in the following section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下部分了解数据类型。
- en: Date type
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期类型
- en: Dates are stored as milliseconds with effect from January 01, 1970 (epoch time).
    They are 64-bit signed integers, allowing for a range of 135 million years before
    and after 1970\. A negative date value denotes a date before January 01, 1970\.
    The BSON specification refers to the `date` type as UTC `DateTime`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 日期以毫秒为单位存储，从1970年1月1日（纪元时间）开始生效。它们是64位有符号整数，允许在1970年之前和之后的135百万年范围内。负日期值表示1970年1月1日之前的日期。BSON规范将`date`类型称为UTC`DateTime`。
- en: Dates in MongoDB are stored in UTC. There isn't `timestamp` with a `timezone`
    data type like in some relational databases. Applications that need to access
    and modify timestamps, based on local time, should store the `timezone` offset
    together with the date and offset dates on an application level.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB中的日期存储在UTC中。与一些关系数据库中的`timestamp`带有`timezone`数据类型不同。需要根据本地时间访问和修改时间戳的应用程序应该将`timezone`偏移量与日期一起存储，并在应用程序级别上偏移日期。
- en: 'In the MongoDB shell, this could be done using the following format with JavaScript:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB shell中，可以使用以下JavaScript格式来完成：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then you need to apply the saved offset to reconstruct the original local time,
    as in the following example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您需要应用保存的偏移量来重建原始本地时间，就像以下示例中所示：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the next section, we will cover `ObjectId`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍`ObjectId`。
- en: ObjectId
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ObjectId
- en: '`ObjectId` is a special data type for MongoDB. Every document has an `_id`
    field from cradle to grave. It is the primary key for each document in a collection
    and has to be unique. If we omit this field in a `create` statement, it will be
    assigned automatically with an `ObjectId`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObjectId`是MongoDB的特殊数据类型。每个文档从创建到销毁都有一个`_id`字段。它是集合中每个文档的主键，并且必须是唯一的。如果我们在`create`语句中省略了这个字段，它将自动分配一个`ObjectId`。'
- en: Messing with `ObjectId` is not advisable but we can use it (with caution!) for
    our purposes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 擅自更改`ObjectId`是不可取的，但我们可以小心使用它来达到我们的目的。
- en: '`ObjectId` has the following distinctions:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObjectId`具有以下区别：'
- en: It has 12 bytes
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有12个字节
- en: It is ordered
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是有序的
- en: Sorting by `_id` will sort by creation time for each document
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按_id排序将按每个文档的创建时间进行排序
- en: Storing the creation time can be accessed by `.getTimeStamp()` in the shell
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储创建时间可以通过在shell中使用`.getTimeStamp()`来访问
- en: 'The structure of an `ObjectId` has the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObjectId`的结构如下：'
- en: A 4-byte value representing the seconds since the Unix epoch
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个4字节的值，表示自Unix纪元以来的秒数
- en: A 3-byte machine identifier
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个3字节的机器标识符
- en: A 2-byte process ID
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个2字节的进程ID
- en: A 3-byte counter, starting with a random value
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个3字节的计数器，从一个随机值开始
- en: 'The  following diagram shows the structure of an ObjectID:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了ObjectID的结构：
- en: '![](img/28e23c3f-309a-4e34-b437-cfbce6e41960.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28e23c3f-309a-4e34-b437-cfbce6e41960.png)'
- en: By its structure, `ObjectId` will be unique for all purposes; however, since
    this is generated on the client side, you should check the underlying library's
    source code to verify that implementation is according to specification.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 按其结构，`ObjectId`对于所有目的都是唯一的；但是，由于这是在客户端生成的，您应该检查底层库的源代码，以验证实现是否符合规范。
- en: In the next section, we will learn about modeling data for atomic operations.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习有关建模原子操作的数据。
- en: Modeling data for atomic operations
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建模原子操作的数据
- en: MongoDB is relaxing many of the typical **Atomicity, Consistency, Isolation
    and Durability** (**ACID**) constraints found in RDBMS. In the absence of transactions,
    it can sometimes be difficult to keep the state consistent across operations,
    especially in the event of failures.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB正在放宽许多在关系型数据库中找到的典型**原子性、一致性、隔离性和持久性**（**ACID**）约束。在没有事务的情况下，有时很难在操作中保持状态一致，特别是在发生故障时。
- en: 'Luckily, some operations are atomic at the document level:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，一些操作在文档级别上是原子的：
- en: '`update()`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update()`'
- en: '`findandmodify()`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findandmodify()`'
- en: '`remove()`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove()`'
- en: These are all atomic (all or nothing) for a single document.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是针对单个文档的原子（全部或无）。
- en: This means that, if we embed information in the same document, we can make sure
    they are always in sync.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果我们在同一文档中嵌入信息，我们可以确保它们始终同步。
- en: An example would be an inventory application, with a document per item in our
    inventory, where we would need to total the available items left in stock how
    many have been placed in a shopping cart in sync, and use this data to sum up
    the total available items.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例是库存应用程序，每个库存中的物品都有一个文档，我们需要统计库存中剩余的可用物品数量，购物车中已放置的物品数量，并将这些数据用于计算总可用物品数量。
- en: 'With `total_available = 5`, `available_now = 3`, `shopping_cart_count = 2`,
    this use case could look like the following: `{available_now : 3, Shopping_cart_by:
    ["userA", "userB"] }`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '对于`total_available = 5`，`available_now = 3`，`shopping_cart_count = 2`，这个用例可能如下所示：`{available_now
    : 3, Shopping_cart_by: ["userA", "userB"] }`'
- en: When someone places the item in their shopping cart, we can issue an atomic
    update, adding their user ID in the `shopping_cart_by` field and, at the same
    time, decreasing the `available_now` field by one.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人将商品放入购物车时，我们可以发出原子更新，将他们的用户ID添加到`shopping_cart_by`字段中，并同时将`available_now`字段减少一个。
- en: This operation will be guaranteed to be atomic at the document level. If we
    need to update multiple documents within the same collection, the update operation
    may complete successfully without modifying all of the documents that we intended
    it to. This could happen because the operation is not guaranteed to be atomic
    across multiple document updates.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作将在文档级别上保证是原子的。如果我们需要在同一集合中更新多个文档，更新操作可能会成功完成，而不修改我们打算修改的所有文档。这可能是因为该操作不能保证跨多个文档更新是原子的。
- en: This pattern can help in some, but not all, cases. In many cases, we need multiple
    updates to be applied on all or nothing across documents, or even collections.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在某些情况下有所帮助，但并非所有情况都适用。在许多情况下，我们需要对所有文档或甚至集合应用多个更新，要么全部成功，要么全部失败。
- en: A typical example would be a bank transfer between two accounts. We want to
    subtract *x* GBP from user *A*, then add *x* to user *B*. If we fail to do either
    of the two steps, we would return to the original state for both balances.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的例子是两个账户之间的银行转账。我们想要从用户A那里减去x英镑，然后将x添加到用户B那里。如果我们无法完成这两个步骤中的任何一个，我们将返回到两个余额的原始状态。
- en: 'The details of this pattern are outside the scope of this book, but roughly,
    the idea is to implement a hand-coded two phase **commit** protocol. This protocol
    should create a new transaction entry for each transfer with every possible state
    in this transaction: such as initial, pending, applied, done, cancelling, cancelled,
    and, based on the state that each transaction is left at, applying the appropriate
    rollback function to it.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的细节超出了本书的范围，但大致上，想法是实现一个手工编码的两阶段**提交**协议。该协议应该为每个转账创建一个新的事务条目，并在该事务中的每个可能状态（如初始、挂起、应用、完成、取消中、已取消）中创建一个新的事务条目，并根据每个事务留下的状态，对其应用适当的回滚函数。
- en: If you find yourself having to implement transactions in a database that was
    built to avoid them, take a step back and rethink why you need to do that.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现自己不得不在一个旨在避免它们的数据库中实现事务，请退一步，重新思考为什么需要这样做。
- en: Write isolation
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写隔离
- en: Sparingly, we could use `$isolated` to isolate writes to multiple documents
    from other writers or readers to these documents. In the previous example, we
    could use `$isolated` to update multiple documents and make sure that we update
    both balances before anyone else gets the chance to double-spend, draining the
    source account of its funds.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以节约地使用`$isolated`来隔离对多个文档的写入，以防其他写入者或读取者对这些文档进行操作。在前面的例子中，我们可以使用`$isolated`来更新多个文档，并确保在其他人有机会进行双倍花费并耗尽资金源账户之前，我们更新两个余额。
- en: What this won't give us though, is atomicity, the all-or-nothing approach. So,
    if the update only partially modifies both accounts, we still need to detect and
    unroll any modifications made in the pending state.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不会给我们带来原子性，即全有或全无的方法。因此，如果更新只部分修改了两个账户，我们仍然需要检测并取消处于挂起状态的任何修改。
- en: '`$isolated` uses an exclusive lock on the entire collection, no matter which
    storage engine is used. This means a severe speed penalty when using it, especially
    for WiredTiger document-level locking semantics.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`$isolated`在整个集合上使用独占锁，无论使用哪种存储引擎。这意味着在使用它时会有严重的速度惩罚，特别是对于WiredTiger文档级别的锁定语义。'
- en: '`$isolated` does not work with sharded clusters, which may be an issue when
    we decide to go from replica sets to sharded deployment.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`$isolated`在分片集群中不起作用，当我们决定从副本集转到分片部署时可能会成为一个问题。'
- en: Read isolation and consistency
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取隔离和一致性
- en: MongoDB read operations would be characterized as *read uncommitted* in a traditional
    RDBMS definition. What this means is that, by default, reads may get values that
    may not finally persist to the disk in the event of, for example, data loss or
    a replica set rollback operation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的关系数据库管理系统定义中，MongoDB的读取操作将被描述为*读取未提交*。这意味着，默认情况下，读取可能会获取到最终不会持久到磁盘上的值，例如，数据丢失或副本集回滚操作。
- en: 'In particular, when updating multiple documents with the default write behavior,
    lack of isolation may result in the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，在使用默认写入行为更新多个文档时，缺乏隔离可能会导致以下问题：
- en: Reads may miss documents that were updated during the update operations
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取可能会错过在更新操作期间更新的文档
- en: Non-serializable operations
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非串行化操作
- en: Read operations are not point-in-time
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取操作不是即时的
- en: These can be resolved by using the `$isolated` operator with a heavy performance
    penalty.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以通过使用`$isolated`运算符来解决，但会带来严重的性能惩罚。
- en: 'Queries with cursors that don''t use `.snapshot()` may also, in some cases,
    get inconsistent results. This can happen if the query''s resultant cursor fetches
    a document, which receives an update while the query is still fetching results,
    and, because of insufficient padding, ends up in a different physical location
    on the disk, ahead of the query''s result cursor position. `.snapshot()` is a
    solution for this edge case, with the following limitations:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，不使用`.snapshot()`的游标查询可能会得到不一致的结果。如果查询的结果游标获取了一个文档，而在查询仍在获取结果时该文档接收到更新，并且由于填充不足，最终位于磁盘上的不同物理位置，超出了查询结果游标的位置。`.snapshot()`是这种边缘情况的解决方案，但有以下限制：
- en: It doesn't work with sharding
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不适用于分片
- en: It doesn't work with `sort()` or `hint()` to force an index to be used
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不适用于使用`sort()`或`hint()`来强制使用索引
- en: It still won't provide point-in-time read behavior
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它仍然不会提供即时读取行为
- en: If our collection has mostly static data, we can use a unique index in the query
    field to simulate `snapshot()` and still be able to apply `sort()` to it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的集合大部分是静态数据，我们可以在查询字段中使用唯一索引来模拟`snapshot()`，并且仍然能够对其应用`sort()`。
- en: All in all, we need to apply safeguards at the application level to make sure
    that we won't end up with unexpected results.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们需要在应用程序级别应用保障措施，以确保我们不会得到意外的结果。
- en: Starting from version 3.4, MongoDB offers linearizable read concern. With linearizable
    read concern from the primary member of a replica set and a majority write concern,
    we can ensure that multiple threads can read and write a single document as if
    a single thread was performing these operations one after the other. This is considered
    a linearizable schedule in RDBMS, and MongoDB calls it the real-time order.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本3.4开始，MongoDB提供了可线性化的读关注。通过从副本集的主要成员和大多数写关注中使用线性化的读关注，我们可以确保多个线程可以读取和写入单个文档，就好像单个线程在依次执行这些操作一样。在关系型数据库管理系统中，这被认为是一个线性化的调度，MongoDB称之为实时顺序。
- en: Modeling relationships
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建模关系
- en: In the following sections, we will explain how we can translate relationships
    in RDBMS theory into MongoDB's document-collection hierarchy. We will also examine
    how we can model our data for text search in MongoDB.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将解释如何将关系数据库管理系统理论中的关系转换为MongoDB的文档集合层次结构。我们还将研究如何在MongoDB中为文本搜索建模我们的数据。
- en: One-to-one
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一对一
- en: 'Coming from the relational DB world, we identify objects by their relationships.
    A one-to-one relationship could be a person with an address. Modeling it in a
    relational database would most probably require two tables: a **Person** and an
    **Address** table with a foreign key `person_id` in the **Address** table, as
    shown in the following diagram:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从关系数据库世界来看，我们通过它们的关系来识别对象。一个一对一的关系可能是一个人和一个地址。在关系数据库中对其进行建模很可能需要两个表：一个**Person**表和一个**Address**表，**Address**表中有一个`person_id`外键，如下图所示：
- en: '![](img/b045cf93-073f-43f2-aeb7-d0831e4e7b68.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b045cf93-073f-43f2-aeb7-d0831e4e7b68.png)'
- en: 'The perfect analogy in MongoDB would be two collections, `Person` and `Address`,
    as shown in the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中，完美的类比是两个集合，`Person`和`Address`，如下代码所示：
- en: '[PRE9]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we can use the same pattern as we do in a relational database to find
    `Person` from `address`, as shown in the following example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以像在关系数据库中一样使用相同的模式从`address`中查找`Person`，如下例所示：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This pattern is well known and works in the relational world.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在关系世界中是众所周知的，并且有效。
- en: In MongoDB, we don't have to follow this pattern, as there are more suitable
    ways to model these kinds of relationship.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中，我们不必遵循这种模式，因为有更适合模型这些关系的方式。
- en: 'One way in which we would typically model one-to-one or one-to-many relationships
    in MongoDB would be through embedding. If the person has two addresses, then the
    same example would then be shown in the following way:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中，我们通常会通过嵌入来建模一对一或一对多的关系。如果一个人有两个地址，那么同样的例子将如下所示：
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Using an embedded array, we can have access to every `address` this user has.
    Embedding querying is rich and flexible so that we can store more information
    in each document, as shown in the following example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用嵌入数组，我们可以访问此用户拥有的每个`address`。嵌入查询丰富而灵活，因此我们可以在每个文档中存储更多信息，如下例所示：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The advantages of this approach are as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点如下：
- en: No need for two queries across different collections
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需跨不同集合进行两次查询
- en: It can exploit atomic updates to make sure that updates in the document will
    be all-or-nothing from the perspective of other readers of this document
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以利用原子更新来确保文档中的更新对于其他读取此文档的读者来说是全有或全无的
- en: It can embed attributes in multiple nest levels creating complex structures
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以在多个嵌套级别中嵌入属性，创建复杂的结构
- en: The most notable disadvantage is that the maximum size of the document is 16
    MB so this approach cannot be used for an arbitrary, ever-growing number of attributes.
    Storing hundreds of elements in embedded arrays will also degrade performance.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最显著的缺点是文档的最大大小为16 MB，因此这种方法不能用于任意数量的属性。在嵌入数组中存储数百个元素也会降低性能。
- en: One-to-many and many-to-many
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一对多和多对多
- en: 'When the number of elements in the *many* side of the relationship can grow
    unbounded, it''s better to use references. References can come in two forms:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当关系的*多*方的元素数量可以无限增长时，最好使用引用。引用可以有两种形式：
- en: 'From the *one* side of the relationship, store an array of many-sided elements,
    as shown in the following example:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从关系的*一*方，存储多边元素的数组，如下例所示：
- en: '[PRE13]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This way we can get the array of `addresses` from the one-side and then query
    with `in` to get all the documents from the many-side, as shown in the following
    example:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样我们可以从一方获取`addresses`数组，然后使用`in`查询获取多方的所有文档，如下例所示：
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Turning this one-to-many to many-to-many is as easy as storing this array in
    both ends of the relationship (that is, in the `Person` and `Address` collections).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将这种一对多转换为多对多就像在关系的两端（即`Person`和`Address`集合）都存储这个数组一样容易。
- en: 'From the many-side of the relationship, store a reference to the one-side,
    as shown in the following example:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从关系的多方，存储对一方的引用，如下例所示：
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we can see, with both designs we need to make two queries to the database
    to fetch the information. The second approach has the advantage that it won't
    let any document grow unbounded, so it can be used in cases where one-to-many
    is one-to-millions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，无论哪种设计，我们都需要对数据库进行两次查询以获取信息。第二种方法的优势在于它不会让任何文档无限增长，因此它可以用于一对多是一对数百万的情况。
- en: Modeling data for keyword searches
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为关键字搜索建模数据
- en: Searching for keywords in a document is a common operation for many applications.
    If this is a core operation, it makes sense to use a specialized store for search,
    such as **Elasticsearch**; however, MongoDB can be used efficiently until scale
    dictates moving to a different solution.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多应用程序中，搜索文档中的关键字是一个常见的操作。如果这是一个核心操作，使用专门的搜索存储，如**Elasticsearch**是有意义的；然而，直到规模要求转移到不同的解决方案之前，MongoDB可以有效地使用。
- en: 'The basic need for a keyword search is to be able to search the entire document
    for keywords. For example, with a document in the `products` collection, as shown
    in the following code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字搜索的基本需求是能够搜索整个文档中的关键字。例如，在`products`集合中的文档，如下例所示：
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can create a multi-key index in the `keywords` field, as shown in the following
    code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`keywords`字段中创建多键索引，如下例所示：
- en: '[PRE17]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now we can search in the `keywords` field for any name, manufacturer, price,
    and also any of the custom keywords that we set up. This is not an efficient or
    flexible approach, as we need to keep keywords lists in sync, we can't use stemming,
    and we can't rank results (it's more like filtering than searching). The only
    advantage of this method is that it is slightly quicker to implement.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在`keywords`字段中搜索任何名称、制造商、价格，以及我们设置的任何自定义关键字。这不是一种高效或灵活的方法，因为我们需要保持关键字列表同步，我们不能使用词干处理，也不能对结果进行排名（更像是过滤而不是搜索）。这种方法的唯一优点是它实现起来稍微快一些。
- en: Since version 2.4, MongoDB has had a special text index type. This can be declared
    in one or multiple fields and supports stemming, tokenization, exact phrase (`"
    "`), negation (`-`), and weighting results.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 自2.4版本以来，MongoDB就有了特殊的文本索引类型。它可以在一个或多个字段中声明，并支持词干处理、标记化、精确短语(`" "`)、否定(`-`)和加权结果。
- en: 'Index declaration on three fields with custom `weights` is shown in the following
    example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在三个字段上声明具有自定义`权重`的索引如下例所示：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, `name` is `10` times more important than `price` but only two
    times from `manufacturer`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`name`比`price`重要的程度是`10`倍，但比`manufacturer`只重要两倍。
- en: 'A `text` index can also be declared with a wildcard, matching all the fields
    that match the pattern, as shown in the following example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用通配符声明`text`索引，匹配与模式匹配的所有字段，如下例所示：
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This can be useful when we have unstructured data and we may not know all the
    fields that they will come with. We can drop the index by name, just like with
    any other index.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这在我们有非结构化数据并且可能不知道它们将带有哪些字段时非常有用。我们可以像处理任何其他索引一样，通过名称删除索引。
- en: The greatest advantage though, other than all the features, is that all record
    keeping is done by the database.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最大的优势是，除了所有的功能之外，所有的记录都是由数据库完成的。
- en: In the next section, we will learn how to connect to MongoDB.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何连接到MongoDB。
- en: Connecting to MongoDB
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到MongoDB
- en: 'There are two ways to connect to MongoDB. The first is by using the driver
    for your programming language. The second is by using an ODM layer to map your
    model objects to MongoDB in a transparent way. In this section, we will cover
    both ways, using three of the most popular languages for web application development:
    Ruby, Python, and PHP.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种连接到MongoDB的方式。第一种是使用您的编程语言的驱动程序。第二种是使用ODM层以透明的方式将模型对象映射到MongoDB。在本节中，我们将涵盖使用Web应用程序开发中最流行的三种语言：Ruby、Python和PHP的两种方式。
- en: Connecting using Ruby
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ruby连接
- en: 'Ruby was one of the first languages to have support from MongoDB with an official
    driver. The official MongoDB Ruby driver on GitHub is the recommended way to connect
    to a MongoDB instance. Perform the following steps to connect MongoDB using Ruby:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby是第一批得到MongoDB官方驱动程序支持的语言之一。在GitHub上，官方的MongoDB Ruby驱动程序是连接到MongoDB实例的推荐方式。执行以下步骤使用Ruby连接MongoDB：
- en: 'Installation is as simple as adding it to the Gemfile, as shown in the following
    example:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装就像将其添加到Gemfile一样简单，如下例所示：
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You need to install Ruby, then install RVM from [https://rvm.io/rvm/install](https://rvm.io/rvm/install), and
    finally run `gem install bundler` for this.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装Ruby，然后从[https://rvm.io/rvm/install](https://rvm.io/rvm/install)安装RVM，最后运行`gem
    install bundler`。
- en: 'Then, in our class, we can connect to a database, as shown in the following
    example:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在我们的类中，我们可以连接到数据库，如下例所示：
- en: '[PRE21]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is the simplest example possible: connecting to a single database instance
    called `test` in our `localhost`. In most use cases, we would at least have a
    replica set to connect to, as shown in the following snippet:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是可能的最简单的例子：连接到我们的`localhost`中名为`test`的单个数据库实例。在大多数情况下，我们至少会有一个副本集要连接，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `client_host` servers are seeding the client driver with servers to attempts
    to connect. Once connected, the driver will determine the server that it has to
    connect to according to the primary/secondary read or write configuration. The
    `replica_set` attribute needs to match `REPLICA_SET_NAME` to be able to connect.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`client_host`服务器正在为客户端驱动程序提供服务器以尝试连接。一旦连接，驱动程序将根据主/次读取或写入配置确定要连接的服务器。`replica_set`属性需要匹配`REPLICA_SET_NAME`才能连接。'
- en: '`user` and `password` are optional, but highly recommended in any MongoDB instance.
    It''s good practice to enable authentication by default in the `mongod.conf` file
    and we will learn more about this in [Chapter 8](687220c0-264a-4edb-9e04-c10b0c180766.xhtml), *Monitoring,
    Backup, and Security*.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`user`和`password`是可选的，但在任何MongoDB实例中都强烈建议使用。在`mongod.conf`文件中默认启用身份验证是一个良好的做法，我们将在[第8章](687220c0-264a-4edb-9e04-c10b0c180766.xhtml)中了解更多信息，*监控、备份和安全*。'
- en: Connecting to a sharded cluster is similar to a replica set, with the only difference
    being that, instead of supplying the server host/port, we need to connect to the
    MongoDB process that serves as the MongoDB router.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到分片集群与连接到副本集类似，唯一的区别是，我们需要连接到充当MongoDB路由器的MongoDB进程，而不是提供服务器主机/端口。
- en: Mongoid ODM
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mongoid ODM
- en: Using a low-level driver to connect to the MongoDB database is often not the
    most efficient route. All the flexibility that a low-level driver provides is
    offset against longer development times and code to glue our models with the database.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用低级驱动程序连接到MongoDB数据库通常不是最有效的方法。低级驱动程序提供的所有灵活性都抵消了更长的开发时间和用于将我们的模型与数据库粘合在一起的代码。
- en: An ODM can be the answer to these problems. Just like ORMs, ODMs bridge the
    gap between our models and the database. In Rails, the most widely-used MVC framework
    for Ruby—Mongoid—can be used to model our data in a similar way to Active Record.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ODM可以是这些问题的答案。就像ORM一样，ODM弥合了我们的模型和数据库之间的差距。在Rails中，作为Ruby最广泛使用的MVC框架的Mongoid可以用于以类似于Active
    Record的方式对我们的数据进行建模。
- en: 'Installing `gem` is similar to the Mongo Ruby driver, by adding a single file
    in the Gemfile, as shown in the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`gem`类似于Mongo Ruby驱动程序，通过在Gemfile中添加一个文件，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Depending on the version of Rails, we may need to add the following to `application.rb`
    as well:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Rails的版本，我们可能还需要将以下内容添加到`application.rb`中：
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Connecting to the database is done through a config file, `mongoid.yml`. Configuration
    options are passed as key-value pairs with semantic indentation. Its structure
    is similar to `database.yml` used for relational databases.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过配置文件`mongoid.yml`连接到数据库，配置选项以语义缩进的键值对形式传递。其结构类似于用于关系数据库的`database.yml`。
- en: 'Some of the options that we can pass through the `mongoid.yml` file are shown
    in the following table:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`mongoid.yml`文件传递的一些选项如下表所示：
- en: '| **Option value** | **Description** |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| **选项值** | **描述** |'
- en: '| `Database` | The database name. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `Database` | 数据库名称。 |'
- en: '| `Hosts` | Our database hosts. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `Hosts` | 我们的数据库主机。 |'
- en: '| `Write`/`w` | The write concern (default is 1). |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `Write`/`w` | 写入关注（默认为1）。 |'
- en: '| `Auth_mech` | Authentication mechanism. Valid options are: `:scram`, `:mongodb_cr`, `:mongodb_x509`,
    and `:plain`. The default option on 3.0 is `:scram`, whereas the default on 2.4
    and 2.6 is `:plain`. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `Auth_mech` | 认证机制。有效选项包括：`:scram`、`:mongodb_cr`、`:mongodb_x509`和`:plain`。3.0的默认选项是`:scram`，而2.4和2.6的默认选项是`:plain`。
    |'
- en: '| `Auth_source` | The authentication source for our authentication mechanism.
    |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `Auth_source` | 我们认证机制的认证源。 |'
- en: '| `Min_pool_size`/`max_pool_size` | Minimum and maximum pool size for connections.
    |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `Min_pool_size`/`max_pool_size` | 连接的最小和最大池大小。 |'
- en: '| `SSL`, `ssl_cert`, `ssl_key`,  `ssl_key_pass_phrase`, `ssl_verify` | A set
    of options regarding SSL connections to the database. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `SSL`、`ssl_cert`、`ssl_key`、`ssl_key_pass_phrase`、`ssl_verify` | 一组关于与数据库的SSL连接的选项。
    |'
- en: '| `Include_root_in_json` | Includes the root model name in JSON serialization.
    |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `Include_root_in_json` | 在JSON序列化中包含根模型名称。 |'
- en: '| `Include_type_for_serialization` | Includes the `_type` field when serializing
    MongoDB objects. |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `Include_type_for_serialization` | 在序列化MongoDB对象时包含`_type`字段。 |'
- en: '| `Use_activesupport_time_zone` | Uses active support''s time zone when converting
    timestamps between server and client. |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `Use_activesupport_time_zone` | 在服务器和客户端之间转换时间戳时使用 active support 的时区。 |'
- en: 'The next step is to modify our models to be stored in MongoDB. This is as simple
    as including one line of code in the model declaration, as shown in the following
    example:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是修改我们的模型以存储在 MongoDB 中。这就像在模型声明中包含一行代码那样简单，如下例所示：
- en: '[PRE25]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can also use the following code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用以下代码：
- en: '[PRE26]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We use it to generate `created_at` and `updated_at` fields in a similar way
    to Active Record. Data fields do not need to be declared by type in our models,
    but it''s good practice to do so. The supported data types are as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用它来生成类似于 Active Record 的 `created_at` 和 `updated_at` 字段。在我们的模型中，数据字段不需要按类型声明，但这样做是个好习惯。支持的数据类型如下：
- en: '`Array`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array`'
- en: '`BigDecimal`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BigDecimal`'
- en: '`Boolean`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boolean`'
- en: '`Date`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date`'
- en: '`DateTime`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DateTime`'
- en: '`Float`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Float`'
- en: '`Hash`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hash`'
- en: '`Integer`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Integer`'
- en: '`BSON::ObjectId`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BSON::ObjectId`'
- en: '`BSON::Binary`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BSON::Binary`'
- en: '`Range`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Range`'
- en: '`Regexp`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Regexp`'
- en: '`String`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`'
- en: '`Symbol`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol`'
- en: '`Time`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Time`'
- en: '`TimeWithZone`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimeWithZone`'
- en: If the types of fields are not defined, fields will be cast to the object and
    stored in the database. This is slightly faster, but doesn't support all types.
    If we try to use `BigDecimal`, `Date`, `DateTime`, or `Range`, we will get back
    an error.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字段的类型未定义，字段将被转换为对象并存储在数据库中。这样稍微快一些，但不支持所有类型。如果我们尝试使用 `BigDecimal`、`Date`、`DateTime`
    或 `Range`，将会收到错误信息。
- en: Inheritance with Mongoid models
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Mongoid 模型进行继承
- en: 'The following code is an example of inheritance using the Mongoid models:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是使用 Mongoid 模型进行继承的示例：
- en: '[PRE27]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, we have a `Canvas` class with many `Shape` objects embedded in it. Mongoid
    will automatically create a field, which is `_type`, to distinguish between parent
    and child node fields. In scenarios where documents are inherited from their fields,
    relationships, validations, and scopes get copied down into their child documents,
    but not vice-versa.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个具有许多嵌入的 `Shape` 对象的 `Canvas` 类。Mongoid 将自动创建一个字段，即 `_type`，以区分父节点和子节点字段。在从字段继承文档的情况下，关系、验证和作用域会复制到其子文档中，但反之则不会。
- en: '`embeds_many` and `embedded_in` pairs will create embedded sub-documents to
    store the relationships. If we want to store these via referencing to `ObjectId`,
    we can do so by substituting these with `has_many` and `belongs_to`.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`embeds_many` 和 `embedded_in` 对将创建嵌入式子文档以存储关系。如果我们想通过引用 `ObjectId` 来存储这些关系，可以通过将它们替换为
    `has_many` 和 `belongs_to` 来实现。'
- en: Connecting using Python
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 进行连接
- en: A strong contender to Ruby and Rails is Python with Django. Similar to Mongoid,
    there is MongoEngine and an official MongoDB low-level driver, PyMongo.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Ruby 和 Rails 相媲美的是 Python 和 Django。类似于 Mongoid，还有 MongoEngine 和官方的 MongoDB
    低级驱动程序 PyMongo。
- en: 'Installing PyMongo can be done using `pip` or `easy_install`, as shown in the
    following code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `pip` 或 `easy_install` 安装 PyMongo，如下代码所示：
- en: '[PRE28]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, in our class, we can connect to a database, as shown in the following
    example:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的类中，我们可以连接到数据库，如下例所示：
- en: '[PRE29]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Connecting to a replica set requires a set of seed servers for the client to
    find out what the primary, secondary, or arbiter nodes in the set are, as indicated
    in the following example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到副本集需要一组种子服务器，客户端可以找出集合中的主、从或仲裁节点，如下例所示：
- en: '[PRE30]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Using the connection string URL, we can pass a username and password and the `replicaSet`
    name all in a single string. Some of the most interesting options for the connection
    string URL are present in the next section.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用连接字符串 URL，我们可以在单个字符串中传递用户名、密码和 `replicaSet` 名称。连接字符串 URL 的一些最有趣的选项在下一节中。
- en: Connecting to a shard requires the server host and IP for the MongoDB router,
    which is the MongoDB process.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到分片需要 MongoDB 路由器的服务器主机和 IP，这是 MongoDB 进程。
- en: PyMODM ODM
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyMODM ODM
- en: 'Similar to Ruby''s Mongoid, PyMODM is an ODM for Python that follows closely
    on Django''s built-in ORM. Installing `pymodm` can be done via `pip`, as shown
    in the following code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Ruby 的 Mongoid 类似，PyMODM 是 Python 的 ODM，紧随 Django 内置的 ORM。通过 `pip` 安装 `pymodm`，如下代码所示：
- en: '[PRE31]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then we need to edit `settings.py` and replace the database `ENGINE` with a
    `dummy` database, as shown in the following code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要编辑 `settings.py`，将数据库 `ENGINE` 替换为 `dummy` 数据库，如下代码所示：
- en: '[PRE32]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then we add our connection string anywhere in `settings.py`, as shown in the
    following code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在 `settings.py` 的任何位置添加我们的连接字符串，如下代码所示：
- en: '[PRE33]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, we have to use a connection string that has the following structure:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须使用具有以下结构的连接字符串：
- en: '[PRE34]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Options have to be pairs of `name=value` with an `&` between each pair. Some
    interesting pairs are shown in the following table:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 选项必须是`name=value`对，每对之间用`&`分隔。一些有趣的对如下表所示：
- en: '| **Name** | **Description** |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **描述** |'
- en: '| `minPoolSize`/`maxPoolSize` | Minimum and maximum pool size for connections.
    |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `minPoolSize`/`maxPoolSize` | 连接的最小和最大池大小。 |'
- en: '| `w` | Write concern option. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `w` | 写关注选项。 |'
- en: '| `wtimeoutMS` | Timeout for write concern operations. |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `wtimeoutMS` | 写关注操作的超时时间。 |'
- en: '| `Journal` | Journal options. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `Journal` | 日志选项。 |'
- en: '| `readPreference` | Read preference to be used for replica sets. Available
    options are: `primary`, `primaryPreferred`, `secondary`, `secondaryPreferred`,
    `nearest`. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `readPreference` | 用于副本集的读取偏好。可用选项包括：`primary`、`primaryPreferred`、`secondary`、`secondaryPreferred`、`nearest`。
    |'
- en: '| `maxStalenessSeconds` | Specifies, in seconds, how stale (data lagging behind
    master) a secondary can be before the client stops using it for read operations.
    |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `maxStalenessSeconds` | 指定从主服务器滞后的数据可以在客户端停止使用之前的秒数。 |'
- en: '| `SSL` | Using SSL to connect to the database. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `SSL` | 使用 SSL 连接到数据库。 |'
- en: '| `authSource` | Used in conjunction with username, this specifies the database
    associated with the user''s credentials. When we use external authentication mechanisms,
    this should be `$external` for LDAP or Kerberos. |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `authSource` | 与用户名一起使用，指定与用户凭据关联的数据库。当我们使用外部认证机制时，LDAP 或 Kerberos 应该是 `$external`。
    |'
- en: '| `authMechanism` | Authentication mechanism can be used for connections. Available
    options for MongoDB are: **SCRAM-SHA-1**, **MONGODB-CR**, **MONGODB-X.509**.MongoDB
    enterprise (paid version) offers two more options: **GSSAPI** (Kerberos), **PLAIN**
    (**LDAP SASL**) |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `authMechanism` | 可用于连接的身份验证机制。MongoDB的可用选项有：**SCRAM-SHA-1**，**MONGODB-CR**，**MONGODB-X.509**。MongoDB企业版（付费版本）提供了两个更多的选项：**GSSAPI**（Kerberos），**PLAIN**（**LDAP
    SASL**）|'
- en: 'Model classes need to inherit from `MongoModel`. The following code shows what
    a sample class will look like:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 模型类需要继承自`MongoModel`。以下代码显示了一个示例类的样子：
- en: '[PRE35]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This has a `User` class with `first_name`, `last_name`, and `email` fields,
    where `email` is the primary field.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个`User`类，有`first_name`，`last_name`和`email`字段，其中`email`是主要字段。
- en: Inheritance with PyMODM models
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyMODM模型的继承
- en: 'Handling one-to-one and one-to-many relationships in MongoDB can be done using
    references or embedding. The following example shows both ways, which are references
    for the model user and embedding for the comment model:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中处理一对一和一对多关系可以使用引用或嵌入。下面的例子展示了两种方式，即用户模型的引用和评论模型的嵌入：
- en: '[PRE36]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Similar to Mongoid for Ruby, we can define relationships as being embedded or
    referenced, depending on our design decision.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于Ruby的Mongoid，我们可以根据设计决定将关系定义为嵌入式或引用式。
- en: Connecting using PHP
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PHP连接
- en: 'The MongoDB PHP driver was rewritten from scratch two years ago to support
    the PHP 5, PHP 7, and HHVM architectures. The current architecture is shown in
    the following diagram:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 两年前，MongoDB PHP驱动程序从头开始重写，以支持PHP 5、PHP 7和HHVM架构。当前的架构如下图所示：
- en: '![](img/0e79b102-ba4d-4275-9559-dcb782394764.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e79b102-ba4d-4275-9559-dcb782394764.png)'
- en: Currently, we have official drivers for all three architectures with full support
    for the underlying functionality.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们对所有三种架构都有官方驱动程序，完全支持底层功能。
- en: 'Installation is a two-step process. First, we need to install the MongoDB extension.
    This extension is dependent on the version of PHP (or HHVM) that we have installed
    and can be done using `brew` in macOS.  The following example is with PHP 7.0:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 安装是一个两步过程。首先，我们需要安装MongoDB扩展。这个扩展依赖于我们安装的PHP（或HHVM）的版本，可以使用macOS中的`brew`来完成。以下示例是使用PHP
    7.0：
- en: '[PRE37]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, use `composer` (a widely-used dependency manager for PHP) as shown in
    the following example:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，像下面的例子一样使用`composer`（PHP中广泛使用的依赖管理器）：
- en: '[PRE38]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Connecting to the database can be done by using the connection string URL or
    by passing an array of options.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用连接字符串URL或通过传递一个选项数组来连接到数据库。
- en: 'Using the connection string URL, we have the following code:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 使用连接字符串URL，我们有以下代码：
- en: '[PRE39]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For example, to connect to a replica set using SSL authentication, we use the
    following code:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要使用SSL身份验证连接到副本集，我们使用以下代码：
- en: '[PRE40]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Or we can use the `$uriOptions` parameter to pass in parameters without using
    the connection string URL, as shown in the following code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以使用`$uriOptions`参数来传递参数，而不使用连接字符串URL，如下面的代码所示：
- en: '[PRE41]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The set of `$uriOptions` and the connection string URL options available are
    analogous to the ones used for Ruby and Python.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的`$uriOptions`和连接字符串URL选项与用于Ruby和Python的选项类似。
- en: Doctrine ODM
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Doctrine ODM
- en: '**Laravel** is one of the most widely-used MVC frameworks for PHP, similar
    in architecture to Django and Rails from the Python and Ruby worlds respectively.
    We will follow through configuring our models using Laravel, Doctrine, and MongoDB.
    This section assumes that Doctrine is installed and working with Laravel 5.x.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**Laravel**是PHP中最广泛使用的MVC框架之一，类似于Python和Ruby世界中的Django和Rails的架构。我们将通过配置我们的模型使用Laravel，Doctrine和MongoDB。本节假设Doctrine已安装并与Laravel
    5.x一起使用。'
- en: 'Doctrine entities are **Plain Old PHP Objects** (**POPO**) that, unlike **Eloquent**,
    Laravel''s default ORM doesn''t need to inherit from the `Model` class. Doctrine
    uses the **Data Mapper Pattern**, whereas Eloquent uses Active Record. Skipping
    the `get()` and `set()` methods, a simple class would be shown in the following
    way:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine实体是**Plain Old PHP Objects**（**POPO**），与**Eloquent**不同，Laravel的默认ORM不需要继承`Model`类。Doctrine使用**Data
    Mapper Pattern**，而Eloquent使用Active Record。跳过`get()`和`set()`方法，一个简单的类将如下所示：
- en: '[PRE42]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This POPO-based model uses annotations to define field types that need to be
    persisted in MongoDB. For example, `@ORM\Column(type="string")` defines a field
    in MongoDB with the `string` types `firstname` and `lastname` as the attribute
    names, in the respective lines.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基于POPO的模型使用注释来定义需要在MongoDB中持久化的字段类型。例如，`@ORM\Column(type="string")`定义了MongoDB中的一个字段，`string`类型的`firstname`和`lastname`作为属性名称，在相应的行中。
- en: 'There is a whole set of annotations available here: [https://doctrine2.readthedocs.io/en/latest/reference/annotations-reference.html](https://doctrine2.readthedocs.io/en/latest/reference/annotations-reference.html).'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一整套可用的注释：[https://doctrine2.readthedocs.io/en/latest/reference/annotations-reference.html](https://doctrine2.readthedocs.io/en/latest/reference/annotations-reference.html)。
- en: If we want to separate the POPO structure from annotations, we can also define
    them using YAML or XML instead of inlining them with annotations in our POPO model
    classes.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将POPO结构与注释分开，我们也可以使用YAML或XML来定义它们，而不是在我们的POPO模型类中使用注释。
- en: Inheritance with Doctrine
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Doctrine的继承
- en: 'Modeling one-to-one and one-to-many relationships can be done via annotations,
    YAML, or XML. Using annotations, we can define multiple embedded sub-documents
    within our document, as shown in the following example:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过注释、YAML或XML来建模一对一和一对多关系。使用注释，我们可以在我们的文档中定义多个嵌入的子文档，如下例所示：
- en: '[PRE43]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, a `User` document embeds many `phonenumbers`. `@EmbedOne()` will embed
    one sub-document to be used for modeling one-to-one relationships.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个`User`文档嵌入了许多`phonenumbers`。`@EmbedOne()`将嵌入一个子文档，用于建模一对一关系。
- en: 'Referencing is similar to embedding, as shown in the following example:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 引用与嵌入类似，如下例所示：
- en: '[PRE44]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`@ReferenceMany()` and `@ReferenceOne()` are used to model one-to-many and
    one-to-one relationships via referencing into a separate collection.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ReferenceMany()`和`@ReferenceOne()`用于通过引用到单独的集合来建模一对多和一对一关系。'
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about schema design for relational databases and
    MongoDB and how we can achieve the same goal starting from a different starting
    point.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关系数据库和MongoDB的模式设计，以及如何从不同的起点开始实现相同的目标。
- en: In MongoDB, we have to think about read and write ratios, the questions that
    our users will have in the most common cases, and cardinality among relationships.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中，我们必须考虑读写比例，用户在最常见情况下可能会遇到的问题，以及关系之间的基数。
- en: We learnt about atomic operations and how we can construct our queries so that
    we can have ACID properties without the overhead of transactions.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了关于原子操作以及如何构建查询，以便在没有事务开销的情况下具有ACID属性。
- en: We also learned about MongoDB data types, how they can be compared, and some
    special data types, such as the `ObjectId`, which can be used both by the database
    and to our own advantage.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解了MongoDB的数据类型，它们如何进行比较，以及一些特殊的数据类型，比如`ObjectId`，它可以被数据库和我们自己利用。
- en: Starting from modeling simple one-to-one relationships, we went through one-to-many
    and also many-to-many relationship modeling, without the need for an intermediate
    table, as we would do in a relational database, either using references or embedded
    documents.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 从建模简单的一对一关系开始，我们经历了一对多关系和多对多关系建模，而无需像在关系数据库中那样使用中间表，可以使用引用或嵌入文档。
- en: We learned how to model data for keyword searches, one of the features that
    most applications need to support in a web context.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何为关键字搜索建模数据，这是大多数应用程序在Web环境中需要支持的功能之一。
- en: Finally, we explored different use cases for using MongoDB with three of the
    most popular web programming languages. We saw examples using Ruby with the official
    driver and Mongoid ODM. Then we explored how to connect using Python with the
    official driver and PyMODM ODM, and, lastly, we worked through an example using
    PHP with the official driver and Doctrine ODM.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了在三种最流行的Web编程语言中使用MongoDB的不同用例。我们看到了使用官方驱动程序和Mongoid ODM的Ruby的示例。然后我们探讨了如何使用官方驱动程序和PyMODM
    ODM连接Python，最后，我们通过使用官方驱动程序和Doctrine ODM在PHP中的示例进行了工作。
- en: With all these languages (and many others), there are both official drivers
    offering support and full access functionality to the underlying database operations
    and also **object data modeling** frameworks for ease of modeling our data and
    rapid development.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有这些语言（以及许多其他语言），都有官方驱动程序提供支持和完全访问底层数据库操作功能，还有**对象数据建模**框架，用于轻松建模我们的数据和快速开发。
- en: In the next chapter, we will dive deeper into the MongoDB shell and the operations
    we can achieve using it. We will also master using the drivers for CRUD operations
    on our documents.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨MongoDB shell以及我们可以使用它实现的操作。我们还将掌握使用驱动程序对我们的文档进行CRUD操作。
