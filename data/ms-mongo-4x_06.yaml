- en: Advanced Querying
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级查询
- en: 'In the previous chapter, we learned how to use the mongo shell for scripting,
    administration, and developing in a secure way. In this chapter, we will dive
    deeper into using MongoDB with drivers and popular frameworks from Ruby, Python,
    and PHP: **Hypertext Preprocessor** (**PHP**).'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何以安全的方式使用mongo shell进行脚本编写、管理和开发。在本章中，我们将更深入地使用来自Ruby，Python和PHP的驱动程序和流行框架与MongoDB一起使用：**超文本预处理器**（**PHP**）。
- en: We will also show the best practices for using these languages and the variety
    of comparison and update operators that MongoDB supports on a database level,
    which are accessible through Ruby, Python, and PHP.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将展示使用这些语言的最佳实践以及MongoDB在数据库级别支持的各种比较和更新运算符，这些运算符可以通过Ruby，Python和PHP访问。
- en: 'In this chapter we will learn the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: MongoDB operations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB操作
- en: CRUD using Ruby, Mongoid, Python, PyMODM, PHP and Doctrine
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ruby，Mongoid，Python，PyMODM，PHP和Doctrine进行CRUD
- en: Comparison operators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较运算符
- en: Change streams
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改流
- en: MongoDB CRUD operations
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB CRUD操作
- en: In this section, we will cover CRUD operations using Ruby, Python, and PHP with
    the official MongoDB driver and some popular frameworks for each language, respectively.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分别使用官方MongoDB驱动程序和每种语言的一些流行框架，使用Ruby，Python和PHP进行CRUD操作。
- en: CRUD using the Ruby driver
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ruby驱动程序进行CRUD
- en: In [Chapter 3](e61d07bb-3244-4180-a77c-e8cde4be6189.xhtml), *MongoDB CRUD Operations*,
    we covered how to connect to MongoDB from Ruby, Python, and PHP using the drivers
    and ODM. In this chapter, we will explore `create`, `read`, `update`, and `delete`
    operations using the official drivers and the most commonly used ODM frameworks.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](e61d07bb-3244-4180-a77c-e8cde4be6189.xhtml)中，*MongoDB CRUD操作*，我们介绍了如何使用驱动程序和ODM从Ruby，Python和PHP连接到MongoDB。在本章中，我们将探索使用官方驱动程序和最常用的ODM框架进行`create`，`read`，`update`和`delete`操作。
- en: Creating documents
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建文档
- en: 'Using the process described in Chapter 2, *Schema Design and Data Modeling,*
    we assume that we have an `@collection` instance variable pointing to our `books`
    collection in a `mongo_book` database in the `127.0.0.1:27017` default database:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第2章中描述的过程，*模式设计和数据建模*，我们假设我们有一个`@collection`实例变量，指向`mongo_book`数据库中`127.0.0.1:27017`默认数据库中的`books`集合：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We insert a single document with our definition, as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们插入一个具有我们定义的单个文档，如下所示：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This can be performed with a single line of code as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过一行代码执行如下：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The resulting object is a `Mongo::Operation::Result` class with content that
    is similar to what we had in the shell, as shown in the following code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的对象是`Mongo::Operation::Result`类，其内容与我们在shell中看到的内容相似，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `n` is the number of affected documents; `1` means we inserted one object
    and `ok` means `1` (`true`).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`n`是受影响的文档数量；`1`表示我们插入了一个对象，`ok`表示`1`（`true`）。
- en: 'Creating multiple documents in one step is similar to this. For two documents
    with `isbn 102` and `103`, and using `insert_many` instead of `insert_one`, we
    have the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在一步中创建多个文档与此类似。对于具有`isbn 102`和`103`的两个文档，并且使用`insert_many`而不是`insert_one`，我们有以下代码：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The resulting object is now a `Mongo::BulkWrite::Result` class, meaning that
    the `BulkWrite` interface was used for improved performance.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的对象现在是`Mongo::BulkWrite::Result`类，这意味着使用了`BulkWrite`接口以提高性能。
- en: The main difference is that we now have an attribute, `inserted_ids,`, which
    will return `ObjectId` of the inserted objects from the `BSON::ObjectId` class.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于我们现在有一个属性`inserted_ids`，它将返回从`BSON::ObjectId`类中插入的对象的`ObjectId`。
- en: Read
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取
- en: 'Finding documents work in the same way as creating them, that is, at the collection
    level:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 查找文档的工作方式与创建它们的方式相同，即在集合级别：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Multiple search criteria can be chained and are equivalent to an `AND` operator
    in SQL:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可以链接多个搜索条件，并且相当于SQL中的`AND`运算符：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The mongo-ruby-driver API provides several query options to enhance queries;
    the most widely used query options are listed in the following table:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: mongo-ruby-driver API提供了几个查询选项来增强查询；最常用的查询选项列在以下表中：
- en: '| **Option** | **Description** |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **选项** | **描述** |'
- en: '| `allow_partial_results` | This is for use with sharded clusters. If a shard
    is down, it allows the query to return results from the shards that are up, potentially
    getting only a portion of the results. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `allow_partial_results` | 这是用于分片集群。如果一个分片关闭，它允许查询从打开的分片返回结果，可能只得到部分结果。'
- en: '| `batch_size(Integer)` | This can change the batch size that the cursor will
    fetch from MongoDB. This is done on each `GETMORE` operation (for example, by
    typing it on the mongo shell). |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `batch_size(Integer)` | 这可以改变游标从MongoDB获取的批量大小。这是在每个`GETMORE`操作（例如，在mongo
    shell上输入）上完成的。'
- en: '| `comment(String)` | With this command we can add a comment in our query for
    documentation reasons. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `comment(String)` | 使用此命令，我们可以为了文档目的在我们的查询中添加注释。 |'
- en: '| `hint(Hash)` | We can force usage of an index using `hint()`. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `hint(Hash)` | 我们可以使用`hint()`强制使用索引。 |'
- en: '| `limit(Integer)` | We can limit the result set to the number of documents
    specified by `Integer`. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `limit(Integer)` | 我们可以将结果集限制为`Integer`指定的文档数量。 |'
- en: '| `max_scan(Integer)` | We can limit the number of documents that will be scanned.
    This will return incomplete results and is useful if we are performing operations
    where we want to guarantee that they won''t take a long time, such as when we
    connect to our production database. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `max_scan(Integer)` | 我们可以限制将被扫描的文档数量。这将返回不完整的结果，并且在执行我们希望保证不会花费很长时间的操作时非常有用，例如当我们连接到我们的生产数据库时。'
- en: '| `no_cursor_timeout` | If we don''t specify this parameter, MongoDB will close
    any inactive cursor after 600 seconds. With this parameter our cursor will never
    be closed. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `no_cursor_timeout` | 如果我们不指定此参数，MongoDB将在600秒后关闭任何不活动的游标。使用此参数，我们的游标将永远不会关闭。
    |'
- en: '| `projection(Hash)` | We can use this parameter to fetch or exclude specific
    attributes from our results. This will reduce data transfer over the wire. An
    example of this can be`client[:books].find.projection(:price => 1)`. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `projection(Hash)` | 我们可以使用这个参数来获取或排除结果中的特定属性。这将减少通过网络的数据传输。例如，`client[:books].find.projection(:price
    => 1)`。 |'
- en: '| `read(Hash)` | We can specify a read preference to be applied only for this
    query:`client[:books].find.read(:mode => :secondary_preferred)`. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `read(Hash)` | 我们可以指定一个读取偏好，仅应用于此查询：`client[:books].find.read(:mode => :secondary_preferred)`。
    |'
- en: '| `show_disk_loc(Boolean)` | We should use this option if we want to find the
    actual location of our results on a disk. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `show_disk_loc(Boolean)` | 如果我们想要查找结果在磁盘上的实际位置，应该使用此选项。 |'
- en: '| `skip(Integer)` | This can be used to skip the specified number of documents.
    It''s useful for the pagination of results. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `skip(Integer)` | 这可以用于跳过指定数量的文档。对于结果的分页很有用。 |'
- en: '| `snapshot` | This can be used to execute our query in snapshot mode. This
    is useful for when we want a more stringent consistency. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `snapshot` | 这可以用于以快照模式执行我们的查询。当我们需要更严格的一致性时，这是很有用的。 |'
- en: '| `sort(Hash)` | We can use this to sort our results, for example,`client[:books].find.sort(:name
    => -1)`. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `sort(Hash)` | 我们可以使用这个来对结果进行排序，例如，`client[:books].find.sort(:name => -1)`。
    |'
- en: 'On top of the query options, mongo-ruby-driver provides some helper functions
    that can be chained at the method call level, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了查询选项之外，mongo-ruby-driver 还提供了一些辅助函数，可以在方法调用级别进行链接，如下所示：
- en: '`.count`: The total count for the preceding query'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.count`：前面查询的总计数'
- en: '`.distinct(:field_name)`: To distinguish between the results of the preceding
    query by `:field_name`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.distinct(:field_name)`：通过 `:field_name` 区分前面查询的结果'
- en: '`Find()` returns a cursor containing the result set that we can iterate using
    `.each` in Ruby like every other object:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Find()` 返回一个包含结果集的游标，我们可以像其他对象一样在 Ruby 中使用 `.each` 进行迭代：'
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output for our `books` collection is as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `books` 集合的输出如下：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Chaining operations in find()
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 find() 中链接操作
- en: '`find()`, by default, uses an `AND` operator to match multiple fields. If we
    want to use an `OR` operator, our query needs to be as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`find()` 默认使用 `AND` 运算符来匹配多个字段。如果我们想使用 `OR` 运算符，我们的查询需要如下所示：'
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can also use `$and` instead of `$or` in the previous example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们也可以使用 `$and` 而不是 `$or`：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This, of course, will return no results since no document can have both `isbn
    101` and `102`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这将不返回任何结果，因为没有文档可以同时具有 `isbn 101` 和 `102`。
- en: 'An interesting and hard bug to find is if we define the same key multiple times,
    such as in the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣且难以发现的 bug 是如果我们多次定义相同的键，就像以下代码中一样：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In comparison, the opposite order will cause the document with `isbn 101` to
    be returned:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 相反的顺序将导致返回带有 `isbn 101` 的文档：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is because in Ruby hashes, by default, all duplicated keys except for the
    last one are silently ignored. This may not happen in the simplistic form shown
    in the preceding example, but it is prone to happen if we create keys programmatically.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在 Ruby 哈希中，默认情况下，除了最后一个之外，所有重复的键都会被静默忽略。这可能不会发生在前面示例中所显示的简单形式中，但如果我们以编程方式创建键，这种情况很容易发生。
- en: Nested operations
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套操作
- en: 'Accessing embedded documents in mongo-ruby-driver is as simple as using the
    dot notation:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 mongo-ruby-driver 中访问嵌入式文档就像使用点表示法一样简单：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We need to enclose the key name in quotes (`''`) to access the embedded object
    just as we need it for operations starting with `$`, such as `'$set'`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要用引号 (`''`) 括起键名来访问嵌入对象，就像我们需要对以 `$` 开头的操作一样，比如 `'$set'`。
- en: Update
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新
- en: 'Updating documents using mongo-ruby-driver is chained to finding them. Using
    our example `books` collection, we can do the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 mongo-ruby-driver 更新文档是通过查找它们进行链接的。使用我们的示例 `books` 集合，我们可以执行以下操作：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This finds the document with `isbn 101` and changes its name to `Mastering MongoDB,
    2nd Edition`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将找到具有 `isbn 101` 的文档，并将其名称更改为 `Mastering MongoDB, 2nd Edition`。
- en: In a similar way to `update_one`, we can use `update_many` to update multiple
    documents retrieved via the first parameter of the method.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `update_one`，我们可以使用 `update_many` 来更新通过方法的第一个参数检索到的多个文档。
- en: If we don't use the `$set` operator, the contents of the document will be replaced
    by the new document.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不使用 `$set` 运算符，文档的内容将被新文档替换。
- en: 'Assuming Ruby version >=2.2, keys can be either quoted or unquoted; however,
    keys that start with `$` need to be quoted as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 Ruby 版本 >=2.2，键可以是带引号或不带引号的；但是，以 `$` 开头的键需要按如下方式带引号：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The resulting object of an update will contain information about the operation,
    including these methods:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的对象将包含有关操作的信息，包括以下方法：
- en: '`ok?`: A Boolean value that shows whether the operation was successful or not'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ok?`：一个布尔值，显示操作是否成功'
- en: '`matched_count`: The number of documents matching the query'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matched_count`：匹配查询的文档数量'
- en: '`modified_count`: The number of documents affected (updated)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modified_count`：受影响的文档数量（已更新）'
- en: '`upserted_count`: The number of documents upserted if the operation includes
    `$set`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upserted_count`：如果操作包括 `$set`，则插入的文档数量'
- en: '`upserted_id`: The unique `ObjectId` of the upserted document if there is one'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upserted_id`：如果有的话，插入文档的唯一 `ObjectId`'
- en: Updates that modify fields of a constant data size will be *in place*; this
    means that they won't move the document from its physical location on the disk.
    This includes operations such as `$inc` and `$set` on the `Integer` and `Date`
    fields.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 修改字段大小恒定的更新将是 *原地* 进行的；这意味着它们不会将文档从物理位置上移动。这包括对 `Integer` 和 `Date` 字段进行的操作，如
    `$inc` 和 `$set`。
- en: 'Updates that can increase the size of a document may result in the document
    being moved from its physical location on the disk to a new location at the end
    of the file. In this case, queries may miss or return the document multiple times.
    To avoid this, we can use `$snapshot: true` while querying.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '可能会导致文档大小增加的更新可能会导致文档从磁盘上的物理位置移动到文件末尾的新位置。在这种情况下，查询可能会错过或多次返回文档。为了避免这种情况，我们可以在查询时使用`$snapshot:
    true`。'
- en: Delete
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除
- en: Deleting documents work in a similar way to finding documents. We need to find
    documents and then apply the delete operation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 删除文档的工作方式与查找文档类似。我们需要找到文档，然后应用删除操作。
- en: 'For example, with our `books` collection used before, we can issue the following
    code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于我们之前使用的`books`集合，我们可以发出以下代码：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will delete a single document. In our case, since `isbn` is unique for
    every document, this is expected. If our `find()` clause had matched multiple
    documents, then `delete_one` would have deleted just the first one that `find()`
    returned, which may or may not have been what we wanted.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除单个文档。在我们的情况下，由于每个文档的`isbn`都是唯一的，这是预期的。如果我们的`find()`子句匹配了多个文档，那么`delete_one`将只删除`find()`返回的第一个文档，这可能是我们想要的，也可能不是。
- en: If we use `delete_one` with a query matching multiple documents, the results
    may be unexpected.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`delete_one`与匹配多个文档的查询，结果可能会出乎意料。
- en: 'If we want to delete all documents matching our `find()` query, we have to
    use `delete_many`, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要删除与我们的`find()`查询匹配的所有文档，我们必须使用`delete_many`，如下所示：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding example, we are deleting all books that have a price greater
    than or equal to `30`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们正在删除所有价格大于或等于`30`的书籍。
- en: Batch operations
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 批量操作
- en: 'We can use the `BulkWrite` API for batch operations. In our previous insert
    many documents example, this would be as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`BulkWrite` API进行批量操作。在我们之前插入多个文档的示例中，操作如下：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `BulkWrite` API can take the following parameters:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`BulkWrite` API可以接受以下参数：'
- en: '`insertOne`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insertOne`'
- en: '`updateOne`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateOne`'
- en: '`updateMany`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateMany`'
- en: '`replaceOne`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replaceOne`'
- en: '`deleteOne`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deleteOne`'
- en: '`deleteMany`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deleteMany`'
- en: One version of these commands will `insert`/`update`/`replace`/`delete` a single
    document even if the filter that we specify matches more than one document. In
    this case, it's important to have a filter that matches a single document to avoid
    unexpected behaviors.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令的一个版本将`insert`/`update`/`replace`/`delete`单个文档，即使我们指定的过滤器匹配多个文档。在这种情况下，为了避免意外行为，重要的是要有一个匹配单个文档的过滤器。
- en: 'It''s also possible, and a perfectly valid use case, to include several operations
    in the first argument of the `bulk_write` command. This allows us to issue commands
    in a sequence when we have operations that depend on each other and we want to
    batch them in a logical order according to our business logic. Any error will
    stop `ordered:true` batch writes and we will need to manually roll back our operations.
    A notable exception is `writeConcern` errors, for example, requesting a majority
    of our replica set members to acknowledge our write. In this case, batch writes
    will go through and we can observe the errors in the `writeConcernErrors` result
    field:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在`bulk_write`命令的第一个参数中包含多个操作也是可能的，也是一个完全有效的用例。这允许我们在有相互依赖的操作并且我们想要根据业务逻辑批量处理它们的情况下按照逻辑顺序发出命令。任何错误都将停止`ordered:true`批量写入，我们将需要手动回滚我们的操作。一个值得注意的例外是`writeConcern`错误，例如，请求我们的副本集成员中的大多数确认我们的写入。在这种情况下，批量写入将继续进行，我们可以在`writeConcernErrors`结果字段中观察到错误：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the previous example, we made sure that we deleted the original book before
    adding the new (and more expensive) edition of our `MongoDB for experts` book.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们确保在添加新的（更昂贵的）版本我们的`MongoDB for experts`书之前删除了原始书籍。
- en: '`BulkWrite` can batch up to 1,000 operations. If we have more than 1,000 underlying
    operations in our commands, these will be split into chunks of thousands. It is
    good practice to try to keep our write operations to a single batch if we can
    to avoid unexpected behavior.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`BulkWrite`可以批处理最多1,000个操作。如果我们的命令中有超过1,000个基础操作，这些操作将被分成数千个块。如果可能的话，最好尽量将写操作保持在一个批次中，以避免意外行为。'
- en: CRUD in Mongoid
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mongoid中的CRUD
- en: In this section, we will use Mongoid to perform `create`, `read`, `update`,
    and `delete` operations. All of this code is also available on GitHub at [https://github.com/agiamas/mastering-mongodb/tree/master/chapter_4](https://github.com/agiamas/mastering-mongodb/tree/master/chapter_4).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Mongoid执行`create`、`read`、`update`和`delete`操作。所有这些代码也可以在GitHub上找到：[https://github.com/agiamas/mastering-mongodb/tree/master/chapter_4](https://github.com/agiamas/mastering-mongodb/tree/master/chapter_4)。
- en: Read
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取
- en: Back in Chapter 2, *Schema Design and Data Modeling**,* we described how to
    install, connect, and set up models, including an inheritance to Mongoid. Here,
    we will go through the most common use cases of CRUD.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 回到第2章*模式设计和数据建模*中，我们描述了如何安装、连接和设置模型，包括对Mongoid的继承。在这里，我们将介绍CRUD的最常见用例。
- en: 'Finding documents is done using a DSL similar to **Active Record** (**AR**).
    As with AR using a relational database, Mongoid assigns a class to a MongoDB collection
    (table) and any object instance to a document (row from a relational database):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似于**Active Record**（**AR**）的DSL来查找文档。与使用关系数据库的AR一样，Mongoid将一个类分配给一个MongoDB集合（表），并将任何对象实例分配给一个文档（关系数据库中的行）：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will find the document by `ObjectId` and return the document with `isbn
    101`, as will the query by a name attribute:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过`ObjectId`查找文档并返回具有`isbn 101`的文档，与通过名称属性进行的查询一样：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In a similar fashion to the dynamically generated AR queries by an attribute,
    we can use the helper method:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与通过属性动态生成的AR查询类似，我们可以使用辅助方法：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This queries by attribute name, equivalent to the previous query.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过属性名称查询，相当于之前的查询。
- en: 'We should enable `QueryCache` to avoid hitting the database for the same query
    multiple times, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该启用`QueryCache`以避免多次命中数据库相同的查询，如下所示：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This can be added in any code block that we want to enable, or in the initializer
    for Mongoid.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以添加在我们想要启用的任何代码块中，或者在Mongoid的初始化程序中。
- en: Scoping queries
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围查询
- en: 'We can scope queries in Mongoid using class methods, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类方法在Mongoid中范围查询，如下所示：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then we will use this query:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将使用这个查询：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It will query for books with a price greater than 20.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 它将查询价格大于20的书籍。
- en: Create, update, and delete
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建、更新和删除
- en: 'The Ruby interface for creating documents is similar to active record:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建文档的Ruby接口类似于活动记录：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will return an error if the creation fails.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果创建失败，这将返回错误。
- en: 'We can use the bang version to force an exception to be raised if saving the
    document fails:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用感叹号版本来强制引发异常，如果保存文档失败：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `BulkWrite` API is not supported as of Mongoid version 6.x. The workaround
    is to use the mongo-ruby-driver API, which will not use the `mongoid.yml` configuration
    or custom validations. Otherwise, you can use `insert_many([array_of_documents])`,
    which will insert the documents one by one.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 截至Mongoid版本6.x，不支持`BulkWrite` API。解决方法是使用mongo-ruby-driver API，它不会使用`mongoid.yml`配置或自定义验证。否则，您可以使用`insert_many([array_of_documents])`，它将逐个插入文档。
- en: 'To update documents, we can use `update` or `update_all`. Using `update` will
    update only the first document retrieved by the query part, whereas `update_all`
    will update all of them:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新文档，我们可以使用`update`或`update_all`。使用`update`将仅更新查询部分检索到的第一个文档，而`update_all`将更新所有文档：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Deleting a document is similar to creating it, providing `delete` to skip callbacks,
    and `destroy` if we want to execute any available callbacks in the affected document.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 删除文档类似于创建文档，提供`delete`以跳过回调，以及如果我们想要执行受影响文档中的任何可用回调，则使用`destroy`。
- en: '`delete_all` and `destroy_all` are convenient methods for multiple documents.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete_all`和`destroy_all`是用于多个文档的便捷方法。'
- en: '`destroy_all` should be avoided if possible, as it will load all documents
    into the memory to execute callbacks and thus can be memory-intensive.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，应该避免使用`destroy_all`，因为它将加载所有文档到内存中以执行回调，因此可能会占用大量内存。
- en: CRUD using the Python driver
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python驱动程序进行CRUD
- en: PyMongo is the officially supported driver for Python by MongoDB. In this section,
    we will use PyMongo to `create`, `read`, `update`, and `delete` documents in MongoDB.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: PyMongo是MongoDB官方支持的Python驱动程序。在本节中，我们将使用PyMongo在MongoDB中创建、读取、更新和删除文档。
- en: Creating and deleting
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和删除
- en: 'The Python driver provides methods for CRUD just like Ruby and PHP. Following
    on from Chapter 2, *Schema Design and Data Modeling,* and the `books` variable
    that points to our `books` collection, we will write the following code block:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Python驱动程序提供了与Ruby和PHP一样的CRUD方法。在第2章“模式设计和数据建模”之后，指向我们的“books”集合的“books”变量，我们将编写以下代码块：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the previous example, we used `insert_one()` to insert a single document,
    which we can define using the Python dictionary notation; we can then query it
    for all documents in the collection.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用`insert_one()`来插入单个文档，我们可以使用Python字典表示法来定义它；然后我们可以查询它以获取集合中的所有文档。
- en: 'The resulting object for `insert_one` and `insert_many` has two fields of interest:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert_one`的结果对象和`insert_many`的结果对象有两个感兴趣的字段：'
- en: '`Acknowledged`: A Boolean that is `true` if the insert has succeeded and `false`
    if it hasn''t, or if write concern is `0` (fire and forget write).'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Acknowledged`：如果插入成功则为`true`，如果插入失败则为`false`，或者写关注为`0`（即插即忘写）。'
- en: '`inserted_id` for `insert_one`: The `ObjectId` of the written document and
    `inserted_ids` for `insert_many`. The array of `ObjectIds` of the written documents.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inserted_id`对于`insert_one`：写入文档的`ObjectId`和`inserted_ids`对于`insert_many`：写入文档的`ObjectIds`数组。'
- en: 'We used the `pprint` library to pretty-print the `find()` results. The built-in
    way to iterate through the result set is by using the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`pprint`库对`find()`结果进行漂亮打印。通过使用以下代码来迭代结果集的内置方式：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Deleting documents work in a similar to creating them. We can use `delete_one`
    to delete the first instance or `delete_many` to delete all instances of the matched
    query:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 删除文档的工作方式与创建它们类似。我们可以使用`delete_one`来删除第一个实例，或者使用`delete_many`来删除匹配查询的所有实例：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `deleted_count` instance tells us how many documents were deleted; in our
    case, it is `1`, even though we used the `delete_many` method.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleted_count`实例告诉我们删除了多少个文档；在我们的案例中，它是`1`，即使我们使用了`delete_many`方法。'
- en: To delete all documents from a collection, we can pass in the empty document
    `{}`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要从集合中删除所有文档，我们可以传入空文档`{}`。
- en: 'To drop a collection, we can use `drop()`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除集合，我们可以使用`drop()`：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Finding documents
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找文档
- en: 'To find documents based on top-level attributes, we can simply use a dictionary:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据顶级属性查找文档，我们可以简单地使用字典：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To find documents in an embedded document, we can use the dot notation. In
    the following example, we use `meta.authors` to access the `authors` embedded
    document inside the `meta` document:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要在嵌入文档中查找文档，我们可以使用点表示法。在下面的示例中，我们使用`meta.authors`来访问`meta`文档内的`authors`嵌入文档：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this example, we used a regular expression to match `aLEx`, which is case
    insensitive, in every document that the string is mentioned in the `meta.authors`
    embedded document. PyMongo uses this notation for regular expression queries,
    called the `$regex` notation in MongoDB documentation. The second parameter is
    the options parameter for `$regex`, which we will explain in detail in the *Using
    regular expressions* section later in this chapter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用正则表达式来匹配`aLEx`，它是不区分大小写的，在`meta.authors`嵌入文档中提到字符串的每个文档中。PyMongo在MongoDB文档中称之为正则表达式查询的`$regex`表示法。第二个参数是`$regex`的选项参数，我们将在本章后面的“使用正则表达式”部分详细解释。
- en: 'Comparison operators are also supported, and a full list of these are given
    in the *Comparison operators* section, which can be seen later in this chapter:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 还支持比较运算符，完整列表将在本章后面的“比较运算符”部分中给出：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Adding multiple dictionaries in our query results in a logical `AND` query:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的查询中添加多个字典会导致逻辑`AND`查询：
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For books having both `isbn=101` and `name=Mastering MongoDB`, to use logical
    operators such as `$or` and `$and`, we have to use the following syntax:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于同时具有`isbn=101`和`name=Mastering MongoDB`的书籍，要使用`$or`和`$and`等逻辑运算符，我们必须使用以下语法：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For books having an `isbn` of `101` or `102`, if we want to combine `AND` and
    `OR` operators, we have to use the `$and` operator, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有`isbn`为`101`或`102`的书籍，如果我们想要结合`AND`和`OR`运算符，我们必须使用`$and`运算符，如下所示：
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For a result of `OR` between two queries, consider the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个查询之间的`OR`结果，请考虑以下内容：
- en: The first query is asking for documents that have `isbn=101 AND name=Mastering
    MongoDB`
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个查询是要求具有`isbn=101 AND name=Mastering MongoDB`的文档
- en: The second query is asking for documents that have `isbn=102 AND name=MongoDB`
    in 7 years.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个查询是要求在7年内具有`isbn=102 AND name=MongoDB`的文档。
- en: The result is the union of these two datasets
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果是这两个数据集的并集
- en: Updating documents
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新文档
- en: In the following code block, you can see an example of updating a single document
    using the `update_one` helper method.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，您可以看到使用`update_one`辅助方法更新单个文档的示例。
- en: 'This operation matches one document in the search phase and modifies one document
    based on the operation to be applied to the matched documents:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作在搜索阶段匹配一个文档，并根据要应用于匹配文档的操作修改一个文档：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In a similar way to inserting documents, when updating documents, we can use
    `update_one` or `update_many`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于插入文档时，更新文档时，我们可以使用`update_one`或`update_many`：
- en: The first argument here is the filter document for matching the documents that
    will be updated
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里的第一个参数是匹配将要更新的文档的过滤文档
- en: The second argument is the operation to be applied to the matched documents
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是要应用于匹配文档的操作
- en: The third (optional) argument is to use `upsert=false` (the default) or `true`,
    which is used to create a new document if it's not found
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个（可选）参数是使用`upsert=false`（默认值）或`true`，用于在找不到文档时创建新文档
- en: Another interesting argument is `bypass_document_validation=false` (the default)
    or `true`, which is optional. This will ignore validations (if there are any)
    for the documents in the collection.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的参数是`bypass_document_validation=false`（默认值）或`true`，这是可选的。这将忽略集合中文档的验证（如果有的话）。
- en: The resulting object will have `matched_count` for the number of documents that
    matched the filter query, and `modified_count` for the number of documents that
    were affected by the `update` part of the query.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 结果对象将具有`matched_count`，表示匹配过滤查询的文档数量，以及`modified_count`，表示受`update`部分影响的文档数量。
- en: In our example, we are setting `price=100` for the first book with `isbn=101`
    through the `$set` update operator. A list of all update operators is displayed
    in the *Update operators* section later in this chapter.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们通过`$set`更新运算符为具有`isbn=101`的第一本书设置`price=100`。所有更新运算符的列表将在本章后面的*更新运算符*部分中显示。
- en: If we don't use an update operator as the second argument, the contents of the
    matched document will be entirely replaced by the new document.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不使用更新运算符作为第二个参数，匹配文档的内容将完全被新文档替换。
- en: CRUD using PyMODM
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PyMODM进行CRUD
- en: PyMODM is a core ODM that provides simple and extensible functionality. It is
    developed and maintained by MongoDB's engineers who get fast updates and support
    for the latest stable version of MongoDB available.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: PyMODM是一个核心ODM，提供简单且可扩展的功能。它由MongoDB的工程师开发和维护，他们可以获得最新稳定版本的快速更新和支持。
- en: In Chapter 2, *Schema Design and Data Modeling**,* we explored how to define
    different models and connect to MongoDB. CRUD when using PyMODM, as with every
    ODM, is simpler than when using low-level drivers.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章*模式设计和数据建模*中，我们探讨了如何定义不同的模型并连接到MongoDB。使用PyMODM进行CRUD，与使用低级驱动程序相比，更简单。
- en: Creating documents
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建文档
- en: 'A new `user` object, as defined in Chapter 2, *Schema Design and Data Modeling,*
    can be created with a single line:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用单行代码创建一个新的`user`对象，如第2章*模式设计和数据建模*中所定义的：
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this example, we used positional arguments in the same order that they were
    defined in the `user` model to assign values to the `user` model attributes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们按照`user`模型中定义的顺序使用位置参数来为`user`模型属性赋值。
- en: 'We can also use keyword arguments or a mix of both, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用关键字参数或两者的混合，如下所示：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Bulk saving can be done by passing in an array of users to `bulk_create()`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将用户数组传递给`bulk_create()`来进行批量保存：
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Updating documents
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新文档
- en: 'We can modify a document by directly accessing the attributes and calling `save()` again:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过直接访问属性并再次调用`save()`来修改文档：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If we want to update one or more documents, we have to use `raw()` to filter
    out the documents that will be affected and chain `update()` to set the new values:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要更新一个或多个文档，我们必须使用`raw()`来过滤将受影响的文档，并链接`update()`来设置新值：
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the preceding example, we search for all `User` documents that have a first
    name and set a new field, `updated_at`, to the current timestamp. The result of
    the `raw()` method is `QuerySet`, a class used in PyMODM to handle queries and
    work with documents in bulk.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们搜索所有具有名字的`User`文档，并设置一个新字段`updated_at`为当前时间戳。`raw()`方法的结果是`QuerySet`，这是PyMODM中用于处理查询和批量处理文档的类。
- en: Deleting documents
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除文档
- en: 'Deleting an API is similar to updating it – by using `QuerySet` to find the
    affected documents and then chaining on a `.delete()` method to delete them:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 删除API与更新API类似-通过使用`QuerySet`查找受影响的文档，然后链接`.delete()`方法来删除它们：
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `BulkWrite` API is still not supported at the time of writing this book
    (December, 2018) and the relevant ticket, PYMODM-43, is open. Methods such as
    `bulk_create()` will, under the hood, issue multiple commands to the database.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时（2018年12月），`BulkWrite`API仍不受支持，相关的票号为PYMODM-43。例如`bulk_create()`方法将在幕后向数据库发出多个命令。
- en: Querying documents
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询文档
- en: Querying is done using `QuerySet`, as described before the `update` and `delete`
    operations.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 查询是使用`QuerySet`进行的，如在`update`和`delete`操作之前所述。
- en: 'Some convenience methods available include the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一些可用的便利方法包括以下内容：
- en: '`all()`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all()`'
- en: '`count()`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count()`'
- en: '`first()`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first()`'
- en: '`exclude(*fields)` to exclude some fields from the result'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exclude(*fields)` 从结果中排除一些字段'
- en: '`only(*fields)` to include only some fields in the result (this can be chained
    for a union of fields)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`only(*fields)` 只包括结果中的一些字段（可以链接以获取字段的并集）'
- en: '``limit(limit)``'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '``limit(limit)``'
- en: '`order_by(ordering)`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`order_by(ordering)`'
- en: '`reverse()` if we want to reverse the `order_by()` order'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reverse()` 如果我们想要反转`order_by()`的顺序'
- en: '`skip(number)`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skip(number)`'
- en: '`values()` to return Python dict instances instead of model instances'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values()` 返回Python字典实例而不是模型实例'
- en: By using `raw()`, we can use the same queries that we described in the previous
    PyMongo section for querying and still exploit the flexibility and convenience
    methods provided by the ODM layer.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`raw()`，我们可以使用与前面PyMongo部分中描述的相同查询，同时利用ODM层提供的灵活性和便利方法。
- en: CRUD using the PHP driver
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PHP驱动程序进行CRUD
- en: In PHP, there is a new driver called `mongo-php-library` that should be used
    instead of the deprecated MongoClient. The overall architecture was explained
    in Chapter 2, *Schema Design and Data Modeling*. Here, we will cover more details
    of the API and how we can perform CRUD operations using it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，有一个名为`mongo-php-library`的新驱动程序，应该代替已弃用的MongoClient。总体架构在第2章*模式设计和数据建模*中有解释。在这里，我们将介绍API的更多细节以及如何使用它执行CRUD操作。
- en: Creating and deleting
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和删除
- en: 'The following command will insert a single `$document` that contains an array
    of two key/value pairs, with the key names of `isbn` and `name`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将插入一个包含两个键/值对数组的单个`$document`：
- en: '[PRE47]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The output from the `var_dump($result)` command is shown as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`var_dump($result)`命令的输出如下所示：'
- en: '[PRE48]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This rather lengthy output contains all the information that we may need. We
    can get the `ObjectId` of the document inserted; the number of `inserted`, `matched`,
    `modified`, `removed`, and `upserted` documents by fields prefixed with `n`; and
    information about `writeError` or `writeConcernError`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相当冗长的输出包含了我们可能需要的所有信息。我们可以获取插入文档的`ObjectId`；通过以`n`为前缀的字段获取`inserted`，`matched`，`modified`，`removed`和`upserted`文档的数量；以及关于`writeError`或`writeConcernError`的信息。
- en: 'There are also convenience methods in the `$result` object if we want to get
    the information:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要获取信息，`$result`对象中还有一些便利方法：
- en: '`$result->getInsertedCount()`: To get the number of inserted objects'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$result->getInsertedCount()`: 获取插入对象的数量'
- en: '`$result->getInsertedId()`: To get the `ObjectId` of the inserted document'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$result->getInsertedId()`: 获取插入文档的`ObjectId`'
- en: 'We can also use the `->insertMany()` method to insert many documents at once,
    as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`->insertMany()`方法一次插入多个文档，如下所示：
- en: '[PRE49]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The result can be seen as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '[PRE50]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Again, `$result->getInsertedCount()` will return `2`, whereas `$result->getInsertedIds()`
    will return an array with the two newly-created `ObjectIds`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`$result->getInsertedCount()`将返回`2`，而`$result->getInsertedIds()`将返回一个包含两个新创建的`ObjectIds`的数组：
- en: '[PRE51]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Deleting documents is a similar process to inserting documents, but uses the `deleteOne()`
    and `deleteMany()` methods instead; an example of `deleteMany()` is shown as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 删除文档与插入文档类似，但是使用`deleteOne()`和`deleteMany()`方法；`deleteMany()`的示例如下所示：
- en: '[PRE52]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The following code block shows the output:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块显示了输出：
- en: '[PRE53]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this example, we used `->getDeletedCount()` to get the number of affected
    documents, which is printed in the last line of the output.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`->getDeletedCount()`来获取受影响文档的数量，这个数量在输出的最后一行打印出来。
- en: BulkWrite
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BulkWrite
- en: 'The new PHP driver supports the `BulkWrite` interface to minimize network calls
    to MongoDB:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 新的PHP驱动程序支持`BulkWrite`接口，以最小化对MongoDB的网络调用：
- en: '[PRE54]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The result can be seen as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '[PRE55]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding example, we executed two inserts, one `update`, and a third
    `insert` in an ordered fashion. The `WriteResult` object contains a total of three
    inserted documents and one modified document.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们按顺序执行了两次插入，一次更新和第三次插入。`WriteResult`对象包含了总共三个插入文档和一个修改文档。
- en: The main difference compared to simple create/delete queries is that `executeBulkWrite()`
    is a method of the `MongoDB\Driver\Manager` class, which we instantiate on the
    first line.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 与简单的创建/删除查询相比的主要区别是，`executeBulkWrite()`是`MongoDB\Driver\Manager`类的一个方法，我们在第一行实例化它。
- en: Read
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取
- en: 'Querying an interface is similar to inserting and deleting, with the `findOne()`
    and `find()` methods used to retrieve the first result or all results of a query:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 查询接口类似于插入和删除，使用`findOne()`和`find()`方法来检索查询的第一个结果或所有结果：
- en: '[PRE56]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In the second example, we are using a regular expression to search for a key
    name with the value, `mongo` (which is case insensitive).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，我们使用正则表达式搜索具有值`mongo`（不区分大小写）的键名。
- en: 'Embedded documents can be queried using the `.` notation, as with the other
    languages that we examined earlier in this chapter:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.`符号可以查询嵌入文档，就像我们在本章前面检查的其他语言一样：
- en: '[PRE57]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We do this to query for a `price` embedded document inside the meta key field.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是为了查询`meta`键字段内嵌的`price`文档。
- en: 'Similarly to Ruby and Python, in PHP, we can query using comparison operators,
    as shown in the following code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 与Ruby和Python类似，在PHP中，我们可以使用比较运算符进行查询，如下面的代码所示：
- en: '[PRE58]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: A complete list of comparison operators supported in the PHP driver is available
    at the end of this chapter.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: PHP驱动程序支持的比较运算符的完整列表可在本章末尾找到。
- en: 'Querying with multiple key-value pairs is an implicit `AND`, whereas queries
    using `$or`, `$in`, `$nin`, or `AND` (`$and`) combined with `$or` can be achieved
    with nested queries:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个键值对进行查询是隐式的`AND`，而使用`$or`，`$in`，`$nin`或`AND`（`$and`）与`$or`组合的查询可以通过嵌套查询实现：
- en: '[PRE59]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This finds documents that have `price>=60 OR price<=20`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这将找到`price>=60 OR price<=20`的文档。
- en: Updating documents
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新文档
- en: Updating documents has a similar interface with the `->updateOne() OR ->updateMany()`
    method.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 更新文档与`->updateOne() OR ->updateMany()`方法具有类似的接口。
- en: The first parameter is the query used to find documents and the second one will
    update our documents.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是用于查找文档的查询，第二个参数将更新我们的文档。
- en: 'We can use any of the update operators explained at the end of this chapter
    to update in place, or specify a new document to completely replace the document
    in the query:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用本章末尾解释的任何更新操作符来进行原地更新，或者指定一个新文档来完全替换查询中的文档：
- en: '[PRE60]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We can use single quotes or double quotes for key names, but if we have special
    operators starting with `$`, we need to use single quotes. We can use `array(
    "key" => "value" )` or `["key" => "value"]`. We prefer the more explicit `array()`
    notation in this book.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用单引号或双引号作为键名，但如果我们有以`$`开头的特殊操作符，我们需要使用单引号。我们可以使用`array( "key" => "value"
    )`或`["key" => "value"]`。在本书中，我们更喜欢更明确的`array()`表示法。
- en: The `->getMatchedCount()` and `->getModifiedCount()` methods will return the
    number of documents matched in the query part or the ones modified from the query.
    If the new value is the same as the existing value of a document, it will not
    be counted as modified.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`->getMatchedCount()`和`->getModifiedCount()`方法将返回查询部分匹配的文档数量或从查询中修改的文档数量。如果新值与文档的现有值相同，则不会计为修改。'
- en: CRUD using Doctrine
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Doctrine进行CRUD
- en: Following on from our Doctrine example in Chapter 2, *Schema Design and Data
    Modeling*, we will work on these models for CRUD operations.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们在第2章*模式设计和数据建模*中的Doctrine示例，我们将对这些模型进行CRUD操作。
- en: Creating, updating, and deleting
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建、更新和删除
- en: 'Creating documents is a two-step process. First, we create our document and
    set the attribute values:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 创建文档是一个两步过程。首先，我们创建我们的文档并设置属性值：
- en: '[PRE61]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Following this, we ask Doctrine to save `$book` in the next `flush()` call:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们要求Doctrine在下一次`flush()`调用中保存`$book`：
- en: '[PRE62]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can force saving by manually calling `flush()`, as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过手动调用`flush()`来强制保存，如下所示：
- en: '[PRE63]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In this example, `$dm` is a `DocumentManager` object that we use to connect
    to our MongoDB instance, as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`$dm`是一个`DocumentManager`对象，我们用它来连接到我们的MongoDB实例，如下所示：
- en: '[PRE64]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Updating a document is as easy as assigning values to the attributes:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 更新文档就像给属性赋值一样简单：
- en: '[PRE65]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This will save our `MongoDB with Doctrine` book with the new price of `39`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以新价格`39`保存我们的`MongoDB with Doctrine`书。
- en: Updating documents in place uses the `QueryBuilder` interface.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在原地更新文档时使用`QueryBuilder`接口。
- en: 'Doctrine provides several helper methods around atomic updates, listed as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine提供了几个围绕原子更新的辅助方法，列举如下：
- en: '`set($name, $value, $atomic = true)`'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set($name, $value, $atomic = true)`'
- en: '`setNewObj($newObj)`'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setNewObj($newObj)`'
- en: '`inc($name, $value)`'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inc($name, $value)`'
- en: '`unsetField($field)`'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsetField($field)`'
- en: '`push($field, $value)`'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push($field, $value)`'
- en: '`pushAll($field, array $valueArray)`'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pushAll($field, array $valueArray)`'
- en: '`addToSet($field, $value)`'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addToSet($field, $value)`'
- en: '`addManyToSet($field, array $values)`'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addManyToSet($field, array $values)`'
- en: '`popFirst($field)`'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`popFirst($field)`'
- en: '`popLast($field)`'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`popLast($field)`'
- en: '`pull($field, $value)`'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pull($field, $value)`'
- en: '`pullAll($field, array $valueArray)`'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pullAll($field, array $valueArray)`'
- en: '`update` will, by default, update the first document found by the query. If
    we want to change multiple documents, we need to use `->updateMany()`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`默认会更新查询找到的第一个文档。如果我们想要更改多个文档，我们需要使用`->updateMany()`：'
- en: '[PRE66]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In the preceding example, we are setting the price of the book with `name='MongoDB
    with Doctrine'` to be `69`. The list of comparison operators in Doctrine is available
    in the following *Read*  section.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们将书名为`'MongoDB with Doctrine'`的书的价格设置为`69`。Doctrine中的比较运算符列表在以下*读取*部分中可用。
- en: We can chain multiple comparison operators, resulting in an `AND` query and
    also multiple helper methods, resulting in updates to several fields.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以链接多个比较运算符，得到一个`AND`查询，也可以链接多个辅助方法，得到对多个字段的更新。
- en: 'Deleting a document is similar to creating it, as demonstrated in the following
    code block:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 删除文档与创建文档类似，如下面的代码块所示：
- en: '[PRE67]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Removing multiple documents is best done using the `QueryBuilder` interface,
    which we will explore further in the following section:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 最好使用`QueryBuilder`接口来删除多个文档，我们将在下一节中进一步探讨：
- en: '[PRE68]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Read
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取
- en: 'Doctrine provides a `QueryBuilder` interface to build queries for MongoDB.
    Given that we have defined our models as described in Chapter 2, *Schema Design
    and Data Modeling**,* we can do this to obtain an instance of a `QueryBuilder` interface
    named `$db`, get a default find-all query, and execute it, as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine为MongoDB提供了一个`QueryBuilder`接口来构建查询。鉴于我们已经在第2章*模式设计和数据建模*中描述了我们的模型，我们可以这样做来获取一个名为`$db`的`QueryBuilder`接口的实例，获取默认的查找所有查询，并执行它，如下所示：
- en: '[PRE69]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `$books` variable now contains an iterable lazy data-loading cursor over
    our result set.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`$books`变量现在包含了一个可迭代的懒加载数据加载游标，用于遍历我们的结果集。'
- en: Using `$qb->eagerCursor(true)`; over the `QueryBuilder` object will return an
    eager cursor, fetching all data from MongoDB as soon as we start iterating our
    results.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在`QueryBuilder`对象上使用`$qb->eagerCursor(true)`将返回一个急切的游标，一旦我们开始遍历结果，就会从MongoDB中获取所有数据。
- en: 'Some helper methods for querying are listed here:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了一些用于查询的辅助方法：
- en: '`->getSingleResult()`: This is equivalent to `findOne()`.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->getSingleResult()`: 这相当于`findOne()`。'
- en: '`->select(''name'')`: This returns only the values for the `''key''` attribute
    from our `books` collection. `ObjectId` will always be returned.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->select(''name'')`: 这将仅返回我们的`books`集合中`''key''`属性的值。`ObjectId`将始终被返回。'
- en: '`->hint(''book_name_idx'')`: This forces the query to use this index. We''ll
    see more about indexes in [Chapter 7](afc0e040-c29c-4520-8daa-30a475ca9ae6.xhtml),
    *Indexing*.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->hint(''book_name_idx'')`: 强制查询使用此索引。我们将在[第7章](afc0e040-c29c-4520-8daa-30a475ca9ae6.xhtml)
    *索引*中更多地了解索引。'
- en: '`->distinct(''name'')`: This returns distinct results by name.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->distinct(''name'')`: 这将按名称返回不同的结果。'
- en: '`->limit(10)`: This returns the first `10` results.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->limit(10)`: 这将返回前`10`个结果。'
- en: '`->sort(''name'', ''desc'')`: This sorts by name (such as `desc` or `asc`).'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->sort(''name'', ''desc'')`: 这将按名称排序（如`desc`或`asc`）。'
- en: Doctrine uses the concept of hydration when fetching documents from MongoDB.
    Hydration defines the query's result schema. We can, for example, configure hydration
    to return a collection of objects, a single scalar value, or an array of arrays
    representing different records. Using an identity map, it will cache MongoDB results
    in memory and consult this map before hitting the database. Disabling hydration
    can be done per query by using `->hydration(false)`, or globally using the configuration
    as explained in Chapter 2, *Schema Design and Data Modeling*.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当从MongoDB获取文档时，Doctrine使用了水合概念。水合定义了查询的结果模式。例如，我们可以配置水合以返回对象集合、单个标量值或表示不同记录的数组数组。使用身份映射，它将在内存中缓存MongoDB结果，并在访问数据库之前查询此映射。通过使用`->hydration(false)`可以在每个查询中禁用水合，或者可以在全局范围内使用第2章*模式设计和数据建模*中解释的配置。
- en: We can also force Doctrine to refresh data in the identity map for a query from
    MongoDB using `->refresh()` on `$qb`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过在`$qb`上使用`->refresh()`来强制Doctrine从MongoDB中的查询刷新身份映射中的数据。
- en: 'The comparison operators that we can use with Doctrine are as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的比较运算符如下：
- en: '`where($javascript)`'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`where($javascript)`'
- en: '`in($values)`'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in($values)`'
- en: '`notIn($values)`'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notIn($values)`'
- en: '`equals($value)`'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equals($value)`'
- en: '`notEqual($value)`'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notEqual($value)`'
- en: '`gt($value)`'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gt($value)`'
- en: '`gte($value)`'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gte($value)`'
- en: '`lt($value)`'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lt($value)`'
- en: '`lte($value)`'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lte($value)`'
- en: '`range($start, $end)`'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range($start, $end)`'
- en: '`size($size)`'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size($size)`'
- en: '`exists($bool)`'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exists($bool)`'
- en: '`type($type)`'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type($type)`'
- en: '`all($values)`'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all($values)`'
- en: '`mod($mod)`'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mod($mod)`'
- en: '`addOr($expr)`'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addOr($expr)`'
- en: '`addAnd($expr)`'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addAnd($expr)`'
- en: '`references($document)`'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`references($document)`'
- en: '`includesReferenceTo($document)`'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`includesReferenceTo($document)`'
- en: 'Consider the following query as an example:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下查询作为示例：
- en: '[PRE70]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This will return all books whose price is less than 30.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回所有价格低于30的书籍。
- en: '`addAnd()` may seem redundant since chaining multiple query expressions in
    Doctrine is implicitly `AND`, but it is useful if we want to do `AND ( (A OR B),
    (C OR D) )` where `A`, `B`, `C`, and `D` are standalone expressions.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`addAnd()`可能看起来多余，因为在Doctrine中链接多个查询表达式隐式是`AND`，但如果我们想要执行`AND ( (A OR B), (C
    OR D) )`，其中`A`、`B`、`C`和`D`是独立的表达式，它是有用的。'
- en: 'To nest multiple `OR` operators with an external `AND` query, and in other
    equally complex cases, the nested `ORs` need to be evaluated as expressions using
    `->expr()`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 要嵌套多个`OR`运算符与外部`AND`查询，以及其他同样复杂的情况，需要使用`->expr()`将嵌套的`OR`作为表达式进行评估：
- en: '[PRE71]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`$expression` is a standalone expression that can be used with `$qb->addOr($expression)`
    and similarly with `addAnd()`.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`$expression`是一个独立的表达式，可以与`$qb->addOr($expression)`一起使用，类似地使用`addAnd()`。'
- en: Best practices
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Some best practices for using Doctrine with MongoDB are as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Doctrine与MongoDB的一些最佳实践如下：
- en: Don't use unnecessary cascading.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用不必要的级联。
- en: Don't use unnecessary life cycle events.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用不必要的生命周期事件。
- en: Don't use special characters such as non-ASCII ones in class, field, table,
    or column names, as Doctrine is not Unicode-safe yet.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在类、字段、表或列名称中使用特殊字符，因为Doctrine目前不支持Unicode。
- en: Initialize collection references in the model's constructor.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模型的构造函数中初始化集合引用。
- en: Constrain relationships between objects as much as possible. Avoid bidirectional
    associations between models and eliminate the ones that are not needed. This helps
    with performance, loose coupling, and produces simpler and more easily maintainable
    code.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能限制对象之间的关系。避免模型之间的双向关联，并消除不需要的关联。这有助于性能、松散耦合，并产生更简单、更易维护的代码。
- en: Comparison operators
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较运算符
- en: 'The following is a list of all comparison operators that MongoDB supports:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是MongoDB支持的所有比较运算符的列表：
- en: '| **Name** | **Description** |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '**名称** | **描述**'
- en: '| `$eq` | Matches values that are equal to a specified value |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '`$eq` | 匹配等于指定值的值'
- en: '| `$gt` | Matches values that are greater than a specified value |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '`$gt` | 匹配大于指定值的值'
- en: '| `$gte` | Matches values that are greater than or equal to the specified value
    |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '`$gte` | 匹配大于或等于指定值的值'
- en: '| `$lt` | Matches values that are less than the specified value |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '`$lt` | 匹配小于指定值的值'
- en: '| `$lte` | Matches values that are less than or equal to the specified value
    |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '`$lt` | 匹配小于指定值的值'
- en: '| `$ne` | Matches all values that are not equal to the specified value |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '`$ne` | 匹配所有不等于指定值的值'
- en: '| `$in` | Matches any of the values specified in an array |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '`$in` | 匹配数组中指定的任何值'
- en: '| `$nin` | Matches none of the values specified in an array |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '`$nin` | 匹配数组中未指定的值'
- en: Update operators
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新运算符
- en: 'The following is a list of all update operators that MongoDB supports:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是MongoDB支持的所有更新运算符的列表：
- en: '| **Name** | **Description** |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '**名称** | **描述**'
- en: '| `$inc` | This increments the value of the field by the specified amount.
    |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '`$inc` | 将字段的值增加指定的数量'
- en: '| `$mul` | This multiplies the value of the field by the specified amount.
    |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '`$mul` | 将字段的值乘以指定的数量'
- en: '| `$rename` | This renames a field. |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '`$rename` | 重命名字段。'
- en: '| `$setOnInsert` | This sets the value of a field if an update results in an
    insert of a document. It has no effect on update operations and modifying existing
    documents. |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '`$setOnInsert` | 如果更新导致文档插入，则设置字段的值。它不影响更新操作和修改现有文档。'
- en: '| `$set` | This sets the value of a field in a document. |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '`$set` | 设置文档中字段的值。'
- en: '| `$unset` | This removes the specified field from a document. |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '`$unset` | 从文档中删除指定的字段。'
- en: '| `$min` | This only updates the field if the specified value is less than
    the existing field value. |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '`$min` | 仅在指定值小于现有字段值时更新字段。'
- en: '| `$max` | This only updates the field if the specified value is greater than
    the existing field value. |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '`$max` | 仅在指定值大于现有字段值时更新字段。'
- en: '| `$currentDate` | This sets the value of a field to the current date, either
    as a date or as a timestamp. |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '`$currentDate` | 将字段的值设置为当前日期，可以是日期或时间戳。'
- en: Smart querying
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能查询
- en: There are several considerations when querying in MongoDB that we have to take
    into account. Here are some best practices for using regular expressions, query
    results, cursors, and when deleting documents.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询MongoDB时，我们必须考虑几个因素。以下是一些使用正则表达式、查询结果、游标以及删除文档的最佳实践。
- en: Using regular expressions
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式
- en: 'MongoDB offers a rich interface for querying using regular expressions. In
    its simplest form, we can use regular expressions in queries by modifying the
    query string:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB提供了丰富的接口，用于使用正则表达式进行查询。在其最简单的形式中，我们可以通过修改查询字符串来使用正则表达式：
- en: '[PRE72]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This is done to search for books in our `books` collection that contain the
    `mongo` name. It is the equivalent of a SQL `LIKE` query.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了在我们的`books`集合中搜索包含`mongo`名称的书籍。这相当于SQL的`LIKE`查询。
- en: MongoDB uses **Perl Compatible Regular Expression** (**PCRE**) version 8.39
    with UTF-8 support.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB使用**Perl Compatible Regular Expression**（**PCRE**）版本8.39，并支持UTF-8。
- en: 'We can also use some options when querying:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询时，我们还可以使用一些选项：
- en: '| **Option** | **Description** |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| **选项** | **描述** |'
- en: '| `i` | This option queries case insensitivity. |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| `i` | 此选项查询不区分大小写。 |'
- en: '| `m` | For patterns that include anchors (that is, `^` for the start and `$`
    for the end), this option matches at the beginning or end of each line for strings
    with multiline values. Without this option, these anchors match at the beginning
    or end of the string.If the pattern contains no anchors, or if the string value
    has no newline characters (for example, `\n`), the `m` option has no effect. |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| `m` | 对于包含锚点（即`^`表示开头，`$`表示结尾）的模式，此选项将在每行的开头或结尾匹配多行值的字符串。如果模式不包含锚点，或者字符串值没有换行符（例如`\n`），则`m`选项不起作用。
    |'
- en: 'In our previous example, if we wanted to search for `mongo`, `Mongo`, `MONGO`,
    and any other case-insensitive variation, we would need to use the `i` option,
    as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的先前示例中，如果我们想搜索`mongo`、`Mongo`、`MONGO`以及任何其他不区分大小写的变体，我们需要使用`i`选项，如下所示：
- en: '[PRE73]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Alternatively, we can use the `$regex` operator, which provides more flexibility.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`$regex`运算符，这样可以提供更多的灵活性。
- en: 'The same queries using `$regex` will be written as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`$regex`进行相同的查询将写成如下形式：
- en: '[PRE74]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'By using the `$regex` operator, we can also use the following two options:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`$regex`运算符，我们还可以使用以下两个选项：
- en: '| **Option** | **Description** |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| **选项** | **描述** |'
- en: '| `x` | Extended capability to ignore all whitespace characters in the `$regex`
    pattern, unless they have escaped or are included in a character class.Additionally,
    it ignores characters in between (and including) an unescaped hash/pound (`#`, `£`)
    character and the next newline so that you may include comments in complicated
    patterns. This only applies to data characters; whitespace characters may never
    appear within special character sequences in a pattern.The `x` option does not
    affect the handling of the VT character. |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| `x` | 扩展功能，忽略`$regex`模式中的所有空白字符，除非它们已被转义或包含在字符类中。此外，它还忽略未转义的井号（`#`、`£`）字符及其后的字符，以便在复杂模式中包含注释。这仅适用于数据字符；空白字符永远不会出现在模式中特殊字符序列中。`x`选项不影响对VT字符的处理。
    |'
- en: '| `s` | This option allows the dot character (that is, `.`) to match all characters,
    including newline characters. |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| `s` | 此选项允许点字符（即`.`）匹配所有字符，包括换行符。 |'
- en: Expanding matching documents using regex makes our queries slower to execute.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正则表达式扩展匹配文档会使我们的查询执行速度变慢。
- en: Indexes using regular expressions can only be used if our regular expression
    does queries for the beginning of a string that is indexed; that is, regular expressions
    starting with `^` or `\A`. If we want to query only using a `starts with` regular
    expression, we should avoid writing lengthier regular expressions, even if they
    will match the same strings.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正则表达式的索引只能在我们的正则表达式查询字符串的开头进行使用；也就是说，以`^`或`\A`开头的正则表达式。如果我们只想使用`starts with`正则表达式进行查询，我们应该避免编写更长的正则表达式，即使它们会匹配相同的字符串。
- en: 'Take the following code block as an example:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下代码块为例：
- en: '[PRE75]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Both queries will match name values starting with `mongo` (case-sensitive),
    but the first one will be faster as it will stop matching as soon as it hits the
    sixth character in every name value.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个查询都将匹配以`mongo`开头的名称值（区分大小写），但第一个查询将更快，因为它在每个名称值中的第六个字符时就会停止匹配。
- en: Querying results and cursors
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询结果和游标
- en: MongoDB's lack of support for transactions means that several semantics that
    we take for granted in RDBMS work differently.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB不支持事务意味着我们在RDBMS中认为理所当然的几个语义工作方式不同。
- en: As explained previously, updates can modify the size of a document. Modifying
    the size can result in MongoDB moving the document on the disk to a new slot toward
    the end of the storage file.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，更新可能会修改文档的大小。修改大小可能会导致MongoDB将文档移动到存储文件末尾的新位置。
- en: When we have multiple threads querying and updating a single collection, we
    can end up with a document appearing multiple times in the result set.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有多个线程查询和更新单个集合时，可能会导致一个文档在结果集中出现多次。
- en: 'This will happen in the following scenario:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这将发生在以下情况下：
- en: Thread `A` starts querying the collection and matches document `A1`.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程`A`开始查询集合并匹配文档`A1`。
- en: Thread `B` updates document `A1`, increasing its size and forcing MongoDB to
    move it to a different physical location toward the end of the storage file.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程`B`更新文档`A1`，增加其大小，并迫使MongoDB将其移动到存储文件末尾的不同物理位置。
- en: 'Thread `A` is still querying the collection. It reaches the end of the collection
    and finds document `A1` again with its new value, as shown in the following diagram:'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程`A`仍在查询集合。它到达集合末尾，并再次找到文档`A1`，其新值如下图所示：
- en: '![](img/91064db2-8b5e-4ad4-9d26-03e08cca5006.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91064db2-8b5e-4ad4-9d26-03e08cca5006.png)'
- en: This is rare, but it can happen in production; if we can't safeguard from such
    a case in the application layer, we can use `snapshot()` to prevent it.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这很少见，但在生产中可能会发生；如果我们无法在应用层保护免受这种情况，我们可以使用`snapshot()`来防止它发生。
- en: '`snapshot()` is supported by official drivers and the shell by appending it
    into an operation that returns a cursor:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`snapshot()`由官方驱动程序和shell支持，通过将其附加到返回游标的操作中：'
- en: '[PRE76]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '`$snapshot` cannot be used with sharded collections. `$snapshot` has to be
    applied before the query returns the first document. Snapshot cannot be used together
    with the `hint()` or `sort()` operators.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`$snapshot`不能与分片集合一起使用。`$snapshot`必须在查询返回第一个文档之前应用。快照不能与`hint()`或`sort()`操作符一起使用。'
- en: We can simulate the `snapshot()` behavior by querying using `hint({id :1})`,
    thus forcing the query engine to use the `id` index just like the `$snapshot`
    operator.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`hint({id :1})`来模拟`snapshot()`的行为，从而强制查询引擎使用`id`索引，就像`$snapshot`操作符一样。
- en: If our query runs on a unique index of a field whose values won't get modified
    during the duration of the query, we should use this query to get the same query
    behavior. Even then, `snapshot()` cannot protect us from insertions or deletions
    happening in the middle of a query. The `$snapshot` operator will traverse the
    built-in index that every collection has on the `id` field, making it inherently
    slow. This should only be used as a last resort.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的查询在一个字段的唯一索引上运行，而这个字段的值在查询期间不会被修改，我们应该使用这个查询来获得相同的查询行为。即使如此，`snapshot()`也无法保护我们免受插入或删除发生在查询中间的影响。`$snapshot`操作符将遍历每个集合在`id`字段上具有的内置索引，使其固有地缓慢。这应该只作为最后的手段使用。
- en: 'If we want to `update`, `insert`, or `delete` multiple documents without other
    threads seeing the results of our operation while it''s happening, we can use
    the `$isolated` operator:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在进行`update`、`insert`或`delete`多个文档时，不让其他线程在操作进行时看到操作的结果，我们可以使用`$isolated`操作符：
- en: '[PRE77]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In this example, threads querying the `books` collection will see either all
    books with a price greater than `30` or no books at all. The isolated operator
    will acquire an exclusive write lock in the collection for the whole duration
    of the query, no matter what the storage engine can support, contributing to the
    contention in this collection.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，查询`books`集合的线程将看到价格大于`30`的所有书籍，或者根本看不到任何书籍。隔离操作符将在整个查询期间为集合获取独占写锁，无论存储引擎支持什么，都会导致这个集合的争用。
- en: Isolated operations are still not transactions; they don't provide `atomicity
    ( "all-or-nothing")`. So, if they fail midway, we need to manually roll back the
    operation to get our database into a consistent state.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离操作仍然不是事务；它们不提供`原子性（"全有或全无"）`。因此，如果它们在中途失败，我们需要手动回滚操作，使我们的数据库处于一致状态。
- en: Again, this should be a last resort and only used in cases where it's mission-critical
    to avoid multiple threads seeing inconsistent information at any time.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这应该是最后的手段，只在使得多个线程随时看到不一致信息变得至关重要的情况下使用。
- en: Storage considerations for the delete operation
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除操作的存储考虑
- en: Deleting documents in MongoDB does not reclaim the disk space used by it. If
    we have 10 GB of disk space used by MongoDB and we delete all documents, we will
    still be using 10 GB. What happens under the hood is that MongoDB will mark these
    documents as deleted and may use the space to store new documents.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中删除文档不会回收其使用的磁盘空间。如果我们的MongoDB使用了10GB的磁盘空间，我们删除了所有文档，我们仍然会使用10GB。在幕后发生的是，MongoDB会将这些文档标记为已删除，并可能使用空间来存储新文档。
- en: 'This results in our disk having space that is not used, but is not freed up
    for the operating system. If we want to claim it back, we can use `compact()`
    to reclaim any unused space:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致我们的磁盘有未使用的空间，但不会为操作系统释放。如果我们想要收回它，我们可以使用`compact()`来收回任何未使用的空间：
- en: '[PRE78]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Alternatively, we can start the `mongod` server with the `--repair` option.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`--repair`选项启动`mongod`服务器。
- en: A better option is to enable compression, which is available from version 3.0
    and only with the WiredTiger storage engine. We can use the snappy or zlib algorithms
    to compress our document size. This will, again, not prevent storage holes, but
    if we are tight on disk space, it is preferable to the heavy operational route
    of repair and compact.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的选择是启用压缩，这在3.0版本中可用，且仅适用于WiredTiger存储引擎。我们可以使用snappy或zlib算法来压缩我们的文档大小。这将再次不会防止存储空洞，但如果我们的磁盘空间紧张，这比修复和压缩的繁重操作更可取。
- en: Storage compression uses less disk space at the expense of CPU usage, but this
    trade-off is mostly worth it.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 存储压缩使用更少的磁盘空间，但以CPU使用为代价，但这种权衡大多是值得的。
- en: Always take a backup before running operations that can result in a catastrophic
    loss of data. Repair or compact will run in a single thread, blocking the entire
    database from other operations. In production systems, always perform these on
    the slave first; then switch the master-slave roles, and compact the ex-master,
    now-slave instance.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行可能导致灾难性数据丢失的操作之前，始终进行备份。修复或压缩将在单个线程中运行，阻塞整个数据库的其他操作。在生产系统中，始终先在从库上执行这些操作；然后切换主从角色，并压缩原主服务器，现在的从服务器实例。
- en: Change streams
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变更流
- en: Change streams functionality was introduced in version 3.6 and augmented in
    version 4.0, making it a safe and efficient way to listen for database changes.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 变更流功能在3.6版本中引入，并在4.0版本中增强，使其成为监听数据库变更的安全有效的方式。
- en: Introduction
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The fundamental problem that change streams solve is the need for applications
    to react immediately to changes in the underlying data. Modern web applications
    need to be reactive to data changes and refresh the page view without reloading
    the entire page. This is one of the problems that frontend frameworks (such as
    Angular, React, and Vue.js) are solving. When a user performs an action, the frontend
    framework will submit the request to the server asynchronously and refresh the
    relevant fragment of the page based on the response from the server.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 改变流解决的基本问题是应用程序需要立即对基础数据的变化做出反应。现代Web应用程序需要对数据变化做出反应，并在不重新加载整个页面的情况下刷新页面视图。这是前端框架（如Angular、React和Vue.js）正在解决的问题之一。当用户执行操作时，前端框架将异步地向服务器提交请求，并根据服务器的响应刷新页面的相关片段。
- en: Thinking of a multiuser web application, there are cases where a database change
    may have occurred as a result of another user's action. For example, in a project
    management Kanban board, user A may be viewing the Kanban board, while another
    user, B, may be changing the status of a ticket from "To do" to "In progress".
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到多用户Web应用程序，存在数据库更改可能是由另一个用户的操作引起的情况。例如，在项目管理看板中，用户A可能正在查看看板，而另一个用户B可能正在将一个工单的状态从“待办”更改为“进行中”。
- en: 'User A''s view needs to be updated with the change that user B has performed
    in real time, without refreshing the page. There are already three approaches
    to this problem, as follows:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 用户A的视图需要实时更新，以反映用户B所做的更改，无需刷新页面。目前已经有三种方法来解决这个问题，如下所示：
- en: The most simple approach is to poll the database every X number of seconds and
    determine if there has been a change. Usually this code will need to use some
    kind of status, timestamp, or version number to avoid fetching the same change
    multiple times. This is simple, yet inefficient, as it cannot scale with a great
    number of users. Having thousands of users polling the database at the same time
    will result in a high database-locking rate.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最简单的方法是每隔X秒轮询数据库并确定是否有变化。通常，此代码将需要使用某种状态、时间戳或版本号，以避免多次获取相同的变化。这种方法简单，但效率低，因为它无法随着大量用户的增加而扩展。成千上万的用户同时轮询数据库将导致数据库锁定率高。
- en: To overcome the problems imposed by the first approach, database-and application-level
    triggers have been implemented. A database trigger relies on the underlying database
    executing some code in response to a database change. However, the main downside
    is again similar to the first approach in that the more triggers that we add to
    a database, the slower our database will become. It is also coupled to the database,
    instead of being a part of the application code base.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了克服第一种方法带来的问题，已经实现了数据库和应用程序级触发器。数据库触发器依赖于底层数据库对数据库更改做出响应执行一些代码。然而，主要的缺点与第一种方法类似，即我们向数据库添加的触发器越多，我们的数据库就会变得越慢。它也与数据库耦合，而不是应用程序代码库的一部分。
- en: Finally, we can use the database transaction or replication log to query for
    the latest changes and react to them. This is the most efficient and scalable
    approach of the three previously mentioned as it doesn't put a strain on the database.
    The database writes to this log anyway, it is usually append only and our background
    task serially reads entries as they come into the log. The downside of this method
    is that it is the most complicated one to implement and one that can lead to nasty
    bugs if it's not implemented properly.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用数据库事务或复制日志来查询最新的更改并对其做出反应。这是前面提到的三种方法中最有效和可扩展的方法，因为它不会对数据库造成压力。数据库会将写入此日志，通常是仅追加的，我们的后台任务会按顺序读取日志中的条目。这种方法的缺点是它是最复杂的实现方法，如果没有正确实现，可能会导致严重的错误。
- en: Change streams provide a way to solve this problem that is developer-friendly
    and easy to implement and maintain. It is based on the oplog, which is essentially
    MongoDB's operations log, containing each and every operation happening server-wide
    across all databases in the server. This way the developer does not have to deal
    with the server-wide oplog or tailable cursors, which are often not exposed or
    easy to deal with from MongoDB language-specific drivers. Also, the developer
    does not have to decipher and understand any of the internal oplog data structures
    that are designed and built for MongoDB's benefit, and not for an application
    developer.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 改变流提供了一种解决这个问题的方式，这种方式对开发人员友好，易于实现和维护。它基于oplog，本质上是MongoDB的操作日志，包含服务器范围内所有数据库中发生的每个操作。这样，开发人员就不必处理服务器范围内的oplog或可追溯的游标，这些通常不会从MongoDB特定语言驱动程序中公开或易于处理。此外，开发人员也不必解密和理解为MongoDB的利益而设计和构建的任何内部oplog数据结构。
- en: 'Change streams have other advantages in which they are secure: users can only
    create change streams on collections, databases, or deployments to those for which
    they have read access.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 改变流在安全方面还有其他优势：用户只能在具有读取权限的集合、数据库或部署上创建改变流。
- en: Change streams are also idempotent by design. Even in the case that the application
    cannot fetch the absolute latest change stream event notification ID, it can resume
    applying from an earlier known one and it will eventually reach the same state.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 改变流也是幂等的设计。即使应用程序无法获取绝对最新的改变流事件通知ID，它也可以从先前已知的ID开始应用，并最终达到相同的状态。
- en: Finally, change streams are resumable. Every change stream response document
    includes a resume token. If the application gets out of sync with the database,
    it can send the latest resume token back to the database and continue processing
    from there. This token needs to be persisted in the application, as the MongoDB
    driver won't keep application failures and restarts. It will only keep state and
    retry in case of transient network failures and MongoDB replica set elections.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更改流是可恢复的。每个更改流响应文档都包括一个恢复令牌。如果应用程序与数据库不同步，它可以将最新的恢复令牌发送回数据库，并从那里继续处理。这个令牌需要在应用程序中持久化，因为MongoDB驱动程序不会保留应用程序的故障和重新启动。它只会在瞬态网络故障和MongoDB副本集选举的情况下保持状态并重试。
- en: Setup
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: A change stream can be opened against a collection, a database, or an entire
    deployment (such as a replica set or sharded cluster). A change stream will not
    react to changes in any system collection or any collection in the admin, config,
    and local databases.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 更改流可以针对集合、数据库或整个部署（如副本集或分片集群）进行打开。更改流不会对系统集合或admin、config和local数据库中的任何集合的更改做出反应。
- en: A change stream requires a WiredTiger storage engine and replica set protocol
    version 1 (pv1). pv1 is the only supported version starting from MongoDB 4.0\.
    Change streams are compatible with deployments that use encryption-at-rest.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 更改流需要WiredTiger存储引擎和副本集协议版本1（pv1）。从MongoDB 4.0开始，pv1是唯一受支持的版本。更改流与使用加密存储的部署兼容。
- en: Using change streams
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用更改流
- en: To use a change stream, we need to connect to our replica set. A replica set
    is a prerequisite to using change streams. As change streams internally use the
    oplog, it's not possible to work without it. Change streams will also output documents
    that won't be rolled back in a replica set setting, so they need to follow a majority
    read concern. Either way, it's a good practice to develop and test locally using
    a replica set, as this is the recommended deployment for production. As an example,
    we are going to use a `signals` collection within our database named `streams`.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用更改流，我们需要连接到我们的副本集。副本集是使用更改流的先决条件。由于更改流内部使用oplog，没有oplog是不可能工作的。更改流还将输出在副本集设置中不会回滚的文档，因此它们需要遵循大多数读取关注。无论如何，使用副本集进行本地开发和测试是一个好习惯，因为这是生产的推荐部署方式。例如，我们将在名为`streams`的数据库中使用`signals`集合。
- en: 'We will use the following sample Python code:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下示例Python代码：
- en: '[PRE79]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We can open one Terminal and run it using `python change_streams.py`.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打开一个终端并使用`python change_streams.py`运行它。
- en: 'Then, in another Terminal, we connect to our MongoDB replica set using the
    following code:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在另一个终端中，我们使用以下代码连接到我们的MongoDB副本集：
- en: '[PRE80]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Going back to our first Terminal window, we can now observe that the output
    is similar to the following code block:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的第一个终端窗口，我们现在可以观察到输出类似于以下代码块：
- en: '[PRE81]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: What has happened here is that we have opened a cursor watching the entire `streams` database
    for changes. Every data update in our database will be logged and outputted in
    the console.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的是，我们已经打开了一个游标，监视整个`streams`数据库的更改。我们数据库中的每个数据更新都将被记录并输出到控制台。
- en: 'For example, if we go back to the mongo shell, we can issue the following code:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们回到mongo shell，我们可以发出以下代码：
- en: '[PRE82]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The Python code output should then be similar to the following code:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: Python代码输出应该类似于以下代码：
- en: '[PRE83]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This means that we are getting notifications for each and every data update
    across all collections in our database.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们会收到关于数据库中所有集合的每个数据更新的通知。
- en: 'We can then change line 11 of our code to the following:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将我们的代码的第11行更改为以下内容：
- en: '[PRE84]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This will result in only watching the `signals` collection, as should be the
    most common use case.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致只观察`signals`集合，这应该是最常见的用例。
- en: 'PyMongo''s `watch` command can take several parameters, as follows:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: PyMongo的`watch`命令可以采用几个参数，如下所示：
- en: '[PRE85]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The most important parameters are as follows:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的参数如下：
- en: '`Pipeline`: This is an optional parameter that we can use to define an aggregation
    pipeline to be executed on each document that matches `watch()`. Because the change
    stream itself uses the aggregation pipeline, we can attach events to it. The aggregation
    pipeline events we can use are as follows:'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pipeline`：这是一个可选参数，我们可以使用它来定义要在每个与`watch()`匹配的文档上执行的聚合管道。因为更改流本身使用聚合管道，我们可以将事件附加到它。我们可以使用的聚合管道事件如下：'
- en: '[PRE86]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '`Full_document`: This is an optional parameter that we can use by setting it
    to `''updateLookup''` to make change streams return both a delta describing the
    changes to the document, and a copy of the entire document that was changed from
    some time after the change occurred in the case of a partial update.'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Full_document`：这是一个可选参数，我们可以通过将其设置为`''updateLookup''`来使用，以使更改流返回描述文档更改的增量和在部分更新的情况下从更改发生后的一段时间内更改的整个文档的副本。'
- en: '`Start_at_operation_time`: This is an optional parameter that we can use to
    only watch for changes that occurred at, or after, the specified timestamp.'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Start_at_operation_time`：这是一个可选参数，我们可以使用它来仅观察在指定时间戳之后或之后发生的更改。'
- en: '`Session`: This is an optional parameter in case our driver supports passing
    a `ClientSession` object to watch for updates.'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Session`：这是一个可选参数，如果我们的驱动程序支持传递`ClientSession`对象以侦听更新。'
- en: Change streams response documents have to be under 16 MB in size. This is a
    global limit in MongoDB for BSON documents and the change stream has to follow
    this rule.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 更改流响应文档的大小不能超过16 MB。这是MongoDB对BSON文档的全局限制，更改流必须遵循此规则。
- en: Specification
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范
- en: 'The following document shows all of the possible fields that a change event
    response may or may not include, depending on the actual change that happened:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文档显示了更改事件响应可能包括或不包括的所有可能字段，具体取决于实际发生的更改：
- en: '[PRE87]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The most important fields are as follows:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的字段如下：
- en: '| `fullDocument` | This is the new state of the document, which can include
    the following:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '| `fullDocument` | 这是文档的新状态，可以包括以下内容：'
- en: If it's a delete operation, this field is omitted as the document no longer
    exists.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是删除操作，则该字段被省略，因为文档已不再存在。
- en: If it's an insert or replace operation, this will be the new value of the document.
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是插入或替换操作，则将是文档的新值。
- en: If it's an update operation and we have enabled `'updateLookup'`, then it will
    have the most recently major-committed version of the document modified by the
    update operation.
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是更新操作，并且我们已启用`'updateLookup'`，那么它将具有更新操作修改的文档的最近主要提交的版本。
- en: '|'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `operationType` | This is the type of operation; it can be either of `insert`,
    `delete`, `replace`, `update`, or `invalidate`. |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '| `operationType` | 这是操作的类型；它可以是`insert`、`delete`、`replace`、`update`或`invalidate`中的任何一个。
    |'
- en: '| `documentKey` | This is `ObjectID` of the document that was affected by the
    operation. |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| `documentKey` | 这是操作影响的文档的`ObjectID`。 |'
- en: '| `updateDescription.updatedFields / removedFields` | This is a document or
    an array of keys respectively, showing the data that was updated or removed by
    the update or remove operation. |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '| `updateDescription.updatedFields / removedFields` | 这是一个文档或相应的键数组，分别显示了更新或删除操作更新或删除的数据。
    |'
- en: '| `txnNumber` | This is the transaction number. It is only applicable if the
    operation is part of a multi-document **ACID** (**atomicity, consistency, isolation,
    durability**) transaction. |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '| `txnNumber` | 这是事务号。仅当操作是多文档ACID事务的一部分时才适用。 |'
- en: '| `lsid` | This is the session identifier of the transaction. It is only applicable
    if the operation is part of a multi-document ACID transaction. |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '| `lsid` | 这是事务的会话标识符。仅当操作是多文档ACID事务的一部分时才适用。 |'
- en: Important notes
  id: totrans-490
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要说明
- en: When using a sharded database, change streams need to be opened against a MongoDB
    server. When using replica sets, a change stream can only be opened against a
    data-bearing instance. Each change stream will open a new connection, as of 4.0.2\.
    If we want to have lots of change streams in parallel, we need to increase the
    connection pool (as per the SERVER-32946 JIRA MongoDB ticket) to avoid severe
    performance degradation.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用分片数据库时，更改流需要针对MongoDB服务器打开。在使用副本集时，更改流只能针对承载数据的实例打开。从4.0.2版本开始，每个更改流将打开一个新连接。如果我们想要并行地有大量的更改流，我们需要增加连接池（根据SERVER-32946
    JIRA MongoDB票）以避免严重的性能下降。
- en: Production recommendations
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产建议
- en: Change streams are a fairly recent addition to the MongoDB database. As such,
    the following recommendations for production deployments may change in later versions.
    These are the guidelines as recommended by MongoDB and expert architects at the
    time of writing this chapter.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 更改流是MongoDB数据库的一个相当新的添加。因此，生产部署的以下建议可能会在以后的版本中更改。这些是MongoDB和专家架构师在撰写本章时推荐的指南。
- en: Replica sets
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 副本集
- en: A change stream will only process an event that has been written to the majority
    of members processing data. It will pause if we lose the majority of data-storing
    servers, or if we rely on arbiters to establish a majority.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 更改流只会处理已写入大多数处理数据成员的事件。如果我们失去了存储数据服务器的大多数，或者我们依赖仲裁者来建立多数，它将暂停。
- en: Invalidating events, such as dropping or renaming a collection, will close the
    change stream. We cannot resume a change stream after an invalidate event closes
    it.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 使事件无效，例如删除或重命名集合，将关闭更改流。在使事件无效后关闭更改流后，我们无法恢复更改流。
- en: As the change stream relies on the oplog size, we need to make sure that the
    oplog size is large enough to hold events until they are processed by the application.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 由于更改流依赖于oplog大小，我们需要确保oplog大小足够大，以容纳事件，直到应用程序处理完毕。
- en: Sharded clusters
  id: totrans-498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分片集群
- en: 'On top of the considerations for replica sets, there are a few more to keep
    in mind for sharded clusters. They are as follows:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 除了副本集的考虑之外，对于分片集群还有一些需要牢记的事项。它们如下：
- en: The change stream is executed against every shard in a cluster and will be as
    fast as the slowest shard.
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改流在集群中的每个分片上执行，并且速度将取决于最慢的分片。
- en: To avoid creating change stream events for orphaned documents, we need to use
    the new feature of ACID compliant transactions if we have multi-document updates
    under sharding.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免为孤立文档创建更改流事件，如果我们在分片下有多文档更新，我们需要使用ACID兼容事务的新功能。
- en: While sharding an unsharded collection (that is, migrating from replica sets
    to sharding), `documentKey` of the change stream notification document will include `_id`
    until the change stream catches up to the first chunk migration.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在对未分片集合进行分片（即从副本集迁移至分片）时，更改流通知文档的`documentKey`将包括`_id`，直到更改流追上第一个分块迁移。
- en: Summary
  id: totrans-503
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through advanced querying concepts using Ruby, Python,
    and PHP by both using the official drivers and an ODM.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过使用官方驱动程序和ODM，使用Ruby、Python和PHP，讨论了使用这些语言进行高级查询的概念。
- en: Using Ruby and the Mongoid ODM, Python and the PyMODM ODM, and PHP and the Doctrine
    ODM, we went through code samples exploring how to `create`, `read`, `update`,
    and `delete` documents.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ruby和Mongoid ODM，Python和PyMODM ODM，以及PHP和Doctrine ODM，我们通过代码示例探讨了如何`创建`、`读取`、`更新`和`删除`文档。
- en: We also discussed batching operations for performance and best practices. We
    presented an exhaustive list of comparison and update operators that MongoDB uses.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了性能和最佳实践的批处理操作。我们提供了MongoDB使用的比较和更新操作符的详尽列表。
- en: Finally, we discussed smart querying, how cursors in querying work, what our
    storage performance considerations should be on delete, and how to use regular
    expressions.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了智能查询，查询中的游标工作原理，删除时应考虑的存储性能，以及如何使用正则表达式。
- en: In the next chapter, we will learn about the aggregation framework, using a
    complete use case that involves processing transaction data from the Ethereum
    blockchain.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习聚合框架，使用一个涉及从以太坊区块链处理交易数据的完整用例。
