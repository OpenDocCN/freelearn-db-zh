- en: Storage Engines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储引擎
- en: MongoDB introduced the concept of pluggable storage engines in version 3.0\.
    After the acquisition of WiredTiger, it introduced its storage engine as optional
    at first, and then as the default storage engine for the current version of MongoDB.
    In this chapter, we will dive deeply into the concept of storage engines, why
    they matter, and how we can choose the best one according to our workload.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB在3.0版本中引入了可插拔存储引擎的概念。在收购WiredTiger之后，它首先将其存储引擎作为可选引擎引入，然后作为当前版本MongoDB的默认存储引擎。在本章中，我们将深入探讨存储引擎的概念，它们的重要性以及如何根据我们的工作负载选择最佳存储引擎。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Pluggable storage engines
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可插拔存储引擎
- en: WiredTiger
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WiredTiger
- en: Encrypted
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密
- en: In-memory
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存中
- en: MMAPv1
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MMAPv1
- en: Locking in MongoDB
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB中的锁定
- en: Pluggable storage engines
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可插拔存储引擎
- en: With MongoDB breaking out from the web application paradigm into domains with
    different requirements, storage has become an increasingly important consideration.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 随着MongoDB从Web应用程序范式中分离出来进入具有不同要求的领域，存储已成为一个越来越重要的考虑因素。
- en: Using multiple storage engines can be seen as an alternative way to using different
    storage solutions and databases in our infrastructure stack. This way, we can
    reduce operational complexity and development time to market with the application
    layer being agnostic of the underlying storage layer.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个存储引擎可以被视为使用基础架构堆栈中不同存储解决方案和数据库的替代方式。这样，我们可以减少操作复杂性，并且应用层对基础存储层是不可知的，从而缩短开发时间。
- en: MongoDB currently offers four different storage engines that we will examine
    in further detail in the following sections.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB目前提供了四种不同的存储引擎，我们将在接下来的章节中更详细地讨论。
- en: WiredTiger
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WiredTiger
- en: As of version 3.2, WiredTiger is the default storage engine, and also the best
    choice for most workloads. By providing document-level locking, it overcomes one
    of the most significant drawbacks earlier versions of MongoDB had—lock contention
    under high load.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本3.2开始，WiredTiger是默认的存储引擎，也是大多数工作负载的最佳选择。通过提供文档级别的锁定，它克服了MongoDB早期版本中最显著的缺点之一——在高负载下的锁争用。
- en: We will explore some of WiredTiger's benefits in the following sections.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中探讨一些WiredTiger的好处。
- en: Document-level locking
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档级别的锁定
- en: Locking is so important that we will explain the performance implications that
    fine-grained locking has in further detail at the end of this section. Having
    document-level locking as opposed to MMAPv1 collection-level locking can make
    a huge difference in many real-world use cases, and is one of the main reasons
    to choose WiredTiger over MMAPv1.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定是如此重要，以至于我们将在本节末尾更详细地解释细粒度锁定的性能影响。与MMAPv1集合级别锁定相比，具有文档级别锁定可以在许多实际用例中产生巨大的差异，并且是选择WiredTiger而不是MMAPv1的主要原因之一。
- en: Snapshots and checkpoints
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快照和检查点
- en: WiredTiger uses **Multi-Version Concurrency Control** (**MVCC**). MVCC is based
    upon the concept that the database keeps multiple versions of an object so that
    readers will be able to view consistent data that doesn't change during a read.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: WiredTiger使用**多版本并发控制**（**MVCC**）。MVCC基于这样一个概念，即数据库保留对象的多个版本，以便读者能够查看在读取期间不会发生变化的一致数据。
- en: In a database, if we have multiple readers accessing data at the same time that
    writers are modifying the data, we can end up with a case where readers view an
    inconsistent view of this data. The simplest and easiest way to solve this problem
    is to block all readers until the writers are done modifying data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中，如果我们有多个读者在写入者修改数据的同时访问数据，我们可能会出现读者查看此数据的不一致视图的情况。解决这个问题的最简单和最容易的方法是阻止所有读者，直到写入者完成对数据的修改。
- en: This will, of course, cause severe performance degradation. MVCC solves this
    problem by providing a snapshot of the database for each reader. When the read
    starts, each reader is guaranteed to view data as exactly it was at the point
    in time that the read started. Any changes made by writers will only be seen by
    readers after the write has been completed, or, in database terms, after the transaction
    is committed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然会导致严重的性能下降。MVCC通过为每个读者提供数据库的快照来解决这个问题。当读取开始时，每个读者都保证查看数据与读取开始时的时间点完全一致。写入者进行的任何更改只有在写入完成后才会被读者看到，或者在数据库术语中，只有在事务提交后读者才能看到。
- en: To achieve this goal, when a write is coming in, updated data will be kept in
    a separate location on disk and MongoDB will mark the affected document as obsolete.
    MVCC is said to provide point-in-time consistent views. This is equivalent to
    a read committed isolation level in traditional RDBMS systems.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个目标，当写入数据时，更新后的数据将被保存在磁盘的一个单独位置，并且MongoDB将标记受影响的文档为过时。MVCC被认为提供了时点一致的视图。这相当于传统RDBMS系统中的读提交隔离级别。
- en: For every operation, WiredTiger will snapshot our data at the exact moment that
    it happens and provide a consistent view of application data to the application.
    When we write data, WiredTiger will create a snapshot every 2 GB of journal data
    or 60 seconds, whichever comes first. WiredTiger relies on its built-in journal
    to recover any data after the latest checkpoint in case of failure.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个操作，WiredTiger将在发生操作的确切时刻对我们的数据进行快照，并为应用程序提供一致的应用程序数据视图。当我们写入数据时，WiredTiger将在每2GB的日志数据或60秒内创建一个快照，以先到者为准。在故障情况下，WiredTiger依赖于其内置日志来恢复最新检查点之后的任何数据。
- en: We can disable journaling using WiredTiger, but if the server crashes, we will
    lose any data after the last checkpoint is written.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用WiredTiger禁用日志记录，但如果服务器崩溃，我们将丢失最后一个检查点之后的任何数据。
- en: Journaling
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录
- en: As explained in the *Snapshots and checkpoints* section, journaling is the cornerstone
    of WiredTiger crash recovery protection.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在*快照和检查点*部分中所解释的，日志记录是WiredTiger崩溃恢复保护的基石。
- en: 'WiredTiger compresses the journal using the snappy compression algorithm. We
    can use the following setting to set a different compression algorithm:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: WiredTiger使用snappy压缩算法压缩日志。我们可以使用以下设置来设置不同的压缩算法：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can also disable journaling for WiredTiger by setting the following to `false`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过将以下设置为 `false` 来禁用 WiredTiger 的日志记录：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we use a replica set, we may be able to recover our data from a secondary
    that will get elected as a primary and start taking writes in the event that our
    primary fails. It is recommended to always use journaling, unless we understand
    and can take the risk of suffering through the consequences of not using it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用副本集，我们可能能够从次要节点中恢复数据，该节点将被选举为主节点并开始接受写入，以防我们的主节点发生故障。建议始终使用日志记录，除非我们了解并能够承受不使用它的后果。
- en: Data compression
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据压缩
- en: MongoDB uses the snappy compression algorithm by default to compress data and
    prefixes for indexes. Index-prefixed compression means that identical index key
    prefixes are stored only once per page of memory. Compression not only reduces
    our storage footprint, but will increase I/O operations per second, as less data
    needs to be stored and moved to and from disk. Using more aggressive compression
    can lead to performance gains if our workload is I/O bound and not CPU bound.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 默认使用 snappy 压缩算法来压缩数据和索引前缀。索引前缀压缩意味着相同的索引键前缀仅存储一次在内存页中。压缩不仅减少了存储空间，还会增加每秒的
    I/O 操作，因为需要存储和从磁盘移动的数据更少。如果我们的工作负载是 I/O 限制而不是 CPU 限制，使用更激进的压缩可以带来性能提升。
- en: 'We can define `.zlib` compression instead of snappy or no compression by setting
    the following parameter to `false`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将以下参数设置为 `false` 来定义 `.zlib` 压缩而不是 snappy 或无压缩：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Data compression uses less storage at the expense of CPU. `.zlib` compression
    achieves better compression at the expense of higher CPU usage, as opposed to
    the default snappy compression algorithm.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 数据压缩使用更少的存储空间，但会增加 CPU 的使用。`.zlib` 压缩以牺牲更高的 CPU 使用率来实现更好的压缩，与默认的 snappy 压缩算法相比。
- en: 'We can disable index prefixes compression by setting the following parameter
    to `false`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将以下参数设置为 `false` 来禁用索引前缀压缩：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can also configure storage per-index during creation using the following parameter:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在创建过程中使用以下参数为每个索引配置存储：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Memory usage
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存使用
- en: WiredTiger is significantly different to MMAPv1 in how it uses RAM. MMAPv1 is
    essentially using the underlying operating system's filesystem cache to page data
    from disk to memory and vice versa.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: WiredTiger 在使用 RAM 方面与 MMAPv1 有显著不同。MMAPv1 本质上是使用底层操作系统的文件系统缓存来将数据从磁盘分页到内存，反之亦然。
- en: WiredTiger, on the contrary, introduces the new concept of the WiredTiger internal
    cache.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，WiredTiger 引入了 WiredTiger 内部缓存的新概念。
- en: 'The WiredTiger internal cache is, by default, the larger of the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: WiredTiger 内部缓存默认为以下两者中的较大者：
- en: 50% of RAM minus 1 GB
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 50% 的 RAM 减去 1 GB
- en: 256 MB
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 256 MB
- en: 'This means if our server has 8 GB RAM we will get the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们的服务器有 8 GB RAM，我们将得到以下结果：
- en: '*max(3 GB , 256 MB) = WiredTiger will use 3 GB of RAM*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*max(3 GB , 256 MB) = WiredTiger 将使用 3 GB 的 RAM*'
- en: 'And if our server has 2,512 MB RAM we will get the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的服务器有 2,512 MB RAM，我们将得到以下结果：
- en: '*max(256 MB, 256 MB) = WiredTiger will use 256 MB of RAM*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*max(256 MB, 256 MB) = WiredTiger 将使用 256 MB 的 RAM*'
- en: Essentially, for any server that has less than 2,512 MB RAM, WiredTiger will
    use 256 MB for its internal cache.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，对于任何 RAM 小于 2,512 MB 的服务器，WiredTiger 将使用 256 MB 作为其内部缓存。
- en: 'We can change the size of the WiredTiger internal cache by setting the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过设置以下方式改变 WiredTiger 内部缓存的大小：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can also do this from the command line using the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用以下命令行来执行此操作：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Apart from the WiredTiger internal cache that is uncompressed for higher performance,
    MongoDB also uses the filesystem cache that is compressed, just like MMAPv1, and
    will end up using all available memory in most cases.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了未压缩以获得更高性能的 WiredTiger 内部缓存外，MongoDB 还使用了压缩的文件系统缓存，就像 MMAPv1 一样，在大多数情况下将使用所有可用内存。
- en: The WiredTiger internal cache can provide similar performance to in-memory storage.
    As such, it is important to grow it as much as possible.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: WiredTiger 内部缓存可以提供类似于内存存储的性能。因此，尽可能地扩大它是很重要的。
- en: We can achieve better performance when using WiredTiger with multi-core processors.
    This is also a big win compared to MMAPv1, which does not scale as well.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多核处理器时，使用 WiredTiger 可以获得更好的性能。与 MMAPv1 相比，这也是一个很大的优势，因为后者的扩展性不如 WiredTiger。
- en: We can, and should, use Docker or other containerization technologies to isolate
    the `mongod` processes from each other and make sure that we know how much memory
    each process can, and should, use in a production environment. It is not recommended
    to increase the WiredTiger internal cache above its default value. The filesystem
    cache should not be less than 20% of the total RAM.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以，也应该，使用 Docker 或其他容器化技术来隔离 `mongod` 进程，并确保我们知道每个进程在生产环境中可以使用多少内存。不建议将 WiredTiger
    内部缓存增加到其默认值以上。文件系统缓存不应少于总 RAM 的 20%。
- en: readConcern
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: readConcern
- en: WiredTiger supports multiple `readConcern` levels. Just like `writeConcern`,
    which is supported by every storage engine in MongoDB, with `readConcern`, we
    can customize how many servers in a replica set must acknowledge the query results
    for the document to be returned in the result set.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: WiredTiger 支持多个 `readConcern` 级别。就像 `writeConcern` 一样，它被 MongoDB 中的每个存储引擎支持，通过
    `readConcern`，我们可以自定义副本集中必须确认查询结果的服务器数量，以便将文档返回到结果集中。
- en: 'Available options for read concern are as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 读关注的可用选项如下：
- en: '`local`: Default option. Will return most recent data from the server. Data
    may, or may not, have propagated to the other servers in a replica set, and we
    run the risk of a rollback.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local`：默认选项。将从服务器返回最近的数据。数据可能已经传播到副本集中的其他服务器，也可能没有，我们面临回滚的风险。'
- en: '`linearizable`:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`线性化`：'
- en: Only applicable for reads from the primary
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅适用于从主节点读取
- en: Only applicable in queries that return a single result
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅适用于返回单个结果的查询
- en: 'Data returns satisfy two conditions:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据返回满足两个条件：
- en: '`majority`, ``writeConcern``'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`majority`, ``writeConcern``'
- en: Data was acknowledged before the start of the read operation
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据在读操作开始前已被确认
- en: In addition, if we have set `writeConcernMajorityJournalDefault` to `true`,
    we are guaranteed that the data won't get rolled back.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们将`writeConcernMajorityJournalDefault`设置为`true`，我们可以确保数据不会被回滚。
- en: If we have set `writeConcernMajorityJournalDefault` to `false`, MongoDB will
    not wait for `majority` writes to be durable before acknowledging the write. In
    this case our data may be rolled back in the event of a loss of a member from
    the replica set. Data returned has already been propagated and acknowledged from
    `majority` of the servers before read has started.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`writeConcernMajorityJournalDefault`设置为`false`，MongoDB在确认写入之前不会等待`majority`写入变得持久。在这种情况下，如果复制集中的成员丢失，我们的数据可能会被回滚。返回的数据已经从大多数服务器传播和确认后才开始读取。
- en: We need to use `maxTimeMS` when using `linearizable` and `majority` read concern
    levels in case we can't establish `majority writeConcern` to avoid blocking, forever
    waiting for the response. In this case, the operation will return a timeout error.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`linearizable`和`majority`读取关注级别时，我们需要使用`maxTimeMS`，以防我们无法建立`majority writeConcern`而永远等待响应。在这种情况下，操作将返回超时错误。
- en: MMAPv1 is the older storage engine and is considered, in many aspects, as being
    deprecated, but many deployments are still using it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: MMAPv1是较旧的存储引擎，在许多方面被认为是废弃的，但仍然有许多部署在使用它。
- en: '`local` and `linearizable` read concerns are available for MMAPv1 as well.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`local`和`linearizable`读取关注对MMAPv1也可用。'
- en: WiredTiger collection-level options
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WiredTiger集合级选项
- en: 'When we create a new collection, we can pass in options to WiredTiger like
    this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个新的集合时，可以像这样向WiredTiger传递选项：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This helps to create our `mongo_books` collection with a key-value pair from
    the available ones that WiredTiger exposes through its API. Some of the most widely
    used key-value pairs are the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于创建我们的`mongo_books`集合，并从WiredTiger通过其API公开的可用选项中选择一个键值对。一些最常用的键值对如下：
- en: '| **Key** | **Value** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **键** | **值** |'
- en: '| `block_allocation` | Best or first |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `block_allocation` | 最佳或首选 |'
- en: '| `allocation_size` | 512 bytes through to 4 KB; default 4 KB |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `allocation_size` | 512字节到4KB；默认4KB |'
- en: '| `block_compressor` | None, `.lz4`, `.snappy`, `.zlib`, `.zstd`, or custom
    compressor identifier string depending on configuration |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `block_compressor` | 无，`.lz4`，`.snappy`，`.zlib`，`.zstd`，或根据配置的自定义压缩器标识符字符串
    |'
- en: '| `memory_page_max` | 512 bytes through to 10 TB; default 5 MB |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `memory_page_max` | 512字节到10TB；默认5MB |'
- en: '| `os_cache_max` | Integer greater than zero; default zero |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `os_cache_max` | 大于零的整数；默认为零 |'
- en: 'This is taken directly from the definition in the WiredTiger documents located
    at [http://source.wiredtiger.com/mongodb-3.4/struct_w_t___s_e_s_s_i_o_n.html](http://source.wiredtiger.com/mongodb-3.4/struct_w_t___s_e_s_s_i_o_n.html):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这直接取自WiredTiger文档中的定义，位于[http://source.wiredtiger.com/mongodb-3.4/struct_w_t___s_e_s_s_i_o_n.html](http://source.wiredtiger.com/mongodb-3.4/struct_w_t___s_e_s_s_i_o_n.html)：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Collection-level options allow for flexibility in configuring storage but should
    be used with extreme care and after careful testing in development/staging environments.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 集合级选项允许灵活配置存储，但应在开发/暂存环境中经过仔细测试后谨慎使用。
- en: Collection-level options will get propagated to secondaries if applied to a
    primary in a replica set. `block_compressor` can also be configured from the command
    line globally for the database using the `--wiredTigerCollectionBlockCompressor`
    option.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用于复制集中的主要服务器，集合级选项将传播到辅助服务器。`block_compressor`也可以通过使用`--wiredTigerCollectionBlockCompressor`选项全局配置数据库的命令行来进行配置。
- en: WiredTiger performance strategies
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WiredTiger性能策略
- en: As discussed earlier in this chapter, WiredTiger uses an internal cache to optimize
    performance. On top of it, there is always the filesystem cache that the operating
    system (and MMAPv1) uses to fetch data from disk.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章前面讨论的，WiredTiger使用内部缓存来优化性能。此外，操作系统（和MMAPv1）使用文件系统缓存来从磁盘中获取数据。
- en: By default, we have 50% of RAM dedicated to the filesystem cache and 50% to
    the WiredTiger internal cache.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们将50%的RAM专用于文件系统缓存，另外50%专用于WiredTiger内部缓存。
- en: 'The filesystem cache will keep data compressed as it is stored on disk. The
    internal cache will decompress it as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统缓存将保持数据在存储在磁盘上时的压缩状态。内部缓存将按如下方式解压缩：
- en: '**Strategy 1**: Allocate 80% or more to the internal cache. This has the goal
    of fitting our working set in WiredTiger''s internal cache.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略1**：将80%或更多分配给内部缓存。这样可以将我们的工作集适应WiredTiger的内部缓存中。'
- en: '**Strategy 2**: Allocate 80% or more to the filesystem cache. Our goal here
    is to avoid using the internal cache as much as possible, and rely on the filesystem
    cache for our needs.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略2**：将80%或更多分配给文件系统缓存。我们的目标是尽可能避免使用内部缓存，并依赖文件系统缓存来满足我们的需求。'
- en: '**Strategy 3**: Use an SSD as the underlying storage for fast seek time and
    keep defaults at 50-50% allocation.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略3**：使用SSD作为快速搜索时间的基础存储，并将默认值保持在50-50%的分配。'
- en: '**Strategy 4**: Enable compression in our storage layer through MongoDB''s
    configuration to save on storage, and potentially improve our performance by having
    a smaller working set size.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略4**：通过MongoDB的配置在我们的存储层启用压缩，以节省存储空间，并通过减小工作集大小来提高性能。'
- en: Our workload will dictate whether we need to deviate from the default Strategy
    1 to any of the rest. In general, we should use SSDs wherever possible, and with
    MongoDB's configurable storage, we can even use SSDs for some of the nodes where
    we need the best performance and keep HDDs for analytics workloads.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工作负载将决定我们是否需要偏离默认的策略1。一般来说，我们应该尽可能使用SSD，并且通过MongoDB的可配置存储，我们甚至可以在需要最佳性能的一些节点上使用SSD，并将HDD用于分析工作负载。
- en: WiredTiger B-tree versus LSM indexes
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WiredTiger B树与LSM索引
- en: B-tree is the most common data structure for indexes across different database
    systems. WiredTiger offers the option to use a **Log Structured Merge** (**LSM**)
    tree instead of a B-tree for indexing.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: B树是不同数据库系统中索引的最常见数据结构。WiredTiger提供了使用**日志结构合并**（**LSM**）树而不是B树进行索引的选项。
- en: An LSM tree can provide better performance when we have a workload of random
    inserts that would otherwise overflow our page cache and start paging in data
    from disk to keep our index up to date.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有随机插入的工作负载时，LSM树可以提供更好的性能，否则会导致页面缓存溢出，并开始从磁盘中分页数据以保持我们的索引最新。
- en: 'LSM indexes can be selected from the command line like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: LSM索引可以像这样从命令行中选择：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding command chooses `lsm` as `type`, and `block_compressor` is `zlib`
    for indexes in this `mongod` instance.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令选择`lsm`作为`type`，并且在这个`mongod`实例中，`block_compressor`是`zlib`。
- en: Encrypted
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密
- en: The encrypted storage engine was added to support a series of special use cases,
    mostly revolving around finance, retail, healthcare, education, and government.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 加密存储引擎是为支持一系列特殊用例而添加的，主要围绕金融、零售、医疗保健、教育和政府。
- en: 'We need to have encryption for the rest of our data if we have to comply to
    a set of regulations, including the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须遵守一系列法规，包括以下内容，我们需要对其余数据进行加密：
- en: PCI DSS for handling credit card information
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理信用卡信息的PCI DSS
- en: HIPAA for healthcare applications
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 医疗保健应用的HIPAA
- en: NIST for government
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 政府的NIST
- en: FISMA for government
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 政府的FISMA
- en: STIG for government
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 政府的STIG
- en: This can be done in several ways, and cloud service providers, such as EC2,
    provide EBS storage volumes with built-in encryption. Encrypted storage supports
    Intel's AES-NI equipped CPUs for acceleration of the encryption/decryption process.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过几种方式来实现，云服务提供商（如EC2）提供了内置加密的EBS存储卷。加密存储支持英特尔的AES-NI配备的CPU，以加速加密/解密过程。
- en: 'The encryption algorithms supported are the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的加密算法如下：
- en: AES-256, CBC (default)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AES-256，CBC（默认）
- en: AES-256, GCM
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AES-256，GCM
- en: FIPS, FIPS-140-2
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FIPS，FIPS-140-2
- en: Encryption is supported at page level for better performance. When a change
    is made in a document, instead of re-encrypting/decrypting the entire underlying
    file, only the page that is affected gets modified.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 加密支持页面级别的更好性能。当文档中进行更改时，只需修改受影响的页面，而不是重新加密/解密整个底层文件。
- en: Encryption key management is a huge aspect of encrypted storage security. Most
    specifications previously mentioned require key rotation at least once per year.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 加密密钥管理是加密存储安全性的一个重要方面。大多数先前提到的规范要求至少每年进行一次密钥轮换。
- en: MongoDB's encrypted storage uses an internal database key per node. This key
    is wrapped by an external (master) key that must be used to start the node's `mongod`
    process. By using the underlying operating system's protection mechanisms such
    as `mlock` or `VirtualLock`, MongoDB can guarantee that the external key will
    never be leaked from memory to disk by page faults.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB的加密存储使用每个节点的内部数据库密钥。这个密钥由一个外部（主）密钥包装，必须用于启动节点的`mongod`进程。通过使用底层操作系统的保护机制，如`mlock`或`VirtualLock`，MongoDB可以保证外部密钥永远不会因页面错误从内存泄漏到磁盘。
- en: The external (master) key can be managed either by using the **Key Management
    Interoperability Protocol** (**KMIP**) or by using local key management via a
    keyfile.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 外部（主）密钥可以通过使用**密钥管理互操作性协议**（**KMIP**）或通过使用密钥文件进行本地密钥管理来管理。
- en: MongoDB can achieve key rotation by performing rolling restarts of the replica
    set members. Using KMIP, MongoDB can rotate only the external key and not the
    underlying database files. This delivers significant performance benefits.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB可以通过对副本集成员执行滚动重启来实现密钥轮换。使用KMIP，MongoDB可以仅轮换外部密钥而不是底层数据库文件。这带来了显著的性能优势。
- en: Using KMIP is the recommended approach for encrypted data storage. Encrypted
    storage is based on WiredTiger, so all its advantages can be enjoyed using encryption
    as well. Encrypted storage is a part of MongoDB Enterprise Edition, the paid offering
    by MongoDB.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用KMIP是加密数据存储的推荐方法。加密存储基于WiredTiger，因此可以使用加密来享受其所有优势。加密存储是MongoDB企业版的一部分，这是MongoDB的付费产品。
- en: Using MongoDB's encrypted storage gives the advantage of increased performance
    versus encrypted storage volumes. MongoDB's encrypted storage has an overhead
    of around 15% as compared to 25% or more for third-party encrypted storage solutions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MongoDB的加密存储可以提高性能，相对于加密存储卷。与第三方加密存储解决方案相比，MongoDB的加密存储的开销约为15%，而第三方加密存储解决方案的开销为25%或更高。
- en: In most cases, if we need to use encrypted storage, we will know it well in
    advance from the application design phase, and we can perform benchmarks against
    different solutions to choose the one that best fits our use case.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，如果我们需要使用加密存储，我们将在应用程序设计阶段提前知道，并且可以对不同的解决方案进行基准测试，以选择最适合我们用例的解决方案。
- en: In-memory
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存中
- en: MongoDB storage in-memory is a risky task with high rewards. Keeping data in-memory
    can be up to 100,000 times faster than durable storage on disk.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中存储MongoDB是一项高风险的任务，但回报很高。将数据保留在内存中的速度可能比在磁盘上持久存储快100,000倍。
- en: Another advantage of using in-memory storage is that we can achieve predictable
    latency when we write or read data. Some use cases dictate for latency that does
    not deviate from normal, no matter what the operation is.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内存存储的另一个优势是，我们在写入或读取数据时可以实现可预测的延迟。一些用例要求延迟不论操作是什么都不偏离正常。
- en: On the other hand, by keeping data in-memory we are open to power loss and application
    failure where we can lose all of our data. Using a replica set can safeguard against
    some classes of errors, but we will always be more exposed to data loss if we
    store in data as opposed to storing on disk.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，通过将数据保留在内存中，我们面临断电和应用程序故障的风险，可能会丢失所有数据。使用副本集可以防范某些类别的错误，但如果我们将数据存储在内存中而不是存储在磁盘上，我们将始终更容易面临数据丢失。
- en: 'However, there are some use cases in which we may not care that much about
    losing older data. For example, in the financial world we may have the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些用例，我们可能不太在乎丢失旧数据。例如，在金融领域，我们可能有以下情况：
- en: High-frequency trading/algorithmic trading, where higher latency in the case
    of high traffic can lead to transactions not being fulfilled
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高频交易/算法交易，高流量情况下更高的延迟可能导致交易无法完成
- en: In fraud detection systems, we are concerned about real-time detection being
    as fast as possible and we can safely store only the cases that require further
    investigation, or the definitely positive ones, to durable storage
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在欺诈检测系统中，我们关心的是尽可能快地进行实时检测，并且我们可以安全地将只需要进一步调查的案例或明确的阳性案例存储到持久存储中。
- en: Credit card authorizations, trade ordering reconciliation, and other high-traffic
    systems that demand a real-time answer
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信用卡授权、交易订单对账和其他需要实时答复的高流量系统
- en: 'In the web applications ecosystem we have the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序生态系统中，我们有以下内容：
- en: In intrusion detection systems, such as fraud detection, we are concerned with
    detecting intrusion as fast as possible without so much concern for false positive
    cases.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在入侵检测系统中，如欺诈检测，我们关心的是尽可能快地检测入侵，而对假阳性案例并不那么关心。
- en: In the case of the product search cache, losing data is not mission-critical,
    but rather a small inconvenience from the customer's perspective.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在产品搜索缓存的情况下，数据丢失并不是使命关键，而是从客户的角度来看是一个小不便。
- en: For real-time personalized product recommendations, there is a low-risk operation
    in terms of data loss. We can always rebuild the index even if we suffer data
    loss.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于实时个性化产品推荐来说，数据丢失的风险较低。即使我们遭受数据丢失，我们也可以重新构建索引。
- en: A major disadvantage of an in-memory storage engine is that our dataset has
    to fit in-memory. This means we must know and keep track of our data usage so
    we don't exceed the memory of our server.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 内存存储引擎的一个主要缺点是我们的数据集必须适合内存。这意味着我们必须了解并跟踪我们的数据使用情况，以免超出服务器的内存。
- en: Overall, using the MongoDB in-memory storage engine may be useful in some edge
    use cases, but lacking durability in a database system can be a blocking factor
    in its adoption.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，在某些边缘用例中使用MongoDB内存存储引擎可能是有用的，但在数据库系统中缺乏耐久性可能是其采用的一个阻碍因素。
- en: In-memory storage is part of MongoDB Enterprise Edition, the paid offering by
    MongoDB.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 内存存储是MongoDB企业版的一部分，这是MongoDB的付费产品。
- en: MMAPv1
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MMAPv1
- en: With the introduction of WiredTiger and its many benefits, such as document-level
    locking, many MongoDB users are questioning whether it's worth discussing MMAPv1
    anymore.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 随着WiredTiger的引入及其许多好处，如文档级别锁定，许多MongoDB用户开始质疑是否还值得讨论MMAPv1。
- en: 'In reality, the only cases where we should consider using MMAPv1 instead of
    WiredTiger would be the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们应该考虑在以下情况下使用MMAPv1而不是WiredTiger：
- en: '**Legacy systems**: If we have a system that fits our needs, we may upgrade
    to MongoDB 3.0+ and not transition to WiredTiger.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传统系统**：如果我们有一个适合我们需求的系统，我们可以升级到MongoDB 3.0+，而不转换到WiredTiger。'
- en: '**Version downgrade**: Once we upgrade to MongoDB 3.0+ and convert our storage
    to WiredTiger, we cannot downgrade to a version lower than 2.6.8\. This should
    be kept in mind if we want the flexibility to downgrade at a later time.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本降级**：一旦我们升级到MongoDB 3.0+并将存储转换为WiredTiger，我们就无法降级到低于2.6.8的版本。如果我们希望在以后有灵活性进行降级，这一点应该牢记在心。'
- en: As shown previously, WiredTiger is a better choice than MMAPv1, and we should
    use it whenever we get the chance. This book is oriented around WiredTiger, and
    assumes we will be able to use the latest stable version of MongoDB (3.4 at the
    time of writing).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所示，WiredTiger比MMAPv1更好，我们应该在有机会时使用它。本书以WiredTiger为中心，并假设我们将能够使用MongoDB的最新稳定版本（写作时为3.4）。
- en: MMAPv1, as of version 3.4, only supports collection-level locking, as opposed
    to the document-level locking supported by WiredTiger. This can lead to a performance
    penalty in high contention database loads and is one of the main reasons why we
    should use WiredTiger whenever possible.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从3.4版本开始，MMAPv1仅支持集合级别的锁定，而不支持WiredTiger支持的文档级别锁定。这可能会导致高争用数据库负载的性能损失，这是我们尽可能使用WiredTiger的主要原因之一。
- en: MMAPv1 storage optimization
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MMAPv1存储优化
- en: MongoDB, by default, uses the power-of-two allocation strategy. When a document
    is created it will get allocated a power of size two. That is, `ceiling(document_size)`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB默认使用二次幂分配策略。创建文档时，它将被分配为二次幂大小。也就是说，`ceiling(document_size)`。
- en: For example, if we create a document of 127 bytes, MongoDB will allocate 128
    bytes (*2^7*), while if we create a document of 129 bytes, MongoDB will allocate
    256 bytes (*2^8*). This is helpful when updating documents, as we can update them
    and not move the underlying document on disk until it exceeds the space allocated.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们创建一个127字节的文档，MongoDB将分配128字节（*2^7*），而如果我们创建一个129字节的文档，MongoDB将分配256字节（*2^8*）。这在更新文档时很有帮助，因为我们可以更新它们而不移动底层文档，直到超出分配的空间。
- en: If a document is moved on disk (that is, adding a new subdocument or an element
    in an array of the document that forces the size to exceed the allocated storage),
    a new power-of-two allocation size will be used.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文档在磁盘上移动（即向文档的数组中添加一个新的子文档或元素，使其大小超过分配的存储空间），将使用新的二次幂分配大小。
- en: If the operation doesn't affect its size (that is, changing an integer value
    from one to two), the document will remain stored in the same physical location
    on disk. This concept is called **padding**. We can configure padding using the
    compact administration command as well.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作不影响其大小（即将整数值从一个更改为两个），文档将保持存储在磁盘上的相同物理位置。这个概念被称为**填充**。我们也可以使用紧凑的管理命令来配置填充。
- en: When we move documents on disk, we have non-contiguous blocks of data stored,
    essentially holes in storage. We can prevent this from happening by setting `paddingFactor`
    at collection level.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在磁盘上移动文档时，我们存储的是非连续的数据块，实质上是存储中的空洞。我们可以通过在集合级别设置`paddingFactor`来防止这种情况发生。
- en: '`paddingFactor` has a default value of `1.0` (no padding) and a maximum of
    `4.0` (expanding size by three times as much as the original document size). For
    example, `paddingFactor` of `1.4` will allow the document to expand by 40% before
    getting moved on to a new location on disk.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`paddingFactor`的默认值为`1.0`（无填充），最大值为`4.0`（将文档大小扩展三倍）。例如，`paddingFactor`为`1.4`将允许文档在被移动到磁盘上的新位置之前扩展40%。'
- en: 'For example, with our favorite `books` collection, to get 40% more space, we
    would do the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于我们喜爱的`books`集合，要获得40%的额外空间，我们将执行以下操作：
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can also set padding in terms of bytes per document. This way we get *x*
    bytes padding from the initial creation of each document in our collection:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以根据每个文档的字节设置填充。这样我们就可以从集合中每个文档的初始创建中获得*x*字节的填充：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will allow a document created at 200 bytes to grow to 500 bytes, while
    a document created at 4,000 bytes will be allowed to grow to 4,300 bytes.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许一个在200字节时创建的文档增长到500字节，而一个在4000字节时创建的文档将被允许增长到4300字节。
- en: We can eliminate holes altogether by running a `compact` command with no parameters,
    but this means that every update that increases document size will have to move
    documents, essentially creating new holes in storage.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行`compact`命令来完全消除空洞，但这意味着每次增加文档大小的更新都必须移动文档，从根本上在存储中创建新的空洞。
- en: Mixed usage
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合使用
- en: When we have an application with MongoDB as the underlying database, we can
    set it up to use different replica sets for different operations at application
    level, matching their requirements.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序以MongoDB作为基础数据库时，我们可以在应用程序级别为不同操作设置不同的副本集，以满足它们的需求。
- en: 'For example, in our financial application, we can use one connection pool for
    the fraud detection module utilizing in-memory nodes, and a different one for
    the rest of our system, shown as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的金融应用程序中，我们可以使用一个连接池来进行欺诈检测模块，利用内存节点，并为我们系统的其他部分使用另一个连接池，如下所示：
- en: '![](img/2eb80ef3-4570-4763-a401-27e581114ac0.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2eb80ef3-4570-4763-a401-27e581114ac0.png)'
- en: In addition, storage engine configuration in MongoDB is applied per node, which
    allows for some interesting setups.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，MongoDB中的存储引擎配置是针对每个节点应用的，这允许一些有趣的设置。
- en: As shown in the preceding architectural diagram, we can use a mix of different
    storage engines in different members of a replica set. In this case, we are using
    the in-memory engine for optimal performance in the primary node, while one of
    the secondaries uses WiredTiger to ensure data durability. We can use `priority=1`
    in the in-memory secondary node to make sure that, if the primary fails, the secondary
    will get elected right away. If we don't do it, we risk having a failing primary
    server exactly when we have high load in the system, and the secondary has not
    kept up with the primary's writes in-memory.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的架构图所示，我们可以在副本集的不同成员中使用不同的存储引擎的混合。在这种情况下，我们在主节点中使用内存引擎以获得最佳性能，而其中一个从节点使用WiredTiger以确保数据的持久性。我们可以在内存从节点中使用`priority=1`来确保，如果主节点失败，从节点将立即被选中。如果我们不这样做，我们就有可能在系统负载很高时出现主服务器故障，而从节点没有及时跟上主服务器的内存写入。
- en: The mixed storage approach is widely used in the microservice architecture.
    By decoupling service and database and using the appropriate database for each
    use case, we can easily horizontally scale our infrastructure.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 混合存储方法广泛应用于微服务架构中。通过解耦服务和数据库，并针对每个用例使用适当的数据库，我们可以轻松地水平扩展我们的基础架构。
- en: 'All storage engines support a common baseline functionality, such as the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所有存储引擎都支持一些共同的基线功能，例如以下内容：
- en: Querying
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询
- en: Indexing
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引
- en: Replication
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制
- en: Sharding
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分片
- en: Ops and Cloud Manager support
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ops和Cloud Manager支持
- en: Authentication and authorization semantics
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证和授权语义
- en: Other storage engines
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他存储引擎
- en: Modular MongoDB architecture allows for third parties to develop their own storage
    engines.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化的MongoDB架构允许第三方开发他们自己的存储引擎。
- en: RocksDB
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RocksDB
- en: RocksDB is an embedded database for key-value data. It's a fork of `LevelDB`
    storing key-value pairs in arbitrary byte arrays. It was started at Facebook in
    2012, and now serves as the backend for the interestingly named **CockroachDB**,
    the open source DB inspired by Google Spanner.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: RocksDB是一个用于键值数据的嵌入式数据库。它是`LevelDB`的一个分支，存储任意字节数组中的键值对。它于2012年在Facebook启动，现在作为名为**CockroachDB**的开源DB的后端服务，该DB受到Google
    Spanner的启发。
- en: MongoRocks is a project backed by Percona and Facebook aiming to bring RocksDB
    backend to MongoDB. RocksDB can achieve higher performance than WiredTiger for
    some workloads, and is worth investigating.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: MongoRocks是由Percona和Facebook支持的项目，旨在将RocksDB后端引入MongoDB。对于某些工作负载，RocksDB可以实现比WiredTiger更高的性能，并值得研究。
- en: TokuMX
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TokuMX
- en: Another widely used storage engine is TokuMX by Percona. TokuMX was designed
    with both MySQL and MongoDB in mind, but since 2016, Percona has focused its efforts
    on the MySQL version, instead switching over to **RocksDB** for MongoDB storage
    support.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个广泛使用的存储引擎是Percona的TokuMX。TokuMX是为MySQL和MongoDB设计的，但自2016年以来，Percona已将其重点放在了MySQL版本上，而不是切换到**RocksDB**以支持MongoDB存储。
- en: Locking in MongoDB
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB中的锁定
- en: Document-level and collection-level locking is mentioned throughout this chapter
    and also in several other chapters in this book. It is important to understand
    how locking works and why it is important.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 文档级和集合级锁定在本章中以及本书的其他几章中都有提到。了解锁定的工作原理以及其重要性是很重要的。
- en: Database systems use the concept of locks to achieve ACID properties. When there
    are multiple read or write requests coming in parallel, we need to lock our data
    so that all readers and writers have consistent and predictable results.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库系统使用锁的概念来实现ACID属性。当有多个读取或写入请求并行进行时，我们需要锁定我们的数据，以便所有读者和写入者都能获得一致和可预测的结果。
- en: 'MongoDB uses multi-granularity locking. The available granularity levels in
    descending order are as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB使用多粒度锁定。可用的粒度级别按降序排列如下：
- en: Global
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局
- en: Database
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库
- en: Collection
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: Document
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档
- en: 'The locks that MongoDB and other databases use are the following, in order
    of granularity:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB和其他数据库使用的锁按粒度顺序如下：
- en: '*IS*: Intent shared'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*IS*：意向共享'
- en: '*IX*: Intent exclusive'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*IX*：意向排他'
- en: '*S*: Shared'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*S*：共享'
- en: '*X*: Exclusive'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*X*：排他'
- en: If we use locking at a granularity level with *S* or *X* locks, then all higher
    levels need to be locked with an intent lock of the same type.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在粒度级别使用*S*或*X*锁，那么所有更高级别都需要使用相同类型的意向锁进行锁定。
- en: 'Other rules for locks are as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 锁的其他规则如下：
- en: A single database can simultaneously be locked in *IS* and *IX* mode
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数据库可以同时以*IS*和*IX*模式被锁定
- en: An exclusive (*X*) lock cannot coexist with any other lock
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排他（*X*）锁不能与任何其他锁共存
- en: A shared (*S*) lock can only coexist with *IS* locks
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享（*S*）锁只能与*IS*锁共存
- en: Reads and writes requesting locks are generally queued in **first-in, first-out**
    (**FIFO**) order. The only optimization that MongoDB will actually do is reordering
    requests according to the next request in queue to be serviced.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 读取和写入请求锁通常按照**先进先出**（**FIFO**）顺序排队。MongoDB实际上会做的唯一优化是根据队列中的下一个请求重新排序请求以便服务。
- en: 'What this means is that if we have an *IS(1)* request coming up next and our
    current queue has the following *IS(1)->IS(2)->X(3)->S(4)->IS(5)* as shown in
    the following screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果我们有一个*IS(1)*请求即将到来，而我们当前的队列如下*IS(1)->IS(2)->X(3)->S(4)->IS(5)*，如下截图所示：
- en: '![](img/eaed832c-b511-4484-a5cc-34840526172f.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eaed832c-b511-4484-a5cc-34840526172f.png)'
- en: 'Then MongoDB will reorder requests like this, *IS(1)->IS(2)->S(4)->IS(5)->X(3)
    a*s shown in the following screenshot:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后MongoDB会重新排序请求，如下，*IS(1)->IS(2)->S(4)->IS(5)->X(3)*，如下截图所示：
- en: '![](img/ac8c0989-a235-4176-ab63-e60ea5fa7742.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac8c0989-a235-4176-ab63-e60ea5fa7742.png)'
- en: If, during servicing, the *IS(1)* request, new *IS*, or *S* requests come in,
    let's say *IS(6)* and *S(7),* in that order, they will still be added at the end
    of the queue and won't be considered until the *X(3)* request is done with.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在服务过程中，*IS(1)*请求、新的*IS*或*S*请求进来，比如*IS(6)*和*S(7)*，它们仍将被添加到队列的末尾，并且在*X(3)*请求完成之前不会被考虑。
- en: 'Our new queue will now look like *IS(2)->S(4)->IS(5)->X(3)->IS(6)->S(7)*:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新队列现在看起来是*IS(2)->S(4)->IS(5)->X(3)->IS(6)->S(7)*：
- en: '![](img/00940bca-eff2-4efe-9fb7-00c1e0ea3676.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00940bca-eff2-4efe-9fb7-00c1e0ea3676.png)'
- en: This is done to prevent the starvation of the *X(3)* request that would end
    up getting pushed back in the queue all the time because new *IS* and *S* requests
    come in. It is important to understand the difference between intent locks and
    locks themselves. WiredTiger storage engine will only use intent locks for global,
    database, and collection levels.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了防止*X(3)*请求被饿死，因为新的*IS*和*S*请求不断进来而不断被推迟。重要的是要理解意向锁和锁本身之间的区别。WiredTiger存储引擎只会在全局、数据库和集合级别使用意向锁。
- en: 'It uses intent locks at higher levels (that is, collection, database, global),
    when a new request comes in and according to the compatibility matrix as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当新请求进来时，它在更高级别（即集合、数据库、全局）使用意向锁，并根据以下兼容性矩阵：
- en: '![](img/0bf12ed6-cd4a-4da4-80fd-b0b1df10bca9.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0bf12ed6-cd4a-4da4-80fd-b0b1df10bca9.png)'
- en: MongoDB will first acquire intention locks in all ancestors before acquiring
    the lock on the document itself. This way, when a new request comes in, it can
    quickly identify if it cannot be serviced based on less granular locks.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB在获取文档本身的锁之前，会首先获取所有祖先的意向锁。这样，当新请求进来时，它可以快速确定是否无法基于更少粒度的锁提供服务。
- en: WiredTiger will use *S* and *X* locks at the document level. The only exception
    to that is for typically infrequent and/or short-lived operations involving multiple
    databases. These will still require a global lock, similar to the behavior MongoDB
    had in pre 2.x versions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: WiredTiger将在文档级别使用*S*和*X*锁。唯一的例外是通常不频繁和/或短暂的涉及多个数据库的操作。这些操作仍然需要全局锁，类似于MongoDB在2.x之前版本的行为。
- en: Administrative operations, such as dropping a collection, still require an exclusive
    database lock.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 管理操作，例如删除集合，仍然需要独占数据库锁。
- en: MMAPv1, as explained previously, uses collection-level locks. Operations that
    span a single collection, but may or may not be spanning a single document, will
    still lock up the entire collection. This is the main reason why WiredTiger is
    the preferred storage solution for all new deployments.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前解释的那样，MMAPv1使用集合级别的锁。跨越单个集合但可能或可能不跨越单个文档的操作仍然会锁定整个集合。这是为什么WiredTiger是所有新部署的首选存储解决方案的主要原因。
- en: Lock reporting
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁报告
- en: 'We can inspect lock status using any of the following tools and commands:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下任何工具和命令来检查锁状态：
- en: '`db.serverStatus()` through the `locks` document'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`locks`文档的`db.serverStatus()`
- en: '`db.currentOp()` through the `locks` field'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`locks`字段的`db.currentOp()`
- en: '`mongotop`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mongotop`'
- en: '`mongostat`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mongostat`'
- en: MongoDB Cloud Manager
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB Cloud Manager
- en: MongoDB Ops Manager
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB Ops Manager
- en: Lock contention is a really important metric to keep track of, as it can bring
    our database to its knees if it grows out of control.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 锁争用是一个非常重要的指标，因为如果它失控，可能会使我们的数据库陷入困境。
- en: If we want to terminate an operation, we have to use the `db.killOp()` shell
    command.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想终止一个操作，我们必须使用`db.killOp()` shell命令。
- en: Lock yield
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁让渡
- en: A database with a database-level lock will not be really useful under stress,
    and will end being locked up most of the time. A smart solution to that in the
    early versions of MongoDB was getting operations to yield their locks on the basis
    of some heuristics.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 具有数据库级别锁的数据库在压力下将不会真正有用，并且最终将大部分时间被锁定。在MongoDB早期版本中的一个聪明的解决方案是根据一些启发式原则使操作释放它们的锁。
- en: '`update()` commands affecting multiple documents would yield their *X* lock
    to improve concurrency.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 影响多个文档的`update()`命令将释放它们的*X*锁以提高并发性。
- en: MMAPv1's predecessor in earlier versions of MongoDB would use these heuristics
    to predict whether data was already in-memory before performing the requested
    operation. If it wasn't, it would yield the lock until the underlying operating
    system pages data in-memory, and then re-acquire the lock to continue with servicing
    the request.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB早期版本中，MMAPv1的前身会使用这些启发式方法来预测请求的操作之前数据是否已经在内存中。如果没有，它会释放锁，直到底层操作系统将数据加载到内存中，然后重新获取锁以继续处理请求。
- en: The most notable exceptions to these are index scans, where the operation will
    not yield its lock and will just block on waiting for the data to get loaded from
    disk.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最显著的例外是索引扫描，该操作不会释放其锁，并且会在等待数据从磁盘加载时阻塞。
- en: Since WiredTiger is only using intent locks at collection level and above, it
    doesn't really need these heuristics, as intent locks don't block other readers
    and writers.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于WiredTiger仅在集合级别及以上使用意向锁，因此它实际上不需要这些启发式方法，因为意向锁不会阻塞其他读者和写者。
- en: Commonly used commands and locks
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常用命令和锁
- en: 'The commonly used commands and locks are as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 常用命令和锁如下：
- en: '| **Command** | **Lock** |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **锁** |'
- en: '| `find()` | *S* |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `find()` | *S* |'
- en: '| `it() (query cursor)` | *S* |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `it() (查询游标)` | *S* |'
- en: '| `insert()` | *X* |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `insert()` | *X* |'
- en: '| `remove()` | *X* |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `remove()` | *X* |'
- en: '| `update()` | *X* |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `update()` | *X* |'
- en: '| `mapreduce()` | Both *S* and *X*, depending on the case. Some MapReduce chunks
    can run in parallel. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `mapreduce()` | 根据情况为*S*和*X*。一些MapReduce块可以并行运行。 |'
- en: '| `index()` |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `index()` |'
- en: '**Foreground indexing**: Database lock.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前台索引**：数据库锁。'
- en: '**Background indexing**: No lock, except for administrative commands that will
    return an error. Also, background indexing will take considerably more time.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后台索引**：无锁，除了会返回错误的管理命令。此外，后台索引将花费更多的时间。'
- en: '|'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `aggregate()` | *S* |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `aggregate()` | *S* |'
- en: Commands requiring a database lock
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要数据库锁的命令
- en: 'The following commands require a database lock. We should plan in advance before
    issuing them in a production environment:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令需要数据库锁。在生产环境中发布这些命令之前，我们应该提前计划：
- en: '`db.collection.createIndex()` in the (default) foreground mode'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.collection.createIndex()` 使用（默认）前台模式'
- en: '`reIndex`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reIndex`'
- en: '`compact`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compact`'
- en: '`db.repairDatabase()`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.repairDatabase()`'
- en: '`db.createCollection()` if creating a multiple GB capped collection'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.createCollection()` 如果创建一个多GB的固定大小集合'
- en: '`db.collection.validate()`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.collection.validate()`'
- en: '`db.copyDatabase()`, which may lock more than one database'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.copyDatabase()`，可能会锁定多个数据库'
- en: 'We also have some commands that lock the entire database for a really short
    period of time:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些命令会在非常短的时间内锁定整个数据库：
- en: '`db.collection.dropIndex()`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.collection.dropIndex()`'
- en: '`db.getLastError()`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.getLastError()`'
- en: '`db.isMaster()`'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.isMaster()`'
- en: Any `rs.status()` command
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何`rs.status()`命令
- en: '`db.serverStatus()`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.serverStatus()`'
- en: '`db.auth()`'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.auth()`'
- en: '`db.addUser()`'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.addUser()`'
- en: These commands shouldn't take more than a few milliseconds to operate and so
    we shouldn't worry about it, unless we have automated scripts with these commands
    in place, in which case we must take note to throttle how often they would occur.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令不应该花费超过几毫秒的时间，所以我们不用担心，除非我们有使用这些命令的自动化脚本，那么我们必须注意限制它们发生的频率。
- en: In a sharded environment, each `mongod` applies its own locks, thus greatly
    improving concurrency.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在分片环境中，每个`mongod`都会应用自己的锁，从而大大提高并发性。
- en: In replica sets, our primary server must take all write operations. For these
    to be replicated correctly to the secondaries we must lock the local database
    that holds the oplog of operations at the same time that we lock our primary document/collection/database.
    This is usually a short-lived lock that, again, we shouldn't worry about.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在副本集中，我们的主服务器必须执行所有写操作。为了正确地将它们复制到辅助节点，我们必须同时锁定保存操作的oplog的本地数据库和我们的主要文档/集合/数据库。这通常是一个短暂的锁，我们不用担心。
- en: Secondaries in replica sets will fetch write operations from the primary local
    database's oplog, apply the appropriate *X* lock, and apply service reads once
    the *X* locks are done with.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 副本集中的辅助节点将从主要本地数据库的oplog中获取写操作，应用适当的*X*锁，并在*X*锁完成后应用服务读取。
- en: From the long preceding explanation, it's evident that locking should be avoided
    at all costs in MongoDB. We should design our database so that we avoid as many
    *X* locks as possible, and when we need to take *X* locks over one or multiple
    databases, do so in a maintenance window with a backup plan in case operations
    take longer than expected.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的长篇解释中，很明显在MongoDB中应该尽量避免锁定。我们应该设计我们的数据库，以尽量避免尽可能多的*X*锁，并且当我们需要在一个或多个数据库上获取*X*锁时，在维护窗口中执行，并制定备份计划以防操作时间超出预期。
- en: Further reading
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can refer to the following links for further reference:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下链接以获取更多信息：
- en: '[https://docs.mongodb.com/manual/faq/concurrency/](https://docs.mongodb.com/manual/faq/concurrency/)'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.mongodb.com/manual/faq/concurrency/](https://docs.mongodb.com/manual/faq/concurrency/)'
- en: '[https://docs.mongodb.com/manual/core/storage-engines/](https://docs.mongodb.com/manual/core/storage-engines/)'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.mongodb.com/manual/core/storage-engines/](https://docs.mongodb.com/manual/core/storage-engines/)'
- en: '[https://www.mongodb.com/blog/post/building-applications-with-mongodbs-pluggable-storage-engines-part-1](https://www.mongodb.com/blog/post/building-applications-with-mongodbs-pluggable-storage-engines-part-1)'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.mongodb.com/blog/post/building-applications-with-mongodbs-pluggable-storage-engines-part-1](https://www.mongodb.com/blog/post/building-applications-with-mongodbs-pluggable-storage-engines-part-1)'
- en: '[https://www.mongodb.com/blog/post/building-applications-with-mongodbs-pluggable-storage-engines-part-2](https://www.mongodb.com/blog/post/building-applications-with-mongodbs-pluggable-storage-engines-part-2?jmp=docs&_ga=2.154506616.1736193377.1502822527-355279797.1491859629)'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.mongodb.com/blog/post/building-applications-with-mongodbs-pluggable-storage-engines-part-2](https://www.mongodb.com/blog/post/building-applications-with-mongodbs-pluggable-storage-engines-part-2?jmp=docs&_ga=2.154506616.1736193377.1502822527-355279797.1491859629)'
- en: '[https://docs.mongodb.com/manual/core/wiredtiger/](https://docs.mongodb.com/manual/core/wiredtiger/)'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.mongodb.com/manual/core/wiredtiger/](https://docs.mongodb.com/manual/core/wiredtiger/)'
- en: '[https://docs.mongodb.com/manual/reference/method/db.collection.createIndex/#createindex-options](https://docs.mongodb.com/manual/reference/method/db.collection.createIndex/#createindex-options)'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.mongodb.com/manual/reference/method/db.collection.createIndex/#createindex-options](https://docs.mongodb.com/manual/reference/method/db.collection.createIndex/#createindex-options)'
- en: '[https://docs.mongodb.com/manual/core/mmapv1/](https://docs.mongodb.com/manual/core/mmapv1/)'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.mongodb.com/manual/core/mmapv1/](https://docs.mongodb.com/manual/core/mmapv1/)'
- en: '[https://docs.mongodb.com/manual/reference/method/db.createCollection/#create-collection-storage-engine-options](https://docs.mongodb.com/manual/reference/method/db.createCollection/#create-collection-storage-engine-options)'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.mongodb.com/manual/reference/method/db.createCollection/#create-collection-storage-engine-options](https://docs.mongodb.com/manual/reference/method/db.createCollection/#create-collection-storage-engine-options)'
- en: '[http://source.wiredtiger.com/mongodb-3.4/struct_w_t___s_e_s_s_i_o_n.html](http://source.wiredtiger.com/mongodb-3.4/struct_w_t___s_e_s_s_i_o_n.html)'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://source.wiredtiger.com/mongodb-3.4/struct_w_t___s_e_s_s_i_o_n.html](http://source.wiredtiger.com/mongodb-3.4/struct_w_t___s_e_s_s_i_o_n.html)'
- en: '[https://webassets.mongodb.com/microservices_white_paper.pdf?_ga=2.158920114.90404900.1503061618-355279797.1491859629](https://webassets.mongodb.com/microservices_white_paper.pdf?_ga=2.158920114.90404900.1503061618-355279797.1491859629)'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://webassets.mongodb.com/microservices_white_paper.pdf?_ga=2.158920114.90404900.1503061618-355279797.1491859629](https://webassets.mongodb.com/microservices_white_paper.pdf?_ga=2.158920114.90404900.1503061618-355279797.1491859629)'
- en: '[https://webassets.mongodb.com/storage_engines_adress_wide_range_of_use_cases.pdf?_ga=2.125749506.90404900.1503061618-355279797.1491859629](https://webassets.mongodb.com/storage_engines_adress_wide_range_of_use_cases.pdf?_ga=2.125749506.90404900.1503061618-355279797.1491859629)'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://webassets.mongodb.com/storage_engines_adress_wide_range_of_use_cases.pdf?_ga=2.125749506.90404900.1503061618-355279797.1491859629](https://webassets.mongodb.com/storage_engines_adress_wide_range_of_use_cases.pdf?_ga=2.125749506.90404900.1503061618-355279797.1491859629)'
- en: '[https://docs.mongodb.com/manual/reference/method/db.createCollection/#create-collection-storage-engine-options](https://docs.mongodb.com/manual/reference/method/db.createCollection/#create-collection-storage-engine-options)'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.mongodb.com/manual/reference/method/db.createCollection/#create-collection-storage-engine-options](https://docs.mongodb.com/manual/reference/method/db.createCollection/#create-collection-storage-engine-options)'
- en: '[http://source.wiredtiger.com/mongodb-3.4/struct_w_t___s_e_s_s_i_o_n.html](http://source.wiredtiger.com/mongodb-3.4/struct_w_t___s_e_s_s_i_o_n.html)'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://source.wiredtiger.com/mongodb-3.4/struct_w_t___s_e_s_s_i_o_n.html](http://source.wiredtiger.com/mongodb-3.4/struct_w_t___s_e_s_s_i_o_n.html)'
- en: '[https://docs.mongodb.com/manual/reference/read-concern/](https://docs.mongodb.com/manual/reference/read-concern/)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.mongodb.com/manual/reference/read-concern/](https://docs.mongodb.com/manual/reference/read-concern/)'
- en: '[https://www.percona.com/live/17/sessions/comparing-mongorocks-wiredtiger-and-mmapv1-performance-and-efficiency](https://www.percona.com/live/17/sessions/comparing-mongorocks-wiredtiger-and-mmapv1-performance-and-efficiency)'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.percona.com/live/17/sessions/comparing-mongorocks-wiredtiger-and-mmapv1-performance-and-efficiency](https://www.percona.com/live/17/sessions/comparing-mongorocks-wiredtiger-and-mmapv1-performance-and-efficiency)'
- en: '[https://www.percona.com/blog/2016/06/01/embracing-mongorocks/](https://www.percona.com/blog/2016/06/01/embracing-mongorocks/)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.percona.com/blog/2016/06/01/embracing-mongorocks/](https://www.percona.com/blog/2016/06/01/embracing-mongorocks/)'
- en: '[https://www.percona.com/software/mongo-database/percona-tokumx](https://www.percona.com/software/mongo-database/percona-tokumx)'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.percona.com/software/mongo-database/percona-tokumx](https://www.percona.com/software/mongo-database/percona-tokumx)'
- en: '[https://www.slideshare.net/profyclub_ru/4-understanding-and-tuning-wired-tiger-the-new-high-performance-database-engine-in-mongodb-henrik-ingo-mongodb](https://www.slideshare.net/profyclub_ru/4-understanding-and-tuning-wired-tiger-the-new-high-performance-database-engine-in-mongodb-henrik-ingo-mongodb/27)'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.slideshare.net/profyclub_ru/4-understanding-and-tuning-wired-tiger-the-new-high-performance-database-engine-in-mongodb-henrik-ingo-mongodb](https://www.slideshare.net/profyclub_ru/4-understanding-and-tuning-wired-tiger-the-new-high-performance-database-engine-in-mongodb-henrik-ingo-mongodb/27)'
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about different storage engines in MongoDB. We identified
    the pros and cons of each one and the use cases for choosing each storage engine.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了MongoDB中不同的存储引擎。我们确定了每种存储引擎的优缺点以及选择每种存储引擎的用例。
- en: We learned about using multiple storage engines, how we can use them, and the
    benefits. A big part of this chapter was also dedicated to database locking, how
    it can happen, why it is bad, and how we can avoid it.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用多个存储引擎，我们如何使用它们以及它们的好处。本章的很大一部分也专门讨论了数据库锁定，它可能发生的原因，为什么它是不好的，以及我们如何避免它。
- en: We split our operations by the lock they need. This way, when we design and
    implement our application, we can make sure that we have a design that locks our
    database as little as possible.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据它们需要的锁将操作分开。这样，当我们设计和实现应用程序时，我们可以确保我们有一个尽可能少锁定我们数据库的设计。
- en: In the next chapter, we will learn about MongoDB and how we can use it to ingest
    and process big data.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习MongoDB以及如何使用它来摄取和处理大数据。
