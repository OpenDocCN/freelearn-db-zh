- en: Chapter 2. Working with Databases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。与数据库一起工作
- en: 'In the previous chapter, we saw how to set up different types of connections
    to a MySQL server from Navicat. Now that we’re ready to get connected to a server,
    it’s time to work with databases. In this chapter you’ll learn how to:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何从Navicat连接到MySQL服务器的不同类型的连接。现在我们准备好连接到服务器，是时候开始处理数据库了。在本章中，您将学习如何：
- en: Create a database from scratch
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始创建数据库
- en: Create tables and views using Navicats visual design tools
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Navicat的可视化设计工具创建表和视图
- en: Create foreign key constraints and triggers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建外键约束和触发器
- en: Define stored procedures and functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义存储过程和函数
- en: Create scheduled events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建计划事件
- en: Work with database queries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理数据库查询
- en: Managing database objects with Navicat
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Navicat管理数据库对象
- en: What do we mean by database objects? Basically tables, views, functions, and
    events are what we refer to as objects. For each of them, there is a toolbar icon
    in Navicat’s main window and they also appear on the tree view list on the left-hand
    side of the navigation pane. It’s possible to hide the object hierarchy from **Tools**
    | **Options** by unchecking the **Show objects in connection tree** option, but
    this would probably be trivial, especially for novice users.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的数据库对象是什么意思？基本上，表、视图、函数和事件是我们所说的对象。对于每个对象，在Navicat的主窗口中都有一个工具栏图标，它们也出现在导航窗格左侧的树视图列表中。可以通过取消选中**工具**
    | **选项**中的**在连接树中显示对象**选项来隐藏对象层次结构，但这对于新手用户来说可能是微不足道的。
- en: 'The toolbar in Navicat’s main window has large buttons with icons for working
    with the database objects. Clicking on the **Table** button on the toolbar, for
    example, is the equivalent of selecting **Tables** in the tree view in the navigation
    pane titled **Connections**. The larger remaining portion on the right-hand side
    of the main window, under the toolbar, is called the object pane, which displays
    the objects of the selected type. The following screenshot shows the objects of
    **Tables**:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Navicat主窗口的工具栏上有大按钮和图标，用于处理数据库对象。例如，单击工具栏上的**表**按钮相当于在导航窗格中的**连接**下选择**表**。在工具栏下方的主窗口右侧剩余的较大部分称为对象窗格，用于显示所选类型的对象。以下屏幕截图显示了**表**的对象：
- en: '![Managing database objects with Navicat](img/7461EN_02_01_Navicat-Overview.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![使用Navicat管理数据库对象](img/7461EN_02_01_Navicat-Overview.jpg)'
- en: Creating a database from scratch
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从头开始创建数据库
- en: 'Navicat makes it extremely easy to create databases and objects, such as tables
    and views from scratch. As we have established a connection to a MySQL server
    in the previous chapter, it’s time to get started with a blank database of our
    own. The following steps describe how to create a database from scratch:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Navicat使得从头开始创建数据库和对象（如表和视图）变得非常容易。由于我们在上一章中已经连接到了MySQL服务器，现在是时候开始使用我们自己的空白数据库了。以下步骤描述了如何从头开始创建数据库：
- en: Double-click on **localhost** (or whatever you named your server) in the **Connections**
    pane to get connected.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**localhost**（或者您命名的服务器）在**连接**窗格中以连接。
- en: Then right-click on the server name, and select **New Database...** from the
    contextual menu that pops up.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后右键单击服务器名称，并从弹出的上下文菜单中选择**新建数据库...**。
- en: In the new smaller window that opens, enter the **Database Name** as `our_first_db`,
    specify the **Character set** as **utf8--UTF-8 Unicode**, and the **Collation**
    as **utf8_unicode_ci**.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的新较小窗口中，将**数据库名称**输入为`our_first_db`，将**字符集**指定为**utf8--UTF-8 Unicode**，将**校对**指定为**utf8_unicode_ci**。
- en: Finally click on **OK**.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后点击**确定**。
- en: Now **our_first_db** should appear among the other databases under **localhost**.
    By right-clicking on it, you can see what actions you can perform on our new blank
    database from the contextual pop-up menu, such as opening it, viewing, and editing
    its properties like **Character set**, **Collation**, and deleting it. There’s
    also an item named **Data Transfer...**in the same pop-up menu, which in my opinion
    is one of the most powerful features of Navicat. It allows you to transfer data
    directly to and from another database, which we will cover in [Chapter 3](ch03.html
    "Chapter 3. Data Management with Navicat"), *Data Management with Navicat*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在**our_first_db**应该出现在**localhost**下的其他数据库中。通过右键单击它，您可以查看可以在我们的新空白数据库上执行的操作，例如打开它，查看和编辑其属性，如**字符集**，**校对**和删除它。在同一弹出菜单中还有一个名为**数据传输...**的项目，我认为这是Navicat最强大的功能之一。它允许您直接在另一个数据库之间传输数据，我们将在[第3章](ch03.html
    "第3章。使用Navicat进行数据管理") *使用Navicat进行数据管理*中介绍。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Due to limitations of MySQL 5.x, it is not possible to rename a database via
    GUI tools. The best way to do this is to dump the database to an SQL file, create
    a new database with the desired name, and execute the dump file to fill it with
    the contents of the previous database. You will also find details of such tasks
    in [Chapter 3](ch03.html "Chapter 3. Data Management with Navicat"), *Data Management
    with Navicat*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于MySQL 5.x的限制，无法通过GUI工具重命名数据库。这样做的最佳方法是将数据库转储到SQL文件中，创建一个具有所需名称的新数据库，并执行转储文件以填充其内容。您还可以在[第3章](ch03.html
    "第3章。使用Navicat进行数据管理") *使用Navicat进行数据管理*中找到此类任务的详细信息。
- en: '![Creating a database from scratch](img/7461EN_02_02_new-database.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![从头开始创建数据库](img/7461EN_02_02_new-database.jpg)'
- en: Creating tables
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建表
- en: 'Now let’s create some tables for **our_first_db** by following these steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们按照以下步骤为**our_first_db**创建一些表：
- en: Select and open the database from the navigation pane by double-clicking on
    its name.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过双击其名称，从导航窗格中选择并打开数据库。
- en: Then either click on the **New Table** button on the toolbar or right-click
    on **Tables** right under **our_first_db**.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后要么单击工具栏上的**新建表**按钮，要么右键单击**our_first_db**下的**表**。 '
- en: Finally, select **New Table** from the pop-up menu.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从弹出菜单中选择**新建表**。
- en: 'Navicat’s table designer window will appear. The controls here are pretty intuitive.
    We’ll create a department table for a simple employee database and we need three
    fields for it: `id` (**int**), `name` (**varchar**), and `manager_id` (**int**).
    To create the fields, follow these steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Navicat的表设计窗口将出现。这里的控件非常直观。我们将为一个简单的员工数据库创建一个部门表，我们需要三个字段：`id`（**int**）、`name`（**varchar**）和`manager_id`（**int**）。要创建这些字段，请按照以下步骤进行：
- en: Create the first field named `id`, select **Type** as **int**, leave the **Length**
    column blank as it will automatically be set to `11`, uncheck **Allow Null**,
    make it a **Primary key** either by clicking on the tiny button with a yellow
    key icon or by clicking on the empty cell next to the checkbox under **Allow Null**,
    and then finally check the **Auto Increment** option at the bottom.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第一个名为`id`的字段，选择**类型**为**int**，将**长度**列留空，因为它将自动设置为`11`，取消**允许空值**，通过单击带有黄色钥匙图标的小按钮或单击**允许空值**复选框旁边的空单元格，将其设置为**主键**，最后在底部勾选**自动递增**选项。
- en: Adding a new field is as easy as clicking on the **Add Field** button on the
    toolbar, or pressing the *Tab* key while in the last cell of the most recently
    created field.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加新字段就像单击工具栏上的**添加字段**按钮一样简单，或者在最近创建的字段的最后一个单元格中按下*Tab*键。
- en: Next, we will create the field called `name`, select **Type** as **varchar**,
    with `31` characters of length, again uncheck the **Allow Null** checkbox.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个名为`name`的字段，选择**类型**为**varchar**，长度为`31`个字符，再次取消**允许空值**复选框。
- en: Finally, select **Type** as **int**, leave the **Length** column blank as it
    will be automatically be set to `11`, and we also want to leave **Allow Null**
    checked for this one.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，选择**类型**为**int**，将**长度**列留空，因为它将自动设置为`11`，我们还希望为此字段保留**允许空值**的选中状态。
- en: Now, save this table as `department` by clicking on one of the **Save** or **Save
    As** buttons on the toolbar. Navicat also prompts us to save our progress if we
    just try to close the window without saving anyway. Refer to the following screenshot:![Creating
    tables](img/Image443749.jpg)
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过单击工具栏上的**保存**或**另存为**按钮之一，将此表保存为`department`。Navicat还会在我们试图关闭窗口而没有保存时提示我们保存进度。参考以下截图：![创建表](img/Image443749.jpg)
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible to interpose a newly-created field between previously created
    ones by clicking on the existing field and clicking on the **Insert Field** button
    on the toolbar. We can also change the order of the fields by selecting a field
    and using the buttons **Move Up** and **Move Down** on the toolbar as we please.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过单击现有字段并单击工具栏上的**插入字段**按钮在先前创建的字段之间插入新创建的字段。我们还可以通过选择字段并使用工具栏上的**上移**和**下移**按钮来更改字段的顺序。
- en: 'Now we’ll repeat the previous steps to create the employee table, but this
    time defining the fields with the following specifications. In the following table,
    false implies uncheck and true implies check:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将重复之前的步骤来创建员工表，但这次使用以下规格定义字段。在下表中，false表示取消选中，true表示选中：
- en: '| **Name** | **Type** | **Length** | **Decimals** | **Allow Null** | **Primary
    Key** |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **类型** | **长度** | **小数** | **允许空值** | **主键** |'
- en: '| `id` | **int** |   |   | false | X (auto-incrementing) |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `id` | **int** |   |   | false | X (自动递增) |'
- en: '| `first_name` | **varchar** | `50` |   | true |   |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `first_name` | **varchar** | `50` |   | true |   |'
- en: '| `last_name` | **varchar** | `40` |   | false |   |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `last_name` | **varchar** | `40` |   | false |   |'
- en: '| `email` | **varchar** | `60` |   | true |   |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `email` | **varchar** | `60` |   | true |   |'
- en: '| `title` | **varchar** | `35` |   | true |   |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `title` | **varchar** | `35` |   | true |   |'
- en: '| `salary` | **decimal** | `10` | `2` | true |   |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `salary` | **decimal** | `10` | `2` | true |   |'
- en: '| `perks` | **int** |   |   | false |   |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `perks` | **int** |   |   | false |   |'
- en: '| `department_id` | **int** |   |   | true |   |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `department_id` | **int** |   |   | true |   |'
- en: '| `manager_id` | **int** |   |   | true |   |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `manager_id` | **int** |   |   | true |   |'
- en: Next, we need to establish some relationships between the two tables by defining
    some foreign key constraints.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要通过定义一些外键约束来在两个表之间建立一些关系。
- en: Defining foreign keys
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义外键
- en: 'First of all, I recommend saving the table and naming it `employee` (If you
    happen to close the table designer after that, right-click on the name of the
    table and choose **Design Table** from the pop-up menu.) While back in the table
    designer, perform the following steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我建议保存表并将其命名为`employee`（如果您在那之后关闭了表设计师，请右键单击表的名称，然后从弹出菜单中选择**设计表**）。回到表设计师后，执行以下步骤：
- en: Switch to the **Foreign Keys** tab.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**外键**选项卡。
- en: Enter `fk_employee_4_department` as the name of the foreign key in the first
    field of the first row.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一行的第一个字段中输入`fk_employee_4_department`作为外键的名称。
- en: Choose **department_id** for the **Fields** in the second column.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二列中选择**字段**为**department_id**。
- en: Select **our_first_db** as the **Reference Database** in the third column.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第三列中选择**our_first_db**作为**参考数据库**。
- en: Pick the **department** table for the **Reference Table** in the fourth column.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第四列中选择**department**表作为**参考表**。
- en: Select **id** for **Reference Fields**.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**参考字段**为**id**。
- en: Optionally, you could specify the cascading options **On Delete** and **On Update**
    depending on your programming strategy.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据您的编程策略，您还可以选择级联选项**在删除时**和**在更新时**。
- en: For example, selecting the cascading option **On Delete** in this case means,
    when a department record is deleted, all employees in that department will also
    be deleted. Leaving **On Delete** and **On Update** blank will set them to restrict
    as default, which would mean that you can’t delete a department that has employees
    associated with it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这种情况下选择级联选项**在删除时**意味着，当删除部门记录时，该部门中的所有员工也将被删除。将**在删除时**和**在更新时**留空将默认设置为限制，这意味着您无法删除与之关联员工的部门。
- en: The above definition will be enforcing a referential integrity check for every
    employee to be assigned to an existing department via the **department_id** column.
    It means you can’t set a non-existent department ID for a given employee.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上述定义将强制执行引用完整性检查，以确保每个员工都被分配到现有部门，通过**department_id**列。这意味着您不能为给定的员工设置不存在的部门ID。
- en: 'Now repeat the steps mentioned earlier to define a foreign key for the **manager_id**,
    name it `fk_employee_4_manager_id`, set the **Referenced Table** to **employee,**
    and the **Referenced Fields** to **id,** as shown in the following screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重复之前提到的步骤，为**manager_id**定义一个外键，命名为`fk_employee_4_manager_id`，将**引用表**设置为**employee**，**引用字段**设置为**id**，如下图所示：
- en: '![Defining foreign keys](img/7461EN_02_04_defining_fk.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![定义外键](img/7461EN_02_04_defining_fk.jpg)'
- en: 'If you switch to the **SQL Preview** tab before saving your changes, you will
    be able to see a couple of automatically generated SQL commands for adding the
    designed foreign key constraint(s) to your table. In fact, every change you make
    on a table’s design has corresponding SQL commands, which Navicat performs behind
    the scenes and executes them on the database server. This can also be useful for
    learning SQL, or in the case of a server error, for analyzing what went wrong
    at the backstage. The screenshot of the **SQL Preview** tab is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在保存更改之前切换到**SQL预览**选项卡，您将能够看到一些自动生成的SQL命令，用于向表中添加设计的外键约束。实际上，您对表设计所做的每一项更改都有相应的SQL命令，Navicat在幕后执行这些命令并在数据库服务器上执行它们。这对于学习SQL也很有用，或者在服务器出现错误时，用于分析幕后发生了什么。**SQL预览**选项卡的屏幕截图如下：
- en: '![Defining foreign keys](img/7461EN_02_05_defining_fk_sql_preview.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![定义外键](img/7461EN_02_05_defining_fk_sql_preview.jpg)'
- en: Repeat the same steps for defining a foreign key constraint for the **manager_id**
    in the **department** table referencing the **id** field of the **employee table**,
    and name it `fk_department_4_manager`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 重复相同的步骤，为**department**表中的**manager_id**定义一个外键约束，引用**employee表**的**id**字段，并命名为`fk_department_4_manager`。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As for the table naming convention, I encourage the use of single nouns for
    table names particularly to make life easier for developers, who use **object-relational
    mapping** (**ORM**) APIs that have reverse-engineering tools for the development
    of database-driven applications.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 至于表命名约定，我鼓励使用单个名词作为表名，特别是为了让使用**对象关系映射**（**ORM**）API的开发人员更容易，这些API具有用于开发基于数据库的应用程序的反向工程工具。
- en: Navicat’s Table Designer also features a tab called **Indexes** that makes creating
    indexes as easy as creating fields and defining foreign keys using similar methods.
    In fact, creating a foreign key requires a corresponding index also to be created,
    and Navicat does that automatically for us by creating an index for every foreign
    key we define and create.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Navicat的表设计器还具有一个名为**索引**的选项卡，使得创建索引与使用类似方法创建字段和定义外键一样简单。实际上，创建外键需要相应的索引也要被创建，Navicat会自动为我们创建每个定义和创建的外键的索引。
- en: You will also notice the **Triggers** tab, where you can easily define a trigger
    for a table. Let’s define a simple trigger, which will be activated every time
    a new row is added to the employee table. For this example, we will need an auxiliary
    table that I will call **emp_log**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会注意到**触发器**选项卡，您可以轻松地为表定义触发器。让我们定义一个简单的触发器，每当向员工表添加新行时都会被激活。在这个例子中，我们将需要一个我称之为**emp_log**的辅助表。
- en: Defining triggers
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义触发器
- en: 'You can either practice what you have learned in this section by creating the
    **emp_log** table using the table designer, by defining three basic fields: `id`
    (**Type**-**int,** check primary key auto-incrementing), `emp_id` (**Type**-**int**),
    and `date_created` (**Type**-**datetime**) or by going to the menu bar in Navicat’s
    main window, choosing **Tools** | **Console...** (alternatively press *F6* as
    a shortcut) and entering the following command in the MySQL console window:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用表设计器创建**emp_log**表来练习本节学到的知识，定义三个基本字段：`id`（**类型**-**int**，检查主键自动递增），`emp_id`（**类型**-**int**）和`date_created`（**类型**-**datetime**），或者转到Navicat主窗口的菜单栏，选择**工具**
    | **控制台...**（或者按*F6*作为快捷键），并在MySQL控制台窗口中输入以下命令：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the **emp_log** table is created, we’re ready to define a trigger that
    will log every employee record we created in the **employee** table. Right-click
    on the **employee** table, select **Design Table,** and then perform the following
    steps in the table designer for the employee table:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 创建**emp_log**表后，我们准备定义一个触发器，用于记录我们在**employee**表中创建的每个员工记录。右键单击**employee**表，选择**设计表**，然后在员工表的表设计器中执行以下步骤：
- en: Go to the **Triggers** tab and click on **Add Trigger** from the toolbar.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**触发器**选项卡，然后从工具栏中单击**添加触发器**。
- en: Name the trigger as `ins_trig`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将触发器命名为`ins_trig`。
- en: In the **Fires** column, select **After**.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**触发**列中，选择**之后**。
- en: Check **Insert** and leave the other checkboxes alone.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选**插入**，其他复选框保持不变。
- en: 'Enter the following code in the **Definition** pane:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**定义**窗格中输入以下代码：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The screenshot of the **Triggers** tab is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**触发器**选项卡的屏幕截图如下：'
- en: '![Defining triggers](img/7461EN_02_06_trigger.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![定义触发器](img/7461EN_02_06_trigger.jpg)'
- en: The **Options** tab is another useful aide, which lets you modify certain settings
    of a MySQL table. A major pitfall for MySQL database designers is that when creating
    a MySQL table, they might accidentally end up with a MyISAM table, whereas they
    actually intended to use the InnoDB engine. Navicat makes it easy to change the
    engine to InnoDB. This kind of modification is not foolproof though. Due to MySQL’s
    internal mechanism, if there’s already some data entered in the table, this might
    make the conversion difficult, and sometimes even impossible. The other options
    here include **Character set** and **Collation** modification, setting or resetting
    the **Auto Increment** value for the next record, and maintaining a live checksum
    for all rows—a feature exclusive to MyISAM tables.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**Options**选项卡是另一个有用的辅助工具，它允许您修改MySQL表的某些设置。MySQL数据库设计者的一个主要陷阱是，在创建MySQL表时，他们可能会意外地得到一个MyISAM表，而实际上他们打算使用InnoDB引擎。Navicat使得将引擎更改为InnoDB变得容易。不过，这种修改并不是绝对安全的。由于MySQL的内部机制，如果表中已经输入了一些数据，这可能会使转换变得困难，有时甚至是不可能的。这里的其他选项包括**字符集**和**校对**修改，设置或重置下一条记录的**自动增量**值，并为所有行维护一个实时校验和——这是MyISAM表的一个独有特性。'
- en: More advanced tweaks are possible on this screen, which is covered in detail
    in Navicat’s manual.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕上还可以进行更高级的调整，这在Navicat的手册中有详细介绍。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is also possible to duplicate tables by just clicking on the table’s name
    and selecting **Duplicate Table** from the pop-up menu. Another related cool feature
    of Navicat is that you can copy a table in the same way and paste it to another
    database.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 只需点击表的名称，然后从弹出菜单中选择**Duplicate Table**，即可复制表。Navicat的另一个相关功能是，您可以以相同的方式复制表，并将其粘贴到另一个数据库中。
- en: '![Defining triggers](img/7461EN_02_07_table_options.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![定义触发器](img/7461EN_02_07_table_options.jpg)'
- en: Entering data in tables
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在表中输入数据
- en: Now that we have built the basis for our database, we’d better enter some data
    in our tables. To open a table for data entry, simply double-click on it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了数据库的基础，最好在表中输入一些数据。要打开表进行数据输入，只需双击它。
- en: 'Navicat provides two ways of data entry in tables: one of them is using the
    **Grid View**, which is predictably the most common way of entering data just
    like you would do in a spreadsheet.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Navicat提供了两种在表中输入数据的方法：其中一种是使用**Grid View**，这是最常见的输入数据的方式，就像在电子表格中一样。
- en: Just click on a cell to start entering the data, and when you’re done with it,
    you can press the *Tab* key to move on to the next cell or click on anywhere outside
    the active cell. Fields with foreign key constraints will contain a small square
    button for selecting data from a drop-down list, which will present data items
    from the field of the table to which it has reference(s). In our case, the **department_id**
    can be selected from the IDs of records entered in the department table as you
    can see in the following screenshot.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 只需点击单元格即可开始输入数据，完成后，可以按*Tab*键移动到下一个单元格，或者单击活动单元格外的任何位置。具有外键约束的字段将包含一个小方形按钮，用于从下拉列表中选择数据，该列表将显示来自具有引用的表字段的数据项。在我们的情况下，**department_id**可以从部门表中输入的记录的ID中选择，如下面的屏幕截图所示。
- en: 'When you’re finished with editing the row, you can click on the tiny tick **P**
    button at the bottom of the window to save your changes, or the **O** button to
    discard them. Click on the (**+**) plus or minus (**-**) sign to delete a record
    if you need to, as shown in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑行完成后，可以单击窗口底部的小勾选**P**按钮保存更改，或者单击**O**按钮放弃更改。如果需要，可以单击(**+**)加号或减号(**-**)删除记录，如下面的屏幕截图所示：
- en: '![Entering data in tables](img/7461EN_02_08_employee_data.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![在表中输入数据](img/7461EN_02_08_employee_data.jpg)'
- en: 'If you used Microsoft Access or Oracle Forms before, the form view will look
    familiar to you. Every table row or record will be displayed on a separate page
    with the fields aligned vertically in that view. Refer to the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前使用过Microsoft Access或Oracle Forms，表单视图对您来说会很熟悉。在该视图中，每个表行或记录将显示在单独的页面上，字段垂直对齐。请参阅下面的屏幕截图：
- en: '![Entering data in tables](img/7461EN_02_09_data_entry_form_view.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![在表中输入数据](img/7461EN_02_09_data_entry_form_view.jpg)'
- en: Creating views
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建视图
- en: Database views are usually used to hide complex details of certain tables and
    in some cases, they’re used simply as a security mechanism by limiting the data
    that a user is allowed to retrieve. In this section, I’ll show you how to create
    a view, in a moment, using Navicat’s view designer. It has a powerful visual editing
    tool called the **View Builder** and it allows you to design views visually using
    point-and-click and drag-and-drop gestures.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库视图通常用于隐藏某些表的复杂细节，并且在某些情况下，它们仅用作安全机制，通过限制用户被允许检索的数据。在本节中，我将向您展示如何在Navicat的视图设计器中创建视图。它具有一个强大的可视化编辑工具称为**View
    Builder**，它允许您使用点按和拖放手势直观地设计视图。
- en: 'To add a table to the view, simply click on its name on the left pane, and
    drag it to the graphical view area, or just double-click on its name in the tree
    view and click on **View Builder** tab and then follows these steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要将表添加到视图中，只需在左侧窗格上单击其名称，然后将其拖动到图形视图区域，或者只需在树视图中双击其名称，然后单击**View Builder**选项卡，然后按照以下步骤操作：
- en: When you get all your tables in the graphical view, you can click on the tiny
    boxes next to the field names on the left-hand side to include them in the view.
    If you click on the box on the left-hand side of the table name, all the fields
    will be included in the **SELECT** query of the view, as shown in the following
    screenshot:![Creating views](img/7461EN_02_10_employee_view.jpg)
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您在图形视图中放置了所有表后，可以单击左侧字段名称旁边的小框，将其包含在视图中。如果单击表名称左侧的框，所有字段将包含在视图的**SELECT**查询中，如下面的屏幕截图所示：![创建视图](img/7461EN_02_10_employee_view.jpg)
- en: To define the relationships, click on the name of a field of a table and drag
    it onto the field of the table it is related to. For example, in this view, we
    want to display the name of the department of every employee instead of his/her
    department ID.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要定义关系，请点击表的字段名称，并将其拖动到相关的表的字段上。例如，在这个视图中，我们希望显示每个员工的部门名称，而不是他/她的部门ID。
- en: Click on the **department_id** field in the **employee** table and drag it onto
    the **id** field of the **department** table. A connecting line will be drawn
    representing the relationship between the two tables.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**employee**表中的**department_id**字段，将其拖动到**department**表的**id**字段上。将会画出一条连接线，表示两个表之间的关系。
- en: In the meantime, the SQL representation of the visual design will be updated
    accordingly in the lower-right pane, which is called the syntax view. The relationships
    will be created as **INNER JOIN** by default; however, you can change them to
    **LEFT JOIN** or **RIGHT JOIN** by clicking on its SQL syntax highlighted in blue,
    and selecting a different join type from the menu that pops up.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，可视设计的SQL表示将相应更新在右下角的语法视图中。关系将默认创建为**INNER JOIN**；但是，您可以通过点击其在SQL语法中以蓝色突出显示的部分，并从弹出菜单中选择不同的连接类型来将其更改为**LEFT
    JOIN**或**RIGHT JOIN**。
- en: Alternatively you can switch to the **Definition** tab of the view designer
    to work with plain SQL. You can switch between the two any time, as it is possible
    to generate the SQL query from the visual design and vice versa. However, make
    sure you save your view definition at every step and even back up the SQL to an
    external file at every major step as it is possible that the SQL query gets mixed
    up when trying complex things in the visual editor.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以切换到视图设计器的**Definition**选项卡，使用纯SQL进行操作。您可以随时在两者之间切换，因为可以从可视化设计生成SQL查询，反之亦然。但是，请确保在每个步骤保存视图定义，甚至在每个主要步骤将SQL备份到外部文件，因为在可视化编辑器中尝试复杂操作时可能会导致SQL查询混乱。
- en: 'For our example, enter the following SQL query in the **Definition** pane:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，在**Definition**窗格中输入以下SQL查询：
- en: '[PRE2]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To preview the results of the generated SQL, click on the **Preview** button
    on the toolbar. You will see the data retrieved by the view in a tab called **Result1**,
    if your SQL statement had no errors.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要预览生成的SQL的结果，请点击工具栏上的**Preview**按钮。如果您的SQL语句没有错误，您将在名为**Result1**的选项卡中看到视图检索的数据。
- en: The **Explain** button on the toolbar shows the query plan of the view.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏上的**Explain**按钮显示视图的查询计划。
- en: For power users, there’s also a tab titled **Advanced**, where you can set advanced
    properties for the view. One of them is the **Algorithm**, and it gives you the
    ability to force MySQL to use a specific algorithm when executing the SQL.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高级用户，还有一个名为**Advanced**的选项卡，您可以在其中为视图设置高级属性。其中之一是**Algorithm**，它使您能够在执行SQL时强制MySQL使用特定的算法。
- en: The default is **Undefined**, which leaves the choice to MySQL
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认是**Undefined**，将选择权留给MySQL
- en: As the **Merge** algorithm is more efficient in most cases; it is the one MySQL
    picks whenever possible
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于**Merge**算法在大多数情况下更有效，因此MySQL在可能的情况下会选择它
- en: The alternative is the **Temptable** algorithm that retrieves the results after
    caching them in a temporary table
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种选择是**Temptable**算法，它在将结果缓存在临时表中后检索结果
- en: The **Security** option lets you customize access privileges by choosing between
    the user who defined the view and the one who invoked it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**Security**选项允许您通过选择定义视图的用户和调用视图的用户之间进行访问权限的自定义。'
- en: More details about these settings are available in Navicat’s manual.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些设置的更多详细信息，请参阅Navicat的手册。
- en: When you double-click on a view you saved, you will get the results in a grid
    window, which is very similar to opening tables for viewing or entering data.
    From this window, it’s possible to export the data in a variety of formats. The
    details of this functionality are covered in [Chapter 3](ch03.html "Chapter 3. Data
    Management with Navicat"), *Data Management with Navicat*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 双击保存的视图，将在一个网格窗口中获得结果，这与打开表进行查看或输入数据非常相似。从这个窗口，可以将数据以各种格式导出。有关此功能的详细信息在[第3章](ch03.html
    "第3章. 使用Navicat进行数据管理")中有所涵盖，*使用Navicat进行数据管理*。
- en: 'The created **View** will look like the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的**视图**将看起来像以下的屏幕截图：
- en: '![Creating views](img/7461EN_02_11_view-execution.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![创建视图](img/7461EN_02_11_view-execution.jpg)'
- en: Working with functions and procedures
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数和存储过程
- en: MySQL has brought support for functions and stored procedures as of Version
    5\. A stored procedure is a set of SQL statements that can be stored on the server,
    so that they can be invoked later by a client, a trigger, or even another stored
    procedure.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 从版本5开始支持函数和存储过程。存储过程是一组SQL语句，可以存储在服务器上，以便稍后由客户端、触发器甚至另一个存储过程调用。
- en: Now, we will create a simple stored procedure that will select the employees
    with the lowest, highest, and average salaries in the company.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个简单的存储过程，该存储过程将选择公司中工资最低、最高和平均的员工。
- en: The default way of creating such a routine in Navicat is through the **Function
    Wizard** that is invoked by clicking on the **New function** button in the toolbar
    or by selecting the **New Function** command from the pop-up menu showing up with
    a right-click on the appropriate context.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在Navicat中创建这样的例程的默认方式是通过**Function Wizard**，可以通过工具栏上的**New function**按钮或者右键单击弹出菜单中选择**New
    Function**命令来调用。
- en: In the **Function Wizard** window, select **Procedure** and click on **Next**.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Function Wizard**窗口中，选择**Procedure**，然后点击**Next**。
- en: 'Then enter the following parameters for the procedure before you click on **Finish**:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在点击**Finish**之前，输入存储过程的以下参数：
- en: '| **Mode** | **Name** | **Type** |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **Mode** | **Name** | **Type** |'
- en: '| **OUT** | `lowest_salary` | **decimal(10,2)** |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **OUT** | `lowest_salary` | **decimal(10,2)** |'
- en: '| **OUT** | `l_emp` | **varchar** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **OUT** | `l_emp` | **varchar** |'
- en: '| **OUT** | `highest_salary` | **decimal(10,2)** |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| **OUT** | `highest_salary` | **decimal(10,2)** |'
- en: '| **OUT** | `h_emp` | **varchar** |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **OUT** | `h_emp` | **varchar** |'
- en: '| **OUT** | `average_salary` | **decimal(10,2)** |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| **OUT** | `average_salary` | **decimal(10,2)** |'
- en: 'After entering the parameters in the previous table, the screenshot will look
    like the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在上表中输入参数后，屏幕截图将如下所示：
- en: '![Working with functions and procedures](img/7461EN_02_13_function_wizard_sp2.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![使用函数和存储过程](img/7461EN_02_13_function_wizard_sp2.jpg)'
- en: 'After clicking on **Finish**, the created **Procedure** will look like the
    following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**完成**后，创建的**Procedure**将如下所示：
- en: '![Working with functions and procedures](img/7461EN_02_14_function_wizard_sp3.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![使用函数和存储过程](img/7461EN_02_14_function_wizard_sp3.jpg)'
- en: Finally, enter the following code in the routine’s **Definition** on the next
    screen and save the procedure as `sp_salaries`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在下一个屏幕的例程**定义**中输入以下代码，并将存储过程保存为`sp_salaries`。
- en: '[PRE3]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While entering the previous code, you can enjoy the code editing capabilities
    of Navicat, such as the code highlighting, word wrapping, auto-completion, and
    code-folding.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入上述代码时，您可以享受Navicat的代码编辑功能，如代码高亮、自动换行、自动完成和代码折叠。
- en: 'Now, in order to test the procedure, go to the **Queries** node, create a **New
    Query**, and then enter the following statements in the **Query Editor**:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了测试该过程，转到**查询**节点，创建一个**新查询**，然后在**查询编辑器**中输入以下语句：
- en: '[PRE4]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Working with functions and procedures](img/7461EN_02_15_sp_salaires_results_qry.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![使用函数和存储过程](img/7461EN_02_15_sp_salaires_results_qry.jpg)'
- en: To see the results of the query, click on the **Run** button in the toolbar
    and there we are with the lowest and highest paid employee in the company, their
    salaries, and the average salary of all employees in the company.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看查询结果，请点击工具栏上的**运行**按钮，然后就可以看到公司中薪水最低和最高的员工、他们的薪水以及公司所有员工的平均薪水了。
- en: Lastly, since we don’t have a single field for the full name of employees and
    instead have separate fields for first name, we will create a function that returns
    the full name of an employee by concatenating his/her first name and last name
    delimited with a single space character whose ID is taken as an input parameter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们没有一个用于员工全名的单个字段，而是为名字和姓氏分别创建了单独的字段，我们将创建一个函数，通过将名字和姓氏用单个空格字符分隔起来，返回员工的全名，其ID作为输入参数。
- en: To do this, we’ll follow almost the same steps from the beginning of this section,
    except that in the first screen of the **Function Wizard**, we’ll select **Function**
    instead of **Procedure**.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将几乎按照本节开头的相同步骤进行，只是在**函数向导**的第一个屏幕中，我们将选择**函数**而不是**存储过程**。
- en: 'Next, we’ll specify `emp_id` of type **int** as the input parameter and click
    on **Finish**. Finally, in the function’s **Definition** area, enter the following
    code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将指定类型为**int**的`emp_id`作为输入参数，然后点击**完成**。最后，在函数的**定义**区域中输入以下代码：
- en: '[PRE5]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Save the function as `fn_fullname` and test it by clicking on **Run** on the
    toolbar. When prompted, enter **id** of an employee whose full name you want to
    display. Refer to the following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数保存为`fn_fullname`，并通过单击工具栏上的**运行**来测试它。在提示时，输入您想要显示全名的员工的**id**。参考下面的屏幕截图：
- en: '![Working with functions and procedures](img/7461EN_02_16_fn_fullname.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![使用函数和存储过程](img/7461EN_02_16_fn_fullname.jpg)'
- en: Using Navicat’s event designer for MySQL
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Navicat的MySQL事件设计器
- en: As of Version 5.1.6, the **Event Scheduler** feature of MySQL was introduced,
    which lets you design scheduled tasks. An event in MySQL is a scheduled task consisting
    of one or more SQL statements to be executed at certain intervals, beginning,
    and ending at specific dates and time.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本5.1.6开始，MySQL引入了**事件调度程序**功能，允许您设计定期任务。在MySQL中，事件是由一个或多个SQL语句组成的定期任务，这些语句将在特定间隔、开始和结束日期和时间执行。
- en: In this section, I’ll show you how to create a scheduled event that will back
    up our employee table, which will recur at specific intervals. As a prerequisite,
    we need to make sure that MySQL’s global event scheduler is active (which is disabled
    by default).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向您展示如何创建一个定期事件，该事件将备份我们的员工表，并在特定间隔重复。作为先决条件，我们需要确保MySQL的全局事件调度程序处于活动状态（默认情况下处于禁用状态）。
- en: 'For this, select **Console** from the **Tools** menu in Navicat’s main window
    to get a command-line access to the MySQL server, as shown in the following screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，请从Navicat主窗口的**工具**菜单中选择**控制台**，以获取对MySQL服务器的命令行访问，如下面的屏幕截图所示：
- en: '![Using Navicat’s event designer for MySQL](img/7461EN_02_17_enabling-scheduler-from-the-console.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![使用Navicat的MySQL事件设计器](img/7461EN_02_17_enabling-scheduler-from-the-console.jpg)'
- en: 'While in the **localhost - Console** prompt, type the following command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在**localhost - 控制台**提示中，键入以下命令：
- en: '[PRE6]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Secondly, we will need to create a new stored procedure that will contain a
    set of commands to back up the employee table and delete any existing backup.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要创建一个新的存储过程，其中包含一组命令来备份员工表并删除任何现有的备份。
- en: 'Time to put into practice what you have learned in the previous section:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将你在上一节中学到的知识付诸实践了：
- en: 'Create a new stored procedure called `refresh_employee_bu` with no in or out
    parameters and enter the following code in its definition:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`refresh_employee_bu`的新存储过程，没有输入或输出参数，并在其定义中输入以下代码：
- en: '[PRE7]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now were ready to create a scheduled event in Navicat; click on the **Event**
    button in the toolbar, then select **New Event**. This will bring in Navicats
    event designer.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备在Navicat中创建一个定期事件；点击工具栏中的**事件**按钮，然后选择**新事件**。这将引入Navicat的事件设计器。
- en: While in the **Definition** tab of the event designer, set the **Definer** as
    `root@localhost` or `CURRENT_USER` if you had established the connection using
    `root`. Set **Status** to **ENABLE**, and select **PRESERVE** for **ON COMPLETION**,
    as shown in the following screenshot:![Using Navicat’s event designer for MySQL](img/7461EN_02_18_event_designer.jpg)
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件设计器的**定义**选项卡中，将**Definer**设置为`root@localhost`或使用`root`建立连接时设置为`CURRENT_USER`。将**Status**设置为**ENABLE**，并选择**ON
    COMPLETION**的**PRESERVE**，如下面的屏幕截图所示：![使用Navicat的MySQL事件设计器](img/7461EN_02_18_event_designer.jpg)
- en: 'Then enter the following code in the definition code area: `CALL refresh_employee_bu`.
    This will invoke the stored procedure you created earlier for backing up the employee
    table.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在定义代码区域输入以下代码：`CALL refresh_employee_bu`。这将调用您之前创建的用于备份员工表的存储过程。
- en: Finally, switch to the **Schedule** tab of the event designer to adjust the
    timing of the event, as shown in the following screenshot:![Using Navicat’s event
    designer for MySQL](img/7461EN_02_19_event_designer2.jpg)
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，切换到事件设计师的**日程安排**选项卡，调整事件的时间，如下截图所示：![使用Navicat的MySQL事件设计师](img/7461EN_02_19_event_designer2.jpg)
- en: We want the backup process to run every month, so refer to the previous screenshot
    to adjust your settings so that the event will be triggered every month, **STARTS**
    at **CURRENT_TIMESTAMP** + `1` hour **INTERVAL**. Save this event as `backup_employees`
    and you’re done.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望备份过程每个月运行一次，因此请参考上一个截图，调整设置，使事件每个月触发一次，**从** **CURRENT_TIMESTAMP** + `1`
    **小时间隔**开始。将此事件保存为`backup_employees`，然后完成。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To test if the scheduled event is working, you can set a much sooner date and
    time and shorter interval for a start, and then once you verify it’s working,
    you can set the timing back to a reasonable frequency.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试预定的事件是否有效，可以设置一个更早的日期和时间以及更短的间隔开始，然后验证其是否有效后，可以将时间设置回合理的频率。
- en: Working with queries in Navicat
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Navicat中使用查询
- en: Designing a query in Navicat is much like designing a view except that views
    are limited to SELECT statements whereas the queries can perform any **CRUD**
    (**create**, **read**, **update**, and **delete**) operation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在Navicat中设计查询很像设计视图，不同之处在于视图仅限于SELECT语句，而查询可以执行任何**CRUD**（**创建**，**读取**，**更新**和**删除**）操作。
- en: Just like the **View Builder**, Navicat’s visual query builder allows you to
    graphically represent tables and fields as well as relationships between them
    (JOINS) and by leaving the SQL generation to Navicat, however, this approach only
    works with SELECT queries. You still have to handcode the SQL for create, update,
    and delete queries.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 就像**视图构建器**一样，Navicat的可视化查询构建器允许您以图形方式表示表和字段以及它们之间的关系（连接），并且通过将SQL生成交给Navicat，但是，这种方法仅适用于SELECT查询。对于创建，更新和删除查询，您仍然必须手动编写SQL。
- en: In this section, we’ll go through an imaginary scenario regarding the fictional
    company `Acme.com,` where the CEO is unhappy with the financial results from the
    past fiscal year and believes that the company’s organization should be revised.
    Toward this end, he wants preliminarily analysis of who’s doing what and how much
    salary he or she gets in the company.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将通过一个关于虚构公司`Acme.com`的想象情景，CEO对上一财政年度的财务结果感到不满，并认为公司的组织应该进行修订。为此，他希望初步分析公司中谁在做什么，以及他或她在公司中获得多少薪水。
- en: First, we will design a simple query to list all departments and their managers.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将设计一个简单的查询来列出所有部门及其经理。
- en: Designing the Query
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计查询
- en: Let’s go to the **Queries** view by either clicking on the large **Query** button
    on the toolbar or by selecting **Queries** from the navigation pane on the left-hand
    side, and then click on the smaller **New Query** button on the toolbar.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过点击工具栏上的大**查询**按钮或从左侧导航窗格中选择**查询**，然后点击工具栏上较小的**新查询**按钮，进入**查询**视图。
- en: In the window that opens, the **Query Editor** tab is active by default. This
    is where you can handcode the SQL language to construct a query. What we want
    is the visual designer, so we’ll switch to the **Query Builder** tab.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开的窗口中，默认情况下**查询编辑器**选项卡是活动的。这是您可以手动编写SQL语言来构建查询的地方。我们想要的是可视化设计师，因此我们将切换到**查询构建器**选项卡。
- en: In this view, we have a visual diagram pane where we can create graphical representations
    of tables and views by either double-clicking on their names on the left pane,
    or simply by moving them to the empty area using drag-and-drop gestures.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个视图中，我们有一个可视化图表窗格，可以通过在左侧窗格上双击它们的名称，或者简单地通过拖放手势将它们移动到空白区域来创建表和视图的图形表示。
- en: 'For this query, we need **department** and **employee** tables side-by-side;
    so after bringing them to the stage, start building a SELECT query by choosing
    the following fields by clicking on the tiny boxes next to their names: **name**
    of the **department** table, **first_name**, **last_name**, and **title** of the
    **employee** table.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个查询，我们需要**部门**和**员工**表并排；因此，在将它们带到舞台后，通过点击它们名称旁边的小方框选择以下字段来构建一个SELECT查询：**部门**表的**名称**，**员工**表的**名**，**姓**和**职称**。
- en: 'Next, click on **manager_id** of the **department** table and move it onto
    the **id** field of the **employee** table. A line with round ends bonding the
    two fields should appear, and in the pane below an editable SQL code is previewed.
    You can click on the gray words in the SQL query to make additions to the syntax,
    such as aliases for fields and tables. This query is now almost ready except that
    I want a **LEFT JOIN** between **department** and **employee** instead of an **INNER
    JOIN** here. Click on the blue **INNER JOIN** expression to change it to a **LEFT
    JOIN** using a drop-down list that will show up automatically, as shown in the
    following screenshot:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击**部门**表的**manager_id**，将其移动到**员工**表的**id**字段上。应该会出现一个带有圆形端点的连接两个字段的线，并且在下面的窗格中预览了可编辑的SQL代码。您可以点击SQL查询中的灰色单词来添加语法，例如字段和表的别名。这个查询现在几乎准备好了，只是我想在这里使用**部门**和**员工**之间的**LEFT
    JOIN**而不是**INNER JOIN**。点击蓝色的**INNER JOIN**表达式，使用自动显示的下拉列表将其更改为**LEFT JOIN**，如下截图所示：
- en: '![Designing the Query](img/7461EN_02_20.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![设计查询](img/7461EN_02_20.jpg)'
- en: Now let’s save this query and execute it to find out about the organization
    of the company. I named it `qry_departments`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们保存这个查询并执行它，以了解公司的组织情况。我将其命名为`qry_departments`。
- en: 'Click on the **Run** button on the window’s toolbar to execute the query. Invoking
    it will switch back to the query editor and retrieve the results in a data grid
    below the generated SQL code. At this stage, we have the option of exporting the
    resulting data to a variety of formats, such as text (csv), Excel spreadsheet,
    XML, MS Access database (Windows only), or even a DBase file. Details of importing/exporting
    data functionality of Navicat are covered in [Chapter 3,](ch03.html "Chapter 3. Data
    Management with Navicat") *Data Management with Navicat*. Refer to the following
    screenshot:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 单击窗口工具栏上的**运行**按钮来执行查询。调用它将切换回查询编辑器，并在生成的SQL代码下方的数据网格中检索结果。在这个阶段，我们可以将结果数据导出为各种格式，如文本（csv）、Excel电子表格、XML、MS
    Access数据库（仅限Windows），甚至是DBase文件。Navicat的导入/导出数据功能的详细信息在[第3章](ch03.html "第3章。使用Navicat进行数据管理")*使用Navicat进行数据管理*中有介绍。请参考以下屏幕截图：
- en: '![Designing the Query](img/7461EN_02_21.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![设计查询](img/7461EN_02_21.jpg)'
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike other database objects, Navicat does not prompt you to save your query
    when you are closing the query designer window, so be sure to save your work to
    avoid losing your changes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他数据库对象不同，Navicat在关闭查询设计器窗口时不会提示您保存查询，因此请确保保存您的工作以避免丢失更改。
- en: Building further queries
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建进一步的查询
- en: Having designed our first query in the previous section, I think that we could
    spice up what we have learned by adding some more to it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中设计了我们的第一个查询之后，我认为我们可以通过添加一些内容来丰富我们所学到的知识。
- en: Going back to our scenario, the boss wants a list of employees (specifically
    the managers) with a monthly salary amount of more than $15,000, which department
    they work in, and who they report to. That’s the specification of the next query
    we will design. If you are good at SQL programming, you could conceive such a
    query in a matter of minutes just by handcoding. Navicat’s code editor is very
    useful also for this kind of task, thanks to its code-completion aid, SQL formatting,
    code folding, and brace highlighting. However, I want to demonstrate a few more
    features of the visual builder for the sake of the ease-of-use it provides for
    setting filtering criteria. For this query, we’ll be working with the **department**
    table to retrieve the names of departments associated with the department ID of
    employees, and two instances of the **employee** table—one for the employees themselves
    and the second one to fetch the names of their managers.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的场景，老板想要一个员工（特别是经理）的名单，他们的月薪超过15000美元，他们所在的部门，以及他们的汇报对象。这是我们将设计的下一个查询的规范。如果你擅长SQL编程，你可以很快地手工编写这样一个查询。Navicat的代码编辑器也非常有用，因为它具有代码补全功能、SQL格式化、代码折叠和括号高亮等功能。然而，为了演示可视化构建器提供的便利性，我想再介绍一些功能来设置过滤条件。对于这个查询，我们将使用**department**表来检索与员工部门ID相关联的部门名称，以及**employee**表的两个实例——一个用于员工本身，另一个用于获取他们的经理的名称。
- en: 'Open a new query window and add two **employee** tables and one **department**
    table to the (graphical) diagram view area by dragging them from the left pane
    or double-clicking on their names. Name the second **employee** table as **manager**
    using an alias. You can do this either by double-clicking on the table’s title
    bar or by clicking on the slightly dimmed **<Alias>** in the syntax view, and
    entering **manager**. (The former method is similar to renaming a file by clicking
    on its name under or next to its icon in Windows Explorer or the Macintosh Finder.)
    Refer to the following screenshot:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的查询窗口，并通过从左窗格拖动它们或双击它们的名称将两个**employee**表和一个**department**表添加到（图形）图表视图区域。使用别名将第二个**employee**表命名为**manager**。您可以通过双击表的标题栏或单击语法视图中略暗的**<Alias>**并输入**manager**来执行此操作。（前一种方法类似于在Windows资源管理器或Macintosh
    Finder中单击文件名下方或旁边的图标来重命名文件。）请参考以下屏幕截图：
- en: '![Building further queries](img/7461EN_02_22.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![构建进一步的查询](img/7461EN_02_22.jpg)'
- en: Connect the **department** table to the **employee** table by associating **id**
    of the **department** table to **department_id** of the **employee** table, and
    then connect the **employee** table to the **manager** table by associating **manager_id**
    of the **employee** table to **id** of the **manager** table. Convert these associations
    to **LEFT** **JOIN** instances, so that we also retrieve the employees who are
    not assigned to any manager or a department.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将**department**表的**id**与**employee**表的**department_id**相关联，然后将**employee**表与**manager**表相关联，将**employee**表的**manager_id**与**manager**表的**id**相关联。将这些关联转换为**LEFT
    JOIN**实例，以便我们还可以检索未分配给任何经理或部门的员工。
- en: 'Next, select the following fields: **first_name** of the **employee** table,
    **last_name** of the **employee** table, **title** of the **employee** table,
    **salary** of the **employee** table, **perks** of the **employee** table, and
    **name** of the department table for the query.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，选择以下字段：**employee**表的**first_name**，**employee**表的**last_name**，**employee**表的**title**，**employee**表的**salary**，**employee**表的**perks**，以及查询的**department**表的**name**。
- en: 'Now we need to specify two conditions: **employee.salary** must be greater
    than `15,000` or **employee.perks** must be greater than `1,500`.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要指定两个条件：**employee.salary**必须大于`15000`或**employee.perks**必须大于`1500`。
- en: To add a condition in the visual editor, click on the symbol group **<--> =
    <-->** from the **WHERE** clause in the syntax view. Click on **<-->** to choose
    the field from the list of all the table fields, available in the query. To define
    your own criteria, you can type your values directly in the **Edit** tab. Click
    on the equals sign (**=**) to change the condition operator.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要在可视化编辑器中添加条件，请单击语法视图中**WHERE**子句中的符号组**<--> = <-->**。单击**<-->**以从查询中所有可用的表字段列表中选择字段。要定义自己的条件，可以直接在**编辑**选项卡中输入值。单击等号（**=**）以更改条件运算符。
- en: Now if we execute the query, we’ll get more or less of what we wanted; all the
    employees with salaries over $15,000 or perks over $1,500\. But the CEO is also
    on the list. Besides, the result sheet is not very appealing to the eye with some
    of the bizarre column names and with the first names and last names appearing
    in different columns. While in the query editor, we shall manually edit the SQL
    to address these issues while enjoying the comfort of Navicat’s code editor.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们执行查询，我们将得到更多或更少我们想要的结果；所有工资超过$15,000或津贴超过$1,500的员工。但CEO也在列表中。此外，结果表的列名有些奇怪，并且名字和姓氏出现在不同的列中，不太令人满意。在查询编辑器中，我们将手动编辑SQL以解决这些问题，同时享受Navicat代码编辑器的舒适性。
- en: I think it’s a good idea to concatenate the first and last names to show them
    in a single column, change the column title of department names to something sensible,
    exclude the CEO from the query results by adding another condition to the query,
    and sort the results by the amount of salaries in descending order.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为将名字和姓氏连接起来显示在一个列中是个好主意，将部门名称的列标题更改为有意义的内容，通过向查询添加另一个条件来排除CEO的查询结果，并按工资金额降序排序结果。
- en: 'To achieve these little goals, we’ll modify the SQL to resemble the following
    code listing and re-run the query:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些小目标，我们将修改SQL以使其类似于以下代码清单，并重新运行查询：
- en: '[PRE8]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Navicat also provides us with the ability to show the query profile and status,
    thanks to which we can monitor certain status parameters, such as table locks,
    system locks, and statistics under the **Profile** tab in the query results window.
    Refer to the following screen shot:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Navicat还为我们提供了显示查询概要和状态的能力，借助这一功能，我们可以监视某些状态参数，如表锁定、系统锁定和统计信息，在查询结果窗口的**概要**选项卡下。参考以下屏幕截图：
- en: '![Building further queries](img/7461EN_02_23.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![构建更多查询](img/7461EN_02_23.jpg)'
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have covered a great deal of database features from Navicat
    and we learned how to create and manage database objects using Navicat’s visual
    tools.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经涵盖了许多Navicat的数据库功能，并学会了如何使用Navicat的可视工具创建和管理数据库对象。
- en: 'We now know how to make use of Navicat’s GUI tools to:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何使用Navicat的GUI工具来：
- en: Create a database and perform its initial setup
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据库并执行其初始设置
- en: Create and manage database objects such as tables and views
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和管理数据库对象，如表和视图
- en: Define foreign key constraints and triggers
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义外键约束和触发器
- en: Create stored procedures and functions
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建存储过程和函数
- en: Schedule tasks using MySQL events
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MySQL事件调度任务
- en: Design and customize queries
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和自定义查询
- en: In the next chapter, we will see in detail Navicat’s data management tools and
    learn how to manipulate and transform databases easily using Navicat.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将详细了解Navicat的数据管理工具，并学习如何使用Navicat轻松操作和转换数据库。
