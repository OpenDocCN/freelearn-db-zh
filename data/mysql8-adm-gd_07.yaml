- en: Indexing in MySQL 8
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQL 8中的索引
- en: In the previous chapter, we learned about storage engines. Now we are aware
    what types of storage engines are available and which ones to use for our requirements.
    The previous chapter also covered the `InnoDB` storage engine in detail, along
    with other storage engine information. It also described how to define a custom
    storage engine for use, with a practical example. Now it's time to understand
    one more important functionality of MySQL 8 and that is, indexing. We will cover
    different types of indexes with their functionalities, which will encourage you
    to use indexes and provided you with guidance on how to use them. So, your journey
    into indexes has started! Let's go.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了存储引擎。现在我们知道了有哪些类型的存储引擎可用，以及哪些存储引擎适合我们的需求。上一章还详细介绍了`InnoDB`存储引擎，以及其他存储引擎信息。它还描述了如何定义用于使用的自定义存储引擎，并提供了一个实际示例。现在是时候了解MySQL
    8的另一个重要功能，即索引。我们将涵盖不同类型的索引及其功能，这将鼓励您使用索引，并为您提供如何使用它们的指导。因此，您的索引之旅已经开始！让我们开始吧。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: An overview on indexing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引概述
- en: Column-level indexing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列级索引
- en: B-Tree indexes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B-Tree索引
- en: Hash indexes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希索引
- en: Index extensions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引扩展
- en: Using an optimizer for indexes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用优化器进行索引
- en: Invisible and descending indexes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可见和降序索引
- en: An overview on indexing
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引概述
- en: To define an index on a table is the best way to improve the performance of
    the `SELECT` operation. An index acts like a pointer for the table rows and permits
    queries to quickly point to matching rows based on the `WHERE` condition. MySQL
    8 allows you to create indexes on all the data types. Although indexing provides
    good performance on queries, it is recommend to define it in the proper way, because
    unnecessary indexes waste space and time (for MySQL 8 to find which index is best
    to use). In addition to that, indexes also add costs to `INSERT`, `UPDATE`, and
    `DELETE` operations, because during these operations, MySQL 8 will update each
    index.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在表上定义索引是改善`SELECT`操作性能的最佳方式。索引就像表行的指针，允许查询根据`WHERE`条件快速指向匹配的行。MySQL 8允许您在所有数据类型上创建索引。尽管索引在查询中提供了良好的性能，但建议以正确的方式定义它，因为不必要的索引会浪费空间和时间（MySQL
    8需要找到最佳使用的索引）。此外，索引还会增加`INSERT`、`UPDATE`和`DELETE`操作的成本，因为在这些操作期间，MySQL 8将更新每个索引。
- en: 'As we described previously, an index is a data structure that improves the
    speed of operations. Based on the structure, an index is bifurcated into two major
    forms—a clustered index and a non-clustered index:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所描述的，索引是一种改善操作速度的数据结构。根据结构，索引分为两种主要形式——聚集索引和非聚集索引：
- en: '**Clustered index**: A clustered index defines the order in which data is physically
    stored in a table. Therefore, only one clustered index is allowed per table. It
    greatly increases the speed of retrieval when data is retrieved in a sequential
    manner, either in the same order or in reverse order. A clustered index also provides
    better performance when a range of items are selected. A primary key is defined
    as a clustered index.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚集索引**：聚集索引定义了数据在表中的物理存储顺序。因此，每个表只允许一个聚集索引。当以顺序方式检索数据时，无论是相同顺序还是相反顺序，聚集索引都会大大提高检索速度。当选择一系列项目时，聚集索引也提供更好的性能。主键被定义为聚集索引。'
- en: '**Non-clustered index**: A non-clustered index doesn''t define the order in
    which data is physically stored. This means a non-clustered index is stored in
    one place, and data is stored in another place. Therefore, more than one non-clustered
    index is allowed per table. It refers to non-primary keys.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非聚集索引**：非聚集索引不定义数据物理存储的顺序。这意味着非聚集索引存储在一个地方，数据存储在另一个地方。因此，每个表允许有多个非聚集索引。它指的是非主键。'
- en: As we know, the primary key represents the column, or set of columns, which
    is most widely used for fetching records from the table. The primary key has an
    index associated with it and is used for fast query performance. It provides comparatively
    faster performance because a primary key does not allow a `NULL` value, so no
    check is required on `NULL` values. It is recommended that if your table does
    not have a column or set of columns to define as a primary key, then you define
    one auto increment field as the primary key for better performance. On the other
    hand, if your table contains many columns and there is a need to execute a query
    with a combination of multiple columns, then it is advisable to the less frequently
    used data and transfer in onto a separate table. Relate all the separate tables
    with primary and foreign key references, which will help you in managing data,
    and query retrieval provides you good performance.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，主键代表从表中获取记录最广泛使用的列或列集。主键与之关联的索引用于快速查询性能。它提供了相对较快的性能，因为主键不允许`NULL`值，因此不需要对`NULL`值进行检查。建议如果您的表没有列或列集来定义为主键，那么为了更好的性能，您可以定义一个自动增量字段作为主键。另一方面，如果您的表包含许多列，并且需要执行带有多列组合的查询，则建议将不经常使用的数据转移到单独的表中。将所有单独的表与主键和外键引用相关联，这将帮助您管理数据，并且查询检索会提供良好的性能。
- en: Uses of indexes in MySQL 8
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQL 8中索引的用途
- en: 'Indexes are mainly used to find a row of specific values without iterating
    a complete table. If an index is not define,d then MySQL 8 will start searching
    from the first row and then read the entire table, which makes for a costly operation.
    MySQL 8 uses indexes for the following operations:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 索引主要用于在不迭代完整表的情况下找到特定值的行。如果未定义索引，则MySQL 8将从第一行开始搜索，然后读取整个表，这将导致昂贵的操作。MySQL 8使用索引进行以下操作：
- en: To sort or group tables when it is done on the left-most prefix of an index.
    This means that if all keys are defined for the `DESC` clause, then the keys will
    be considered in reverse order, and if all keys are followed by `ASC`, then the
    keys will be considered in forward order.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对索引的最左前缀进行排序或分组时。这意味着如果所有键都为`DESC`子句定义，那么键将按相反顺序考虑，如果所有键后跟`ASC`，则键将按正向顺序考虑。
- en: To find rows whose values match with the `WHERE` clause.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找与`WHERE`子句匹配的行。
- en: In the case of multiple column indexes, any left-most prefix of the index can
    be used to find the row. This topic is covered in the later part of this chapter
    with a detailed example.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于多列索引，可以使用索引的任何最左前缀来查找行。本章后面将以详细示例介绍此主题。
- en: If there is a case where MySQL has to choose one index from multiple options,
    then it will choose the index which has the smallest set of rows.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果MySQL需要从多个选项中选择一个索引，则会选择具有最小行集的索引。
- en: 'Sometimes, the query is optimized to get the values without referring to rows.
    For example, if the query uses only columns that are included in indexes, MySQL
    8 will get the selected value from the index tree:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，查询会被优化以获取值而不是引用行。例如，如果查询仅使用包含在索引中的列，MySQL 8将从索引树中获取所选值：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At the time of performing the join, MySQL 8 will use the index in a more efficient
    way, if columns are declared with the same type and size. For example, `VARCHAR
    (15)` and `CHAR(15)` will be considered as the same, but `VARCHAR(10)` and `CHAR(15)`
    will not be considered as the same.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行连接时，如果列声明为相同的类型和大小，MySQL 8将以更有效的方式使用索引。例如，`VARCHAR(15)`和`CHAR(15)`将被视为相同，但`VARCHAR(10)`和`CHAR(15)`将不被视为相同。
- en: 'In the case of `MIN ()` and `MAX ()` functions, if you have used part of the
    index columns, then the optimizer will check whether all the other parts of the
    index columns are available in the `WHERE` condition. If they are mentioned, then
    MySQL 8 will perform a single lookup for the `MIN ()` and `MAX ()` functions and
    replace them with constants. For example:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`MIN()`和`MAX()`函数，如果使用了索引列的一部分，优化器将检查索引列的所有其他部分是否在`WHERE`条件中可用。如果提到了，MySQL
    8将执行`MIN()`和`MAX()`函数的单个查找，并用常量替换它们。例如：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: SQL commands related to indexes
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与索引相关的SQL命令
- en: MySQL 8 provides two main commands related to indexes. We will discuss these
    commands in the following sections.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8提供了两个与索引相关的主要命令。我们将在以下部分讨论这些命令。
- en: Creating an INDEX command
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建INDEX命令
- en: 'The following command enables the user to add indexes into an existing table.
    This command is also used with `CREATE TABLE` and `ALTER TABLE` to create indexes:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令允许用户向现有表中添加索引。此命令也可与`CREATE TABLE`和`ALTER TABLE`一起使用以创建索引：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Using `col_name(length)` syntax, the user is able to specify an index prefix
    length, which will consider only a specified number of characters from the string
    value. At the time of defining, the prefix considers the following points:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`col_name(length)`语法，用户可以指定索引前缀长度，只考虑字符串值中指定数量的字符。在定义时，前缀考虑以下几点：
- en: The prefix is optional for `CHAR`, `VARCHAR`, `BINARY`, and `VARBINARY` column
    indexes
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`CHAR`、`VARCHAR`、`BINARY`和`VARBINARY`列索引，前缀是可选的
- en: The prefix must be specified in the case of `BLOB `and `TEXT `column indexes
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`BLOB`和`TEXT`列索引中必须指定前缀
- en: MySQL 8 will consider prefixes as a number of characters for non-binary string
    types (`CHAR`, `VARCHAR`, `TEXT`) and a number of bytes for binary types (`BINARY`, `VARBINARY`, `BLOB`)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL 8将考虑非二进制字符串类型（`CHAR`、`VARCHAR`、`TEXT`）的字符数和二进制类型（`BINARY`、`VARBINARY`、`BLOB`）的字节数作为前缀
- en: The prefix is not allowed for the spatial columns
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空间列不允许前缀
- en: 'A detailed example of the prefix option is described later in this chapter,
    under the *Column indexes* section. A `UNIQUE` index is a constraint which indicates
    that all the values in the index will be unique. If you try to add values which
    already exist, then MySQL 8 displays an error. All types of storage engines with
    a `UNIQUE` index permit multiple null values. In the case of prefixes when you
    use `NULL` values, make sure column values are unique within the prefixes. If
    an index prefix exceeds its size, then MySQL 8 will handle the index as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面的*列索引*部分将详细介绍前缀选项的示例。`UNIQUE`索引是一个约束，表示索引中的所有值都将是唯一的。如果尝试添加已经存在的值，MySQL
    8会显示错误。所有类型的存储引擎都允许在`UNIQUE`索引中存在多个空值。在使用`NULL`值时，确保列值在前缀内是唯一的。如果索引前缀超出其大小，MySQL
    8将按以下方式处理索引：
- en: '**For a non-unique index**: If the strict SQL mode is enabled, then MySQL 8
    will throw an error, and if the strict mode is disabled, then the index length
    is reduced to the maximum column data type size and will produce a warning.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于非唯一索引**：如果启用了严格的SQL模式，MySQL 8会抛出错误，如果禁用了严格模式，则索引长度将减少到最大列数据类型大小，并产生警告。'
- en: '**For a unique index**: In this case, MySQL 8 produces an error regardless
    of the SQL mode, because it might break the uniqueness of the column. This means
    you have defined a column with 25 length and tried to define an index on the same
    column with a prefix length 27; then MySQL 8 throws an error.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于唯一索引**：在这种情况下，无论SQL模式如何，MySQL 8都会产生错误，因为这可能会破坏列的唯一性。这意味着您定义了一个长度为25的列，并尝试在相同列上定义一个前缀长度为27的索引，那么MySQL
    8会报错。'
- en: Spatial index characteristics
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空间索引特性
- en: 'MySQL 8 follows the following rules for spatial index characteristics:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8遵循以下规则来处理空间索引特性：
- en: It is only available for `InnoDB` and `MyISAM` storage engines; if you try to
    use it for other storage engines, then MySQL 8 gives an error.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅适用于`InnoDB`和`MyISAM`存储引擎；如果尝试用于其他存储引擎，MySQL 8会报错。
- en: A `NULL` value is not allowed for indexed columns.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许对索引列使用`NULL`值。
- en: A prefix attribute is not allowed for this column. Full width will be considered
    for the index.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此列不允许使用前缀属性。索引将考虑全宽度。
- en: Non-spatial index characteristics
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非空间索引特性
- en: 'MySQL 8 follows the following rules for non-spatial index characteristics:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8 遵循以下规则，用于非空间索引特性：
- en: A `NULL` value is allowed for an indexed column in the case of `InnoDB`, `MyISAM`,
    and `MEMORY` storage engines.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `InnoDB`、`MyISAM` 和 `MEMORY` 存储引擎，允许在索引列中使用 `NULL` 值。
- en: The column prefix length must be specified in the case of each spatial column,
    if it exists under a non-spatial index. The prefix length will be considered in
    terms of bytes.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个空间列的情况下，必须指定列前缀长度，如果它存在于非空间索引中。前缀长度将以字节为单位。
- en: Except for `ARCHIVE`, it is supported for all the storage engines which support
    spatial columns.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了 `ARCHIVE`，它适用于所有支持空间列的存储引擎。
- en: A `NULL` value is allowed for this index, unless it is defined as a `PRIMARY`
    key.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于此索引，允许使用 `NULL` 值，除非它被定义为 `PRIMARY` 键。
- en: For an `InnoDB` table, run the `ANALYZE TABLE` statement after creating an index
    on that table, if the `innodb_stats_persistent` setting is enabled.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `InnoDB` 表，在创建表上的索引后，如果启用了 `innodb_stats_persistent` 设置，则运行 `ANALYZE TABLE` 语句。
- en: The index type will depend on the storage engine; currently, B-Tree is used.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引类型将取决于存储引擎；目前使用 B-Tree。
- en: A non-spatial index is allowed on a `BLOB` or `TEXT` column only if it is defined
    using `InnoDB` and `MyISAM` tables.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在使用 `InnoDB` 和 `MyISAM` 表定义时，才允许在 `BLOB` 或 `TEXT` 列上使用非空间索引。
- en: 'The default value of the `index_col_name` attribute is in ascending order,
    and neither an `ASC` nor `DESC` value is permitted for `HASH` indexes with this
    attribute. MySQL 8 provides any of the following values with the `index_option`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`index_col_name` 属性的默认值是升序的，对于具有此属性的 `HASH` 索引，不允许使用 `ASC` 或 `DESC` 值。MySQL
    8 提供以下任何一个值与 `index_option`：'
- en: '`KEY_BLOCK_SIZE [=]` value: This parameter defines the size of the index key
    block in bytes. It is an optional parameter and its value is treated as a hint.
    MySQL 8 may use a different size if it is required. If this parameter is defined
    at the individual index level, then it overrides the table-level `KEY_BLOCK_SIZE` value.
    The `InnoDB` engine doesn''t support this parameter at the index level; it allows
    it at the table level only.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KEY_BLOCK_SIZE [=]` value: 此参数定义了索引键块的大小（以字节为单位）。这是一个可选参数，其值被视为提示。如果需要，MySQL
    8 可能会使用不同的大小。如果此参数在单个索引级别上定义，则它会覆盖表级别的 `KEY_BLOCK_SIZE` 值。`InnoDB` 引擎不支持此参数在索引级别上；它只允许在表级别上使用。'
- en: '`index_type`: MySQL 8 permits the user to define the index type at the time
    of index creation. For example:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index_type`：MySQL 8 允许用户在索引创建时定义索引类型。例如：'
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Refer to the following table to find the permissible index types related to
    the storage engine. Consider the first index type as the default type in cases
    where multiple types are defined. If any storage engine is not mentioned in this
    table, it means that the index type is not supported by that engine:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下表格，查找与存储引擎相关的允许的索引类型。在多种类型定义的情况下，将第一个索引类型视为默认类型。如果此表中未提及任何存储引擎，则表示该引擎不支持该索引类型。
- en: '| **Storage Engine** | **Permissible Index Types** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **存储引擎** | **允许的索引类型** |'
- en: '| --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `InnoDB` | `BTREE` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `InnoDB` | `BTREE` |'
- en: '| `MyISAM` | `BTREE` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `MyISAM` | `BTREE` |'
- en: '| `MEMORY`/`HEAP` | `HASH`, `BTREE` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `MEMORY`/`HEAP` | `HASH`, `BTREE` |'
- en: '| `NDB` | `HASH`, `BTREE` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `NDB` | `HASH`, `BTREE` |'
- en: Reference: [https://dev.mysql.com/doc/refman/8.0/en/create-index.html](https://dev.mysql.com/doc/refman/8.0/en/create-index.html)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 参考：[https://dev.mysql.com/doc/refman/8.0/en/create-index.html](https://dev.mysql.com/doc/refman/8.0/en/create-index.html)
- en: 'If you try to define an index type which is not supported by the storage engine,
    then MySQL 8 will consider it as a supported index type, without affecting the
    query result. Refer to the following table to learn more about the characteristics
    of indexes, based on storage types:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试定义存储引擎不支持的索引类型，则 MySQL 8 将其视为支持的索引类型，而不会影响查询结果。请参考以下表格，了解基于存储类型的索引特性：
- en: '| **Storage Engine** | **Index Type** | **Index Class** | **Stores NULL Values**
    | **Permits Multiple NULL Values** | **IS NULL Scan Type** | **IS NOT NULL Scan
    Type** |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **存储引擎** | **索引类型** | **索引类** | **存储 NULL 值** | **允许多个 NULL 值** | **IS NULL
    扫描类型** | **IS NOT NULL 扫描类型** |'
- en: '| `InnoDB` | `BTREE` | Primary key | No | No | N/A | N/A |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `InnoDB` | `BTREE` | Primary key | No | No | N/A | N/A |'
- en: '| Unique | Yes | Yes | Index | Index |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| Unique | Yes | Yes | Index | Index |'
- en: '| Key | Yes | Yes | Index | Index |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| Key | Yes | Yes | Index | Index |'
- en: '| Inapplicable | `FULLTEXT` | Yes | Yes | Table | Table |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 不适用 | `FULLTEXT` | Yes | Yes | Table | Table |'
- en: '| Inapplicable | SPATIAL | No | No | N/A | N/A |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 不适用 | SPATIAL | No | No | N/A | N/A |'
- en: '| `MyISAM` | `BTREE` | Primary key | No | No | N/A | N/A |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `MyISAM` | `BTREE` | Primary key | No | No | N/A | N/A |'
- en: '| Unique | Yes | Yes | Index | Index |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| Unique | Yes | Yes | Index | Index |'
- en: '| Key | Yes | Yes | Index | Index |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| Key | Yes | Yes | Index | Index |'
- en: '| Inapplicable | `FULLTEXT` | Yes | Yes | Table | Table |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 不适用 | `FULLTEXT` | Yes | Yes | Table | Table |'
- en: '| Inapplicable | SPATIAL | No | No | N/A | N/A |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 不适用 | SPATIAL | No | No | N/A | N/A |'
- en: '| `MEMORY` | `HASH` | Primary key | No | No | N/A | N/A |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `MEMORY` | `HASH` | Primary key | No | No | N/A | N/A |'
- en: '| Unique | Yes | Yes | Index | Index |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| Unique | Yes | Yes | Index | Index |'
- en: '| Key | Yes | Yes | Index | Index |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| Key | Yes | Yes | Index | Index |'
- en: '| `BTREE` | Primary | No | No | N/A | N/A |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `BTREE` | Primary | No | No | N/A | N/A |'
- en: '| Unique | Yes | Yes | Index | Index |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| Unique | Yes | Yes | Index | Index |'
- en: '| Key | Yes | Yes | Index | Index |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| Key | Yes | Yes | Index | Index |'
- en: Reference: [https://dev.mysql.com/doc/refman/8.0/en/create-index.html](https://dev.mysql.com/doc/refman/8.0/en/create-index.html)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 参考：[https://dev.mysql.com/doc/refman/8.0/en/create-index.html](https://dev.mysql.com/doc/refman/8.0/en/create-index.html)
- en: '`WITH PARSER parser_name`: This option is valid only for a `FULLTEXT` index
    which was supported by a `InnoDB` and `MyISAM` storage engine. If `FULLTEXT` index
    and searching operations require special handling, then MySQL 8 will use a parser
    plugin with the index.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WITH PARSER parser_name`：此选项仅适用于由 `InnoDB` 和 `MyISAM` 存储引擎支持的 `FULLTEXT` 索引。如果
    `FULLTEXT` 索引和搜索操作需要特殊处理，则 MySQL 8 将使用索引的解析器插件。'
- en: '`COMMENT ''string''`: This attribute is optional and allows up to 1024 characters
    in comments. This option also supports the `MERGE_THRESHOLD` parameter whose default
    value is 50\. Consider the following command to define the `MERGE_THRESHOLD`:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMMENT ''string''`：此属性是可选的，允许在注释中使用最多1024个字符。此选项还支持`MERGE_THRESHOLD`参数，其默认值为50。考虑以下命令来定义`MERGE_THRESHOLD`：'
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If the page-full percentage for an index is less than the `MERGE_THRESHOLD` value,
    then the `InnoDB` storage engine will merge the index page with a neighboring
    index page.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果索引的页满百分比低于`MERGE_THRESHOLD`值，那么`InnoDB`存储引擎将会将索引页与相邻的索引页合并。
- en: '`VISIBLE`, `INVISIBLE`: This parameter defines the index visibility. By default,
    all indexes are visible. The optimizer will not use an invisible index during
    the optimization process.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VISIBLE`，`INVISIBLE`：此参数定义了索引的可见性。默认情况下，所有索引都是可见的。优化器在优化过程中不会使用不可见的索引。'
- en: The `ALGORITHM`and `LOCK` attributes will have an impact when you try to use
    the table for reading or writing, and while simultaneously modifying its indexing.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当您尝试使用表进行读取或写入，并同时修改其索引时，`ALGORITHM`和`LOCK`属性将产生影响。
- en: Drop index command
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除索引命令
- en: 'The following command drops the index from the table. We can also map this
    statement with `ALTER TABLE` to drop the index from the table:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令从表中删除索引。我们也可以将此语句映射到`ALTER TABLE`以从表中删除索引：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this command, only two options are available: the algorithm and the lock.
    Both of these options are useful in the case of concurrent access of index and
    work, similar to the `CREATE INDEX` command. For example, to drop the index of
    an employee table, execute the following command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在此命令中，只有两个选项可用：算法和锁。这两个选项在索引的并发访问和工作情况下非常有用，类似于`CREATE INDEX`命令。例如，要删除员工表的索引，请执行以下命令：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: SPATIAL index creation and optimization
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空间索引的创建和优化
- en: 'MySQL 8 allows you to create a spatial index on a `InnoDB` and `MyISAM` storage
    engine using the same syntax mentioned in the preceding topic. The only change
    in the standard command is to use the keyword **spatial** at the time of creating
    the index. When you define a spatial index, make sure that the column is declared
    as `NOT NULL`. The following code demonstrates the method to create a spatial
    index on table:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8允许您在`InnoDB`和`MyISAM`存储引擎上使用与前述主题中提到的相同语法创建空间索引。标准命令中唯一的变化是在创建索引时使用关键字**spatial**。在定义空间索引时，请确保列声明为`NOT
    NULL`。以下代码演示了在表上创建空间索引的方法：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The spatial index, by default, creates an R-Tree index. From MySQL 8.0.3 onwards,
    the optimizer checks the **spatial reference identifier** (**SRID**) attribute
    of the indexed column to find the **Spatial Reference System** (**SRS**) for comparisons
    and performs calculations according to SRS. For comparison, each column in a spatial
    index must be SRID-restricted. This means that each column definition must contain
    an SRID attribute, and all the column values must have the same SRID. The spatial
    index performs the following two actions based on the SRID:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，空间索引会创建一个R-Tree索引。从MySQL 8.0.3开始，优化器会检查索引列的**空间参考标识符**（**SRID**）属性，以找到用于比较和执行计算的**空间参考系统**（**SRS**）。对于比较，空间索引中的每个列必须受到SRID的限制。这意味着每个列定义必须包含一个SRID属性，并且所有列值必须具有相同的SRID。基于SRID，空间索引执行以下两个操作：
- en: If the column is restricted to a **Cartesian SRID**, then it enables Cartesian
    bounding box computation
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果列被限制为**笛卡尔SRID**，那么它会启用笛卡尔边界框计算
- en: If the column is restricted to a **Geographic SRID**, then it enables geographic
    bounding box computation
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果列被限制为**地理SRID**，那么它会启用地理边界框计算
- en: 'As mentioned above, MySQL 8 will ignore a `SPATIAL INDEX` on a column which
    does not have an SRID attribute, but MySQL still manages these indexes as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，MySQL 8将忽略没有SRID属性的列上的`SPATIAL INDEX`，但MySQL仍会管理这些索引，如下所示：
- en: These types of indexes are updated when the table is modified with the `INSERT`,
    `UPDATE`, or `DELETE` command.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些类型的索引在表被使用`INSERT`，`UPDATE`或`DELETE`命令修改时会被更新。
- en: 'These indexes are considered in dump backups and are restored with backward
    compatibility. As mentioned in the previous point, spatial indexes with no SRID
    restricted columns are not used by the optimizer, so in that case, all these columns
    must be modified. To modify them, perform the following steps:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些索引在转储备份中被考虑，并且可以通过向后兼容性进行恢复。如前所述，没有受到SRID限制列的空间索引不会被优化器使用，因此在这种情况下，所有这些列必须被修改。要修改它们，请执行以下步骤：
- en: 'Check all the values of the column that have the same `ST_SRID` with the following
    command:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查具有相同`ST_SRID`的列的所有值：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If the query returns multiple rows, then it indicates that the column contains
    mixed SRIDs. If so, change the contents of the column for the same SRID value.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查询返回多行，则表示该列包含混合的SRID。如果是这样，请更改列的内容为相同的SRID值。
- en: Define an explicit SRID for the column.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为列定义一个显式的SRID。
- en: Recreate the `SPATIAL INDEX`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新创建`SPATIAL INDEX`。
- en: InnoDB and MyISAM index statistics collection
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InnoDB和MyISAM索引统计收集
- en: 'MySQL 8 will consider table statistics based on the value group, which is nothing
    but a set of rows with the same prefix values. The storage engine collects statistics
    related to the table, which are used by the optimizer. From the optimization perspective, average
    value group size is an important statistic. If the average value of the group
    size increases, then the index is not meaningful. So, it''s better to target a
    small number of rows for each index. This can be achieved by table cardinality,
    which is nothing but a number of value group. For `InnoDB` and `MyISAM` tables,
    MySQL 8 provides control on statistics by the `myisam_stats_method` and the `innodb_stats_method`
    system variables. The following are the possible values for these variables:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8将根据值组对表统计信息进行考虑，这只是具有相同前缀值的一组行。存储引擎收集与表相关的统计信息，这些信息由优化器使用。从优化的角度来看，平均值组大小是一个重要的统计数据。如果组的平均值大小增加，那么索引就没有意义。因此，最好为每个索引定位少量行。这可以通过表基数来实现，即值组的数量。对于`InnoDB`和`MyISAM`表，MySQL
    8通过`myisam_stats_method`和`innodb_stats_method`系统变量提供了对统计信息的控制。以下是这些变量的可能值：
- en: '`nulls_ignored`: It indicates that `NULL` values are ignored'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nulls_ignored`：表示`NULL`值被忽略'
- en: '`nulls_equal`: It indicates all `NULL` values are identical'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nulls_equal`：表示所有`NULL`值相同'
- en: '`nulls_unequal`: It indicates all `NULL` values are not identical'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nulls_unequal`：表示所有`NULL`值不相同'
- en: 'The `innodb_stats_method` system variable has a global value, while the `myisam_stats_method` system
    variable has both global and session values. When we set a global value of a variable,
    it will affect statistics collection for tables from the corresponding storage
    engine. In the case of session value statistics, collection is available only
    for the current client connection. This means that you have to regenerate a table''s
    statistics for the other client on the same table without affecting other clients,
    and need to set it in a session value. To regenerate `MyISAM` statistics, use
    either of these methods:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`innodb_stats_method`系统变量具有全局值，而`myisam_stats_method`系统变量具有全局值和会话值。当我们设置变量的全局值时，它将影响相应存储引擎的表的统计信息收集。在会话值统计的情况下，仅对当前客户端连接可用。这意味着您必须为其他客户端重新生成表的统计信息，而不影响其他客户端，并且需要在会话值中设置它。要重新生成`MyISAM`统计信息，请使用以下方法之一：'
- en: Execute the `myisamchk --stats_method=method_name --analyze` command
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行`myisamchk --stats_method=method_name --analyze`命令
- en: Make changes to the table to make its statistics out of date, and then set `myisam_stats_method` and
    issue an `ANALYZE TABLE` statement
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改表以使其统计信息过时，然后设置`myisam_stats_method`并发出`ANALYZE TABLE`语句
- en: 'There are some points that must be considered before using these two variables:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这两个变量之前，必须考虑一些要点：
- en: These variables are available only for `InnoDB` and `MyISAM` tables. For other
    storage engines, only one method is available to collect table statistics, and
    it is very near to the `nulls_equal` method.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些变量仅适用于`InnoDB`和`MyISAM`表。对于其他存储引擎，只有一种方法可用于收集表统计信息，它非常接近`nulls_equal`方法。
- en: MySQL 8 provides a way to generate statistics for a table explicitly, but this
    is not always the case. Sometimes, MySQL 8 may also generate statistics automatically,
    if it is required. For example, in the case of any operations, if some of the
    SQL statements modified table data, then MySQL 8 will automatically collect statistics.
    Consider bulk insert or delete operations.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL 8提供了一种明确为表生成统计信息的方法，但情况并非总是如此。有时，如果需要，MySQL 8也会自动生成统计信息。例如，在任何操作的情况下，如果某些SQL语句修改了表数据，那么MySQL
    8将自动收集统计信息。考虑批量插入或删除操作。
- en: We cannot say which method was used to generate statistics for a table.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们无法确定用于生成表统计信息的方法。
- en: Column-level indexing
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列级索引
- en: MySQL 8 allows you to create an index on a single column, as well as on multiple
    columns. The maximum number of indexes per table and maximum index length depend
    on the storage engine. Mostly, all the storage engines allow at least 16 indexes
    per table and total index lengths of at least 256 bytes, but most of the storage
    engines permit higher limits.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8允许您在单个列上创建索引，也可以在多个列上创建索引。每个表的最大索引数和最大索引长度取决于存储引擎。大多数存储引擎允许每个表至少有16个索引和至少256个字节的总索引长度，但大多数存储引擎允许更高的限制。
- en: Column indexes
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列索引
- en: This is the most common way to define an index where only a single column is
    involved. MySQL 8 stores a copy of column values in a data structure so that rows
    can be accessed quickly. MySQL 8 uses a **B-Tree** data structure to enable values to
    be accessed quickly. The B-Tree execution will work based on operators, such as
    `=`, `<`, `>`, `BETWEEN`, `IN`, and many more, which were defined in the `where`
    condition. You can get details on the B-Tree data structure and its execution
    in the next topic. We will discuss the characters of column indexes in the coming
    sections.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是定义只涉及单个列的索引的最常见方法。MySQL 8将列值的副本存储在数据结构中，以便可以快速访问行。MySQL 8使用**B-Tree**数据结构来快速访问值。
    B-Tree执行将基于在`where`条件中定义的操作符，例如`=`,`<`,`>`,`BETWEEN`,`IN`等。您可以在下一个主题中了解有关B-Tree数据结构及其执行的详细信息。我们将在接下来的部分讨论列索引的特点。
- en: Index prefixes
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引前缀
- en: 'This option allows the user to specify the number of characters for indexing
    in the case of a string. MySQL 8 has provided the option `column_name(N)`, in
    index creation to specify a number of characters. Indexing prefers only specified
    characters, which will make the index file smaller. So, at the time of the `BLOB`
    and `TEXT` column, you must specify the prefix length for better performance.
    Consider the following example to create indexes with prefix lengths on the `BLOB`
    type:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项允许用户在字符串的情况下指定用于索引的字符数。MySQL 8在索引创建中提供了`column_name(N)`选项，用于指定字符数。索引优先考虑只指定的字符，这将使索引文件更小。因此，在`BLOB`和`TEXT`列的情况下，您必须为了更好的性能指定前缀长度。考虑以下示例，在`BLOB`类型上创建带有前缀长度的索引：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This command creates an index on the `personal_data` column by considering the
    first eight characters. The prefix length varies, based on the storage engine.
    The `InnoDB` storage engine allows up to a 767 byte prefix length for `REDUNDANT` or `COMPACT` row
    formats, while in the case of `DYNAMIC` or `COMPRESSED` row formats, it allows
    up to 3072 bytes. In the case of the `MyISAM` storage engine, the prefix can be
    defined for up to 1,000 bytes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令通过考虑前八个字符在`personal_data`列上创建索引。前缀长度根据存储引擎而变化。`InnoDB`存储引擎允许对`REDUNDANT`或`COMPACT`行格式最多有767字节的前缀长度，而对于`DYNAMIC`或`COMPRESSED`行格式，它允许最多3072字节。在`MyISAM`存储引擎的情况下，前缀最多可以定义为1000字节。
- en: Prefix length will be measured in bytes for binary string types, such as `BINARY`, `VARBINARY`,
    and `BLOB`, while in the case of non-binary string types, it will be considered
    as a number of characters.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀长度将以字节为单位测量二进制字符串类型，例如`BINARY`，`VARBINARY`和`BLOB`，而对于非二进制字符串类型，它将被视为字符数。
- en: FULLTEXT indexes
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FULLTEXT索引
- en: 'As the name implies, `FULLTEXT` indexes allow `CHAR`, `VARCHAR`, and `TEXT` columns
    only. This index is supported by `InnoDB` and `MyISAM` storage engines. In this
    type, indexing will take place on an entire column, rather than a prefix length.
    MySQL 8 evaluates the full text expression during the optimization phase of the
    query execution. Before making estimations, optimization evaluates the full text
    expression in the process of developing an execution plan. As a result, the `EXPLAIN`
    query of full text is slower than non-full text queries. Full text queries are
    useful in the following scenarios:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，`FULLTEXT`索引仅允许`CHAR`，`VARCHAR`和`TEXT`列。此索引受`InnoDB`和`MyISAM`存储引擎支持。在这种类型中，索引将在整个列上进行，而不是在前缀长度上。MySQL
    8在查询执行的优化阶段评估全文表达式。在进行执行计划的过程中，优化会在进行估计之前评估全文表达式。因此，全文查询的`EXPLAIN`查询比非全文查询慢。全文查询在以下情况下很有用：
- en: When a `FULLTEXT` query returns either a document ID or a document ID and search
    rank
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`FULLTEXT`查询返回文档ID或文档ID和搜索排名时
- en: When a `FULLTEXT` query sorts the matching rows by descending order and uses
    a `LIMIT` clause to fetch *N* number of rows, apply only a single `ORDER BY` clause
    in descending order, and don't use a `WHERE` clause in it for optimization
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`FULLTEXT`查询按降序对匹配行进行排序并使用`LIMIT`子句获取*N*行数时，只应用单个降序`ORDER BY`子句，并且不要在其中使用`WHERE`子句进行优化
- en: When a `FULLTEXT` query fetches a `COUNT(*)` value from the rows without any
    additional `WHERE` clauses, apply the `WHERE` clause as `WHERE MATCH(text)` `AGAINST
    ('other_text')`, without any `>` 0 comparison operator
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`FULLTEXT`查询从行中获取`COUNT(*)`值而没有任何额外的`WHERE`子句时，应用`WHERE`子句为`WHERE MATCH(text)`
    `AGAINST ('other_text')`，而不使用`>` 0比较运算符
- en: Spatial Indexes
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空间索引
- en: MySQL 8 allows you to create indexes on spatial data types. The `InnoDB` and
    `MyISAM` storage engines support R-Tree for spatial data, while other storage
    engines use B-Tree. Since MySQL 5.7, spatial indexes are supported in `MyISAM`
    and `InnoDB` database engines.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8允许您在空间数据类型上创建索引。`InnoDB`和`MyISAM`存储引擎支持空间数据的R-Tree，而其他存储引擎使用B-Tree。自MySQL
    5.7以来，空间索引在`MyISAM`和`InnoDB`数据库引擎中得到支持。
- en: Indexes in the MEMORY storage engine
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存存储引擎中的索引
- en: Memory storage engines support both `HASH` indexes and B-Tree indexes, but `HASH`
    indexes are, by default, set for the `MEMORY` storage engine.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 内存存储引擎支持`HASH`索引和B-Tree索引，但默认情况下，`MEMORY`存储引擎设置为`HASH`索引。
- en: Multiple-column indexes
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多列索引
- en: 'MySQL 8 allows you to use multiple columns in a single index creation, which
    is also known as a **composite index**. It permits up to 16 columns in a composite
    index. At the time of composite index use, make sure you follow the same order
    of columns which was mentioned during index creation. A multiple-column index
    contains values generated by concatenating the values of indexed columns. Consider
    the following example in order to understand multiple-column indexes:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8允许您在单个索引创建中使用多个列，这也被称为**复合索引**。它允许在复合索引中最多使用16列。在使用复合索引时，请确保遵循在索引创建期间提到的相同列的顺序。多列索引包含通过连接索引列的值生成的值。请考虑以下示例以了解多列索引：
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As described above, we have defined composite indexes using two columns, `lastname`
    and `firstname`. The following queries use the name index:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，我们使用两列`lastname`和`firstname`定义了复合索引。以下查询使用了名称索引：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In all the preceding queries, we can see that the orders of columns are maintained
    in the `WHERE` condition, similar to that of index declaration. Indexes can also
    work when we define only the `lastname` column in the `WHERE` clause, because
    it is the left-most column defined in the index. Now, there are some queries in
    which composite indexes will not work:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有前述的查询中，我们可以看到列的顺序在`WHERE`条件中保持不变，类似于索引声明的顺序。当我们仅在`WHERE`子句中定义`lastname`列时，索引也可以起作用，因为它是索引中定义的最左边的列。现在，有一些查询中复合索引将不起作用：
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Remember, in the case of a multiple-column index, any left-most prefix of the
    index can be used by the optimizer for searching rows. For example, if the index
    was defined on three columns in sequence, `column1`, `column2`, and `column3`,
    then you can use indexed capabilities on (`column1`, `column2`, `column3`), (`column1`),
    (`column1`, `column2`), by defining it in the `WHERE` clause.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在多列索引的情况下，优化器可以使用索引的任何最左前缀来搜索行。例如，如果索引是按顺序定义的三列`column1`，`column2`和`column3`，那么您可以在`WHERE`子句中定义它，使用索引功能(`column1`,
    `column2`, `column3`), (`column1`), (`column1`, `column2`)。
- en: B-Tree index
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: B-Tree索引
- en: 'The main purpose of the B-Tree index is to reduce the number of physical read
    operations. A B-Tree index is created by sorting the data on the search key and
    maintaining a hierarchical search data structure, which helps to search for the
    correct page of data entries. `InnoDB` and `MyISAM` storage engines, by default,
    use the B-Tree index. B-Tree manages to keep an equal distance from all the leaf
    nodes to the root node. This index speeds up data access because there is no need
    to scan the whole data to get the desired output. Instead, it starts with the
    root node. The root node holds a pointer of child nodes, and the storage engine
    follows these pointers to find the next path. It finds the right path by considering
    values in the node page. The node page defines the upper and lower bounds of values
    in the child nodes. At the end of the search process, the storage engine either
    successfully reaches a leaf page, or concludes that there is no value associated
    with the search. Remember, the leaf pages point to the indexed data, and not to
    other pages. Now, let''s refer to one diagram to understand B-Tree indexes in
    more detail:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: B-Tree索引的主要目的是减少物理读取操作的次数。B-Tree索引是通过对搜索键进行排序并维护分层搜索数据结构来创建的，这有助于搜索正确的数据条目页。默认情况下，`InnoDB`和`MyISAM`存储引擎使用B-Tree索引。B-Tree设法使所有叶节点到根节点的距离相等。这个索引加快了数据访问，因为不需要扫描整个数据来获取所需的输出。相反，它从根节点开始。根节点保存子节点的指针，存储引擎遵循这些指针以找到下一个路径。它通过考虑节点页中的值来找到正确的路径。节点页定义了子节点中值的上限和下限。在搜索过程结束时，存储引擎要么成功到达叶页，要么得出结论，即没有与搜索相关联的值。请记住，叶页指向索引数据，而不是其他页面。现在，让我们参考一个图表，以更详细地了解B-Tree索引：
- en: '![](img/ea97c77d-fd74-4e49-ae58-5b66ce5342b8.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: 以下是B-Tree无法使用的查询：
- en: 'As discussed previously, when the query is executed against an index column,
    the MySQL 8 query engine starts from the root node, and through the intermediate
    nodes, it will reach a leaf node. Let''s take an example where you want to find
    the value 89 in an indexed column. In this case, the query engine refers to the
    root node to get the intermediate page reference. So, it will point to **1-100**.
    After that, it determines the next intermediate level, and points to the values
    **51-100**. Then the query engine goes to the third page, which is the next intermediate
    level, **76-100**. From there, it will find the leaf node for the value 89\. The
    leaf node contains either an entire row or a pointer to that row, depending on
    whether the index is clustered or non-clustered. Now, let''s understand how a
    B-Tree index works on a select query by considering the following table:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过考虑以下表格来了解B-Tree索引在选择查询中的工作原理：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As per the table definition index will contains values in combination of three
    columns `firstname`, `lastname`, and `dob`. It will sort values as per the order
    given previously; this means that if some employees have similar names, then they
    will be sorted by their birth dates. Consider the following types of queries which
    will benefit from the B-Tree index:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 根据表定义，索引将包含三列`firstname`、`lastname`和`dob`的组合值。它将根据先前给定的顺序对值进行排序；这意味着如果某些员工具有相似的名称，则它们将按其出生日期进行排序。考虑以下类型的查询，这些查询将受益于B-Tree索引：
- en: '**Match the range of values**: Finds the employees whose last names are Patel
    and Gupta.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**匹配完整值**：查找名为Mohan Patel且出生于1981年11月28日的员工。'
- en: '**Match the full values**: Finds employee whose name is Mohan Patel and was
    born on 28/11/1981.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精确匹配一部分并与另一列的范围匹配**：查找姓氏为Patel且名字以A开头的员工。'
- en: '**Match leftmost prefix**: Finds all employee with a last name. These use only
    the first column in the index.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如之前讨论的，当查询针对索引列执行时，MySQL 8查询引擎从根节点开始，并通过中间节点到达叶节点。让我们举个例子，假设您想在索引列中找到值89。在这种情况下，查询引擎会引用根节点以获取中间页的引用。因此，它将指向**1-100**。然后，它确定下一个中间级别，并指向值**51-100**。然后查询引擎转到第三页，即下一个中间级别，**76-100**。从那里，它将找到值89的叶节点。叶节点包含整行或指向该行的指针，具体取决于索引是聚集还是非聚集。
- en: '**Match with column prefix**: Finds the employees whose last names begin with
    M. It uses only the first column in the index.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与列前缀匹配**：查找姓氏以M开头的员工。它只使用索引中的第一列。'
- en: '**Match one part exactly and with range of another column**: Finds the employee
    whose last name is Patel and whose first name starts with A.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希索引
- en: 'The following are queries where B-Tree is not useful:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**匹配值范围**：查找姓氏为Patel和Gupta的员工。'
- en: '**Don''t use any condition after a range condition**: For example, you have
    put the `WHERE` condition `lastname=''Patel''` and `firstname` like `‘A%''` and
    `dob='' 28/11/1981''`. Here, only the first two columns are considered for the
    index, because `LIKE` is a range condition.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在范围条件之后不要使用任何条件**：例如，您已经放置了`WHERE`条件`lastname=''Patel''`和`firstname`类似`‘A%''`和`dob=''
    28/11/1981''`。在这里，只考虑前两列用于索引，因为`LIKE`是一个范围条件。'
- en: '**Don''t skip any of the columns defined in the index**: This means you are
    not allowed to use `lastname` and `dob` to find an employee where `firstname`
    is missing in the `WHERE` condition.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要跳过索引中定义的任何列**：这意味着您不允许使用`lastname`和`dob`来查找在`WHERE`条件中缺少`firstname`的员工。'
- en: '**Lookup doesn''t start with left-most side of indexed columns**: For example,
    the index will not work if you find the employee whose `firstname` is `Mohan`
    and whose `dob` is on a certain date. In this query, defined columns are not left-most
    in the index. In the same way, the index does not work in the case where you find
    the employee whose `lastname` ends with something.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找不是从索引列的最左侧开始的：例如，如果您查找名为`Mohan`且`dob`在特定日期的员工，则索引将不起作用。在此查询中，定义的列不是索引中最左侧的列。同样，如果您查找姓氏以某些内容结尾的员工，则索引也不起作用。
- en: Hash index
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**匹配最左侧前缀**：查找所有有姓氏的员工。这些只使用索引中的第一列。'
- en: 'It is very difficult to find a single value from a large database by following
    complete tree traversals with multiple levels. To overcome this problem, MySQL
    has provided another index type, which is known as a **hash index**. This index
    creates a hash table rather than a tree, which is very flat in structure compared
    to a B-Tree index. Hashing mainly uses hash functions to generate the addresses
    of data. Two important terms related to hashing are:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完整的树遍历多个级别来从大型数据库中找到单个值是非常困难的。为了克服这个问题，MySQL提供了另一种索引类型，称为**哈希索引**。这个索引创建了一个哈希表，而不是B-Tree索引所具有的结构非常扁平。哈希主要使用哈希函数来生成数据的地址。与哈希相关的两个重要术语是：
- en: '**Hash function**: The mapping function which will be useful to map search-keys
    with the address where actual records are stored.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**哈希函数**：映射函数，用于将搜索键与存储实际记录的地址进行映射。'
- en: '**Bucket**: A bucket is a unit of storage where a hash index stores the data.
    A bucket indicates a complete disk block, which will store one or more records.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bucket**：桶是哈希索引存储数据的存储单元。一个桶表示一个完整的磁盘块，可以存储一个或多个记录。'
- en: 'Along with the hashing mechanism, a hash index has some special characteristics,
    described as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 除了哈希机制之外，哈希索引还具有一些特殊特性，如下所述：
- en: The whole key is used to search the row. While in the case of a B-Tree, only
    the left-most prefix of the key is used to find rows.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个键用于搜索行。而在B-Tree的情况下，只使用键的最左前缀来查找行。
- en: The optimizer will not use a hash index to speed up `ORDER BY` operations. In
    other words, this index is never used to find the next entry.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化器不会使用哈希索引来加速`ORDER BY`操作。换句话说，这个索引永远不会用于查找下一个条目。
- en: Hash indexes are used for equality comparison by using `=` or `<=>` operators.
    It will never use comparison operators which will return a range of values. For
    example, the `<` (less than) operator.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希索引用于使用`=`或`<=>`运算符进行相等比较。它永远不会使用返回一系列值的比较运算符。例如，`<`（小于）运算符。
- en: The range optimizer cannot actually gauge how many rows are available between
    the two values. And, if we use a hash-indexed `MEMORY` table instead of `InnoDB`
    or `MyISAM`, then it may affect the queries as well.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围优化器实际上无法估计两个值之间有多少行可用。而且，如果我们使用哈希索引的`MEMORY`表而不是`InnoDB`或`MyISAM`，那么它也可能影响查询。
- en: Index extension
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引扩展
- en: 'Index extension is the feature by which MySQL 8 extends a secondary index by
    appending the primary key. The `InnoDB` engine automatically extends a secondary
    index if it is required. To control the behavior of index extensions, MySQL 8
    has defined a `use_index_extensions` flag in the `optimizer_switch` system variable.
    By default, this option is enabled, but the user is allowed to change it at runtime
    by using the following command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 索引扩展是MySQL 8通过附加主键扩展次要索引的功能。如果需要，`InnoDB`引擎会自动扩展次要索引。为了控制索引扩展的行为，MySQL 8在`optimizer_switch`系统变量中定义了一个`use_index_extensions`标志。默认情况下，此选项已启用，但用户可以使用以下命令在运行时更改它：
- en: '[PRE14]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s look at one example to understand the index extension in detail. Let''s
    create a table and insert the following values:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，以深入了解索引扩展。让我们创建一个表，并插入以下值：
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This table has a primary key on columns `c1`, `c2` and a secondary index `key_d1`
    on column `d1`. Now, to understand the extension effect, first make it off and
    then execute following select query with explain command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表在列`c1`、`c2`上有一个主键，以及在列`d1`上有一个次要索引`key_d1`。现在，为了理解扩展效果，首先关闭它，然后执行以下带有解释命令的选择查询：
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the same way, we will now turn the extension on and execute the explain
    plan query again to check the effect, using the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们现在将打开扩展并再次执行解释计划查询以检查效果，使用以下代码：
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we will check the difference between these two approaches:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将检查这两种方法之间的区别：
- en: The `key_len` value changes from 4 bytes to 8 bytes, which indicates that key
    lookups use both the columns d1 and c1, not only d1.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key_len`值从4个字节变为8个字节，这表明键查找使用了列d1和c1，而不仅仅是d1。'
- en: The `ref` value changes from `(const)` to `(const, const)` which indicates key
    lookup uses two key parts instead of one.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ref`值从`(const)`变为`(const, const)`，这表明键查找使用了两个键部分而不是一个。'
- en: The `rows` count changes from 5 to 1, which indicates that `InnoDB` requires
    fewer rows than the first approach to produce the result.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rows`计数从5变为1，这表明`InnoDB`需要比第一种方法更少的行来生成结果。'
- en: The `Extra` value changes from **Using where** to **Using index**. It indicates
    that the rows can be read by using only the index, without consulting any other
    columns in the data row.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Extra`值从**Using where**变为**Using index**。这表明行可以通过仅使用索引来读取，而不需要查询数据行中的任何其他列。'
- en: Using an optimizer for indexes
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用索引的优化器
- en: 'MySQL 8 allows you to create indexes on generated columns. Generated columns
    are the columns whose values are computed from an expression included in a column
    definition. Consider the following example where we have defined one generated
    column, `c2`, and created an index on that column:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8允许您在生成列上创建索引。生成列是其值从列定义中包含的表达式计算出来的列。考虑以下示例，我们定义了一个生成列`c2`，并在该列上创建了一个索引：
- en: '[PRE18]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Based on the previous definition of a table, an optimizer will consider an
    index of a generated column in the execution plan. In addition to that, if we
    specify the same expression in the query using the `WHERE`, `GROUP BY`, or `ORDER
    BY` clauses, then the optimizer will use the index of the generated column. For
    example, if we execute the following query, then the optimizer will use the index
    defined on the generated column:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 根据表的先前定义，优化器将在执行计划中考虑生成列的索引。此外，如果我们在查询中使用`WHERE`、`GROUP BY`或`ORDER BY`子句中指定相同的表达式，那么优化器将使用生成列的索引。例如，如果我们执行以下查询，则优化器将使用生成列上定义的索引：
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, the optimizer will identify that the expression is the same as the definition
    of column `c2`. We can check it using the `EXPLAIN` command, as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，优化器将识别表达式与列`c2`的定义相同。我们可以使用`EXPLAIN`命令来检查，如下所示：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There are some limitations on generated column indexes:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 生成列索引有一些限制：
- en: The query expression must be exactly matched with the generated column definition.
    For example, if we have defined the expression as `c1+1` in a column definition,
    then use the same in query, instead of applying `1+c1`.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询表达式必须与生成的列定义完全匹配。例如，如果我们在列定义中将表达式定义为`c1+1`，那么在查询中使用相同的表达式，而不是应用`1+c1`。
- en: 'In the case of JSON string use in a generated column definition, use `JSON_UNQUOTE()`
    to remove extra quotes from the values. For example, don''t use the following
    column definition:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生成列定义中使用JSON字符串时，使用`JSON_UNQUOTE()`从值中删除额外的引号。例如，不要使用以下列定义：
- en: '[PRE21]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Instead of the preceding code, we will use the following:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用以下代码代替前面的代码：
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The optimization applies to these operators: `=`, `<`, `<=`, `>`, `>=`, `BETWEEN`,
    and `IN()`.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化适用于这些运算符：`=`, `<`, `<=`, `>`, `>=`, `BETWEEN`和`IN()`。
- en: 'Don''t use only references of other columns in generated column expressions.
    That is, don''t use the following code:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生成列表达式中不要仅使用其他列的引用。也就是说，不要使用以下代码：
- en: '[PRE23]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Use a index hint if the optimizer tries to use the wrong index, which will disabled
    it and force the optimizer to use a different choice
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果优化器尝试使用错误的索引，请使用索引提示，这将禁用它并强制优化器使用不同的选择
- en: Invisible and descending indexes
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可见和降序索引
- en: The **invisible index** is a special feature which will mark an index as unavailable
    for the optimizer. MySQL 8 will maintain invisible indexes and keep them up-to-date
    when data is modified. This will apply on indexes other than primary key. As we
    know, indexes are visible by default; we have to make them invisible explicitly
    at the time of creation, or by using the `alter` command. MySQL 8 provides the `VISIBLE` and `INVISIBLE`
    keywords to maintain index visibility. A descending index is the method of storing
    key values in descending order. A descending index is more efficient, as it can
    be scanned in the forward order. Let's see these indexes in detail, with examples.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可见索引**是一个特殊功能，它将索引标记为优化器不可用。MySQL 8将维护不可见索引，并在数据修改时保持其最新状态。这将适用于主键以外的索引。我们知道，默认情况下索引是可见的；我们必须在创建时或使用`alter`命令时显式地将它们设置为不可见。MySQL
    8提供了`VISIBLE`和`INVISIBLE`关键字来维护索引的可见性。降序索引是按降序存储键值的方法。降序索引更有效，因为它可以按正向顺序扫描。让我们通过示例详细了解这些索引。'
- en: Invisible index
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可见索引
- en: 'As mention previously, an invisible index is not used by the optimizer. Then
    what is the use of this index? This question comes into our mind, right? We will
    explain to you some of the use cases for invisible indexes:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，优化器不使用不可见索引。那么这个索引有什么用呢？这个问题会出现在我们的脑海中，对吧？我们将向您解释一些不可见索引的用例：
- en: When many indexes are defined, but you are not sure which index is not in use.
    In this case, you can make an index invisible and check the performance impact.
    If it has an impact, then you can make that index visible on an immediate basis.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当定义了许多索引，但不确定哪个索引未被使用时。在这种情况下，您可以使一个索引不可见并检查性能影响。如果有影响，那么您可以立即使该索引可见。
- en: Special cases where only one query is using an index. In this case, an invisible
    index is a good solution.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有一个查询使用索引的特殊情况。在这种情况下，不可见索引是一个很好的解决方案。
- en: 'In the following example, we will create an invisible index using `CREATE TABLE`, `CREATE
    INDEX`, or `ALTER TABLE` commands:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用`CREATE TABLE`、`CREATE INDEX`或`ALTER TABLE`命令创建一个不可见索引：
- en: '[PRE24]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To change the visibility of the indexes, use the following commands:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改索引的可见性，请使用以下命令：
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To get information about an index, execute `INFORMATION_SCHEMA.STATISTICStable`
    or `SHOW INDEX` commands in the following ways:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关索引的信息，请以以下方式执行`INFORMATION_SCHEMA.STATISTICStable`或`SHOW INDEX`命令：
- en: '[PRE26]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'MySQL 8 provides a `use_invisible_indexes` flag in the `optimizer_switch` system
    variable to control invisible indexes used by the query optimizer. If this flag
    is on, then the optimizer uses invisible indexes in execution plan construction,
    while if the flag is off, the optimizer ignores invisible indexes. MySQL 8 provides
    a facility to use an implicit primary key if you have defined a `UNIQUE` index
    on a `NOT NULL` column. Once you define the index on this field, MySQL 8 does
    not allow you to make it invisible. In order to understand this scenario, let''s
    take one example with the following table. Let''s try to execute the following
    command to make the `idx1` index invisible:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8在`optimizer_switch`系统变量中提供了一个`use_invisible_indexes`标志，用于控制查询优化器使用的不可见索引。如果此标志打开，则优化器在执行计划构建中使用不可见索引，而如果标志关闭，则优化器将忽略不可见索引。MySQL
    8提供了一个隐式主键的功能，如果您在`NOT NULL`列上定义了一个`UNIQUE`索引。一旦在此字段上定义了索引，MySQL 8将不允许您将其设置为不可见。为了理解这种情况，让我们以以下表为例。让我们尝试执行以下命令，使`idx1`索引不可见：
- en: '[PRE27]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The server will now give an error, as shown in the following commands:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，服务器将会给出一个错误，如下所示的命令：
- en: '[PRE28]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now let''s add the primary key into the table, using the following command:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用以下命令将主键添加到表中：
- en: '[PRE29]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we will try to make the `idex1` invisible. This time, the server allows
    it, as shown in the following commands:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将尝试使`idex1`不可见。这次，服务器允许了，如下所示的命令：
- en: '[PRE30]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Descending index
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 降序索引
- en: 'A descending index is an index which stores key values in descending order.
    This index is scanned in the forward order, which gives better performance compared
    to other indexes. Descending indexes allow a user to define multi-column indexes
    in a combination of ascending and descending orders. Practical knowledge is always
    easier to understand than theoretical knowledge, right? So, let''s take a look
    at some examples to understand the descending index in detail. First, create a
    table with the following definition:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 降序索引是按降序顺序存储键值的索引。这个索引按正向顺序扫描，与其他索引相比性能更好。降序索引允许用户定义组合升序和降序顺序的多列索引。实际知识总是比理论知识更容易理解，对吧？所以，让我们看一些例子，以深入了解降序索引。首先，创建一个具有以下定义的表：
- en: '[PRE31]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As per the table definition, MySQL 8 will create four different indexes, and
    as a result, the optimizer performs a forward index scan for each `ORDER BY` clause.
    Consider the following different version of the `ORDER BY` clause:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 根据表定义，MySQL 8将创建四个不同的索引，因此优化器对每个`ORDER BY`子句执行前向索引扫描。考虑以下不同版本的`ORDER BY`子句：
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, let''s take a look at a second scenario for the same table definition,
    which will describe the performance impact of a descending index compared to the
    MySQL 5.7.14 version. Consider the following select queries to measure performance:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下相同表定义的第二种情况，它将描述与MySQL 5.7.14版本相比，降序索引对性能的影响。考虑以下选择查询以测量性能：
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following statistical graph is provided by MySQL 8 on 10 million rows,
    with respect to the previously mentioned queries:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下统计图是由MySQL 8提供的，针对先前提到的查询，有1000万行数据：
- en: '![](img/436dd2cc-a878-4a84-88b5-fe96a60311e9.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/436dd2cc-a878-4a84-88b5-fe96a60311e9.jpg)'
- en: Reference:[ https://mysqlserverteam.com/mysql-8-0-labs-descending-indexes-in-mysql/](https://mysqlserverteam.com/mysql-8-0-labs-descending-indexes-in-mysql/)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 参考：[https://mysqlserverteam.com/mysql-8-0-labs-descending-indexes-in-mysql/](https://mysqlserverteam.com/mysql-8-0-labs-descending-indexes-in-mysql/)
- en: 'There are some important points that you should remember at the time of using
    descending indexes, which are as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用降序索引时，有一些重要的要点需要记住，如下所示：
- en: All the data types supported by ascending indexes are also supported by descending
    indexes.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有升序索引支持的数据类型也支持降序索引。
- en: Descending indexes are supported for `BTREE` but not for `HASH`, `FULLTEXT`,
    and `SPATIAL` indexes. If you try to use `ASC` and `DESC` keywords explicitly
    for `HASH`, `FULLTEXT`, and `SPATIAL` indexes, then MySQL 8 will generate an error.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降序索引支持`BTREE`，但不支持`HASH`、`FULLTEXT`和`SPATIAL`索引。如果您尝试为`HASH`、`FULLTEXT`和`SPATIAL`索引显式使用`ASC`和`DESC`关键字，那么MySQL
    8将生成错误。
- en: Descending indexes only support `InnoDB` storage engines, but the `InnoDB` SQL
    parser does not use descending indexes. Change buffering is not supported for
    secondary indexes if the primary key includes a descending index.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降序索引仅支持`InnoDB`存储引擎，但`InnoDB` SQL解析器不使用降序索引。如果主键包括降序索引，则不支持对辅助索引的更改缓冲。
- en: '`DISTINCT` can use any index, including a descending key, but for `MIN ()`/`MAX
    ()`, no descending key parts are used.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DISTINCT`可以使用任何索引，包括降序键，但对于`MIN()`/`MAX()`，不使用降序键部分。'
- en: Both non-generated and generated columns allow use of descending indexes.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非生成和生成列都允许使用降序索引。
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Everything becomes very interesting when you are aware of how it works, right?
    We hope you have found the same thing about indexing in this chapter. We have
    covered very useful information which will help you to define indexes on the right
    columns to get better performance. In addition to that, we have also described
    various types of indexing with their storage structures.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当你了解它是如何工作的时候，一切都变得非常有趣，对吧？我们希望您在本章中对索引有相同的看法。我们已经涵盖了非常有用的信息，这将帮助您在正确的列上定义索引以获得更好的性能。除此之外，我们还描述了各种类型的索引及其存储结构。
- en: In the next chapter, we will provide you with information about replication.
    We will explain the configuration and implementation of replication in detail.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为您提供有关复制的信息。我们将详细解释复制的配置和实现。
