- en: Partitioning in MySQL 8
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQL 8中的分区
- en: In the previous chapter, replication in MySQL 8 was explained. This included
    detailed explanations of replication, configuration, and implementation. The chapter
    also explained group replication versus clustering, and covered the replication
    approach as a solution.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，解释了MySQL 8中的复制。这包括复制、配置和实现的详细解释。该章还解释了组复制与集群，并涵盖了复制方法作为解决方案。
- en: In this chapter, we will do partitioning in MySQL 8\. Partitioning is the concept
    of managing and maintaining data with specific operations with several operators,
    and defining rules to control over partitioning. Basically, it provides a configuration
    hook for managing the underlying data files in a specified way.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在MySQL 8中进行分区。分区是管理和维护具有特定操作的数据的概念，具有多个运算符，并定义了控制分区的规则。基本上，它提供了一个配置钩子，以指定的方式管理底层数据文件。
- en: 'We will cover the following topics on partitioning:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在分区上涵盖以下主题：
- en: Overview of partitioning
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区概述
- en: Types of partitioning
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区类型
- en: Partition management
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区管理
- en: Partition selection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区选择
- en: Partition pruning
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区修剪
- en: Restriction and limitation in partitioning
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区中的限制和限制
- en: Overview of partitioning
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区概述
- en: The concept of partitioning relates to the physical aspects of data storage
    in the database. If you look at the `SQL` standards, they do not give much information
    on the concept, and the `SQL` language itself intends to work independently of
    which media or data structure is used for storing information or data specific
    to different schemas, tables, rows, or columns. Advanced database management systems
    have added means of specifying the physical location used for data storage as
    hardware, the file system, or as both. In MySQL, the `InnoDB` storage engine provides
    support for these purposes with the notion of `tablespace`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 分区的概念与数据库中数据存储的物理方面相关。如果查看`SQL`标准，它们并没有提供关于这个概念的太多信息，`SQL`语言本身意图独立于用于存储信息或特定于不同模式、表、行或列的数据的媒体或数据结构。先进的数据库管理系统已经添加了指定用于数据存储的物理位置的方法，如硬件、文件系统或两者兼而有之。在MySQL中，`InnoDB`存储引擎通过`表空间`的概念支持这些目的。
- en: Partitioning enables us to distribute parts of individual tables to be stored
    as separate tables at different locations in the file system. Additionally, the
    distribution is accomplished with user specified rules provided, such as in the
    form of modulus, a hashing function, or matching with simple value or range, and
    the user provided expression acts as a parameter that is commonly known as a partitioning
    function.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 分区使我们能够将个别表的部分分布为在文件系统中的不同位置存储为单独的表。此外，分布是通过用户指定的规则提供的，例如模数、哈希函数或与简单值或范围匹配，并且用户提供的表达式充当通常称为分区函数的参数。
- en: In MySQL 8, currently `InnoDB` is the only storage engine that supports partitioning.
    No extra specification is required to enable partitioning in the `InnoDB` storage
    engine. Partitioning can not be used with the storage engines `MyISAM`, `CSV`,
    `FEDERATED`, `MERGE`. For all examples given in this chapter we assume that the
    default storage engine is `InnoDB`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在MySQL 8中，目前`InnoDB`是唯一支持分区的存储引擎。在`InnoDB`存储引擎中，不需要额外的规范来启用分区。分区不能与存储引擎`MyISAM`、`CSV`、`FEDERATED`、`MERGE`一起使用。在本章中给出的所有示例中，我们假设默认存储引擎是`InnoDB`。
- en: 'When a partition table is created, the default storage engine is used, same
    as creating a table, and can be overridden just as we would do for any table by
    specifying the `STORAGE ENGINE` option. The following example demonstrates creating
    a table partitioned by hash into four partitions, all of which use the `InnoDB`
    storage engine:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 创建分区表时，使用默认存储引擎，与创建表时相同，并且可以通过指定`STORAGE ENGINE`选项来覆盖，就像我们对任何表所做的那样。以下示例演示了创建一个分为四个分区的哈希表，所有分区都使用`InnoDB`存储引擎：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Partitioning is applicable on all indexes and all data of the table. It is not
    applicable on either indexes or data, and vice versa is also not applicable. It
    can be applicable on both indexes and data together and it cannot be applied on
    part of the table.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 分区适用于表的所有索引和所有数据。它不适用于索引或数据的任何一方，反之亦然。它可以同时适用于索引和数据，也不能应用于表的一部分。
- en: The preceding table `tp` has no unique or primary keys defined but in general
    practice we usually have primary keys, unique keys, or both as part of the table,
    and partitioning column choice depends upon these keys if any of them is present.
    The partitioning column choice is given in detail in the *partitioning keys, primary
    keys, and unique keys* section. To simplify the concept of partitioning the examples
    given may not include these keys.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表`tp`没有定义唯一键或主键，但在一般实践中，我们通常有主键、唯一键或两者作为表的一部分，分区列的选择取决于这些键是否存在。分区列的选择在*分区键、主键和唯一键*部分中有详细说明。为了简化分区的概念，所给出的示例可能不包括这些键。
- en: Types of partitioning
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区类型
- en: 'Several types of partitioning are supported in MySQL 8, listed as follows :'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8支持多种分区类型，列举如下：
- en: '`RANGE Partitioning`: Assigns rows to partitions from the column values that
    come between the given range of values'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RANGE分区`：根据列值的范围将行分配到分区'
- en: '`LIST Partitioning`: Assigns rows to partitions from the column values that
    matches with one of the given set of values'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LIST分区`：根据与给定一组值匹配的列值将行分配到分区'
- en: '`COLUMNS Partitioning`: Assigns rows to partitions with multiple column values
    with either `RANGE` or `LIST` partitioning'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COLUMNS分区`：使用`RANGE`或`LIST`分区将行分配到具有多个列值的分区'
- en: '`HASH Partitioning`: Assigns partition based on user specified expressions
    evaluated on column values'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HASH分区`：根据用户指定的表达式在列值上进行评估来分配分区'
- en: '`KEY Partitioning`: In addition to `HASH` partitioning, allows the use of multiple
    column values'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KEY分区`：除了`HASH`分区外，还允许使用多个列值'
- en: '`Subpartitioning`: In addition to partitioning, allows further division in
    partitioned tables, also known as composite partitioning'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子分区：除了分区外，还允许在分区表中进行进一步的划分，也称为复合分区
- en: Different rows of the table can be assigned to different physical partitions;
    this is known as horizontal partitioning. Different columns of the table can be
    assigned to different physical partitions; this is known as vertical partitioning.
    MySQL 8 currently supports horizontal partitioning.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 表的不同行可以分配到不同的物理分区；这被称为水平分区。表的不同列可以分配到不同的物理分区；这被称为垂直分区。MySQL 8目前支持水平分区。
- en: For the `LIST`, `RANGE`, and `LINEAR HASH` types of partitioning, the value
    of partitioning columns is given to the partitioning function. The partitioning
    function returns an integer value that is the partition number in which the record
    should be stored. The `partition` function must be nonrandom and nonconstant.
    The `partition` function cannot contain queries and can use the SQL expression
    which returns either an integer or `NULL`, where the integer as `intval` must
    follow the expression `-MAXVALUE <= intval <= MAXVALUE`. Here, `-MAXVALUE` represents
    the lower limit and `MAXVALUE` is the upper limit for the integer type value.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表、范围和线性哈希类型的分区，分区列的值被传递给分区函数。分区函数返回一个整数值，即记录应存储在其中的分区号。分区函数必须是非随机和非常数的。分区函数不能包含查询，并且可以使用返回整数或NULL的SQL表达式，其中整数intval必须遵循表达式-MAXVALUE
    <= intval <= MAXVALUE。这里，-MAXVALUE表示整数类型值的下限，MAXVALUE是整数类型值的上限。
- en: The storage engine must be the same for all partitions of the same table, however
    there is no restriction on using different storage engines for different partitioned
    tables in the same database or MySQL server.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 存储引擎必须对同一表的所有分区相同，但是在同一数据库或MySQL服务器中的不同分区表中使用不同的存储引擎没有限制。
- en: Partitioning management
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区管理
- en: There are different ways to use `SQL` statements to modify partitioned tables
    and perform operations such as add, redefine, merge, drop, or split existing partitioned
    tables. Information about partitioned tables and partitions can also be obtained
    with `SQL` statements.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方法可以使用SQL语句修改分区表并执行操作，例如添加、重新定义、合并、删除或拆分现有的分区表。还可以使用SQL语句获取有关分区表和分区的信息。
- en: '`MIN_ROWS` and `MAX_ROWS` can be used to configure the maximum and minimum
    number of rows and can be stored in the partition table.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: MIN_ROWS和MAX_ROWS可用于配置分区表中存储的最大和最小行数。
- en: Partition selection and pruning
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区选择和修剪
- en: Explicit selection of partition and subpartition is also provided. It enables
    row matching to the conditions given in the where clause. In partition, the pruning
    concepts described do not scan partitions where no possible matching values can
    be present, and are applied using queries, whereas partition selection is applicable
    for both queries and many of the `DML` statements.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 还提供了分区和子分区的显式选择。它使得行匹配到where子句中给定的条件。在分区中，所描述的修剪概念不会扫描可能不存在匹配值的分区，并且使用查询应用，而分区选择适用于查询和许多DML语句。
- en: Restrictions and limitations in partitioning
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区的限制和限制
- en: Stored procedures or functions, user defined functions or plugins, and user
    variables or declared variables are restricted in partitioning expressions. There
    are also several restrictions and limitations applicable to partitioning given
    in the detailed section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 存储过程或函数、用户定义函数或插件以及用户变量或声明的变量在分区表达式中受到限制。在详细部分中还有几个适用于分区的限制和限制。
- en: 'See the following list for some of the advantages of partitioning:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下列表，了解分区的一些优点：
- en: Partitioning facilitates storing more data in one table than can be held on
    a file system partition or single disk.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区有助于在一个表中存储比文件系统分区或单个磁盘能容纳的更多数据。
- en: Data that has become useless can be removed easily by dropping a partition or
    partitions that only contain the useless data. In some cases where specific data
    is required to be added separately, this can be done easily with partitioning
    in single or multiple partitions based on the specified rule.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过删除仅包含无用数据的分区或分区，可以轻松删除已经变得无用的数据。在某些情况下，需要单独添加特定数据，可以根据指定的规则轻松地在单个或多个分区中进行分区。
- en: Query optimization that occurs automatically based on partitioned data by not searching
    for data in partitions that are not applicable as per the where condition.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于分区数据自动进行的查询优化，不会在不适用于where条件的分区中搜索数据。
- en: In addition to partition pruning, partition selection is supported explicitly
    by which where clause is applied on a specified partition or multiple partitions.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了分区修剪外，还支持显式的分区选择，其中where子句应用于指定的分区或多个分区。
- en: Greater query throughput is achieved by separating data search into multiple
    disks.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将数据搜索分离到多个磁盘，可以实现更大的查询吞吐量。
- en: Types of partitioning
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区类型
- en: 'In this section, you will understand different types of partitioning and also
    the purpose of using specific partitioning. The following is a list of the partitioning
    types that are available in MySQL 8 :'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解不同类型的分区以及使用特定分区的目的。以下是MySQL 8中可用的分区类型列表：
- en: '`RANGE partitioning`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围分区
- en: '`LIST partitioning`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表分区
- en: '`COLUMNS partitioning`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列分区
- en: '`HASH partitioning`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希分区
- en: '`KEY partitioning`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键分区
- en: '`Subpartitioning`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子分区
- en: In addition to the above list, we will also see `NULL`handling in MySQL 8 Partitioning
    in detailed section.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述列表，我们还将在MySQL 8分区的详细部分中看到对NULL的处理。
- en: A very common use case for database partitioning is segregating data by date.
    MySQL 8 does not support date partitioning, which some database systems provide
    explicitly, but it is easy to create partitioning schemes with date, time, or
    datetime columns, or that are based on date/time related expressions that evaluate
    values from these column types.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库分区的一个非常常见的用例是按日期对数据进行分隔。MySQL 8不支持日期分区，一些数据库系统明确提供了日期分区，但可以使用日期、时间或日期时间列创建分区方案，或者基于日期/时间相关表达式创建分区方案，这些表达式评估这些列类型的值。
- en: You can use the date, time, or datetime types as column values for partition
    columns without any modifications if using `KEY` or `LINEAR KEY` partitioning,
    whereas in other partitioning types an expression giving back an integer or `NULL`
    value is required.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`KEY`或`LINEAR KEY`分区，可以使用日期、时间或日期时间类型作为分区列的列值，而不需要进行任何修改，而在其他分区类型中，需要使用返回整数或`NULL`值的表达式。
- en: Irrespective of which type of partitioning you use, partitions always get numbered
    automatically with an integer number in sequence of the partitions created. If,
    for example, the table uses four partitions, they are numbered as 0,1,2, and 3
    for each of the partitions as per creation sequence.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用哪种类型的分区，分区始终会自动以整数顺序编号，按照创建顺序对每个分区进行编号。例如，如果表使用四个分区，它们将按照创建顺序分别编号为0、1、2和3。
- en: When you specify numbers of partitions, it must be evaluated to a positive,
    non zero integer without any leading zeros. Decimal fractions are not allowed
    as partition numbers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当您指定分区的数量时，它必须评估为正的、非零的整数，没有前导零。不允许使用小数分数作为分区号。
- en: Names of partitions are not case-sensitive and should follow conventions or
    rules just like other MySQL identifiers such as tables. The options used in partition
    definition are already provided by the `CREATE TABLE` syntax.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 分区的名称不区分大小写，应遵循约定或规则，就像其他MySQL标识符（如表）一样。分区定义中使用的选项已经由`CREATE TABLE`语法提供。
- en: Now, let's look at partition in detail and examine each of the types to learn
    how they are different to each other.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细查看分区，并检查每种类型，以了解它们之间的不同之处。
- en: RANGE partitioning
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RANGE分区
- en: In this type of partitioning, as the name states, `RANGE` is given in an expression
    that evaluates whether a value lies in the given range or not. Ranges are defined
    with the `VALUES LESS THAN` operator and they should not be overlapping and contiguous.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种类型的分区中，正如名称所示，`RANGE`是在一个表达式中给出的，该表达式评估值是否在给定范围内。范围是使用`VALUES LESS THAN`运算符定义的，它们不应该重叠且应该是连续的。
- en: 'For the next few examples, suppose we are creating a table holding employee
    personal records for 25 food stores. The stores are numbered from 1 to 25 and
    is a chain of 25 food stores, as shown in the following block:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个示例中，假设我们正在创建一个表，用于保存25家食品店的员工个人记录。这些商店的编号从1到25，是一家拥有25家食品店的连锁店，如下所示：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now let''s do partitioning of the table, so you can partition the table by
    range as per your need. Suppose you consider using division to split the data
    five ways with the `store_id` range for partitioning. For this, the table creation
    definition will look as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们对表进行分区，这样您就可以根据需要按范围对表进行分区。假设您考虑使用除法将数据分为五部分，以`store_id`范围进行分区。为此，表创建定义将如下所示：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So, as per the above partitioning scheme, all inserted rows that contain the
    employees working at stores 1 to 5 are stored in the `p0` partition, employees
    working at stores 6 to 10 are stored in the `p1` partition, and so on. If you
    take a look at the partition definition, partitions are ordered from the lowest
    to highest `store_id` column values, and the `PARTITION BY RANGE` syntax looks
    similar to programming statements `if… elseif …` statements, doesn't it?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据上述分区方案，所有插入的行，其中包含在1到5号店工作的员工，都存储在`p0`分区中，1到10号店工作的员工存储在`p1`分区中，依此类推。如果您查看分区定义，分区按照最低到最高的`store_id`列值排序，`PARTITION
    BY RANGE`语法看起来类似于编程语句`if… elseif…`语句，不是吗？
- en: 'Well, you are thinking about what will happen if a record comes with `store_id` `26`;
    this would result in an error as the server does not know where to place the record.
    There are two ways to keep this error from occurring:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，您可能会想知道如果一条记录带有`store_id` `26`会发生什么；这将导致错误，因为服务器不知道在哪里放置记录。有两种方法可以防止发生此错误：
- en: By using the `IGNORE` key word with the `INSERT` statement.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`INSERT`语句中使用`IGNORE`关键字。
- en: By using `MAXVALUE` instead of a specified range (`26`).
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`MAXVALUE`而不是指定范围（`26`）。
- en: And yes, of course, you can extend the limits by using the `ALTER TABLE` statement
    to add new partitions for stores 26-30, 30-35, and so on.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您也可以使用`ALTER TABLE`语句扩展限制，为26-30号店、30-35号店等添加新的分区。
- en: 'Similar to `store_id`, you could also partition the table based on the job
    codes - based on the range of column values. Suppose if 5 digit codes are used
    for management positions, 4 digit codes are used for office and support personnel,
    and 3 digit codes are used for regular workers, then the partition table creation
    definition would be as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与`store_id`类似，您还可以根据作业代码对表进行分区-基于列值的范围。假设管理职位使用5位代码，办公室和支持人员使用4位代码，普通工人使用3位代码，那么分区表创建定义将如下所示：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also specify partitioning with one of the two columns of date type
    values. Suppose you wish to partition based on the year each of the employee joined
    - so by the value of `YEAR(hired_date)`. Now the table definition will be as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以根据员工加入的年份进行分区，例如根据`YEAR(hired_date)`的值进行分区。现在表定义将如下所示：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: According to this scheme, all employees recorded hired before `1996` will be
    stored in the partition `p0`, then records with a hire date before `2001` will
    be stored in the partition `p1`, records between `2001` and `2006` in `p2`, and
    the rest of the records will be stored in partition `p3`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个方案，所有在`1996`年之前录用的员工记录将存储在分区`p0`中，然后在`2001`年之前录用的记录将存储在分区`p1`中，`2001`年到`2006`年之间的记录将存储在`p2`中，其余的记录将存储在分区`p3`中。
- en: '**Partition schemes based on time intervals** can be implemented using the
    following two options:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于时间间隔的分区方案**可以使用以下两个选项来实现：'
- en: Partition the table by `RANGE` and use a function operating on the date, time
    or datetime column values to return an integer value for the partitioning expression
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`RANGE`对表进行分区，并使用在日期、时间或日期时间列值上操作的函数返回整数值作为分区表达式
- en: Partition the table by `RANGE COLUMN` and use the date, time, or datetime columns
    as the partition column
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`RANGE COLUMN`对表进行分区，并使用日期、时间或日期时间列作为分区列
- en: '`RANGE COLUMN` is supported in MySQL 8 and is described in detail in the `COLUMN
    PARTITIONING` section.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`RANGE COLUMN` 在 MySQL 8 中得到支持，并在`COLUMN PARTITIONING`部分有详细描述。'
- en: LIST partitioning
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LIST partitioning
- en: As the name states, `LIST` partitioning uses lists for table partitioning. The
    list is comma separated integer values defined while partitioning with `VALUES
    IN (value_list)`; here, `value_list` refers to comma separated integer literals.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，`LIST`分区使用列表进行表分区。列表是在使用`VALUES IN (value_list)`进行分区时定义的逗号分隔的整数值；这里，`value_list`指的是逗号分隔的整数文字。
- en: '`LIST` partitioning is similar to `RANGE` partitioning in many ways, but there
    are differences. The operator used in each partitioning is different. The operator
    uses a list of comma separated values to be matched with the column value or the
    partition expression evaluating to integer value.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`LIST`分区在许多方面类似于`RANGE`分区，但也有不同之处。每个分区中使用的运算符是不同的。该运算符使用逗号分隔的值列表与列值或评估为整数值的分区表达式进行匹配。'
- en: 'Considering the employee table as an example, the basic definition for the
    table using the create table syntax will be as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑员工表作为一个例子，使用创建表语法的基本定义如下：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Suppose you wish to distribute these 25 food stores among five zones—North,
    South, East, West, and Central, with the store ID numbers (1,2,11,12,21,22), (3,4,13,14,23,24),
    (5,6,15,16,25), (7,8,17,18), and (9,10,19,20) respectively for the zones.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您希望将这25家食品店分配到五个区域-北、南、东、西和中央，分别使用店铺ID号(1,2,11,12,21,22)、(3,4,13,14,23,24)、(5,6,15,16,25)、(7,8,17,18)和(9,10,19,20)。
- en: 'Partitioning the table with the zones list will provide the following definition
    for table partition:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用区域列表对表进行分区将为表分区提供以下定义：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see in the preceding statement, partitioning per zones means it will
    be easy to update records for stores based on zones within particular partitions.
    Suppose the organization sold the west zone to another company; then you might
    need to remove all employee records from the west zone using the `pWest` partition
    in query. Executing `ALTER TABLE` employee `TRUNCATE PARTITION pWest` would be
    much easier and efficient than the `DELETE` statement `DELETE from employee where
    store_id IN (7,8,17,18)`; also, you can use the `DROP` statement for employee
    records removal - `ALTER TABLE employee DROP PARTITION pWest`. Along with the
    previous statement execution you will also remove the `pWest PARTITION` from the
    table partition definition, and will need to use the `ALTER` statement again to
    add the `pWest PARTITION` and restore the partition table scheme you had earlier.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的陈述所示，按区域进行分区意味着可以很容易地根据特定分区内的区域更新商店的记录。假设组织将西区卖给另一家公司；那么您可能需要使用查询中的`pWest`分区来删除西区的所有员工记录。执行`ALTER
    TABLE` employee `TRUNCATE PARTITION pWest`比`DELETE`语句`DELETE from employee where
    store_id IN (7,8,17,18)`更容易和高效；此外，您还可以使用`DROP`语句来删除员工记录- `ALTER TABLE employee
    DROP PARTITION pWest`。除了前面的语句执行，您还将从表分区定义中删除`pWest PARTITION`，然后需要再次使用`ALTER`语句来添加`pWest
    PARTITION`并恢复先前的分区表方案。
- en: Similar to `RANGE` partitioning, you can also use `LIST` partitioning using
    hash or key to produce composite partitioning, which is also known as `subpartitioning`.
    You will get to know more details on `subpartitioning` as a dedicated section
    for `subpartitioning` follows.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与`RANGE`分区类似，您还可以使用哈希或键来使用`LIST`分区生成复合分区，这也被称为`子分区`。随后的`子分区`专门部分将更详细地介绍`子分区`。
- en: 'In `LIST` partitioning there is no catch-all mechanism such as `MAXVALUE` that
    can contain all possible values. Instead, you have to manage the expected values
    list in the `values_list` itself, otherwise the `INSERT` statement will result
    in an error where the table has no partition for value 9, as in the following
    example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LIST`分区中，没有像`MAXVALUE`这样可以包含所有可能值的捕获机制。相反，您必须在`values_list`中管理预期的值列表，否则`INSERT`语句将导致错误，例如在以下示例中，表中没有值为9的分区：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see in the preceding `INSERT` statement, value 9 is not part of
    the list given during partition schema and so there is an error. If you use multiple
    value insert statements, the same error can result in failure for all inserts
    and no records will be inserted; instead use the `IGNORE` keyword to avoid such
    errors, as in the following `INSERT` statement example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的`INSERT`语句所示，值9不是在分区模式中给定的列表的一部分，因此会出现错误。如果使用多个值插入语句，同样的错误可能导致所有插入失败，不会插入任何记录；而是使用`IGNORE`关键字来避免这样的错误，如以下`INSERT`语句示例：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: COLUMNS partitioning
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: COLUMNS partitioning
- en: 'As the name suggests, this type of partitioning uses columns themselves. We
    can use two versions of column partitioning. One is `RANGE COLUMN` and the other
    is `LIST COLUMN`. In addition to both `RANGE COLUMN` and `LIST COLUMN` partitioning,
    MySQL 8 supports using non-integer types of column that can be used to define
    value ranges or list values. The list of permitted data types are as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，这种类型的分区使用列本身。我们可以使用两种版本的列分区。一种是`RANGE COLUMN`，另一种是`LIST COLUMN`。除了`RANGE
    COLUMN`和`LIST COLUMN`分区之外，MySQL 8还支持使用非整数类型的列来定义值范围或列表值。允许的数据类型列表如下：
- en: All column types of `INT`, `BIGINT`, `MEDIUMINT`, `SMALLINT`, and `TINYINT`
    are supported for the `RANGE` and `LIST` partitioning columns, but other numeric
    column types such as `FLOAT` or `DECIMAL` are not supported
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有`INT`、`BIGINT`、`MEDIUMINT`、`SMALLINT`和`TINYINT`列类型都支持`RANGE`和`LIST`分区列，但不支持其他数值列类型，如`FLOAT`或`DECIMAL`
- en: '`DATE` and `DATETIME` are supported but other column types relating to date
    and time are not supported as partitioning columns'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持`DATE`和`DATETIME`，但不支持与日期和时间相关的其他列类型作为分区列
- en: The string column types `BINARY`, `VARBINARY`, `CHAR` and `VARCHAR` are supported
    but the `TEXT` and `BLOB` column types are not supported as partitioning columns
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持字符串列类型`BINARY`、`VARBINARY`、`CHAR`和`VARCHAR`，但不支持`TEXT`和`BLOB`列类型作为分区列
- en: Now, let's see `RANGE COLUMN` partitioning and `LIST COLUMN` partitioning in
    detail one by one.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐一详细查看`RANGE COLUMN`分区和`LIST COLUMN`分区。
- en: RANGE COLUMN partitioning
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RANGE COLUMN分区
- en: As the name suggests, you can define range using columns with `RANGE` partitioning
    and `RANGE COLUMN` partitioning, but the difference is that you can define multiple
    columns providing range, and additionally you are able to select column types
    other than integer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，您可以使用`RANGE`分区和`RANGE COLUMN`分区使用列定义范围，但不同之处在于您可以定义多个列提供范围，并且还可以选择除整数之外的列类型。
- en: 'Thus, `RANGE COLUMN` partitioning is different to `RANGE` partitioning in the
    following listed ways :'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`RANGE COLUMN`分区与`RANGE`分区在以下列出的方式上有所不同：
- en: '`RANGE COLUMNS` can use one or multiple columns and the comparison occurs between
    list of column values and not between scalar values'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RANGE COLUMNS`可以使用一个或多个列，比较发生在列值列表之间，而不是标量值之间'
- en: '`RANGE COLUMNS` can use only names of columns and not any expressions'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RANGE COLUMNS`只能使用列名，而不能使用任何表达式'
- en: '`RANGE COLUMNS` partitioning column types are not restricted to `INTEGER` column
    types only but can use the string, date, and datetime column types as partitioning
    columns'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RANGE COLUMNS`分区列类型不仅限于`INTEGER`列类型，还可以使用字符串、日期和日期时间列类型作为分区列。'
- en: 'Table partitioning by `RANGE COLUMNS` has the following basic syntax:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`RANGE COLUMNS`对表进行分区具有以下基本语法：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding syntax, `column_list` stands for partitioning column list and
    `value_list` stands for partition definition value list, and `value_list` must
    be given for each of the partition definitions, along with the same number of
    values defined in `column_list`. To say it straight, the number of columns (`column_list`)
    in the `COLUMNS` clause must be the same as the number of values (`value_list`)
    in the `VALUES LESS THAN` clause.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的语法中，`column_list`代表分区列列表，`value_list`代表分区定义值列表，并且对于每个分区定义，`value_list`必须给出，并且与`column_list`中定义的相同数量的值一起给出。简而言之，`COLUMNS`子句中的列数（`column_list`）必须与`VALUES
    LESS THAN`子句中的值数（`value_list`）相同。
- en: 'The following example makes clear what it is and how it goes with the table
    definition:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例清楚地说明了它是什么以及如何与表定义一起使用：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now you go and insert records into the table `trc` with the following statement
    :'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用以下语句将记录插入到表`trc`中：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: LIST COLUMN partitioning
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LIST COLUMN分区
- en: In this type of partitioning, lists of columns are used in the table partitioning
    definition, and similar to the `RANGE COLUMN` the value list for the respective
    columns must be provided. Similar to `RANGE COLUMN`, column types other than integer
    types can be used—that is, the string, date, and datetime column types.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种类型的分区中，表分区定义中使用列列表，并且与`RANGE COLUMN`相似，必须提供相应列的值列表。与`RANGE COLUMN`类似，除了整数类型之外，还可以使用其他列类型，即字符串、日期和日期时间列类型。
- en: 'Suppose you have the requirement that a business has spread over 12 cities,
    and for marketing purposes you manage them with four zones of three cities as
    follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有这样的要求，即业务遍布12个城市，并且出于营销目的，您将它们分为三个城市的四个区域，如下所示：
- en: '**Zone 1 with cities**: Ahmedabad, Surat, Mumbai'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Zone 1 with cities**: Ahmedabad, Surat, Mumbai'
- en: '**Zone 2 with cities**: Delhi, Gurgaon, Punjab'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Zone 2 with cities**: Delhi, Gurgaon, Punjab'
- en: '**Zone 3 with cities**: Kolkata, Mizoram, Hyderabad'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Zone 3 with cities**: Kolkata, Mizoram, Hyderabad'
- en: '**Zone 4 with cities**: Bangalore, Chennai, Kochi'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Zone 4 with cities**: Bangalore, Chennai, Kochi'
- en: 'Now, create a table for the customer data that has four partitions of the corresponding
    zones, and list them with the name of the city where the customer resides. The
    table partition definition will look as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为客户数据创建一个表，该表有四个对应区域的分区，并用客户所居住的城市的名称列出它们。表分区定义如下：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Similar to `RANGE COLUMN` partitioning, it is not required to provide any expression
    in the `COLUMNS()` clause that converts the column value to an integer literal,
    and nothing other than the list of column names itself is permitted.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与`RANGE COLUMN`分区类似，不需要在`COLUMNS()`子句中提供任何将列值转换为整数字面值的表达式，除了列名列表本身之外，不允许提供任何其他内容。
- en: HASH partitioning
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HASH分区
- en: The primary intention behind introducing `HASH` partitioning is to ensure an
    even distribution of date among the number of partitions defined. So, with `HASH`
    partitioning you need to specify the column value or the expression evaluating
    the column value being hashed, and the number of partitions into which the partitioned
    table is to be divided.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 引入`HASH`分区的主要目的是确保在定义的分区数量之间均匀分布数据。因此，使用`HASH`分区需要指定要对其进行分区的表的列值或评估列值的表达式，以及要将分区表划分为的分区数。
- en: For defining `HASH` partitioning in table you need to specify the `PARTITION
    BY HASH (expr)` clause in the table definition, where `expr` is the expression
    that will return the integer, and additionally you need to specify the number
    of partitions with `PARTITIONS n`, where `n` is a positive integer number that
    stands for the number of partitions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要在表中定义`HASH`分区，需要在表定义中指定`PARTITION BY HASH (expr)`子句，其中`expr`是将返回整数的表达式，并且还需要使用`PARTITIONS
    n`指定分区的数量，其中`n`是一个正整数，表示分区的数量。
- en: 'The following definition creates a table with `HASH` partitioning on the `store_id`
    column, dividing into five partitions:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下定义创建了一个在`store_id`列上使用`HASH`分区的表，分成了五个分区：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the above statement, if you exclude the `PARTITIONS` clause, the number of
    partitions automatically defaults to one.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的语句中，如果排除`PARTITIONS`子句，则分区的数量将自动默认为1。
- en: LINEAR HASH partitioning
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性哈希分区
- en: 'MySQL 8 supports linear hashing, which is based on a linear power-of-two algorithm
    instead of regular hashing, which is based on the modulus of the hashing function''s
    value. `LINEAR HASH` partitioning requires the `LINEAR` keyword in the `PARTITION
    BY` clause, shown as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8支持线性哈希，它基于线性二次幂算法，而不是基于哈希函数值的模数的常规哈希。`LINEAR HASH`分区需要在`PARTITION BY`子句中使用`LINEAR`关键字，如下所示：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: An advantage of using linear hashing is faster partitioning operations, and
    a disadvantage is less even data distribution compared to regular hashing partitioning.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线性哈希的优势是更快的分区操作，劣势是与常规哈希分区相比数据分布不均匀。
- en: KEY partitioning
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: KEY分区
- en: 'This type of partitioning is similar to `HASH` partitioning, with the change
    of the use of a user-defined expression instead of the hashing function. `KEY
    PARTITIONING` uses the `PARTITION BY KEY` clause in the `CREATE TABLE` statement
    for the partitioning definition. The syntax rules for `KEY` partitioning are similar
    to that of `HASH` partitioning, so let''s list out the differences so as to understand:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的分区与`HASH`分区类似，只是使用了用户定义的表达式而不是哈希函数。`KEY PARTITIONING`在分区定义的`CREATE TABLE`语句中使用`PARTITION
    BY KEY`子句。`KEY`分区的语法规则与`HASH`分区类似，因此让我们列出一些不同之处以便理解：
- en: Instead of `HASH`, `KEY` is used for partitioning
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分区时使用`KEY`而不是`HASH`。
- en: 'One or more column names list is taken in `KEY()`, and if there is no column
    defined in `KEY` but the table has a defined primary key or unique key with the `NOT
    NULL` constrain, the column is automatically taken as partitioning column for
    `KEY`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在`KEY()`中取一个或多个列名列表，如果在`KEY`中没有定义列，但表具有定义的主键或带有`NOT NULL`约束的唯一键，该列将自动作为`KEY`的分区列：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Unlike other partitioning types, the column type is not only limited to `NULL`
    or integer values:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他分区类型不同，列类型不仅限于`NULL`或整数值：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see in the preceding example statement, similar to `HASH` partitioning,
    `KEY` partitioning also supports `LINEAR KEY` partitioning and has the same effect
    as `LINEAR HASH` partitioning.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例语句所示，与`HASH`分区类似，`KEY`分区也支持`LINEAR KEY`分区，并且与`LINEAR HASH`分区具有相同的效果。
- en: Subpartitioning
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子分区
- en: 'Subpartitioning is also known as composite partitioning, and as the name suggests
    it is only a division of each partition into a partitioned table itself. See the
    following statement:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 子分区也被称为复合分区，正如其名称所示，它只是将每个分区分成一个分区表本身。请参阅以下语句：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see in the preceding example statement, table `trs` has three `RANGE`
    partitions and each of the partitions `p0, p1, p2` is further divided into two
    more subpartitions. Effectively, the entire table is divided into six partitions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例语句所示，表`trs`有三个`RANGE`分区，每个分区`p0、p1、p2`进一步分成两个子分区。有效地，整个表分成了六个分区。
- en: Subpartitioning is possible on tables partitioned using `RANGE` or `LIST` partitioning,
    and subpartitioning can use the `KEY` or `HASH` partitioning types. The syntax
    rules for subpartitioning are the same as in regular partitioning, with the exception
    to specify the default column in `KEY` partitioning as it does not take the column
    automatically for subpartitioning.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`RANGE`或`LIST`分区的表可以进行子分区，并且子分区可以使用`KEY`或`HASH`分区类型。子分区的语法规则与常规分区相同，唯一的例外是在`KEY`分区中指定默认列，因为它不会自动为子分区获取列。
- en: 'The following is a list of points to consider when using subpartitioning:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用子分区时需要考虑以下几点：
- en: Number of partitions must be same for each of the partitions defined
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个定义的分区的分区数量必须相同。
- en: Name must be specified with the `SUBPARTITIONING` clause or specify a default
    option instead
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须在`SUBPARTITIONING`子句中指定名称，或者指定一个默认选项。
- en: Names specified for subpartitioning must be unique across the table
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定的子分区名称必须在整个表中是唯一的。
- en: Handling NULL in partitioning
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区中的NULL处理
- en: There is nothing specific to MySQL 8 that disallows `NULL` in partitioning as
    a column value, partitioning expression, or the value from the user-defined expression.
    Even if `NULL` is permitted as a value ,the value returned from the expression
    must be an integer and so MySQL 8 has implementation for partitioning such that
    it treats `NULL` as less than any non-`NULL` value as done in the `ORDER BY` clause.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8没有特定于禁止`NULL`作为分区的列值、分区表达式或用户定义表达式的内容。即使`NULL`被允许作为一个值，表达式返回的值也必须是整数，因此MySQL
    8对分区的实现是将`NULL`视为小于`ORDER BY`子句中的任何非`NULL`值。
- en: 'Behavior for `NULL` handling varies among different types of partitioning:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`NULL`处理的行为在不同类型的分区中有所不同：'
- en: '**Handling `NULL` in `RANGE` partitioning**: If a `NULL` value contained in
    the column is inserted, the row will be inserted in the lowest partition specified
    in range'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在`RANGE`分区中处理`NULL`**：如果插入了包含`NULL`值的列，行将被插入到范围中指定的最低分区中。'
- en: '**Handling `NULL` with `LIST` partitioning**: If the table has a partitioning
    definition with `LIST` partitioning and its partitions are defined with a value
    list that explicitly specifies `NULL` as a value in `value_list`, then insertion
    will be successful; otherwise, it will give an error table that has no partition
    specified for `NULL`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用`LIST`分区处理`NULL`值**：如果表具有使用`LIST`分区定义的分区，并且其分区使用值列表明确指定`NULL`作为`value_list`中的值，则插入将成功；否则，将出现错误，因为表没有为`NULL`指定分区。'
- en: '**Handling `NULL` with `HASH` and `KEY` partitioning**: `NULL` is handled differently
    when table partitioning is defined with `HASH` or `KEY` partitioning, and if a
    partition expression returns `NULL` it is wrapped with zero value. So that based
    on partitioning the insertion operation will successfully insert the record to
    partition being zero.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用`HASH`和`KEY`分区处理`NULL`值**：当使用`HASH`或`KEY`分区定义表分区时，`NULL`的处理方式不同，如果分区表达式返回`NULL`，它将被包装为零值。因此，根据分区插入操作将成功将记录插入到零分区。'
- en: Partition management
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区管理
- en: 'There are plenty of ways to use `SQL` statements in order to modify partitioned
    tables—you can drop, add, merge, split, or redefine partitions with the `ALTER
    TABLE` statement. There are also ways to retrieve partitioned tables and partition
    information. We will see each of these in the following sections:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`SQL`语句修改分区表有很多方法——您可以使用`ALTER TABLE`语句删除、添加、合并、拆分或重新定义分区。还有一些方法可以检索分区表和分区信息。我们将在以下部分中看到每个方法：
- en: '`RANGE` and `LIST` partition management'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RANGE`和`LIST`分区管理'
- en: '`HASH` and `KEY` partition management'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HASH`和`KEY`分区管理'
- en: Partition maintenance
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区维护
- en: Obtain partition information
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取分区信息
- en: RANGE and LIST partition management
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RANGE和LIST分区管理
- en: Partition adding and dropping is handled in a similar way for the `RANGE` and
    `LIST` partition types. A table partitioned by `RANGE` or `LIST` partitioning
    can be dropped using the `ALTER TABLE` statement with the `DROP PARTITION` option
    available.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`RANGE`和`LIST`分区类型，添加和删除分区的处理方式类似。可以使用`ALTER TABLE`语句的`DROP PARTITION`选项删除通过`RANGE`或`LIST`分区进行分区的表。
- en: Make sure you have the `DROP` privilege before executing the `ALTER TABLE ...
    DROP PARTITION` statement. `DROP PARTITION` will delete all the data and also
    remove the partition from the table partition definition.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行`ALTER TABLE ... DROP PARTITION`语句之前，请确保您拥有`DROP`权限。`DROP PARTITION`将删除所有数据，并从表分区定义中删除分区。
- en: 'The following example illustrates the `DROP PARTITION` option with the `ALTER
    TABLE` statement:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了`ALTER TABLE`语句的`DROP PARTITION`选项：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding statement, after executing the `ALTER TABLE employee DROP PARTITION
    p2;` statement, you can see that all data is removed from partition `p2`. In case
    you want to remove all the data but also need to keep the table definition and
    the partitioning scheme, you can use the `TRUNCATE PARTITION` option to achieve
    a similar result.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行`ALTER TABLE employee DROP PARTITION p2;`语句后，您可以看到所有数据都从分区`p2`中删除。如果您想删除所有数据但又需要保留表定义和分区方案，可以使用`TRUNCATE
    PARTITION`选项来实现类似的结果。
- en: In order to add new `LIST` or `RANGE` partitions to existing partitioned tables
    you can use the `ALTER TABLE ... ADD PARTITION` statement.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要向现有分区表添加新的`LIST`或`RANGE`分区，可以使用`ALTER TABLE ... ADD PARTITION`语句。
- en: By using the `SHOW CREATE TABLE` statement you can verify and see if the `ALTER
    TABLE` statement has the desired effect on the table definition and the partitioning
    schema.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`SHOW CREATE TABLE`语句，您可以验证并查看`ALTER TABLE`语句对表定义和分区模式的影响是否符合预期。
- en: HASH and KEY partition management
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HASH和KEY分区管理
- en: Table partitions of the `HASH` or `KEY` types are similar compared to table
    partitioning by the `RANGE` or `LIST` types of partitioning. Dropping a partition
    is not applicable if a table is partitioned by the `HASH` or `KEY` type of partitioning,
    but there is option for merging `HASH` or `KEY` partitions, using `ALTER TABLE
    ... COALESCE PARTITION`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`HASH`或`KEY`类型的表分区与`RANGE`或`LIST`类型的分区相似。如果表是通过`HASH`或`KEY`类型的分区进行分区，那么无法删除分区，但可以使用`ALTER
    TABLE ... COALESCE PARTITION`选项合并`HASH`或`KEY`分区。'
- en: 'Consider if you have client table data partitioned by `HASH` partitioning,
    divided in twelve partitions as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个客户表数据，通过`HASH`分区分割，分为十二个分区如下：
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding table partitioning schema, if you want to reduce the number
    of partitions to eight instead of twelve, use the following `ALTER TABLE` statement:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述表分区模式中，如果您想将分区数量从十二个减少到八个，可以使用以下`ALTER TABLE`语句：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding statement the number 8 represents the number of partitions
    to be removed from the table. You cannot remove more partitions than already exist
    in the table partitioning schema. Similarly, you can add more partitions using
    the `ALTER TABLE... ADD PARTITION` statement.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述语句中，数字8表示要从表中删除的分区数量。您不能删除超过表分区模式中已存在的分区数量。同样，您可以使用`ALTER TABLE... ADD PARTITION`语句添加更多分区。
- en: Partition maintenance
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区维护
- en: There are many maintenance tasks that can be done with several statements on
    a number of tables and partitions. They can be done using statements such as `ANALYSE
    TABLE`, `CHECK TABLE`, `REPAIR TABLE`, and `OPTIMIZE TABLE` , which are supported
    specifically for partitioned tables.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多维护任务可以通过多个语句在多个表和分区上完成。可以使用`ANALYSE TABLE`、`CHECK TABLE`、`REPAIR TABLE`和`OPTIMIZE
    TABLE`等语句，这些语句专门用于支持分区表。
- en: 'There are a number of extensions of `ALTER TABLE` available for such operations
    on single or multiple partitioned tables, listed as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多`ALTER TABLE`的扩展可用于单个或多个分区表的操作，列举如下：
- en: '**Rebuilding partitions**: This option drops all records from the partitions
    and reinserts them, so this is considered helpful in the defragmentation process.
    The following is an example:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重建分区**：此选项会删除分区中的所有记录并重新插入，因此在碎片整理过程中很有帮助。以下是一个示例：'
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Optimizing partitions**: If many rows are deleted from a partition or partitions
    of the table, or there are many row changes in a huge amount of data in variable
    length column types such as `VARCHAR`, `BLOB`, `TEXT`, and so on, you can perform
    `OPTIMIZE PARTITION` to reclaim unused space in the partition data file. The following
    is an example:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化分区**：如果从表的一个或多个分区中删除了许多行，或者在可变长度列类型（如`VARCHAR`、`BLOB`、`TEXT`等）的大量数据中有许多行更改，可以执行`OPTIMIZE
    PARTITION`来回收分区数据文件中未使用的空间。以下是一个例子：'
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`ALTER TABLE ... OPTIMIZE PARTITION` does not work correctly with the `InnoDB`
    storage engine, so instead use `ALTER TABLE ... REBUILD PARTITION` and `ALTER
    TABLE ... ANALYZE PARTITION` for such tables.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`ALTER TABLE ... OPTIMIZE PARTITION`与`InnoDB`存储引擎不兼容，因此应改用`ALTER TABLE ...
    REBUILD PARTITION`和`ALTER TABLE ... ANALYZE PARTITION`。'
- en: '**Analyzing partitions**: In this option key distributions of the partitions
    are read and stored. The following is an example:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析分区**：在此选项中，读取并存储分区的关键分布。以下是一个例子：'
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Repairing partitions**: This option is only used when there are corrupt partitions
    found to be repaired. The following is an example:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修复分区**：仅在发现损坏的分区需要修复时使用。以下是一个例子：'
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Checking partitions**: This option is used to check for any errors in partitions
    such as the `CHECK TABLE` option used in nonpartitioned tables. The following
    is an example:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查分区**：此选项用于检查分区中的任何错误，例如在非分区表中使用的`CHECK TABLE`选项。以下是一个例子：'
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There is an option to use `ALL` instead of a specific partition, specified in
    all above options, in order to perform the operation on all the partitions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有上述选项中，有一个选项可以使用`ALL`而不是特定分区，以便对所有分区执行操作。
- en: Obtain partition information
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取分区信息
- en: 'Information about partitions can be obtained in a number of ways, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过多种方式获取有关分区的信息，如下所示：
- en: The `SHOW CREATE TABLE` statement can be used to view the partition's schema
    information containing all partitioning clauses in the partitioned tables
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHOW CREATE TABLE`语句可用于查看包含分区表中所有分区子句的分区模式信息'
- en: The `SHOW TABLE STATUS` statement can be used to check if the table is partitioned
    or not by viewing its status
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHOW TABLE STATUS`语句可用于通过查看其状态检查表是否已分区'
- en: The `EXPLAIN SELECT` statement can be used to see partitions used by given `SELECT`
    option
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPLAIN SELECT`语句可用于查看给定`SELECT`选项使用的分区'
- en: Using the `INFORMATION_SCHEMA.PARTITIONS` table for querying partition table
    information.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`INFORMATION_SCHEMA.PARTITIONS`表查询分区表信息。
- en: 'The following is an example with the `SHOW CREATE TABLE` statement option to
    see partition information:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`SHOW CREATE TABLE`语句选项查看分区信息的示例：
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The output from the preceding statement has separate information for partitioning
    schema, including common information for the table schema.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从前述语句的输出中，可以看到分区模式的单独信息，包括表模式的常见信息。
- en: Similarly, you can retrieve information about partitioning from the `INFORMATION_SCHEMA.PARTITIONS`
    table.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以从`INFORMATION_SCHEMA.PARTITIONS`表中检索有关分区的信息。
- en: The `EXPLAIN` option gives a lot of information on partitioning with column.
    For example it gives number of rows obtained from the query specific to partitions.
    The partition would be searched as per the query statement. It also gives information
    about keys.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPLAIN`选项提供了许多有关分区的信息。例如，它提供了从特定于分区的查询中获取的行数。分区将根据查询语句进行搜索。它还提供有关键的信息。'
- en: '`EXPLAIN` is also used to get information from nonpartitioned tables. It does
    not give any error if there are no partitions, but gives a `NULL` value in the
    partitions column.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPLAIN`也用于从非分区表中获取信息。如果没有分区，则不会出现任何错误，但在分区列中会给出一个`NULL`值。'
- en: Partition selection and pruning
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区选择和修剪
- en: In this section, you will see how partitioning can optimize `SQL` statements clause
    execution with the optimizer known as partition pruning, and the use of `SQL`
    statements to effectively use partition data for selection and perform modification
    operations on the partitioning.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将看到分区如何通过称为分区修剪的优化器来优化`SQL`语句的执行，并使用`SQL`语句有效地选择分区数据并对分区进行修改操作。
- en: Partition pruning
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区修剪
- en: Partition pruning is related to the optimization concept in partition. In partition
    pruning the concept described as *Do not scan partitions where no possible matching
    values can be present* is applied based on the query statements.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 分区修剪与分区中的优化概念相关。在分区修剪中，基于查询语句应用了“不要扫描可能不存在匹配值的分区”的概念。
- en: 'Suppose there is a partitioned table, `tp1`, created with the following statement:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个分区表`tp1`，使用以下语句创建：
- en: '[PRE27]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding example table `tp1`, suppose you want to retrieve a result
    from the following `SELECT` statement:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例表`tp1`中，假设您想从以下`SELECT`语句中检索结果：
- en: '[PRE28]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, you can see from the preceding statement that there are no rows that have
    data in partitions `p0` or `p3` as per the statement, so we only need to search
    the data in `p1` or `p2` for matching criteria. So, by limiting the search, it
    is possible to spend less time and effort matching and searching for the data
    through all the partitions in the table. This cutting away of the unmatched partitions
    is known as pruning.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以从前述语句中看到，根据该语句，没有数据存在于分区`p0`或`p3`中，因此我们只需要在`p1`或`p2`中搜索匹配的数据。因此，通过限制搜索，可以在表的所有分区中花费更少的时间和精力进行匹配和搜索数据。这种去除不匹配分区的操作称为修剪。
- en: The optimizer can make use of partition pruning for performing the query execution
    much faster compared to nonpartitioned tables that have the same schema, data,
    and query statements.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 优化器可以利用分区修剪来执行查询执行，与具有相同模式、数据和查询语句的非分区表相比，速度更快。
- en: 'The optimizer can do pruning in the following cases based on the `WHERE` condition
    reduction:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 优化器可以根据`WHERE`条件的减少在以下情况下进行修剪：
- en: '`partition_column IN (constant1, constant2, ..., contantN)`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`partition_column IN (constant1, constant2, ..., contantN)`'
- en: '`partition_column =  constant`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`partition_column = constant`'
- en: In the first case, the optimizer evaluates the partitioning expression for each
    of the values in the list and creates a list of partitions that are matched during
    evaluation, and then scanning or searching is performed only on the partitions
    in this partition list.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，优化器评估列表中每个值的分区表达式，并创建在评估期间匹配的分区列表，然后只在此分区列表中执行扫描或搜索。
- en: In the second case, the optimizer only evaluates the partitioning expression
    based on the given constant or specific value and determines which partition contains
    the value, and searching or scanning is performed only on this partition. There
    can be use of another arithmetic comparison instead of equals for this type of
    case.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，优化器仅根据给定的常量或特定值评估分区表达式，并确定哪个分区包含该值，并且只在此分区上执行搜索或扫描。在这种情况下，可以使用另一个算术比较而不是等于。
- en: Currently, pruning is not supported on `INSERT` statements but is supported
    in `SELECT`, `UPDATE`, and `DELETE` statements.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，修剪不支持`INSERT`语句，但支持`SELECT`，`UPDATE`和`DELETE`语句。
- en: Pruning is also applicable to short ranges where the optimizer can convert the
    ranges into an equivalent list of values. The optimizer can be applied when the
    partitioning expression consists of equality or range that can be reduced to equalities
    set or if an increasing or decreasing relationship is represented by the partitioning
    expression.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 修剪也适用于优化器可以将范围转换为等效值列表的短范围。当分区表达式由可以减少为相等集的相等性或范围组成，或者分区表达式表示递增或递减关系时，可以应用优化器。
- en: Pruning can also applicable to the column types of `DATE` or `DATETIME` if the
    partitioning uses the `TO_DAYS()` or `YEAR()` function, and also applicable if
    such tables use the `TO_SECONDS()` function in their partitioning expression.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 修剪也适用于使用`TO_DAYS()`或`YEAR()`函数进行分区的`DATE`或`DATETIME`列类型，并且如果这些表在其分区表达式中使用`TO_SECONDS()`函数，也适用。
- en: 'Suppose you have a table, `tp2`, as per the following statement :'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个表`tp2`，如下语句所示：
- en: '[PRE29]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, in the preceding statement the following statements can benefit from partition
    pruning:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在前面的语句中，以下语句可以从分区修剪中受益：
- en: '[PRE30]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For the last statement, the optimizer can act as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一条语句，优化器可以采取以下行动：
- en: Finding the partition that has the low end of the range as `YEAR('1984-06-22')`
    gives the value 1984, found in the `p3` partition.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到具有范围低端的分区为`YEAR('1984-06-22')`，得到值1984，找到在`p3`分区中。
- en: Finding the partition that has the high end of the range as `YEAR('1999-06-22')`
    gives the value 1999, found in the `p5` partition.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到具有范围高端的分区为`YEAR('1999-06-22')`，得到值1999，找到在`p5`分区中。
- en: Scan only the above two identified partitions and any partitions that lie between
    them.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅扫描上述两个确定的分区和它们之间的任何分区。
- en: So, in the above mentioned case the partitions to be scanned are `p3`, `p4`,
    and `p5` only, and the rest of the partitions can be ignored while matching.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在上述情况下，要扫描的分区仅为`p3`，`p4`和`p5`，而其余分区在匹配时可以忽略。
- en: 'The preceding examples use `RANGE` partitioning but partition pruning is also
    applicable on other types of partitioning as well. Suppose you have the table
    `tp3` schema as per the following statement:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例使用了`RANGE`分区，但分区修剪也适用于其他类型的分区。假设您有表`tp3`的模式如下语句所示：
- en: '[PRE31]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For the preceding table schema, consider if this statement `SELECT * FROM tp3
    WHERE zone_code BETWEEN 1 AND 3` is to be executed. The optimizer determines which
    of the partitions can have the values `1`, `2`, and `3` and finds `p1` and `p0`,
    so it skips the rest of the partitions `p3` and `p2`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的表模式，请考虑是否要执行此语句`SELECT * FROM tp3 WHERE zone_code BETWEEN 1 AND 3`。优化器确定哪些分区可以具有值`1`，`2`和`3`，并找到`p1`和`p0`，因此跳过其余的分区`p3`和`p2`。
- en: 'Column values with a constant can be pruned, as in the following example statement :'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 具有常量的列值可以被修剪，如以下示例语句：
- en: '[PRE32]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The optimization is performed only when the size of the range is smaller than
    the number of partitions.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当范围的大小小于分区数时才执行优化。
- en: Partition selection
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区选择
- en: 'Explicit selection of partition and subpartition is also supported and this
    enables row matching to conditions given in the where clause - this is known as
    partition selection. It is very similar to partition pruning as only specific
    partitions are scanned for matching, but differs in the following two key aspects:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 还支持显式选择分区和子分区，这使得行匹配到where子句中给定的条件 - 这称为分区选择。它与分区修剪非常相似，因为只有特定的分区用于匹配，但在以下两个关键方面有所不同：
- en: The partitions to be scanned are specified by the issuer of the statement and
    are not automatic such as with partition pruning
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要扫描的分区由发出语句的人指定，而不是像分区修剪那样自动进行。
- en: The partition pruning is limited to queries, whereas partition selection supports
    both queries and a number of `DML` statements
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区修剪仅限于查询，而分区选择支持查询和多个`DML`语句
- en: 'SQL statements supported for explicit partition selection are listed as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 支持显式分区选择的SQL语句如下所示：
- en: '`INSERT`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INSERT`'
- en: '`SELECT`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT`'
- en: '`UPDATE`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPDATE`'
- en: '`REPLACE`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REPLACE`'
- en: '`LOAD DATA`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOAD DATA`'
- en: '`LOAD XML`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOAD XML`'
- en: '`DELETE`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`'
- en: 'The following syntax with the `PARTITION` option is used for explicit partition
    selection:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 用于显式分区选择的`PARTITION`选项的以下语法：
- en: '[PRE33]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding option is always followed by the table structure or table schema
    it belongs to. `partition_names` stands for the list of comma separated names
    of partitions or subpartitions that will be used in partitioning. Partition and
    subpartition names in `partition_names` can be in any order or even overlap but
    each name from the list must be the existing partition or subpartition name of
    the specific table, otherwise the statement will fail with the error message `partition_name` doesn't
    exist.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 上述选项总是跟随它所属的表结构或表模式。`partition_names`代表分区或子分区的逗号分隔名称列表，将用于分区。`partition_names`中的分区和子分区名称可以是任何顺序，甚至可以重叠，但列表中的每个名称必须是特定表的现有分区或子分区名称，否则语句将失败，并显示错误消息`partition_name`不存在。
- en: If the `PARTITION` option is used, only listed partitions and subpartitions
    are checked for matching rows. `PARTITION` option can also be used in the `SELECT`
    statement to retrieve rows belonging to any given partition.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`PARTITION`选项，只有列出的分区和子分区才会被检查匹配的行。`PARTITION`选项也可以用于`SELECT`语句，以检索属于任何给定分区的行。
- en: 'Suppose you have the table `employee` created with the following statements:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你使用以下语句创建了表`employee`：
- en: '[PRE34]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, if you check with partition `p1`, you see the following output as rows
    added in partition `p1`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你检查分区`p1`，你会看到以下输出，因为行添加到分区`p1`中：
- en: '[PRE35]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you use this statement `SELECT * FROM employee WHERE id BETWEEN 5 AND 9;`,
    it will give the same output.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用这个语句`SELECT * FROM employee WHERE id BETWEEN 5 AND 9;`，将得到相同的输出。
- en: In order to retrieve rows from multiple partitions you can use a comma separated
    list of partition names. For example, `SELECT * FROM employee PARTITION (p1,p2)`,
    will result in all the rows from partitions `p1` and `p2` and exclude the remaining
    partitions.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从多个分区中检索行，可以使用逗号分隔的分区名称列表。例如，`SELECT * FROM employee PARTITION (p1,p2)`，将得到来自分区`p1`和`p2`的所有行，并排除其余分区。
- en: Any supported partitioning types can be used using partitioning selection statements.
    MySQL 8 automatically adds partition names when a table is created with the `LINEAR
    HASH` or `LINEAR KEY` partitioning types specified without any names, and this
    is also applicable to subpartitions as well. While executing the `SELECT` statement
    on this table you can specify partition names generated by MySQL 8 for partition
    specific data retrieval.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用任何支持的分区类型来使用分区选择语句。当使用`LINEAR HASH`或`LINEAR KEY`分区类型创建表时，MySQL 8会自动添加分区名称，而且这也适用于子分区。在对这个表执行`SELECT`语句时，可以指定MySQL
    8生成的分区名称来检索特定分区的数据。
- en: The `PARTITION` option is also applicable on the `SELECT` statement for the
    `INSERT ... SELECT` statement, by which we can insert data retrieved from specific
    partitions or subpartitions as well.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`PARTITION`选项也适用于`SELECT`语句，用于`INSERT ... SELECT`语句，可以插入从特定分区或子分区检索的数据。'
- en: The `PARTITION` option is also applicable on the `SELECT` statement with join
    queries on tables with specific partition or subpartition data.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`PARTITION`选项也适用于具有特定分区或子分区数据的表的连接查询的`SELECT`语句。'
- en: Restrictions and limitations in partitioning
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区中的限制和限制
- en: In this section, you will see the restrictions and limitations in MySQL 8 partitioning,
    covering prohibited constructs, performance considerations, and limitation aspects
    related to storage engines and functions in detail, to gain optimum benefits from
    the table partitioning.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将看到MySQL 8分区中的限制和限制，涵盖了禁止的结构、性能考虑和与存储引擎和函数相关的限制方面的详细信息，以便从表分区中获得最佳效益。
- en: Partitioning keys, primary keys, and unique keys
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区键、主键和唯一键
- en: 'The relationship between partitioning keys with primary keys and unique keys
    is very important for partition schema structure design. To say the rule in one
    line it will be that `All` the columns used in the partitioning in the partition
    table must include every unique key of the table. So every unique key, including
    the primary key column on the table, must be part of the partitioning expression.
    Take a look at the following example for the `CREATE TABLE` statement using a
    unique key that does not adhere to the rule:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 分区键与主键和唯一键之间的关系对于分区模式结构设计非常重要。简而言之，规则是分区表中用于分区的所有列必须包括表的每个唯一键。因此，包括表上的主键列在内的每个唯一键都必须是分区表达式的一部分。看一下以下使用不符合规则的唯一键的`CREATE
    TABLE`语句的例子：
- en: '[PRE36]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In each of the preceding statements for the creation of table `tk1` and `tk2` the
    proposed table can have at least one unique key that does not include all columns
    in the partition expression.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述每个用于创建表`tk1`和`tk2`的语句中，建议的表可以至少有一个唯一键，该键不包括分区表达式中的所有列。
- en: 'Now look at the following modified table creation statements, which are made
    to work and are turned from invalid to valid statements:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看一下以下修改后的表创建语句，这些语句已经可以工作，并且从无效变为有效：
- en: '[PRE37]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you take a look at the following table structure, it cannot be partitioned
    at all because there is no way to include both the unique key columns that can
    be part of partitioning key columns:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下以下表结构，它根本无法分区，因为没有办法包含可以成为分区键列的唯一键列：
- en: '[PRE38]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As per the definition, every primary key is a unique key. The restriction is
    also applicable on a table''s primary key, if any. The following are two examples
    for table `tk5` and `tk6` that are invalid statements:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，每个主键都是唯一键。这个限制也适用于表的主键。以下是表`tk5`和`tk6`的两个无效语句的例子：
- en: '[PRE39]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In both the preceding statements, the corresponding primary key is not included
    in all the columns referenced as in the partitioning expression. The following
    statements are valid:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述两个语句中，所有引用的列都不包括相应的主键在分区表达式中。以下语句是有效的：
- en: '[PRE40]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If the table does not have a unique key or primary key then the restriction
    is not applicable, and any column or columns can be used in the partitioning expression
    as per compatible column types for the partitioning type. All above restrictions
    are also applicable to the `ALTER TABLE` statements as well.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表没有唯一键或主键，则该限制不适用，并且可以根据分区类型的兼容列类型在分区表达式中使用任何列。所有上述限制也适用于`ALTER TABLE`语句。
- en: Partitioning limitations relating to storage engines
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与存储引擎相关的分区限制
- en: Partitioning support is not provided by MySQL server but from the storage engine's
    own or native partitioning handler in MySQL 8\. In MySQL 8, the `InnoDB` storage
    engine only provides a native partitioning handler and so the partitioned table
    creation is not applicable with any other storage engine.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 分区支持不是由MySQL服务器提供的，而是来自MySQL 8中的存储引擎自己或本机分区处理程序。在MySQL 8中，`InnoDB`存储引擎只提供本机分区处理程序，因此分区表的创建不适用于任何其他存储引擎。
- en: '`ALTER TABLE ... OPTIMIZE PARTITION` does not work correctly with the `InnoDB` storage
    engine, so instead use the `ALTER TABLE ... REBUILD PARTITION` and `ALTER TABLE
    ... ANALYZE PARTITION` operations for such tables.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`ALTER TABLE ... OPTIMIZE PARTITION`在`InnoDB`存储引擎中无法正确工作，因此请改用`ALTER TABLE
    ... REBUILD PARTITION`和`ALTER TABLE ... ANALYZE PARTITION`操作。'
- en: Partitioning limitations relating to functions
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与函数相关的分区限制
- en: 'In partitioning expressions only the following listed MySQL functions are allowed
    in MySQL 8:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在分区表达式中，只有以下列出的MySQL 8函数是允许的：
- en: '`ABS()`: It provides an absolute value for the given argument'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ABS()`: 它为给定参数提供了绝对值'
- en: '`CEILING()`: It provides the smallest integer number possible for the given
    argument'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CEILING()`: 它为给定参数提供可能的最小整数'
- en: '`DAY()`: It provides the day of the month for the given date'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DAY()`: 它为给定日期提供月份中的日期'
- en: '`DAYOFMONTH()`: It provides the day of the month for the given date same as
    `DAY()`'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DAYOFMONTH()`: 它提供给定日期的月份中的日期，与`DAY()`相同'
- en: '`DAYOFWEEK()`: It provides the weekday number for the given date'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DAYOFWEEK()`: 它为给定日期提供星期几的编号'
- en: '`DAYOFYEAR()`: It provides the day of the year for the given date'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DAYOFYEAR()`: 它为给定日期提供一年中的日期'
- en: '`DATEDIFF()`: It provides the number of days between two given dates'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DATEDIFF()`: 它提供两个给定日期之间的天数'
- en: '`EXTRACT()`: It provides part of the given argument'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXTRACT()`: 它提供给定参数的一部分'
- en: '`FLOOR()`: It provides the largest integer value possible for the given argument'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FLOOR()`: 它为给定参数提供了可能的最大整数值'
- en: '`HOUR()`: It provides the hour from the given argument'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HOUR()`: 它从给定参数中提供小时数'
- en: '`MICROSECOND()`: It provides the microseconds from the given argument'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MICROSECOND()`: 它从给定参数中提供微秒数'
- en: '`MINUTE()`: It provides the minute from the given argument'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MINUTE()`: 它从给定参数中提供分钟数'
- en: '`MOD()`: It performs the Modulo operation and provides the remainder of `N`
    divided by `M` where `MOD(N,M)`'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MOD()`: 它执行模运算并提供`N`除以`M`的余数，其中`MOD(N,M)`'
- en: '`MONTH()`: It provides the month from the given argument'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MONTH()`: 它从给定参数中提供月份'
- en: '`QUARTER()`: It provides the quarter from the given argument'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QUARTER()`: 它从给定参数中提供季度'
- en: '`SECOND()`: It provides the second from the given argument'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SECOND()`: 它从给定参数中提供秒数'
- en: '`TIME_TO_SEC()`: It provides the second from the given time value argument'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIME_TO_SEC()`: 它从给定时间值参数中提供秒数'
- en: '`TO_DAYS()`: It provides the number of days from year 0 for the given argument'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TO_DAYS()`: 它为给定参数提供了从公元0年开始的天数'
- en: '`TO_SECONDS()`: It provides the number of seconds from the year 0 for the given
    argument'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TO_SECONDS()`: 它为给定参数提供从公元0年开始的秒数'
- en: '`UNIX_TIMESTAMP() (with TIMESTAMP columns)`: It provides the seconds since
    ''1970-01-01 00:00:00'' UTC for the given argument'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNIX_TIMESTAMP() (with TIMESTAMP columns)`: 它为给定参数提供自''1970-01-01 00:00:00''
    UTC以来的秒数'
- en: '`WEEKDAY()`: It provides the weekday index for the given argument'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WEEKDAY()`: 它为给定参数提供星期几的索引'
- en: '`YEAR()`: It provides the year for the given argument'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YEAR()`: 它为给定参数提供年份'
- en: '`YEARWEEK()`: It provides the year and week for the given argument'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YEARWEEK()`: 它为给定参数提供年份和周数'
- en: Partition pruning supports the `TO_DAYS()`, `TO_SECONDS()`, `TO_YEAR()`, and
    `UNIX_TIMESTAMP()` functions in MySQL 8.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 分区修剪支持MySQL 8中的`TO_DAYS()`、`TO_SECONDS()`、`TO_YEAR()`和`UNIX_TIMESTAMP()`函数。
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about different types of partitioning and the need
    for partitions. We also covered detailed information on managing all types of
    partitions. We learned about partition pruning and selection of partitions which
    is used by the optimizer. We also discussed applicable limitations and restrictions
    to consider while using partitioning.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了不同类型的分区和分区的需求。我们还详细介绍了管理所有类型的分区的信息。我们学习了分区修剪和选择分区，这是优化器使用的。我们还讨论了在使用分区时需要考虑的适用限制和限制。
- en: In the next chapter, you will learn how to do scaling in MySQL 8, and discover
    common challenges faced when providing scalability in MySQL 8\. You will also
    learn how to make the MySQL server highly available and achieve high availability.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何在MySQL 8中进行扩展，并了解在提供MySQL 8可扩展性时面临的常见挑战。您还将学习如何使MySQL服务器高度可用并实现高可用性。
