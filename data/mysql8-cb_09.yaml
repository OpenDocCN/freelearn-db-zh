- en: Replication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下内容：
- en: Setting up replication
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置复制
- en: Setting up master-master replication
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置主-主复制
- en: Setting up multi-source replication
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置多源复制
- en: Setting up replication filters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置复制过滤器
- en: Switching a slave from master-slave to chain replication
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将从主-从复制切换到链式复制
- en: Switching a slave from chain replication to master-slave
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将从链式复制切换到主-从复制
- en: Setting up delayed replication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置延迟复制
- en: Setting up GTID replication
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置GTID复制
- en: Setting up semi-synchronous replication
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置半同步复制
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: As explained in [Chapter 6](part0223.html#6KLDE0-faa69fe6f4c04957afca3568dcd9cd83), *Binary
    Logging*, replication enables data from one MySQL database server (the master)
    to be copied to one or more MySQL database servers (the slaves). Replication is
    asynchronous by default; slaves do not need to be permanently  connected  to receive
    updates from the master. You can configure to replicate all databases, selected
    databases, or even selected tables within a database.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第6章](part0223.html#6KLDE0-faa69fe6f4c04957afca3568dcd9cd83)中所解释的，*二进制日志*，复制使得来自一个MySQL数据库服务器（主服务器）的数据被复制到一个或多个MySQL数据库服务器（从服务器）。复制默认是异步的；从服务器不需要永久连接以接收来自主服务器的更新。您可以配置复制所有数据库、选定的数据库，甚至是数据库中的选定表。
- en: In this chapter, you will learn how to set up traditional replication; replicate
    selected databases and tables; and set up multi-source replication, chain replication,
    delayed replication, and semi-synchronous replication.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，您将学习如何设置传统复制；复制选定的数据库和表；以及设置多源复制、链式复制、延迟复制和半同步复制。
- en: 'On a high level, replication works like this: all DDL and DML statements executed
    on a server (**master**) are logged into binary logs, which are pulled by the
    servers connecting to it (called **slaves**). The binary logs are simply copied
    to the slaves and are saved as relay logs. This process is taken care of by a
    thread called **IO thread**. There is one more thread called **SQL thread**, that
    executes the statements in the relay log sequentially.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，复制的工作原理是这样的：在一个服务器上执行的所有DDL和DML语句（**主服务器**）都被记录到二进制日志中，这些日志被连接到它的服务器（称为**从服务器**）拉取。二进制日志简单地被复制到从服务器并保存为中继日志。这个过程由一个叫做**IO线程**的线程来处理。还有一个叫做**SQL线程**的线程，按顺序执行中继日志中的语句。
- en: 'How replication works is very clearly explained in this blog:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 复制的工作原理在这篇博客中得到了很清楚的解释：
- en: '[https://www.percona.com/blog/2013/01/09/how-does-mysql-replication-really-work/](https://www.percona.com/blog/2013/01/09/how-does-mysql-replication-really-work/)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.percona.com/blog/2013/01/09/how-does-mysql-replication-really-work/](https://www.percona.com/blog/2013/01/09/how-does-mysql-replication-really-work/)'
- en: 'The advantages of replication are (taken from the manual, at [https://dev.mysql.com/doc/refman/8.0/en/replication.html](https://dev.mysql.com/doc/refman/8.0/en/replication.html)):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 复制的优点（摘自手册，网址为[https://dev.mysql.com/doc/refman/8.0/en/replication.html](https://dev.mysql.com/doc/refman/8.0/en/replication.html)）：
- en: '**Scale-out solutions**: Spreading the load among multiple slaves to improve
    performance. In this environment, all writes and updates must take place on the
    master server. Reads, however, may take place on one or more slaves. This model
    can improve the performance of writes (since the master is dedicated to updates),
    while dramatically increasing read speed across an increasing number of slaves.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展解决方案**：将负载分散在多个从服务器上以提高性能。在这种环境中，所有的写入和更新必须在主服务器上进行。然而，读取可以在一个或多个从服务器上进行。这种模式可以提高写入的性能（因为主服务器专门用于更新），同时大大提高了在越来越多的从服务器上的读取速度。'
- en: '**Data security**: Because data is replicated to the slave and the slave can
    pause the replication process, it is possible to run backup services on the slave
    without corrupting the corresponding master data.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据安全**：因为数据被复制到从服务器并且从服务器可以暂停复制过程，所以可以在从服务器上运行备份服务而不会破坏相应的主服务器数据。'
- en: '**Analytics**: Live data can be created on the master, while the analysis of
    the information can take place on the slave without affecting the performance
    of the master.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析**：可以在主服务器上创建实时数据，而信息的分析可以在从服务器上进行，而不会影响主服务器的性能。'
- en: '**Long-distance data distribution**: You can use replication to create a local
    copy of data for a remote site to use without permanent access to the master.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程数据分发**：您可以使用复制在远程站点创建数据的本地副本，而无需永久访问主服务器。'
- en: Setting up replication
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置复制
- en: There are many replication topologies. Some of them are the traditional master-slave
    replication, chain replication, master-master replication, multi-source replication,
    and so on.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多复制拓扑结构。其中一些是传统的主-从复制、链式复制、主-主复制、多源复制等。
- en: '**Traditional replication** involves a single master and multiple slaves.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**传统复制** 包括一个主服务器和多个从服务器。'
- en: '![](img/00005.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00005.jpeg)'
- en: '**Chain replication** means one server replicates from another, which in turn
    replicates from another. The middle server is referred to as the relay master
    (master ---> relay master ---> slave).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**链式复制** 意味着一个服务器从另一个服务器复制，而另一个服务器又从另一个服务器复制。中间服务器被称为中继主服务器（主服务器 ---> 中继主服务器
    ---> 从服务器）。'
- en: '![](img/00006.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00006.jpeg)'
- en: This is mainly used when you want to set up replication between two data centers.
    The primary master and its slaves will be in one data center. The secondary master
    (relay) replicates from the primary master in the other data center. All the slaves
    of the other data center are replicated from the secondary master.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要用于当您想在两个数据中心之间设置复制时。主服务器和其从服务器将位于一个数据中心。次要主服务器（中继）从另一个数据中心的主服务器进行复制。另一个数据中心的所有从服务器都从次要主服务器进行复制。
- en: '**Master-master replication**: In this topology, both the masters accept writes
    and replicate between each other.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**主-主复制**：在这种拓扑结构中，两个主服务器都接受写入并在彼此之间进行复制。'
- en: '![](img/00007.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00007.jpeg)'
- en: '**Multi-source replication**: In this topology, a slave will replicate from
    multiple masters instead of one.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**多源复制**：在这种拓扑结构中，一个从服务器将从多个主服务器而不是一个主服务器进行复制。'
- en: '![](img/00008.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00008.jpeg)'
- en: If you want to set up chain replication, you can follow the same steps mentioned
    here, replacing the master with the relay master.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要设置链式复制，可以按照此处提到的相同步骤进行，将主服务器替换为中继主服务器。
- en: How to do it...
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, setting up of single slave is explained. The same principles
    can be applied to set up chain replication. Usually the backups are taken from
    the slave when setting up another slave.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，解释了单个从服务器的设置。相同的原则可以应用于设置链式复制。通常在设置另一个从服务器时，备份是从从服务器中获取的。
- en: 'Outline:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 大纲：
- en: Enable binary logging on the master
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主服务器上启用二进制日志记录
- en: Create a replication user on the master
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主服务器上创建一个复制用户
- en: Set the unique `server_id` on the slave
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在从服务器上设置唯一的`server_id`
- en: Take backup from the master
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主服务器备份
- en: Restore the backup on the slave
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在从服务器上恢复备份
- en: Execute the `CHANGE MASTER TO` command
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`CHANGE MASTER TO`命令
- en: Start the replication
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始复制
- en: 'Steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤：
- en: '**On master**: Enable binary logging on the master and set `SERVER_ID`. Refer
    to [Chapter 6](part0223.html#6KLDE0-faa69fe6f4c04957afca3568dcd9cd83), *Binary
    Logging*, to learn how to enable binary logging.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在主服务器上**：在主服务器上启用二进制日志记录并设置`SERVER_ID`。参考[第6章](part0223.html#6KLDE0-faa69fe6f4c04957afca3568dcd9cd83)，*二进制日志记录*，了解如何启用二进制日志记录。'
- en: '**On master**: Create a replication user. The slave connects to the master
    using this account:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在主服务器上**：创建一个复制用户。从服务器使用这个帐户连接到主服务器：'
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**On slave**: Set the unique `SERVER_ID` option (it should be different from
    what you have set on master):'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在从服务器上**：设置唯一的`SERVER_ID`选项（它应该与主服务器上设置的不同）：'
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**On slave**: Take backup from the master by remotely connecting. You can use either `mysqldump`
    or `mydumper`. `mysqlpump` cannot be used because the binary log positions won''t
    be consistent.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在从服务器上**：通过远程连接从主服务器备份。您可以使用`mysqldump`或`mydumper`。不能使用`mysqlpump`，因为二进制日志位置不一致。'
- en: '`mysqldump`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysqldump`：'
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You have to pass the `--slave-dump` option when taking backup from another
    slave.`mydumper`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当从另一个从服务器备份时，您必须传递`--slave-dump`选项。`mydumper`：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**On slave**: After the backup completes, restore the backup. Refer to [Chapter
    8](part0296.html#8Q96G0-faa69fe6f4c04957afca3568dcd9cd83), *Restoring Data*, for
    the restoration methods.'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在从服务器上**：备份完成后，恢复备份。参考[第8章](part0296.html#8Q96G0-faa69fe6f4c04957afca3568dcd9cd83)，*恢复数据*，了解恢复方法。'
- en: '`mysqldump`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysqldump`：'
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`mydumper`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`mydumper`：'
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**On slave**: After restoring the backup, you have to execute the following
    command:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在从服务器上**：在恢复备份后，您必须执行以下命令：'
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`mysqldump`: `<log_file_name>` and `<position>` are included in the backup
    dump file. For example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysqldump`：备份转储文件中包含`<log_file_name>`和`<position>`。例如：'
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`mydumper`: `<log_file_name>` and `<position>` are stored in the metadata file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`mydumper`：`<log_file_name>`和`<position>`存储在元数据文件中：'
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you are taking backup from a slave or master to set up another slave, you
    have to use positions from `SHOW SLAVE STATUS`. If you want to set up the chain
    replication, you can use the positions from `SHOW MASTER STATUS`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从一个从服务器或主服务器备份以设置另一个从服务器，您必须使用`SHOW SLAVE STATUS`中的位置。如果要设置链式复制，可以使用`SHOW
    MASTER STATUS`中的位置。
- en: 'On the slave, execute the `START SLAVE` command:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在从服务器上，执行`START SLAVE`命令：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can check the status of replication by executing:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过执行以下命令来检查复制的状态：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You should look for `Seconds_Behind_Master`, which shows the replication lag.
    If it is `0`, it means the slave is in sync with the master; any non-zero value
    indicates the number of seconds of lag, and if it is `NULL`, it means replication
    is not happening.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该查找`Seconds_Behind_Master`，它显示了复制的延迟。如果是`0`，表示从服务器与主服务器同步；任何非零值表示延迟的秒数，如果是`NULL`，表示复制没有发生。
- en: Setting up master-master replication
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置主-主复制
- en: This recipe will interest many people since many of us try doing this. Let's
    get into the details of it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程会吸引很多人，因为我们中的许多人都尝试过这样做。让我们深入了解一下。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Assume that the masters are `master1` and `master2`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 假设主服务器是`master1`和`master2`。
- en: 'Steps:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤：
- en: Set up replication between `master1` and `master2` as described in Chapter 9,
    *Replication*.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照第9章*复制*中描述的方法在`master1`和`master2`之间设置复制。
- en: 'Make `master2` read-only:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使`master2`成为只读：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: On `master2`, check the current binary log coordinate.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`master2`上，检查当前的二进制日志坐标。
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: From the preceding output, you can start the replication on `master1` from `server1.000017`
    and position `473`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，您可以从`server1.000017`和位置`473`开始在`master1`上启动复制。
- en: 'From the positions taken from the preceding step, execute the `CHANGE MASTER
    TO` command on `master1`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据前面步骤中的位置，在`master1`上执行`CHANGE MASTER TO`命令：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Start the slave on `master1`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`master1`上启动从服务器：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Finally, you can make `master2` read-write, and applications can start writing
    to it.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您可以使`master2`成为读写，应用程序可以开始向其写入。
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Setting up multi-source replication
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置多源复制
- en: MySQL multi-source replication enables a replication slave to receive transactions
    from multiple sources simultaneously. Multi-source replication can be used to
    back up multiple servers to a single server, merge table shards, and consolidate
    data from multiple servers to a single server. Multi-source replication does not
    implement any conflict detection or resolution when applying transactions, and
    those tasks are left to the application if required. In a multi-source replication
    topology, a slave creates a replication channel for each master that it should
    receive transactions from.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL多源复制使得复制从服务器能够同时接收来自多个源的事务。多源复制可用于将多个服务器备份到单个服务器，合并表分片，并将来自多个服务器的数据合并到单个服务器。多源复制在应用事务时不实现任何冲突检测或解决，如果需要，这些任务将留给应用程序。在多源复制拓扑中，从服务器为应该接收事务的每个主服务器创建一个复制通道。
- en: In this section, you will learn how to set up a slave with multiple masters.
    This method is the same as setting up traditional replication over the channels.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何设置具有多个主服务器的从服务器。这种方法与在通道上设置传统复制相同。
- en: How to do it...
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Assume that you are setting up `server3` as a slave of `server1` and `server2`.
    You need to create traditional replication from `server1` to `server3` over a
    channel and from `server2` to `server3` over another channel. To ensure that data
    is consistent on the slave, make sure that different sets of databases are replicated
    or the application takes care of the conflicts.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您要将`server3`设置为`server1`和`server2`的从服务器。您需要从`server1`到`server3`创建传统复制通道，并从`server2`到`server3`创建另一个通道。为了确保从服务器上的数据一致，请确保复制不同的数据库集或应用程序处理冲突。
- en: Before you begin, take a backup from server1 and restore on `server3`; similarly
    take a backup from `server2` and restore on `server3`, as described in Chapter
    9, *Replication*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请从server1备份并在`server3`上恢复；类似地，从`server2`备份并在`server3`上恢复，如第9章“复制”中所述。
- en: 'On `server3`, modify the replication repositories to `TABLE` from `FILE`. You
    can change it dynamically by running the following commands:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`server3`上，将复制存储库从`FILE`修改为`TABLE`。您可以通过运行以下命令动态更改它：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Also make the changes in the configuration file:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 还要更改配置文件：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'On `server3`, execute the `CHANGE MASTER TO` command to make it a slave of
    `server1` over a channel named `master-1`. You can name it anything:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`server3`上，执行`CHANGE MASTER TO`命令，使其成为`server1`的从服务器，通道名为`master-1`。您可以随意命名：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'On `server3`, execute the `CHANGE MASTER TO` command to make it a slave of
    `server2` over channel `master-2`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`server3`上，执行`CHANGE MASTER TO`命令，使其成为`server2`的从服务器，通道为`master-2`：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Execute the `START SLAVE FOR CHANNEL` statement for each channel as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个通道，执行`START SLAVE FOR CHANNEL`语句如下：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Verify the slave status by executing the `SHOW SLAVE STATUS` statement:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`SHOW SLAVE STATUS`语句验证从服务器的状态：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To get the slave status for a particular channel, execute:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取特定通道的从服务器状态，请执行：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is the other way you can use a performance schema to monitor the metrics:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是您可以使用性能模式监视指标的另一种方法：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can specify all the slave-related commands for a channel by appending `FOR
    CHANNEL ''channel_name''`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过附加`FOR CHANNEL 'channel_name'`指定通道的所有与从服务器相关的命令：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Setting up replication filters
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置复制过滤器
- en: You can control which tables or databases are to be replicated. On the master,
    you can control which databases to log changes for by using the `--binlog-do-db`
    and `--binlog-ignore-db` options to control binary logging, as mentioned in Chapter
    6, *Binary Logging*. The better way is to control on the slave side. You can execute
    or ignore statements received from the master by using `--replicate-*` options
    or dynamically by creating replication filters.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以控制要复制的表或数据库。在主服务器上，您可以使用`--binlog-do-db`和`--binlog-ignore-db`选项控制要为其记录更改的数据库，如第6章“二进制日志”中所述。更好的方法是在从服务器端进行控制。您可以使用`--replicate-*`选项或通过创建复制过滤器动态地执行或忽略从主服务器接收的语句。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: To create a filter, you need to execute the `CHANGE REPLICATION FILTER` statement.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建过滤器，您需要执行`CHANGE REPLICATION FILTER`语句。
- en: Replicate a database only
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅复制数据库
- en: Assume that you want to replicate `db1` and `db2` only. Use the following statement
    to create the replication filter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您只想复制`db1`和`db2`。使用以下语句创建复制过滤器。
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that you should specify all the databases inside parentheses.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您应该在括号内指定所有数据库。
- en: Replicate specific tables
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制特定表
- en: 'You can specify the tables you want to be replicated using `REPLICATE_DO_TABLE`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`REPLICATE_DO_TABLE`指定要复制的表：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Suppose that you want to use regex for tables; you can use the `REPLICATE_WILD_DO_TABLE`
    option:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要对表使用正则表达式；您可以使用`REPLICATE_WILD_DO_TABLE`选项：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can mention some databases or tables with regex using various `IGNORE` options.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用各种`IGNORE`选项使用正则表达式提及一些数据库或表。
- en: Ignore a database
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 忽略数据库
- en: 'Just like you can choose to replicate a database, you can ignore a database
    from replication using `REPLICATE_IGNORE_DB`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 就像您可以选择复制数据库一样，您可以使用`REPLICATE_IGNORE_DB`忽略复制中的数据库：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Ignore specific tables
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 忽略特定表
- en: 'You can ignore certain tables using the `REPLICATE_IGNORE_TABLE` and `REPLICATE_WILD_IGNORE_TABLE`
    options. The `REPLICATE_WILD_IGNORE_TABLE` option allows wildcard characters,
    where as `REPLICATE_IGNORE_TABLE` only accepts full table names:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`REPLICATE_IGNORE_TABLE`和`REPLICATE_WILD_IGNORE_TABLE`选项忽略某些表。`REPLICATE_WILD_IGNORE_TABLE`选项允许使用通配符字符，而`REPLICATE_IGNORE_TABLE`仅接受完整的表名：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can also set filters for a channel by specifying the channel name:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过指定通道名称为通道设置过滤器：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: See also
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Refer to [https://dev.mysql.com/doc/refman/8.0/en/change-replication-filter.html](https://dev.mysql.com/doc/refman/8.0/en/change-replication-filter.html)
    for more details on replication filters. If you are using more than one filter,
    refer to [https://dev.mysql.com/doc/refman/8.0/en/replication-rules.html](https://dev.mysql.com/doc/refman/8.0/en/replication-rules.html)
    to know more about how MySQL evaluates filters.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有关复制过滤器的更多详细信息，请参阅[https://dev.mysql.com/doc/refman/8.0/en/change-replication-filter.html](https://dev.mysql.com/doc/refman/8.0/en/change-replication-filter.html)。如果您使用多个过滤器，请参阅[https://dev.mysql.com/doc/refman/8.0/en/replication-rules.html](https://dev.mysql.com/doc/refman/8.0/en/replication-rules.html)以了解有关MySQL如何评估过滤器的更多信息。
- en: Switching slave from master-slave to chain replication
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将从主从复制切换到链式复制
- en: 'If you have a master-slave replication set up, Servers B and C replicating
    from Server A: Server A --> (Server B, Server C) and you wish to make Server C
    a slave of Server B, you have to stop replication on both Server B and Server
    C. Then bring them to the same master log position using the `START SLAVE UNTIL`
    command. After that, you can get the master log coordinates from Server B and
    execute the `CHANGE MASTER TO` command on Server C.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您设置了主从复制，服务器B和C从服务器A复制：服务器A -->（服务器B，服务器C），并且您希望将服务器C设置为服务器B的从服务器，则必须在服务器B和服务器C上停止复制。然后使用`START
    SLAVE UNTIL`命令将它们带到相同的主日志位置。之后，您可以从服务器B获取主日志坐标，并在服务器C上执行`CHANGE MASTER TO`命令。
- en: How to do it...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: '**On Server C**: Stop slave and note the `Relay_Master_Log_File` and `Exec_Master_Log_Pos`
    positions in the `SHOW SLAVE STATUS\G` command:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在服务器C上**：停止从服务器并注意`SHOW SLAVE STATUS\G`命令中的`Relay_Master_Log_File`和`Exec_Master_Log_Pos`位置：'
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**On Server B**: Stop slave and note the `Relay_Master_Log_File` and `Exec_Master_Log_Pos`
    positions in the `SHOW SLAVE STATUS\G` command:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在服务器B上**：停止从服务器并注意`SHOW SLAVE STATUS\G`命令中的`Relay_Master_Log_File`和`Exec_Master_Log_Pos`位置：'
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Compare the Server B log positions with Server C and find out which is the
    latest sync with Server A. Usually, since you have stopped the slave on Server
    C first, Server B will be ahead. In our case, the log positions are:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较服务器B的日志位置和服务器C，找出与服务器A最新的同步。通常，由于您首先在服务器C上停止了从服务器，服务器B将领先。在我们的情况下，日志位置是：
- en: 'Server C: (`server_A-bin.000023`, `2604`)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器C：（`server_A-bin.000023`，`2604`）
- en: 'Server B: (`server_A-bin.000023`, `8250241`)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器B：（`server_A-bin.000023`，`8250241`）
- en: Server B is ahead, so we have to bring Server C to the position of Server B.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器B领先，所以我们必须将服务器C带到服务器B的位置。
- en: '**On Server C**: Use the `START SLAVE UNTIL` statement to sync up to the position
    of server B:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在服务器C上**：使用`START SLAVE UNTIL`语句同步到服务器B的位置：'
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**On Server C**: Wait for server C to catch up by checking `Exec_Master_Log_Pos`
    and `Until_Log_Pos` (both should be the same) in the output of `SHOW SLAVE STATUS`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在服务器C上**：等待服务器C追上，通过检查`SHOW SLAVE STATUS`输出中的`Exec_Master_Log_Pos`和`Until_Log_Pos`（两者应该相同）：'
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**On Server B**: Find out the master status, start the slave, and make sure
    it is replicating:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在服务器B上**：查找主状态，启动从服务器，并确保它正在复制：'
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**On Server C**: Stop the slave, execute the `CHANGE MASTER TO` command, and
    point to server B. You have to use the positions that you have got from the preceding
    step:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在服务器C上**：停止从服务器，执行`CHANGE MASTER TO`命令，并指向服务器B。您必须使用从上一步中获得的位置：'
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**On Server C**: Start replication and verify the slave status:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在服务器C上**：启动复制并验证从服务器状态：'
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Switching the slave from chain replication to master-slave
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将从链式复制切换为主从复制
- en: If you have a chain replication setup (such as server A --> sever B --> server
    C) and you wish to make server C a direct slave of server A, you have to stop
    replication on server B, let server C catch up with server B, and then find the
    coordinates of server A  corresponding to the position where server B stopped.
    Using those coordinates, you can execute a `CHANGE MASTER TO` command on server
    C and make it a slave of server A.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您设置了链式复制（例如服务器A --> 服务器B --> 服务器C）并且希望使服务器C成为服务器A的直接从服务器，则必须在服务器B上停止复制，让服务器C追上服务器B，然后找到服务器A对应于服务器B停止位置的坐标。使用这些坐标，您可以在服务器C上执行`CHANGE
    MASTER TO`命令，并使其成为服务器A的从服务器。
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: '**On server B**: Stop the slave and note down the master status:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在服务器B上**：停止从服务器并记录主状态：'
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**On server C**: Make sure that the slave delay is caught up.  `Relay_Master_Log_File`
    and `Exec_Master_Log_Pos` should be equal to the output of the master status on
    server B. Once the delay is caught up, stop the slave:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在服务器C上**：确保从服务器延迟已经追上。`Relay_Master_Log_File`和`Exec_Master_Log_Pos`应该等于服务器B上主状态的输出。一旦延迟追上，停止从服务器：'
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**On server B**: Get the coordinates of server A from the `SHOW SLAVE STATUS`
    output (note down `Relay_Master_Log_File` and `Exec_Master_Log_Pos`) and start
    the slave:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在服务器B上**：从`SHOW SLAVE STATUS`输出中获取服务器A的坐标（注意`Relay_Master_Log_File`和`Exec_Master_Log_Pos`）并启动从服务器：'
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**On server C**: Stop the slave and execute `CHANGE MASTER TO COMMAND` to point
    to server A. Use the positions noted down from the preceding step (`server_A-bin.000023` and `16497695`).
    Finally start the slave and verify the slave status:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在服务器C上**：停止从服务器并执行`CHANGE MASTER TO COMMAND`指向服务器A。使用从上一步中记录的位置（`server_A-bin.000023`和`16497695`）。最后启动从服务器并验证从服务器状态：'
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Setting up delayed replication
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置延迟复制
- en: Sometimes, you need a delayed slave for disaster recovery purpose. Suppose a
    disastrous statement (such as a `DROP DATABASE` command) was executed on the master.
    You have to use *point-in-time recovery* from backups to restore the database.
    It will lead to a huge downtime depending on the size of the database. To avoid
    that situation, you can use a delayed slave, which will be always delayed from
    the master by a configured amount of time. If a disaster occurs and that statement
    is not applied by the delayed slave, you can stop the slave and start until the
    disastrous statement, so that the disastrous statement won't be executed. Then
    promote it to master.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您需要一个延迟的从服务器用于灾难恢复目的。假设主服务器上执行了灾难性语句（如`DROP DATABASE`命令）。您必须使用备份的*时间点恢复*来恢复数据库。这将导致巨大的停机时间，具体取决于数据库的大小。为了避免这种情况，您可以使用延迟的从服务器，它将始终比主服务器延迟一定的时间。如果发生灾难并且该语句未被延迟的从服务器应用，您可以停止从服务器并启动直到灾难性语句，以便灾难性语句不会被执行。然后将其提升为主服务器。
- en: The procedure is exactly the same as setting up normal replication, except that
    you specify `MASTER_DELAY` in the `CHANGE MASTER TO` command.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程与设置正常复制完全相同，只是在`CHANGE MASTER TO`命令中指定`MASTER_DELAY`。
- en: '**How is the delay measured?**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**延迟是如何衡量的？**'
- en: In versions earlier than MySQL 8.0, the delay is measured based on the `Seconds_Behind_Master`
    value. In MySQL 8.0, it is measured based on `original_commit_timestamp` and `immediate_commit_timestamp`,
    which are written to the binary log.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在MySQL 8.0之前的版本中，延迟是基于`Seconds_Behind_Master`值来衡量的。在MySQL 8.0中，它是基于`original_commit_timestamp`和`immediate_commit_timestamp`来衡量的，这些值写入了二进制日志。
- en: '`original_commit_timestamp` is the number of microseconds since the epoch when
    the transaction was written (committed) to the binary log of the original master.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`original_commit_timestamp`是事务写入（提交）到原始主服务器的二进制日志时距离时代开始的微秒数。'
- en: '`immediate_commit_timestamp` is the number of microseconds since the epoch
    when the transaction was written (committed) to the binary log of the immediate
    master.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`immediate_commit_timestamp`是事务写入（提交）到直接主服务器的二进制日志时距离时代开始的微秒数。'
- en: How to do it...
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Stop the slave:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止从服务器：
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Execute `CHANGE MASTER TO MASTER_DELAY =` and start the slave. Suppose you
    want a 1-hour delay, you can set `MASTER_DELAY` to `3600` seconds:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`CHANGE MASTER TO MASTER_DELAY =`并启动从服务器。假设您想要1小时的延迟，您可以将`MASTER_DELAY`设置为`3600`秒：
- en: '[PRE47]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Check for the following in the slave status:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在从服务器状态中检查以下内容：
- en: '`SQL_Delay`: Number of seconds by which the slave must lag the master.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`SQL_Delay`: 从服务器必须滞后主服务器的秒数。'
- en: '`SQL_Remaining_Delay`: Number of seconds left of the delay. This is NULL when
    there is delay is maintained.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`SQL_Remaining_Delay`: 延迟剩余的秒数。当存在延迟时，此值为NULL。'
- en: '`Slave_SQL_Running_State`: The state of the SQL thread.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`Slave_SQL_Running_State`: SQL线程的状态。'
- en: '[PRE48]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that `Seconds_Behind_Master` will be shown as `0` once the delay is maintained.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一旦延迟被维持，`Seconds_Behind_Master`将显示为`0`。
- en: Setting up GTID replication
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置GTID复制
- en: A **global transaction identifier** (**GTID**) is a unique identifier created
    and associated with each transaction committed on the server of origin (master).
    This identifier is unique, not only to the server on which it originated, but
    also across all servers in a given replication setup. There is a one-to-one mapping
    between all transactions and all GTIDs.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**全局事务标识符**（**GTID**）是在原始服务器（主服务器）上提交的每个事务创建并关联的唯一标识符。此标识符不仅对于其起源服务器是唯一的，而且对于给定复制设置中的所有服务器也是唯一的。所有事务和所有GTID之间存在一对一的映射关系。'
- en: 'A GTID is represented as a pair of coordinates, separated by a colon character
    (`:`):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: GTID表示为一对坐标，用冒号（`:`）分隔。
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `source_id` option identifies the originating server. Normally, the server's
    `server_uuid` option is used for this purpose. The `transaction_id` option is
    a sequence number determined by the order in which the transaction was committed
    on this server. For example, the first transaction to be committed has `1` as
    its `transaction_id`, and the tenth transaction to be committed on the same originating
    server is assigned a `transaction_id` of `10`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`source_id`选项标识了原始服务器。通常，服务器的`server_uuid`选项用于此目的。`transaction_id`选项是由事务在此服务器上提交的顺序确定的序列号。例如，第一个提交的事务其`transaction_id`为`1`，在同一原始服务器上提交的第十个事务被分配了`transaction_id`为`10`。'
- en: As you have seen in previous methods, you have to mention the binary log file
    and position as the starting point for replication. If you are switching a slave
    from one master to another, especially during a failover, you have to get the
    positions from the new master to sync the slave, which can be painful. To avoid
    these, you can use GTID-based replication, where MySQL automatically detects binary
    log positions using GTIDs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在之前的方法中所看到的，您必须在复制的起点上提到二进制日志文件和位置。如果您要将一个从服务器从一个主服务器切换到另一个主服务器，特别是在故障转移期间，您必须从新主服务器获取位置以同步从服务器，这可能很痛苦。为了避免这些问题，您可以使用基于GTID的复制，MySQL会自动使用GTID检测二进制日志位置。
- en: How to do it...
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'If the replication is already set up between the servers, follow these steps:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器之间已经设置了复制，请按照以下步骤操作：
- en: 'Enable GTIDs in `my.cnf`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`my.cnf`中启用GTID：
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Set the master as read-only and make sure that all the slaves catch up with
    the master. This is very important because there should not be any data inconsistency
    between master and slaves:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主服务器设置为只读，并确保所有从服务器与主服务器保持同步。这非常重要，因为主服务器和从服务器之间不应该存在任何数据不一致。
- en: '[PRE51]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Restart all the slaves to put GTID into effect. Since the `skip_slave_start`
    is given in the configuration file, the slave won''t start until you specify the
    `START SLAVE` command. If you start the slave, it will fail with this error—`The
    replication receiver thread cannot start because the master has GTID_MODE = OFF
    and this server has GTID_MODE = ON`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动所有从服务器以使GTID生效。由于在配置文件中给出了`skip_slave_start`，从服务器在指定`START SLAVE`命令之前不会启动。如果启动从服务器，它将失败，并显示此错误——`The
    replication receiver thread cannot start because the master has GTID_MODE = OFF
    and this server has GTID_MODE = ON`。
- en: '[PRE52]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Restart the master. When you restart the master, it begins in read-write mode
    and starts accepting writes in GTID mode:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动主服务器。重新启动主服务器后，它将以读写模式开始，并在GTID模式下开始接受写操作：
- en: '[PRE53]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Execute the `CHANGE MASTER TO` command to set up GTID replication:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`CHANGE MASTER TO`命令以设置GTID复制：
- en: '[PRE54]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You can observe that the binary log file and positions are not given; instead,
    `MASTER_AUTO_POSITION` is given, which automatically finds the GTIDs executed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以观察到二进制日志文件和位置未给出；相反，给出了`MASTER_AUTO_POSITION`，它会自动找到已执行的GTID。
- en: 'Execute `START SLAVE` on all slaves:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有从服务器上执行`START SLAVE`：
- en: '[PRE55]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Verify that the slave is replicating:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证从服务器是否正在复制：
- en: '[PRE56]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: To know more about GTID, refer to [https://dev.mysql.com/doc/refman/5.6/en/replication-gtids-concepts.html](https://dev.mysql.com/doc/refman/5.6/en/replication-gtids-concepts.html).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关GTID的更多信息，请参阅[https://dev.mysql.com/doc/refman/5.6/en/replication-gtids-concepts.html](https://dev.mysql.com/doc/refman/5.6/en/replication-gtids-concepts.html)。
- en: Setting up semi-synchronous replication
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置半同步复制
- en: Replication is asynchronous by default. The master is not aware of whether the
    writes have reached the slaves or not. If there is a delay between master and
    slave, and if the master crashes, you will lose the data that has not reached
    the slave. To overcome this situation, you can use semi-synchronous replication.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，复制是异步的。主服务器不知道写操作是否已到达从服务器。如果主服务器和从服务器之间存在延迟，并且主服务器崩溃，那么尚未到达从服务器的数据将会丢失。为了克服这种情况，您可以使用半同步复制。
- en: In semi-synchronous replication, the master waits until at least one slave has
    received the writes. By default, the value of `rpl_semi_sync_master_wait_point`
    is `AFTER_SYNC`; this means that the master syncs the transaction to the binary
    log, which is consumed by the slave.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在半同步复制中，主服务器会等待至少一个从服务器接收写操作。默认情况下，`rpl_semi_sync_master_wait_point`的值为`AFTER_SYNC`；这意味着主服务器将事务同步到从服务器消耗的二进制日志中。
- en: After that, the slave sends an acknowledgement to the master, then the master
    commits the transaction and returns the result to the client. So, it is enough
    if the writes have reached the relay log; the slave need not commit the transaction.
    You can change this behavior by changing the variable `rpl_semi_sync_master_wait_point`
    to `AFTER_COMMIT`. In this, the master commits the transaction to the storage
    engine but does not return the result to the client. Once the transaction is committed
    on the slave, the master receives an acknowledgment of transaction and then returns
    a result to the client.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，从服务器向主服务器发送确认，然后主服务器提交事务并将结果返回给客户端。因此，如果写入已到达中继日志，则从服务器无需提交事务。您可以通过将变量`rpl_semi_sync_master_wait_point`更改为`AFTER_COMMIT`来更改此行为。在这种情况下，主服务器将事务提交给存储引擎，但不将结果返回给客户端。一旦从服务器上提交了事务，主服务器将收到事务的确认，然后将结果返回给客户端。
- en: If you want the transaction to be acknowledged on more slaves, you can increase
    the value of the dynamic variable `rpl_semi_sync_master_wait_for_slave_count`.
    You can also set how many milliseconds the master has to wait for to get the acknowledgement
    from the slave through the dynamic variable `rpl_semi_sync_master_timeout`; the
    default is `10` seconds.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要在更多从服务器上确认事务，可以增加动态变量`rpl_semi_sync_master_wait_for_slave_count`的值。您还可以通过动态变量`rpl_semi_sync_master_timeout`设置主服务器必须等待从服务器确认的毫秒数；默认值为`10`秒。
- en: In fully synchronous replication, the master waits until all the slaves have
    committed the transaction. To implement this, you have to use Galera Cluster.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在完全同步复制中，主服务器会等待直到所有从服务器都提交了事务。要实现这一点，您必须使用Galera Cluster。
- en: How to do it...
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'On a high level, you need to install and enable semi-synchronous plugins on
    both the master and all slaves where you want semi-synchronous replication. You
    have to restart the slave IO thread to bring the changes into effect. You can
    adjust the value of `rpl_semi_sync_master_timeout` according to your network and
    application. A value of `1` second is a good start:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，您需要在主服务器和所有希望进行半同步复制的从服务器上安装和启用半同步插件。您必须重新启动从服务器IO线程以使更改生效。您可以根据您的网络和应用程序调整`rpl_semi_sync_master_timeout`的值。`1`秒的值是一个很好的起点：
- en: 'On the master, install the `rpl_semi_sync_master` plugin:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主服务器上，安装`rpl_semi_sync_master`插件：
- en: '[PRE57]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Verify that the plugin is activated:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 验证插件是否已激活：
- en: '[PRE58]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'On the master, enable semi-synchronous replication and adjust the timeout (say
    1 second):'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主服务器上，启用半同步复制并调整超时时间（比如1秒）：
- en: '[PRE59]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'On the slave, install the `rpl_semi_sync_slave` plugin:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在从服务器上，安装`rpl_semi_sync_slave`插件：
- en: '[PRE60]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'On the slave, enable semi-synchronous replication and restart the slave IO
    thread:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在从服务器上，启用半同步复制并重新启动从服务器IO线程：
- en: '[PRE61]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You can monitor the status of the semi-synchronous replication through the
    following:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过以下方式监视半同步复制的状态：
- en: 'To find the number of clients connected as semi-sync—on master, execute:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找连接为半同步的客户端数量，请在主服务器上执行：
- en: '[PRE62]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The master switches between asynchronous and semi-synchronous replication when
    the timeout occurs and the slaves catch up. To check what type of replication
    the master is using, check the status of `Rpl_semi_sync_master_status` (on means
    semi-sync and off means async):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当超时发生并且从服务器赶上时，主服务器在异步和半同步复制之间切换。要检查主服务器正在使用的复制类型，请检查`Rpl_semi_sync_master_status`的状态（打开表示半同步，关闭表示异步）：
- en: '[PRE63]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You can verify the semi-synchronous replication using this method:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此方法验证半同步复制：
- en: 'Stop the slave:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止从服务器：
- en: '[PRE64]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'On the master, execute any statement:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主服务器上，执行任何语句：
- en: '[PRE65]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You will notice that the master has switched to asynchronous replication since
    it did not get any acknowledgement from the slave even after 1 second (the value
    of `rpl_semi_sync_master_timeout`):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到主服务器已经切换到异步复制，因为即使在1秒后（`rpl_semi_sync_master_timeout`的值），它仍未收到从从服务器的任何确认：
- en: '[PRE66]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Start the slave:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动从服务器：
- en: '[PRE68]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'On the master, you will notice that the master switched back to semi-synchronous
    replication:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主服务器上，您会注意到主服务器已经切换回半同步复制。
- en: '[PRE69]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
