- en: Table Maintenance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表维护
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Installing Percona Toolkit
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Percona Toolkit
- en: Altering tables
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改表
- en: Moving tables across databases
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据库之间移动表
- en: Altering tables using an online schema change tool
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用在线模式更改工具修改表
- en: Archiving tables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归档表
- en: Cloning tables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克隆表
- en: Partitioning tables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区表
- en: Partition pruning and selection
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区修剪和选择
- en: Partition management
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区管理
- en: Partition information
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区信息
- en: Efficiently managing time to live and soft delete rows
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效管理生存时间和软删除行
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: One of the key aspects in maintaining a database is managing tables. Often,
    you need to alter a big table or clone a table. In this chapter, you will learn
    about managing big tables. Some open source third-party tools are used as MySQL
    does not support certain operations. The installation and usage of third-party
    tools are also covered in this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '在维护数据库中，一个关键方面是管理表。通常，您需要更改一个大表或克隆一个表。在本章中，您将学习如何管理大表。由于MySQL不支持某些操作，因此使用了一些开源第三方工具。本章还涵盖了第三方工具的安装和使用。 '
- en: Installing Percona Toolkit
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Percona Toolkit
- en: Percona Toolkit is a collection of advanced open source command-line tools,
    developed and used by Percona to perform a variety of tasks that are too difficult
    or complex to perform manually. The installation is covered in this section. In
    the later sections, you will learn how to use it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Percona Toolkit是一套高级开源命令行工具，由Percona开发和使用，用于执行各种手动执行的任务。安装在本节中介绍。在后面的部分，您将学习如何使用它。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let us see how to install Percona Toolkit on various operating systems.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在各种操作系统上安装Percona Toolkit。
- en: On Debian/Ubuntu
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Debian/Ubuntu上
- en: 'Download the repository package:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载存储库软件包：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Install the repository package:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装存储库软件包：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Update local package list:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新本地软件包列表：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Make sure that Percona packages are available:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Percona软件包可用：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should see output similar to the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的输出：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Install the `percona-toolkit` package:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`percona-toolkit`软件包：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you do not want to install a repository, you can also install directly:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想安装存储库，也可以直接安装：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: On CentOS/Red Hat/Fedora
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在CentOS/Red Hat/Fedora上
- en: 'Install the repository package:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装存储库软件包：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You should see the following if successful:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，您应该看到以下内容：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Make sure that Percona packages are available:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Percona软件包可用：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should see output similar to the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的输出：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Install Percona Toolkit:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Percona Toolkit：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you do not want to install a repository, you can directly install using
    YUM:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想安装存储库，可以直接使用YUM安装：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Altering tables
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改表
- en: '`ALTER TABLE` changes the structure of a table. For example, you can add or
    delete columns, create or destroy indexes, change the type of existing columns,
    or rename columns or the table itself.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`ALTER TABLE`更改表的结构。例如，您可以添加或删除列，创建或销毁索引，更改现有列的类型，或重命名列或表本身。'
- en: While performing certain alter operations such as changing a column data type,
    adding a `SPATIAL INDEX`, dropping a primary key, converting a character set,
    adding/removing encryption, and so on, DML operations on the table are blocked.
    If the table is big, it will take even more time to alter, and the application
    cannot access the table during that time, which is not desired. In those situations,
    a `pt-online-schema` change is helpful, where DML statements are allowed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行某些alter操作（例如更改列数据类型，添加`SPATIAL INDEX`，删除主键，转换字符集，添加/删除加密等）时，表上的DML操作将被阻止。如果表很大，则更改需要更长的时间，并且应用程序在此期间无法访问表，这是不希望发生的。在这种情况下，`pt-online-schema`更改是有帮助的，其中允许DML语句。
- en: 'There are two algorithms for alter operations:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种alter操作算法：
- en: '**In-place** (default): Does not require copying whole table data'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原地**（默认）：不需要复制整个表数据'
- en: '**Copy**: Copies the data into a temporary disk file and renames it'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制**：将数据复制到临时磁盘文件并重命名'
- en: Only certain alter operations can be done in-place. The performance of an online
    DDL operation is largely determined by whether the operation is performed in-place,
    or requires copying and rebuilding the entire table. Refer to [https://dev.mysql.com/doc/refman/8.0/en/innodb-create-index-overview.html#innodb-online-ddl-summary-grid](https://dev.mysql.com/doc/refman/8.0/en/innodb-create-index-overview.html#innodb-online-ddl-summary-grid)
    to see what kinds of operations can be performed in-place, and any requirements
    for avoiding table-copy operations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 只有某些alter操作可以就地完成。在线DDL操作的性能在很大程度上取决于操作是在原地执行还是需要复制和重建整个表。请参阅[https://dev.mysql.com/doc/refman/8.0/en/innodb-create-index-overview.html#innodb-online-ddl-summary-grid](https://dev.mysql.com/doc/refman/8.0/en/innodb-create-index-overview.html#innodb-online-ddl-summary-grid)查看可以就地执行的操作类型，以及避免表复制操作的任何要求。
- en: '*How copy algorithm works* (taken from the reference manual—[https://dev.mysql.com/doc/refman/8.0/en/alter-table.html](https://dev.mysql.com/doc/refman/8.0/en/alter-table.html))'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*复制算法的工作原理*（摘自参考手册-[https://dev.mysql.com/doc/refman/8.0/en/alter-table.html](https://dev.mysql.com/doc/refman/8.0/en/alter-table.html)）'
- en: '`ALTER TABLE` operations that are not performed *in-place* make a temporary
    copy of the original table. MySQL waits for other operations that are modifying
    the table, then proceeds. It incorporates the alteration into the copy, deletes
    the original table, and renames the new one. While `ALTER TABLE` is executing,
    the original table is readable by other sessions. Updates and writes to the table
    that begin after the `ALTER TABLE` operation begins are stalled until the new
    table is ready, then are automatically redirected to the new table without any
    failed updates. The temporary copy of the original table is created in the database
    directory of the new table. This can differ from the database directory of the
    original table for `ALTER TABLE` operations that rename the table to a different
    database.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 不是*就地*执行的`ALTER TABLE`操作会创建原始表的临时副本。MySQL等待正在修改表的其他操作，然后继续。它将更改合并到副本中，删除原始表，并重命名新表。在执行`ALTER
    TABLE`时，原始表可被其他会话读取。在`ALTER TABLE`操作开始后开始的对表的更新和写入将被暂停，直到新表准备就绪，然后会自动重定向到新表，而不会有任何更新失败。原始表的临时副本创建在新表的数据库目录中。这可能与重命名表到不同数据库的`ALTER
    TABLE`操作的原始表的数据库目录不同。
- en: 'To get an idea on whether a DDL operation performs in-place or a table copy,
    look at the `rows affected` value displayed after the command finishes:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解DDL操作是就地执行还是表复制，请查看命令完成后显示的`受影响行数`值：
- en: 'Changing the default value of a column (superfast, does not affect the table
    data at all), the output would be some thing like this:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改列的默认值（超快，根本不影响表数据），输出将类似于这样：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Adding an index (takes time, but `0 rows affected` shows that the table is
    not copied), the output would be some thing like this:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加索引（需要时间，但`0行受影响`表明表没有被复制），输出将类似于这样：
- en: '`Query OK, 0 rows affected (21.42 sec)`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`查询OK，0行受影响（21.42秒）`'
- en: 'Changing the data type of a column (takes substantial time and does require
    rebuilding all the rows of the table), , the output would be some thing like this:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改列的数据类型（需要大量时间，并且确实需要重建表的所有行），输出将类似于这样：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Changing the data type of a column requires rebuilding all the rows of the table
    with the exception of changing the `VARCHAR` size, which may be performed using
    online `ALTER TABLE`. See the example mentioned in the *Altering tables using
    an online schema change tool* section, which shows how to modify column properties
    using `pt-online-schema`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 更改列的数据类型需要重建表的所有行，除了更改`VARCHAR`大小之外，可以使用在线`ALTER TABLE`来执行。请参阅*使用在线模式更改工具修改表*部分中提到的示例，该示例显示了如何使用`pt-online-schema`修改列属性。
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'If you want to add a new column to the `employees` table, you can execute the
    `ADD COLUMN` statement:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要向`employees`表添加新列，可以执行`ADD COLUMN`语句：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can see that the number of rows affected is `0`, which means that the table
    is not copied and the operation is done in-place.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到受影响的行数为`0`，这意味着表没有被复制，操作是就地完成的。
- en: 'If you want to increase the length of the `varchar` column, you can execute
    the `MODIFY COLUMN` statement:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想增加`varchar`列的长度，可以执行`MODIFY COLUMN`语句：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you think that `varchar(255)` is not sufficient to store addresses, and
    you would like to change it to `tinytext`, you can use the `MODIFY COLUMN` statement.
    However, in this case, since you are modifying the data type of a column, all
    the rows of the existing table should be modified, which requires table copy,
    and DMLs are blocked:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为`varchar(255)`不足以存储地址，并且想要将其更改为`tinytext`，您可以使用`MODIFY COLUMN`语句。但是，在这种情况下，由于您正在修改列的数据类型，所有现有表的行都应该被修改，这需要表复制，并且会阻塞DMLs：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You will notice that the rows affected are `300025`, which is the size of the
    table.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到受影响的行数为`300025`，这是表的大小。
- en: There are various other operations that you can do, such as renaming a column,
    changing the default value, reordering the column positions, and so on; refer
    to the manual at [https://dev.mysql.com/doc/refman/8.0/en/innodb-create-index-overview.html](https://dev.mysql.com/doc/refman/8.0/en/innodb-create-index-overview.html) for
    more details.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他各种操作，例如重命名列，更改默认值，重新排序列位置等；有关更多详细信息，请参阅[https://dev.mysql.com/doc/refman/8.0/en/innodb-create-index-overview.html](https://dev.mysql.com/doc/refman/8.0/en/innodb-create-index-overview.html)的手册。
- en: 'Adding a virtual generated column is just a metadata change and is almost instantaneous:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个虚拟生成的列只是一个元数据更改，几乎是瞬时的：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'However, adding a `STORED GENERATED` column and modifying the `VIRTUAL GENERATED`
    column is not online:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，添加`STORED GENERATED`列和修改`VIRTUAL GENERATED`列不是在线的：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Moving tables across databases
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动表格跨数据库
- en: You can rename a table by executing the `RENAME TABLE` statement.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过执行`RENAME TABLE`语句来重命名表。
- en: For the following illustrations to work, create sample tables and databases
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使以下示例起作用，请创建示例表和数据库
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For example, if you want to rename the `audit_log` table `audit_log_archive_2018`,
    you can execute the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果要将`audit_log`表重命名为`audit_log_archive_2018`，可以执行以下操作：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you want to move the table from one database to an other, you can use dot
    notation to specify the database name. For example, if you want to move the `audit_log`
    table from the database named `prod` to the database named `archive`, execute
    the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将表从一个数据库移动到另一个数据库，可以使用点表示法指定数据库名称。例如，如果要将名为`audit_log`的表从名为`prod`的数据库移动到名为`archive`的数据库，执行以下操作：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Altering tables using an online schema change tool
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用在线模式更改工具修改表
- en: In this section, you will learn about Percona's `pt-online-schema-change` (`pt-osc`)
    tool, which is used to perform `ALTER TABLE` operations without blocking DMLs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解Percona的`pt-online-schema-change`（`pt-osc`）工具，该工具用于执行`ALTER TABLE`操作而不会阻塞DMLs。
- en: '`pt-osc` comes along with Percona Toolkit. Installation of Percona Toolkit
    has already been described earlier in the chapter.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`pt-osc`与Percona Toolkit一起提供。Percona Toolkit的安装已在本章前面进行了描述。'
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: (Taken from [https://www.percona.com/doc/percona-toolkit/LATEST/pt-online-schema-change.html](https://www.percona.com/doc/percona-toolkit/LATEST/pt-online-schema-change.html).)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: （摘自[https://www.percona.com/doc/percona-toolkit/LATEST/pt-online-schema-change.html](https://www.percona.com/doc/percona-toolkit/LATEST/pt-online-schema-change.html)。）
- en: '`pt-online-schema-change` works by creating an empty copy of the table to alter,
    modifying it as desired, and then copying rows from the original table into the
    new table. When the copy is complete, it moves away the original table and replaces
    it with the new one. By default, it also drops the original table.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`pt-online-schema-change`的工作原理是创建要更改的表的空副本，根据需要对其进行修改，然后将原始表中的行复制到新表中。复制完成后，它会将原始表移开，并用新表替换。默认情况下，它还会删除原始表。'
- en: The data copy process is performed in small chunks of data, which are varied
    to attempt to make them execute in a specific amount of time. Any modifications
    to data in the original tables during the copy will be reflected in the new table,
    because the tool creates triggers on the original table to update the corresponding
    rows in the new table. The use of triggers means that the tool will not work if
    any triggers are already defined on the table.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 数据复制过程是以小数据块的形式执行的，这些数据块的大小是不同的，以尝试使它们在特定的时间内执行。在复制过程中对原始表中的数据进行的任何修改都将反映在新表中，因为该工具会在原始表上创建触发器，以更新新表中的相应行。使用触发器意味着如果表上已经定义了任何触发器，该工具将无法工作。
- en: When the tool finishes copying data into the new table, it uses an atomic `RENAME
    TABLE` operation to simultaneously rename the original and new tables. After this
    is complete, the tool drops the original table.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当工具完成将数据复制到新表中后，它会使用原子`RENAME TABLE`操作同时重命名原始表和新表。完成此操作后，工具会删除原始表。
- en: Foreign keys complicate the tool's operation and introduce additional risk.
    The technique of atomically renaming the original and new tables does not work
    when foreign keys refer to the table. The tool must update foreign keys to refer
    to the new table after the schema change is complete. The tool supports two methods
    for accomplishing this. You can read more about this in the documentation for
    `--alter-foreign-keys-method`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 外键会使工具的操作复杂化并引入额外的风险。在外键引用表时，原子重命名原始表和新表的技术无法正常工作。工具必须在模式更改完成后更新外键以引用新表。该工具支持两种方法来实现这一点。您可以在`--alter-foreign-keys-method`的文档中了解更多信息。
- en: How to do it...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Modifying the column data type can be done as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 修改列数据类型的方法如下：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You will have noticed that the tool has created a new table with a modified
    structure, created triggers on the table, copied the rows to a new table, and
    finally, renamed the new table.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到该工具已经创建了一个具有修改结构的新表，为该表创建了触发器，将行复制到新表中，最后重命名了新表。
- en: 'If you want to alter the `salaries` table, which already has triggers, you
    need to specify the `--preserver-triggers` option, otherwise you will end up with
    the error: `The table `employees`.`salaries` has triggers but --preserve-triggers
    was not specified.`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要更改已经具有触发器的`salaries`表，您需要指定`--preserver-triggers`选项，否则将出现错误：`The table `employees`.`salaries`
    has triggers but --preserve-triggers was not specified.`：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If the server has slaves, this tool can create a slave lag while copying from
    an existing table to a new table. To avoid this, you can specify `--check-slave-lag`
    (enabled by default); it pauses the data copy until this replica's lag is less
    than `--max-lag`, which is 1 second by default. You can specify `--max-lag` by
    passing the `--max-lag` option.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器有从属服务器，该工具在从现有表复制到新表时可能会创建从属延迟。为了避免这种情况，您可以指定`--check-slave-lag`（默认启用）；它会暂停数据复制，直到此副本的延迟小于`--max-lag`，默认为1秒。您可以通过传递`--max-lag`选项来指定`--max-lag`。
- en: 'If you want to make sure that the slaves will not be lagged by more than 10
    seconds, pass `--max-lag=10`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要确保从属服务器的延迟不会超过10秒，请传递`--max-lag=10`：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For more details and options, refer to the Percona documentation, at[ ](https://www.percona.com/doc/percona-toolkit/LATEST/pt-online-schema-change.html)[https://www.percona.com/doc/percona-toolkit/LATEST/pt-online-schema-change.html](https://www.percona.com/doc/percona-toolkit/LATEST/pt-online-schema-change.html)[.](https://www.percona.com/doc/percona-toolkit/LATEST/pt-online-schema-change.html)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息和选项，请参阅Percona文档，网址为[https://www.percona.com/doc/percona-toolkit/LATEST/pt-online-schema-change.html](https://www.percona.com/doc/percona-toolkit/LATEST/pt-online-schema-change.html)。
- en: '`pt-online-schema-change` works only when there is a primary key or unique
    key, otherwise it will fail with the following error:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`pt-online-schema-change`仅在有主键或唯一键时才有效，否则将出现以下错误：'
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: So, if the table does not have any unique key, you cannot use `pt-online-schema-change`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果表没有任何唯一键，您无法使用`pt-online-schema-change`。
- en: Archiving tables
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 归档表
- en: 'Sometimes, you do not want to keep older data and wish to delete it. If you
    want to delete all the rows which were last accessed over a month ago, if the
    table is small (<10k rows), you can straight away use the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您不希望保留旧数据并希望删除它。如果要删除所有上个月访问的行，如果表很小（<10k行），您可以直接使用以下命令：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: What happens if the table is big? You know `InnoDB` creates an `UNDO` log to
    restore failed transactions. So all the deleted rows are saved in the `UNDO` log
    space to be used to restore in case the `DELETE` statement aborts in between.
    Unfortunately, if the `DELETE` statement is aborted in between, `InnoDB` copies
    the rows from the `UNDO` log space to table, which can make the table inaccessible.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表很大会发生什么？您知道`InnoDB`会创建一个`UNDO`日志来恢复失败的事务。因此，所有删除的行都保存在`UNDO`日志空间中，以便在`DELETE`语句中止时用于恢复。不幸的是，如果`DELETE`语句在中途中止，`InnoDB`会从`UNDO`日志空间复制行到表中，这可能会导致表无法访问。
- en: To overcome this behavior, you can `LIMIT` the number of rows deleted and `COMMIT`
    the transaction, running the same thing in a loop until all the unwanted rows
    are deleted.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这种行为，您可以`LIMIT`删除的行数并`COMMIT`事务，重复运行相同的操作，直到删除所有不需要的行。
- en: 'This is an example pseudo code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个伪代码示例：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If there is no `INDEX` on `last_accessed`, it can lock the table. In that case,
    you need to find out the primary key for the deleted rows and delete based on
    `PRIMARY KEY`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`last_accessed`上没有`INDEX`，它可以锁定表。在这种情况下，您需要找出已删除行的主键，并基于`PRIMARY KEY`进行删除。
- en: 'This is the pseudo code, assuming `id` is the `PRIMARY KEY`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是伪代码，假设`id`是`PRIMARY KEY`：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Instead of writing the code for deleting the rows, you can use Percona's `pt-archiver`
    tool, which essentially does the same and provides many other options, such as
    saving the rows into another table or file, fine control over the load and replication
    delay, and so on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Percona的`pt-archiver`工具而不是编写删除行的代码，它本质上做的是相同的，并提供许多其他选项，例如将行保存到另一个表或文件中、对负载和复制延迟进行精细控制等。
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: There are many options in `pt-archiver`, we will start with simple purging.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`pt-archiver`中有许多选项，我们将从简单的清除开始。'
- en: Purging data
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清除数据
- en: 'If you want to delete all the rows from the `employees` table for which `hire_date`
    is older than 30 years, you can execute the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要删除`employees`表中`hire_date`早于30年的所有行，您可以执行以下操作：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can pass the hostname, database name, and table name through the `--source`
    option. You can limit the number of rows to delete in a batch using the `--limit`
    option.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过`--source`选项传递主机名、数据库名称和表名。您可以使用`--limit`选项批量限制要删除的行数。
- en: If you specify `--progress`, the output is a header row, plus status output
    at intervals. Each row in the status output lists the current date and time, how
    many seconds `pt-archiver` has been running, and how many rows it has archived.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您指定`--progress`，输出是一个标题行，加上间隔的状态输出。状态输出中的每一行都列出了当前日期和时间、`pt-archiver`运行了多少秒以及它归档了多少行。
- en: If you specify `--statistics`, `pt-archiver` outputs timing and other information
    to help you identify which part of your archiving process takes the most time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您指定`--statistics`，`pt-archiver`将输出时间和其他信息，以帮助您确定归档过程中哪一部分花费了最多时间。
- en: If you specify `--check-slave-lag`, the tool will pause archiving until the
    slave lag is less than `--max-lag`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您指定`--check-slave-lag`，工具将暂停归档，直到从属滞后小于`--max-lag`。
- en: Archiving data
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 归档数据
- en: If you want to save the rows after deletion into a separate table or file, you
    can specify the `--dest` option.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要在删除后将行保存到单独的表或文件中，可以指定`--dest`选项。
- en: 'Suppose you want to move all the rows of the `employees` table from the `employees`
    database to the `employees_archive` table, you can execute the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要将`employees`数据库的`employees`表的所有行移动到`employees_archive`表中，您可以执行以下操作：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you specify `--where="1=1"`, it copies all rows.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您指定`--where="1=1"`，它将复制所有行。
- en: Copying data
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制数据
- en: 'If you want to copy data from one table to another, you can either use `mysqldump`
    or `mysqlpump` to back up certain rows and then load them into the destination
    table. As an alternative, you can also use `pt-archive`. If you specify the `--no-delete`
    option, `pt-archiver` will not delete the rows from the source:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要从一张表复制数据到另一张表，您可以使用`mysqldump`或`mysqlpump`备份特定行，然后将它们加载到目标表中。作为替代，您也可以使用`pt-archive`。如果您指定`--no-delete`选项，`pt-archiver`将不会从源中删除行。
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: See also
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Refer to [https://www.percona.com/doc/percona-toolkit/LATEST/pt-archiver.html](https://www.percona.com/doc/percona-toolkit/LATEST/pt-archiver.html)
    for more details about and options for `pt-archiver`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`pt-archiver`的更多详细信息和选项，请参阅[https://www.percona.com/doc/percona-toolkit/LATEST/pt-archiver.html](https://www.percona.com/doc/percona-toolkit/LATEST/pt-archiver.html)。
- en: Cloning tables
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克隆表
- en: If you want to clone a table, there are many options.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要克隆一个表，有很多选项。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Use the `INSERT INTO SELECT` statement:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`INSERT INTO SELECT`语句：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that if there are any generated columns, the above statement would not
    work. In that case, you should give full insert statement excluding the generated
    columns.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果有任何生成的列，上述语句将不起作用。在这种情况下，您应该提供完整的插入语句，不包括生成的列。
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: But the preceding statement is very slow and dangerous on big tables. Remember,
    if the statement fails, to restore the table state, `InnoDB` saves all the rows
    in `UNDO` logs.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在大表上，上述语句非常慢且危险。请记住，如果语句失败，为了恢复表状态，`InnoDB`会将所有行保存在`UNDO`日志中。
- en: Use `mysqldump` or `mysqlpump` and take a backup of a single table and restore
    it on destination. This can take very long time if the table is big.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`mysqldump`或`mysqlpump`备份单个表并在目标上恢复。如果表很大，这可能需要很长时间。
- en: Use `Innobackupex` to take a backup of specific table and restore the data file
    onto destination.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Innobackupex`备份特定表并将数据文件恢复到目标上。
- en: Use `pt-archiver` with the `--no-delete` option, which will copy the desired
    rows or all rows to the destination table.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pt-archiver`和`--no-delete`选项，它将把所需的行或所有行复制到目标表中。
- en: You can also clone tables by using transportable tablespaces, which are explained
    in the *Copying file-per-table tablespaces to another instance* section of [Chapter
    11](part0388.html#BI0Q80-faa69fe6f4c04957afca3568dcd9cd83), *Managing Tablespace.*
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用可传输表空间来克隆表，这在《第11章》的*管理表空间*部分的*将文件表空间复制到另一个实例*部分中有解释。
- en: Partitioning tables
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区表
- en: You can distribute portions of individual tables across a filesystem using partitions.
    The user-selected rule by which the division of data is accomplished is known
    as a partitioning function, which can be modulus, simple matching against a set
    of ranges or value lists, an internal hashing function, or a linear hashing function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用分区将单个表的部分分布到文件系统中。用户选择的数据划分规则称为分区函数，可以是模数、简单匹配一组范围或值列表、内部哈希函数或线性哈希函数。
- en: Different rows of a table may be assigned to different physical partitions,
    which is called horizontal partitioning. MySQL does not have support for vertical
    partitioning, in which different columns of a table are assigned to different
    physical partitions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 表的不同行可以分配到不同的物理分区，这称为水平分区。MySQL不支持垂直分区，即将表的不同列分配到不同的物理分区。
- en: 'There are many ways to partition a table:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多分区表的方法：
- en: '`RANGE`: This type of partitioning assigns rows to partitions based on column
    values falling within a given range.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RANGE`：这种类型的分区根据列值是否在给定范围内将行分配到分区中。'
- en: '`LIST`: Similar to partitioning by `RANGE`, except that the partition is selected
    based on columns matching one of a set of discrete values.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LIST`：类似于基于`RANGE`的分区，只是根据与一组离散值匹配的列选择分区。'
- en: '`HASH`: With this type of partitioning, a partition is selected based on the
    value returned by a user-defined expression that operates on column values in
    rows to be inserted into the table. The function may consist of any expression
    valid in MySQL that yields a non-negative integer value.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HASH`：使用这种类型的分区，根据用户定义的表达式返回的值选择分区，该表达式在要插入表中的行的列值上操作。该函数可以由MySQL中的任何有效表达式组成，产生非负整数值。'
- en: '`KEY`: This type of partitioning is similar to partitioning by `HASH`, except
    that only one or more columns to be evaluated are supplied, and the MySQL server
    provides its own hashing function. These columns can contain other than integer
    values, since the hashing function supplied by MySQL guarantees an integer result
    regardless of the column data type.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KEY`：这种类型的分区与`HASH`分区类似，只是提供了要评估的一个或多个列，并且MySQL服务器提供了自己的哈希函数。这些列可以包含除整数值以外的其他值，因为MySQL提供的哈希函数保证了整数结果，无论列数据类型如何。'
- en: Each of the preceding partition types have an extension. `RANGE` has `RANGE
    COLUMNS`, `LIST` has `LIST COLUMNS`, `HASH` has `LINEAR HASH`, and `KEY` has `LINEAR
    KEY`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的每种分区类型都有一个扩展。`RANGE`有`RANGE COLUMNS`，`LIST`有`LIST COLUMNS`，`HASH`有`LINEAR
    HASH`，`KEY`有`LINEAR KEY`。
- en: For `[LINEAR] KEY`, `RANGE COLUMNS`, and `LIST COLUMNS` partitioning, the partitioning
    expression consists of a list of one or more columns.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`[LINEAR] KEY`，`RANGE COLUMNS`和`LIST COLUMNS`分区，分区表达式由一个或多个列的列表组成。
- en: In the case of `RANGE`, `LIST`, and `[LINEAR] HASH` partitioning, the value
    of the partitioning column is passed to the partitioning function, which returns
    an integer value representing the number of the partition in which that particular
    record should be stored. This function must be non-constant and non-random.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RANGE`，`LIST`和`[LINEAR] HASH`分区的情况下，分区列的值将传递给分区函数，该函数返回一个整数值，表示应将该特定记录存储在其中的分区的编号。此函数必须是非常数和非随机的。
- en: A very common use of database partitioning is to segregate data by date.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库分区的一个非常常见的用途是按日期对数据进行分隔。
- en: Refer to [https://dev.mysql.com/doc/refman/8.0/en/partitioning-overview.html](https://dev.mysql.com/doc/refman/8.0/en/partitioning-overview.html)
    for advantages and other details on partitioning.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有关分区的优势和其他详细信息，请参阅[https://dev.mysql.com/doc/refman/8.0/en/partitioning-overview.html](https://dev.mysql.com/doc/refman/8.0/en/partitioning-overview.html)。
- en: Note that partitions work only for `InnoDB` tables, and foreign keys are not
    yet supported in conjunction with partitioning.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，分区仅适用于`InnoDB`表，并且外键尚不支持与分区一起使用。
- en: How to do it...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: You can specify the partitioning while creating the table or by executing the
    `ALTER TABLE` command. The partition column should be part of all the unique keys
    in the table.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在创建表时指定分区，也可以通过执行`ALTER TABLE`命令来指定。分区列应该是表中所有唯一键的一部分。
- en: If you defined partitions based on the `created_at` column and `id` is the primary
    key, you should include the `create_at` column as part of `PRIMARY KEY`, that
    is, (`id`, `created_at`).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您根据`created_at`列定义了分区，并且`id`是主键，那么您应该将`create_at`列包括在`PRIMARY KEY`中，即(`id`，`created_at`)。
- en: The following example assumes that there are no foreign keys referenced to the
    table.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例假设没有外键引用到表。
- en: 'If you wish to implement a partitioning scheme based on ranges or intervals
    of time in MySQL 8.0, you have two options:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在MySQL 8.0中基于时间范围或间隔实现分区方案，有两种选择：
- en: Partition the table by `RANGE`, and for the partitioning expression, employ
    a function operating on a `DATE`, `TIME`, or `DATETIME` column and returning an
    integer value
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`RANGE`对表进行分区，并且对分区表达式使用在`DATE`，`TIME`或`DATETIME`列上操作并返回整数值的函数。
- en: Partition the table by `RANGE COLUMNS`, using a `DATE` or `DATETIME` column
    as the partitioning column
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`RANGE COLUMNS`对表进行分区，使用`DATE`或`DATETIME`列作为分区列
- en: RANGE partitioning
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围分区
- en: 'If you want to partition the `employees` table based on `emp_no` and you want
    to keep 100,000 employees in one partition, you can create it like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想根据`emp_no`对`employees`表进行分区，并且想要在一个分区中保留100,000名员工，可以这样创建：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So, all the employees having `emp_no` less than 100,000 will go to partition
    `p0` and all the employees having the `emp_no` less than `200000` and greater
    than `100000` will go to partition `p1`, and so on.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所有`emp_no`小于100,000的员工将进入分区`p0`，所有`emp_no`小于`200000`且大于`100000`的员工将进入分区`p1`，依此类推。
- en: 'If the employee number is above `500000`, since there is no partition defined
    for them, the insert will fail with error. To avoid this, you have to regularly
    check and add partitions or  create a `MAXVALUE` partition to catch all such exceptions:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果员工号大于`500000`，由于没有为它们定义分区，插入将失败并显示错误。为了避免这种情况，您必须定期检查并添加分区，或者创建一个`MAXVALUE`分区来捕获所有这些异常：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you want to partition based on `hire_date`, you can use the `YEAR(hire_date)`
    function as the partition expression:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想基于`hire_date`进行分区，可以使用`YEAR(hire_date)`函数作为分区表达式：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Partitioning in MySQL is widely used on `date`, `datetime`, or `timestamp` columns.
    If you want to store some events on the database, and all the queries are based
    out of a time range, you can use partitioning like this.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL中的分区广泛用于`date`、`datetime`或`timestamp`列。如果您想要在数据库中存储一些事件，并且所有查询都基于时间范围，您可以使用这样的分区。
- en: 'The partitioning function `to_days()` returns the number of days since `0000-01-01`,
    which is a integer:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 分区函数`to_days()`返回自`0000-01-01`以来的天数，这是一个整数：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you want to convert an existing table into a partitioned table, and if the
    partition key is not part of `PRIMARY KEY`, you need to drop `PRIMARY KEY` and
    add the partition key as part of `PRIMARY KEY` and all unique keys. Otherwise,
    you will get the error `ERROR 1503 (HY000): A PRIMARY KEY must include all columns
    in the table''s partitioning function.`. You can do that as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '如果要将现有表转换为分区表，并且分区键不是`PRIMARY KEY`的一部分，则需要删除`PRIMARY KEY`并将分区键作为`PRIMARY KEY`和所有唯一键的一部分添加。否则，您将收到错误`ERROR
    1503 (HY000): A PRIMARY KEY must include all columns in the table''s partitioning
    function.`。您可以按以下方式执行：'
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: For more details on `RANGE` partitioning, refer to [https://dev.mysql.com/doc/refman/8.0/en/partitioning-range.html](https://dev.mysql.com/doc/refman/8.0/en/partitioning-range.html).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`RANGE`分区的更多详细信息，请参阅[https://dev.mysql.com/doc/refman/8.0/en/partitioning-range.html](https://dev.mysql.com/doc/refman/8.0/en/partitioning-range.html)。
- en: Removing partitioning
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除分区
- en: 'If you wish to remove partitioning, you can execute the `REMOVE PARTITIONING`
    statement:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望移除分区，可以执行`REMOVE PARTITIONING`语句：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: RANGE COLUMNS partitioning
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`RANGE COLUMNS`分区'
- en: '`RANGE COLUMNS` partitioning is similar to `RANGE` partitioning, but enables
    you to define partitions using ranges based on multiple column values. In addition,
    you can define the ranges using columns of types other than integer types. `RANGE
    COLUMNS` partitioning differs significantly from `RANGE` partitioning in the following
    ways:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`RANGE COLUMNS`分区类似于`RANGE`分区，但允许您基于多个列值的范围定义分区。此外，您可以使用除整数类型以外的列来定义范围。`RANGE
    COLUMNS`分区与`RANGE`分区有以下显著不同：'
- en: '`RANGE COLUMNS` does not accept expressions, only names of columns'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RANGE COLUMNS`不接受表达式，只接受列名'
- en: '`RANGE COLUMNS` accepts a list of one or more columns'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RANGE COLUMNS`接受一个或多个列的列表'
- en: '`RANGE COLUMNS` partitioning columns are not restricted to integer columns;
    string, `DATE` and `DATETIME` columns can also be used as partitioning columns'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RANGE COLUMNS`分区列不限于整数列；字符串、`DATE`和`DATETIME`列也可以用作分区列'
- en: 'Instead of using the `to_days()` or `year()` function, you can directly use
    the column `hire_date` in `RANGE COLUMNS`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接在`RANGE COLUMNS`中使用`hire_date`列，而不是使用`to_days()`或`year()`函数：
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Or you can divide employees based on their `last_name`. This will not guarantee
    uniform distribution across the partitions:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以根据他们的`last_name`来划分员工。这将不能保证在分区之间的均匀分布：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Using `RANGE COLUMNS`, you can put multiple columns in the partition function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`RANGE COLUMNS`，您可以在分区函数中放置多个列：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you insert values `a=10`, `b=20`, `c=100`, `d=100`, `e=100`, it goes to
    `p1`. When designing tables partitioned by `RANGE COLUMNS`, you can always test
    successive partition definitions by comparing the desired tuples using the `mysql`
    client, like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果插入值`a=10`、`b=20`、`c=100`、`d=100`、`e=100`，它将进入`p1`。在设计按`RANGE COLUMNS`分区的表时，您可以通过使用`mysql`客户端来测试连续的分区定义，如下所示：
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this case, the insert goes to `p1`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，插入将进入`p1`。
- en: LIST and LIST COLUMNS partitioning
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LIST和LIST COLUMNS分区
- en: '`LIST` partitioning is similar to `RANGE` partitioning, where each partition
    is defined and selected based on the membership of a column value in one of a
    set of value lists, rather than in one of a set of contiguous ranges of values.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`LIST`分区类似于`RANGE`分区，每个分区根据列值在一组值列表中的成员资格而不是一组连续值范围中的成员资格来定义和选择。'
- en: You need to define it by `PARTITION BY LIST(<expr>)`, where `expr` is a column
    value or an expression based on a column value and returning an integer value.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要通过`PARTITION BY LIST(<expr>)`来定义，其中`expr`是一个列值或基于列值并返回整数值的表达式。
- en: Partition definition contains `VALUES IN (<value_list>)`, where `value_list`
    is a comma-separated list of integers rather than `VALUES LESS THAN (<value>)`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 分区定义包含`VALUES IN (<value_list>)`，其中`value_list`是一个逗号分隔的整数列表，而不是`VALUES LESS
    THAN (<value>)`。
- en: If you wish to use data types other than integers, you can use `LIST COLUMNS`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望使用除整数以外的数据类型，可以使用`LIST COLUMNS`。
- en: Unlike the case with `RANGE` partitioning, there is no `catch-all` such as `MAXVALUE`;
    all expected values for the partitioning expression should be covered in the `PARTITION`
    expression.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与`RANGE`分区不同，没有`MAXVALUE`这样的`catch-all`；分区表达式中应包含分区表达式的所有预期值。
- en: 'Suppose there is a customer table with a zip code and city. If, for example,
    you want to divide the customers with certain zip codes in a partition, you can
    use `LIST` partitions:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个带有邮政编码和城市的客户表。例如，如果您想要将具有特定邮政编码的客户划分到一个分区中，您可以使用`LIST`分区：
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you wish to use the columns directly, rather than integers, you can use
    `LIST COLUMNS`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望直接使用列而不是整数，可以使用`LIST COLUMNS`：
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: HASH and LINEAR HASH partitioning
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HASH和LINEAR HASH分区
- en: Partitioning by `HASH` is used primarily to ensure an even distribution of data
    among a predetermined number of partitions. With range or list partitioning, you
    must specify explicitly which partition a given column value or set of column
    values should be stored in; with hash partitioning, this decision is taken care
    of for you, and you need only specify a column value or expression based on a
    column value to be hashed and the number of partitions into which the partitioned
    table is to be divided.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`HASH`进行分区主要是为了确保数据在预定数量的分区中均匀分布。对于范围或列表分区，您必须明确指定给定列值或列值集应存储在哪个分区；而对于哈希分区，这个决定已经为您处理，您只需要指定一个要进行哈希处理的列值或基于列值的表达式，以及要将分区表分成的分区数。
- en: If you want to evenly distribute employees, instead of `RANGE` partitioning
    over `YEAR(hire_date)`, you can use `HASH of YEAR(hire_date)` and specify the
    number of partitions. When `PARTITION BY HASH` is used, the storage engine determines
    which partition to use based on the modulus of the result of the expression.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要均匀分配员工，可以使用`YEAR(hire_date)`的`HASH`并指定分区的数量，而不是对`YEAR(hire_date)`进行`RANGE`分区。当使用`PARTITION
    BY HASH`时，存储引擎根据表达式的结果的模来确定要使用的分区。
- en: 'For example, if the `hire_date` is `1987-11-28`, `YEAR(hire_date)` would be
    `1987` and `MOD(1987,8)` is `3`. So the row goes to third partition:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果`hire_date`是`1987-11-28`，`YEAR(hire_date)`将是`1987`，`MOD(1987,8)`是`3`。因此，行进入第三个分区：
- en: '[PRE49]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The most efficient hashing function is one which operates upon a single table
    column and whose value increases or decreases consistently with the column value.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最有效的哈希函数是对单个表列进行操作，并且其值随着列值的增加或减少而一致变化。
- en: 'In `LINEAR HASH` partitioning, you can use the same syntax, except for adding
    a `LINEAR` keyword. Instead of a `MODULUS` operation, MySQL uses a powers-of-two
    algorithm for determining the partition. Refer to [https://dev.mysql.com/doc/refman/8.0/en/partitioning-linear-hash.html](https://dev.mysql.com/doc/refman/8.0/en/partitioning-linear-hash.html)
    for more details:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LINEAR HASH`分区中，您可以使用相同的语法，只是添加一个`LINEAR`关键字。MySQL使用二的幂算法来确定分区，而不是使用`MODULUS`操作。有关更多详细信息，请参阅[https://dev.mysql.com/doc/refman/8.0/en/partitioning-linear-hash.html](https://dev.mysql.com/doc/refman/8.0/en/partitioning-linear-hash.html)：
- en: '[PRE50]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: KEY and LINEAR KEY partitioning
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: KEY和LINEAR KEY分区
- en: Partitioning by key is similar to partitioning by hash, except that, where hash
    partitioning employs a user-defined expression, the hashing function for key partitioning
    is supplied by the MySQL server. This internal hashing function is based on the
    same algorithm as the `PASSWORD()` function.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 按键分区类似于按哈希分区，只是哈希分区使用用户定义的表达式，而键分区的哈希函数由MySQL服务器提供。这个内部哈希函数基于与`PASSWORD()`函数相同的算法。
- en: '`KEY` takes only a list of zero or more column names. Any columns used as the
    partitioning key must comprise part or all of the table''s primary key, if the
    table has one. Where no column name is specified as the partitioning key, the
    table''s primary key is used, if there is one:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`KEY`只接受零个或多个列名的列表。如果将用作分区键的列，必须包括表的主键的一部分或全部，如果表有主键。如果未指定列名作为分区键，则使用表的主键，如果有的话：'
- en: '[PRE51]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Subpartitioning
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子分区
- en: 'You can further divide each partition into a partitioned table. This is called
    **subpartitioning** or **composite partitioning**:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以进一步将每个分区划分为分区表。这称为**子分区**或**复合分区**：
- en: '[PRE52]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Partition pruning and selection
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区修剪和选择
- en: MySQL does not scan partitions where there are no matching values; this is automatic
    and is called partition pruning. The MySQL optimizer evaluates the partitioning
    expression for the value given, determines which partition contains that value,
    and scans only that partition.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL不会扫描没有匹配值的分区；这是自动的，称为分区修剪。MySQL优化器评估给定值的分区表达式，确定包含该值的分区，并仅扫描该分区。
- en: '`SELECT`, `DELETE`, and `UPDATE` statements support partition pruning. `INSERT`
    statements currently cannot be pruned.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT`、`DELETE`和`UPDATE`语句支持分区修剪。`INSERT`语句目前无法修剪。'
- en: You can also explicitly specify partitions and subpartitions for rows matching
    a given `WHERE` condition.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以明确指定匹配给定`WHERE`条件的分区和子分区。
- en: How to do it...
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Partition pruning applies only to queries, but explicit selection of partitions
    is supported for both queries and a number of DML statements.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 分区修剪仅适用于查询，但支持对查询和多个DML语句进行分区的显式分区选择。
- en: Partition pruning
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区修剪
- en: 'Take the example of the `employees` table, which is partitioned based on `emp_no`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以基于`emp_no`进行分区的`employees`表为例：
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Suppose the following `SELECT` query is executed:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 假设执行以下`SELECT`查询：
- en: '[PRE54]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: MySQL optimizer detects that partitioned column is being used in the query and
    automatically determines the partition to scan.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL优化器检测到查询中使用了分区列，并自动确定要扫描的分区。
- en: In this query, it first calculates the `YEAR('1999-02-01')`, which is `1999`,
    and scans the `p2000` partition rather than the whole table. This dramatically
    reduces the query time.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在此查询中，首先计算`YEAR('1999-02-01')`，即`1999`，然后扫描`p2000`分区而不是整个表。这大大减少了查询时间。
- en: Instead of `hire_date='1999-02-01'`, if a range is given, such as `hire_date>='1999-02-01'`,
    then the partitions `p2000`, `p2010`, `p2020`, and `pmax` are scanned.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给出的不是`hire_date='1999-02-01'`，而是一个范围，比如`hire_date>='1999-02-01'`，那么将扫描`p2000`、`p2010`、`p2020`和`pmax`分区。
- en: If the expression `hire_date='1999-02-01'` is not given in the `WHERE` clause,
    MySQL has to scan the whole table.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`WHERE`子句中没有给出`hire_date='1999-02-01'`表达式，MySQL必须扫描整个表。
- en: 'To know which partitions the optimizer scans, you can execute the `EXPLAIN`
    plan of the query, which is explained in the *Explain plan* section of [Chapter
    13](part0432.html#CRVJ00-faa69fe6f4c04957afca3568dcd9cd83), *Performance Tuning*:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解优化器扫描的分区，可以执行查询的`EXPLAIN`计划，该计划在[第13章](part0432.html#CRVJ00-faa69fe6f4c04957afca3568dcd9cd83)的*Explain
    plan*部分中有解释，*性能调整*：
- en: '[PRE55]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Partition selection
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区选择
- en: 'Partition pruning is automatic selection based on the `WHERE` clause. You can
    explicitly specify the partitions to scan in the query. The queries can be `SELECT`,
    `DELETE`, `INSERT`, `REPLACE`, `UPDATE`, `LOAD DATA`, and `LOAD XML`. The `PARTITION`
    option is used to select partitions from a given table, you should specify the
    keyword `PARTITION` <partition name> immediately following the name of the table,
    before all other options, including any table alias, for example:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 分区修剪是基于`WHERE`子句的自动选择。您可以在查询中明确指定要扫描的分区。查询可以是`SELECT`、`DELETE`、`INSERT`、`REPLACE`、`UPDATE`、`LOAD
    DATA`和`LOAD XML`。`PARTITION`选项用于从给定表中选择分区，您应该在所有其他选项之前，包括任何表别名，指定关键字`PARTITION`
    <partition name>，例如：
- en: '[PRE57]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Similarly, we can delete:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以删除：
- en: '[PRE58]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Partition management
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区管理
- en: 'The most important thing when it comes to managing partitions is adding sufficient
    partitions in advance for time-based `RANGE` partitioning. Failure to do so leads
    to errors while inserting or, if the `MAXVALUE` partition is defined, all the
    inserts go into the `MAXVALUE` partition. For example, take the `event_history`
    table without the `pmax` partition:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理分区时最重要的是提前添加足够的分区以进行基于时间的`RANGE`分区。如果未能这样做，将在插入时出现错误，或者如果定义了`MAXVALUE`分区，则所有插入都将进入`MAXVALUE`分区。例如，考虑没有`pmax`分区的`event_history`表：
- en: '[PRE59]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The table accepts the `INSERTS` till October 15, 2017; after that, the `INSERTS`
    fail.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 该表接受`INSERTS`直到2017年10月15日；之后，`INSERTS`将失败。
- en: Another important thing is to `DELETE` the data after it crosses retention.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的事情是在数据超过保留期限后进行`DELETE`。
- en: How to do it...
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: To perform these operations, you need to execute the `ALTER` command.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这些操作，您需要执行`ALTER`命令。
- en: ADD partitions
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加分区
- en: 'To add a new partition, execute the `ADD PARTITION (<PARTITION DEFINITION>)`
    statement:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加新分区，请执行`ADD PARTITION (<PARTITION DEFINITION>)`语句：
- en: '[PRE60]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This statement locks the whole table for a very short time.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 此语句会锁定整个表的时间非常短。
- en: Reorganizing partitions
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新组织分区
- en: 'If the `MAXVALUE` partition is there, you cannot add a partition after `MAXVALUE`;
    in that case, you need to the `REORGANIZE MAXVALUE` partition into two partitions:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在`MAXVALUE`分区，则无法在`MAXVALUE`之后添加分区；在这种情况下，您需要将`REORGANIZE MAXVALUE`分区分成两个分区：
- en: '[PRE61]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Remember MySQL has to substantially move the data while reorganizing partitions
    and the table will be locked during that period.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当重新组织分区时，MySQL必须大幅移动数据，表在此期间将被锁定。
- en: 'You can also reorganize multiple partitions into a single partition:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将多个分区重新组织为单个分区：
- en: '[PRE62]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: DROP partitions
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除分区
- en: If the data has crossed the retention, you can `DROP` the whole partition, which
    is superquick compared with conventional `DELETE FROM TABLE` statement. This is
    very helpful in archiving the data efficiently.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据已经超过保留期限，您可以使用`DROP`整个分区，与传统的`DELETE FROM TABLE`语句相比，这是非常快速的。这对于高效地存档数据非常有帮助。
- en: 'If `p20170930` has crossed the retention, you can `DROP` the partition using
    the `ALTER TABLE ... DROP PARTITION` statement:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`p20170930`已经超过了保留期限，您可以使用`ALTER TABLE ... DROP PARTITION`语句删除该分区：
- en: '[PRE63]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Dropping the partition removes the `PARTITION DEFINITION` from the table.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 删除分区会从表中删除`PARTITION DEFINITION`。
- en: TRUNCATE partitions
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 截断分区
- en: 'If you wish to keep `PARTITION DEFINITION` in the table and remove only the
    data, you can execute the `TRUNCATE PARTITION` command:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在表中保留`PARTITION DEFINITION`并仅删除数据，可以执行`TRUNCATE PARTITION`命令：
- en: '[PRE64]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Managing HASH and KEY partitions
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理HASH和KEY分区
- en: The operations performed on `HASH` and `KEY` partitions are quite different.
    You can only reduce or increase the number of partitions.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 对`HASH`和`KEY`分区执行的操作是完全不同的。您只能减少或增加分区的数量。
- en: 'Suppose the `employees` table is partitioned based on `HASH`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`employees`表是基于`HASH`进行分区的：
- en: '[PRE65]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To reduce the partitions from `8` to `6`, you can execute the `COALESCE PARTITION`
    statement and specify the number of partitions you want to reduce, that is, *8-6=2*:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要将分区从`8`减少到`6`，您可以执行`COALESCE PARTITION`语句，并指定要减少的分区数，即*8-6=2*：
- en: '[PRE66]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To increase the partitions from `6` to `16`, you can execute the `ADD PARTITION`
    statement and specify the number of partitions you want to increase, that is,
    *16-6=10*:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要将分区从`6`增加到`16`，您可以执行`ADD PARTITION`语句，并指定要增加的分区数，即*16-6=10*：
- en: '[PRE67]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Other operations
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他操作
- en: 'You can also perform other operations, such as `REBUILD`, `OPTIMIZE`, `ANALYZE`,
    and `REPAIR` statements, for a particular partition, for example:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以执行其他操作，例如`REBUILD`，`OPTIMIZE`，`ANALYZE`和`REPAIR`语句，例如：
- en: '[PRE68]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Partition information
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区信息
- en: This section discusses obtaining information about existing partitions, which
    can be done in a number of ways.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了获取有关现有分区的信息，可以通过多种方式完成。
- en: How to do it...
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's get into the details.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下。
- en: Using SHOW CREATE TABLE
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SHOW CREATE TABLE
- en: 'To know whether a table is partitioned or not, you can execute the `SHOW CREATE
    TABLE\G` statement, which shows the table definition along with partitions, for
    example:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道表是否已分区，可以执行`SHOW CREATE TABLE\G`语句，该语句显示了表定义以及分区，例如：
- en: '[PRE69]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Using SHOW TABLE STATUS
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SHOW TABLE STATUS
- en: 'You can execute the `SHOW TABLE STATUS` command and check `Create_options`
    in the output:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以执行`SHOW TABLE STATUS`命令，并在输出中检查`Create_options`：
- en: '[PRE70]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Using EXPLAIN
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EXPLAIN
- en: 'The `EXPLAIN` plan shows all the partitions scanned for a query. If you run
    the `EXPLAIN` plan for `SELECT * FROM <table>`, it lists all the partitions, for
    example:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPLAIN`计划显示了查询所扫描的所有分区。如果您对`SELECT * FROM <table>`运行`EXPLAIN`计划，它将列出所有分区，例如：'
- en: '[PRE71]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Querying the INFORMATION_SCHEMA.PARTITIONS table
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询INFORMATION_SCHEMA.PARTITIONS表
- en: 'Compared to all the preceding methods, `INFORMATION_SCHEMA.PARTITIONS` gives
    more information about the partitions:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有前面的方法相比，`INFORMATION_SCHEMA.PARTITIONS`提供了有关分区的更多信息：
- en: '[PRE72]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'To find out more details about a table partition, you can query the `INFORMATION_SCHEMA.PARTITIONS`
    table by specifying the database name through `TABLE_SCHEMA` and table name through
    `TABLE_NAME`, for example:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关表分区的更多详细信息，您可以通过指定数据库名称和表名称来查询`INFORMATION_SCHEMA.PARTITIONS`表，例如：
- en: '[PRE73]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'You can get details such as `PARTITION_METHOD`, `PARTITION_EXPRESSION`, `PARTITION_DESCRIPTION`,
    and `TABLE_ROWS` in that partition:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在该分区中获取诸如`PARTITION_METHOD`，`PARTITION_EXPRESSION`，`PARTITION_DESCRIPTION`和`TABLE_ROWS`等详细信息：
- en: '[PRE74]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: For more details, refer to [https://dev.mysql.com/doc/refman/8.0/en/partitions-table.html](https://dev.mysql.com/doc/refman/8.0/en/partitions-table.html).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请参阅[https://dev.mysql.com/doc/refman/8.0/en/partitions-table.html](https://dev.mysql.com/doc/refman/8.0/en/partitions-table.html)。
- en: Efficiently managing time to live and soft delete rows
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效管理生存时间和软删除行
- en: '`RANGE COLUMNS` is highly useful in managing time to live and soft delete rows.
    Suppose you have a application which specifies the expiry time of row (row to
    be deleted after it crosses the expiry time) and the expiry is varying.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`RANGE COLUMNS`在管理生存期和软删除行方面非常有用。假设您有一个应用程序，它指定了行的到期时间（在超过到期时间后将被删除的行），并且到期时间是变化的。'
- en: 'Suppose the application can do the following types of inserts:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 假设应用程序可以执行以下类型的插入：
- en: Insert persistent data
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入持久数据
- en: Insert with expiry
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有到期日的插入
- en: If the expiry is constant i.e all the rows inserted will be deleted after certain
    time, we can go with RANGE partitioning. But if the expiry is varying i.e some
    rows will be deleted in a week, some in a month, some in a year and some have
    no expiry, it is not possible to create partitions. In that case, you can use
    the `RANGE COLUMNS` partitioning explained below.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果到期时间是恒定的，即所有插入的行都将在一定时间后被删除，我们可以使用范围分区。但是，如果到期时间是变化的，即一些行将在一周内被删除，一些将在一个月内被删除，一些将在一年内被删除，一些没有到期时间，那么就不可能创建分区。在这种情况下，您可以使用下面解释的`RANGE
    COLUMNS`分区。
- en: How it works...
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We introduce a column called `soft_delete` which will be set by trigger. The
    `soft_delete` column will be part of range column partitioning.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入一个名为`soft_delete`的列，将由触发器设置。`soft_delete`列将成为范围列分区的一部分。
- en: Partitioning will be like (`soft_delete`, expires). The `soft_delete` and expires
    together controls which partition a row should go. soft_delete column decides
    the retention of the row. If the expires is 0, the trigger sets the `soft_delete`
    value to 0 which puts the row in a `no_retention` partition and if the value of
    expires is out of partition bounds, trigger sets the `soft_delete` value to 1
    and the row will be put into a `long_retention` partition. If the value of expires
    is with in the partition bounds, trigger sets the `soft_delete` value to `2`.
    Depending on the value of the expires, the row will be put in respective partition.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 分区将是（`soft_delete`，expires）。`soft_delete`和expires共同控制行应该进入哪个分区。soft_delete列决定了行的保留。如果expires为0，则触发器将`soft_delete`值设置为0，将行放入`no_retention`分区，如果expires的值超出分区范围，触发器将`soft_delete`值设置为1，并将行放入`long_retention`分区。如果expires的值在分区范围内，触发器将`soft_delete`值设置为`2`。根据expires的值，行将被放入相应的分区。
- en: 'To summarize, `soft_delete` will be :'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，`soft_delete`将是：
- en: '`0`: If the value of expires is 0'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：如果过期值为0'
- en: '`1`: If the expires is more than 30 days away from the timestamp'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`：如果过期时间距离时间戳超过30天'
- en: '`2`: If the expires is less than or equal to 30 days away from the timestamp'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`：如果过期时间距离时间戳不到30天'
- en: We create
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建
- en: 1 `no_retention` partition (`soft_delete = 0`)
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个`no_retention`分区（`soft_delete = 0`）
- en: 1 `long_retention` partition (`soft_delete = 1`)
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个`long_retention`分区（`soft_delete = 1`）
- en: 8 daily partitions (`soft_delete = 2`)
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 8个每日分区（`soft_delete = 2`）
- en: How to do it...
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You can create a table like this:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建一个如下的表：
- en: '[PRE75]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: There will be a buffer weekly partition which will be 42 days away and will
    be always empty so that we can split and 7+2 daily partitions with 2 buffer.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 将有一个缓冲周分区，将会在42天后，并且始终为空，以便我们可以分割和7+2个每日分区，带有2个缓冲。
- en: '[PRE76]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Suppose the client inserts a row with timestamp of 1508265000 (2017-10-17 18:30:00)
    and expiry value of 1508351400 (2017-10-18 18:30:00), the soft_delete will be
    2 which makes it into partition pd20171019
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设客户端插入了一个时间戳为1508265000（2017-10-17 18:30:00）并且到期值为1508351400（2017-10-18 18:30:00）的行，soft_delete将为2，这将使其进入分区pd20171019
- en: '[PRE78]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Suppose the client does not set expiry, expires column will be 0 which makes
    the `soft_delete` to `0` and it will go to `no_retention` partition.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设客户端没有设置到期时间，expires列将为0，这将使`soft_delete`为`0`，并且将进入`no_retention`分区。
- en: '[PRE80]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Suppose the client wants to have expiry (assume 2017-10-19 06:30:00), expiry
    column can be updated which moves the row from `no_retention` partition to the
    respective partition (this has some performance impact because the row has to
    be moved across partitions)
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设客户端希望设置到期时间（假设为2017-10-19 06:30:00），到期列可以更新，这将把行从`no_retention`分区移动到相应的分区（这会有一些性能影响，因为行必须在分区之间移动）
- en: '[PRE82]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Suppose the client sets a expiry which is beyond our partitions, it will automatically
    go into `long_retention` partition.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设客户端设置了一个超出我们分区范围的到期时间，它将自动进入`long_retention`分区。
- en: '[PRE85]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Movement of rows across partitions is slow, if you update the `soft_delete`,
    the row will be moved from default partition to other partition which will be
    slow.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更新`soft_delete`，则跨分区移动行的速度很慢，行将从默认分区移动到其他分区。
- en: '**Extending the logic**'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展逻辑**'
- en: We can extend the logic and increase the value of `soft_delete` to accommodate
    more types of partitions.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展逻辑并增加`soft_delete`的值，以适应更多类型的分区。
- en: '`0`: If the value of expires is 0'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：如果过期值为0'
- en: '`3`: If the expires is less than or equal to 7 days away from the timestamp'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3`：如果过期时间距离时间戳不到7天'
- en: '`2`: If the expires is less than or equal to 60 days away from the timestamp'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`：如果过期时间距离时间戳不到60天'
- en: '`1`: If the expires is more than 60 days away from the timestamp'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`：如果过期时间距离时间戳超过60天'
- en: The `soft_delete` column will be part of partitioning. We create
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`soft_delete`列将成为分区的一部分。我们创建'
- en: Single `no_retention` partition if value of `soft_delete` is `0`
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个`no_retention`分区，如果`soft_delete`的值为`0`
- en: Single `long_retention` partition if the value of `soft_delete 1`
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个`long_retention`分区，如果`soft_delete 1`的值
- en: Weekly partitions if the value of `soft_delete 2`
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每周分区，如果`soft_delete 2`的值
- en: Daily partitions if the value of `soft_delete 3`
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每日分区，如果`soft_delete 3`的值
- en: '**Example partitioned table structure**'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例分区表结构**'
- en: There will be a buffer weekly partition which will be 42 days away and will
    be always empty so that we can split and 7+2 daily partitions with 2 buffer.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 将有一个缓冲周分区，将会在42天后，并且始终为空，以便我们可以分割和7+2个每日分区，带有2个缓冲。
- en: '[PRE86]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '**Managing partitions**'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**管理分区**'
- en: You can create a `CRON` in Linux or `EVENT` in mysql to manage the partitions.
    As the retention approaches, the partition management tool should reorganize the
    buffer partition into one usable partition and a buffer partition and also drop
    the partitions which crossed the retention.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Linux中创建一个`CRON`或在mysql中创建一个`EVENT`来管理分区。随着保留期的临近，分区管理工具应该将缓冲分区重新组织为一个可用分区和一个缓冲分区，并且删除已经超过保留期的分区。
- en: For example, take the `customer_data` table mentioned previously.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以前提到的`customer_data`表为例。
- en: '**On 20171203, you have to split the partition pw20171210 into pw20171210 and
    pw20171217.**'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**在20171203，您需要将分区pw20171210拆分为pw20171210和pw20171217。**'
- en: '**On 20171017, you have to split the pd20171024 into pd20171024 and pd20171025.**'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**在20171017，您需要将分区pd20171024拆分为pd20171024和pd20171025。**'
- en: Splitting(reorganizing) partitions would be very quick (~milli seconds if there
    are no queries locking the table) only if there is no (or very less) data. So
    we should aim to keep the partition empty by reorganizing it before the data enters
    the partition.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有查询锁定表，分割（重新组织）分区将非常快（~毫秒级），只要没有（或者非常少量的）数据。因此，在数据进入分区之前，我们应该通过重新组织来保持分区为空。
