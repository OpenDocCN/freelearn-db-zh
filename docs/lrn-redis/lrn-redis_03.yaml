- en: Chapter 3. Data Structures and Communicating Protocol in Redis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。Redis中的数据结构和通信协议
- en: The previous chapter dealt with installation of Redis and running some simple
    programs. Since Redis is a datastore, so it's important to understand how Redis
    treats data by providing data structures to handle and store them. Also important
    is how Redis deals with data while communicating it to a client such as the communication
    protocol.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了安装Redis和运行一些简单程序。由于Redis是一个数据存储，因此了解Redis如何通过提供数据结构来处理和存储数据是很重要的。同样重要的是Redis在将数据传输给客户端时如何处理数据，比如通信协议。
- en: Data structures
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构
- en: Data structure, as the word suggests, means a structure for storing data. In
    the world of computing, data is always organized in a way that makes sense to
    the program storing it. Data structure can vary from a simple sequential arrangement
    of characters to a complex map where keys are not arranged sequentially, but on
    the basis of an algorithm. Data structures are often composite in nature, which
    means that one data structure can hold other data structure, which is a map holding
    another map.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构，顾名思义，意味着用于存储数据的结构。在计算世界中，数据总是以一种对存储它的程序有意义的方式组织的。数据结构可以从简单的字符顺序排列到复杂的地图，其中键不是顺序排列的，而是基于算法的。数据结构通常是复合的，这意味着一个数据结构可以容纳另一个数据结构，这是一个包含另一个地图的地图。
- en: The key influencing factors in designing a data structure are performance and
    memory management of the data structure. Some of the common examples of data structures
    are lists, sets, maps, graphs and trees, tuples, and so on. As programmers, we
    have used data structures in our programs time and again. In an object-oriented
    world, a simple *object* is also a data structure since it contains data, and
    logic to access those data. Every data structure is governed by an algorithm which
    decides the efficiency and functional capability of it. So, if the algorithm can
    be classified then it would give a clear idea on the performance of data structure;
    when data is pumped into the data structure or when data is read or when data
    is deleted from the data structure.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 设计数据结构的关键影响因素是数据结构的性能和内存管理。一些常见的数据结构示例包括列表，集合，地图，图和树，元组等。作为程序员，我们一次又一次地在程序中使用数据结构。在面向对象的世界中，一个简单的*对象*也是一个数据结构，因为它包含数据和访问这些数据的逻辑。每个数据结构都受算法的控制，算法决定了其效率和功能能力。因此，如果算法可以分类，那么它将清楚地表明数据结构的性能；当数据被注入数据结构或当数据被读取或从数据结构中删除时。
- en: 'Big O notation is a means to classify the algorithm (data structure) on its
    performance when the data grows. From Redis perspective, we will be classifying
    the data structure on the basis of these following notations:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 大O表示法是一种对算法（数据结构）在数据增长时性能进行分类的方法。从Redis的角度来看，我们将根据以下符号对数据结构进行分类：
- en: '`O (1)`: Time taken by the command on a data structure is constant irrespective
    of the amount of data it contains.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O（1）`：命令在数据结构上花费的时间是恒定的，不管它包含多少数据。'
- en: '`O (N)`: Time taken by the command on a data structure scales linearly on the
    amount of data it contains, where `N` is the number of elements.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O（N）`：命令在数据结构上花费的时间与其包含的数据量成线性比例，其中`N`是元素的数量。'
- en: '`O (log (N))`: Time taken by the command on a data structure is logarithmic
    in nature, where `N` is the number of elements. Algorithms exhibiting this are
    highly efficient and used to find elements in sorted arrays. This can be interpreted
    to be fairly constant with time.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O（log（N））`：命令在数据结构上花费的时间是对数性质的，其中`N`是元素的数量。表现出这种特性的算法非常高效，用于在排序数组中查找元素。这可以解释为随着时间的推移而相当恒定。'
- en: '`O (log (N) + M)`: Time taken by the command is dependent on logarithmic value,
    where `M` is the total number of elements in the sorted sets and `N` is the range
    from which the search has to find. This can be interpreted to be fairly dependent
    on the value of `M`. With increase in the value of `M,` time taken for search
    would increase.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O（log（N）+ M）`：命令花费的时间取决于对数值，其中`M`是排序集中的元素总数，`N`是搜索范围。这可以解释为相当依赖于`M`的值。随着`M`值的增加，搜索所需的时间也会增加。'
- en: '`O (M log (M))`: Time taken by the command is log-linear in nature.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O（M log（M））`：命令花费的时间是对数线性的。'
- en: Data types in Redis
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redis中的数据类型
- en: 'Redis, a data structure server has many in-built data types, which makes it
    a bit different from other key-value NoSQL datastores in the ecosystem. Unlike
    other NoSQL, Redis provides the users with many in-built data types which provide
    a sematic way of arranging their data. Think of it like this; while designing
    a solution we need domain objects which in a way shape up our data layer. After
    deciding on the domain objects, we need to design the structure for our data that
    will be saved in the data store for which we need some predefined data structures.
    The advantage of this is that it saves time and efforts of the programmers to
    externally create and manage this data. For example, suppose in our program there
    is a requirement for a Set like data structure. Using Java, we can easily use
    an in-built data structure such as Set. If we were to put this data as a key-value,
    we will have to put the entire set against a key. Now if we were to sort this
    Set, the normal way would be to extract the data out and programmatically sort
    the data, which can be cumbersome. It would be good if the data store itself gives
    a mechanism to sort the data internally. Redis has the following data types built
    into it for storing data:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Redis是一个数据结构服务器，具有许多内置数据类型，这使得它与生态系统中的其他键值NoSQL数据存储有所不同。与其他NoSQL不同，Redis为用户提供了许多内置数据类型，这提供了一种语义方式来安排其数据。可以这样想：在设计解决方案时，我们需要领域对象，这些对象在某种程度上塑造了我们的数据层。在决定领域对象之后，我们需要设计要保存在数据存储中的数据的结构，为此我们需要一些预定义的数据结构。这样做的好处是节省了程序员外部创建和管理这些数据的时间和精力。例如，假设在我们的程序中需要一种类似Set的数据结构。使用Java，我们可以轻松地使用内置数据结构，如Set。如果我们要将这些数据作为键值存储，我们将不得不将整个集合放在一个键值对中。现在，如果我们要对这个集合进行排序，通常的方法是提取数据并以编程方式对数据进行排序，这可能很麻烦。如果数据存储本身提供了内部对数据进行排序的机制，那就太好了。Redis内置了以下数据类型来存储数据：
- en: String
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Hashes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希
- en: Lists
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表
- en: Sets
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: Sorted Sets
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有序集合
- en: 'The following figure represents the data types that can be mapped to a key.
    The key itself is of type string in Redis and the values it can store can be any
    one of them as shown:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示可以映射到键的数据类型。在Redis中，键本身是字符串类型，它可以存储其中的任何一个，如下所示：
- en: '![Data types in Redis](img/1794_0123OS_03_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![Redis中的数据类型](img/1794_0123OS_03_01.jpg)'
- en: Representation of key and the values it can store
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 键和其可以存储的值的表示
- en: The string data type
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串数据类型
- en: '**String** types are the basic data types in Redis. Though misleading in terminology,
    string in Redis can be considered as a byte array which can hold string, integers,
    images, files, and serializable objects in them. These byte arrays are binary
    safe in nature and the maximum size they can hold is 512 MB. In Redis, strings
    are called **Simple Dynamic String** (**SDS**), which in C language is implemented
    as `Char` array with some other attributes, such as `len` and `free`. These strings
    are binary safe too. The SDS header file is defined in `sds.h` file as following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符串**类型是Redis中的基本数据类型。尽管术语上有些误导，但在Redis中，字符串可以被视为一个可以容纳字符串、整数、图像、文件和可序列化对象的字节数组。这些字节数组在性质上是二进制安全的，它们可以容纳的最大大小为512MB。在Redis中，字符串被称为**Simple
    Dynamic String**（**SDS**），在C语言中实现为`Char`数组，还有一些其他属性，如`len`和`free`。这些字符串也是二进制安全的。SDS头文件在`sds.h`文件中定义如下：'
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So any string, integer, bitmap, image files, and so on, in Redis are stored
    in `buf[]` (`Char` array), the `len` stores the length of the buffer array, and
    `free` stores additional bytes for storage. Redis has an in-built mechanism to
    detect the type of data stored in the array. More information on this can be found
    at [http://redis.io/topics/internals-sds](http://redis.io/topics/internals-sds).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Redis中的任何字符串、整数、位图、图像文件等都存储在`buf[]`（`Char`数组）中，`len`存储缓冲数组的长度，`free`存储额外的字节以进行存储。Redis具有内置机制来检测数组中存储的数据类型。有关更多信息，请访问[http://redis.io/topics/internals-sds](http://redis.io/topics/internals-sds)。
- en: 'The commands in Redis for the string can be categorized in the following parts:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Redis中的命令可以按以下部分对字符串进行分类：
- en: '**Setters and getters commands**: These are the commands that can be used to
    set or get values in Redis. There are commands for single key-value as well as
    multiple key-values. For single get and set, following commands can be used:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置器和获取器命令**：这些是用于在Redis中设置或获取值的命令。有单个键值和多个键值的命令。对于单个获取和设置，可以使用以下命令：'
- en: '`Get` key: This key gets the value for a key. Time-based performance for this
    command is `O (1)`.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Get` key：获取键的值。该命令的时间性能为`O（1）`。'
- en: '`Set` key: This key sets a value against a key. Time-based performance for
    this command is `O (1)`.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set` key：该键设置一个值。该命令的时间性能为`O（1）`。'
- en: '`SETNX` key: This key sets a value against a key if key doesn''t exist - no
    overwrite is done. Time-based performance for this command is `O (1)`.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SETNX` key：如果键不存在，则该键设置一个值 - 不会覆盖。该命令的时间性能为`O（1）`。'
- en: '`GETSET` key: This key gets the old value and sets a new value. Time-based
    performance for this command is `O (1)`.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GETSET` key：获取旧值并设置新值。该命令的时间性能为`O（1）`。'
- en: '`MGET key1` key: This key gets all the corresponding values of keys. Time-based
    performance for this command is `O (N)`.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MGET key1` key：获取所有键的相应值。该命令的时间性能为`O（N）`。'
- en: '`MSET` key: This key sets all the corresponding values of keys. Time-based
    performance for this command is `O (N)`, where `N` is the number of keys to be
    set.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MSET` key：设置所有键的相应值。该命令的时间性能为`O（N）`，其中`N`是要设置的键的数量。'
- en: '`MSETNX` key: This sets all the corresponding values of keys if all the don''t
    keys exist, that is if one key exists then no values are set. Time-based performance
    for this command is `O (N)`, where `N` is the number of keys to be set.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MSETNX` key：如果所有键都不存在，则设置所有键的相应值，即如果一个键存在，则不设置任何值。该命令的时间性能为`O（N）`，其中`N`是要设置的键的数量。'
- en: '**Data clean commands**: These are the commands that can be used for managing
    the lifecycle of a value. By default, the values for the key do not have an expiry
    time. However, if you have a use case where values need to have life duration,
    then use the following keys:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据清理命令**：这些是用于管理值的生命周期的命令。默认情况下，密钥的值没有到期时间。但是，如果您有一个值需要具有生命周期的用例，那么请使用以下密钥：'
- en: '`SET PX/ EX`: Removes the values and the key gets expired after expiry time
    in milliseconds. Time based performance for this command is `O (1)`.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SET PX/ EX`：在到期时间后删除值，密钥在毫秒后过期。该命令的时间性能为`O（1）`。'
- en: '`SETEX`: Removes the values and the key gets expired after the expiry time
    in seconds. Time-based performance for this command is `O (1)`.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SETEX`：在到期时间后删除值，密钥在秒后过期。该命令的时间性能为`O（1）`。'
- en: '**Utility commands**: Following are some of these commands:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实用命令**：以下是一些这些命令：'
- en: '`APPEND`: This command appends to the existing value or sets if it does not
    exist. Time-based performance for this command is `O (1)`.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APPEND`：此命令将附加到现有值，如果不存在则设置。该命令的时间性能为`O（1）`。'
- en: '`STRLEN`: This command returns the length of the value stored as string. Time-based
    performance for this command is `O (1).`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STRLEN`：此命令返回存储为字符串的值的长度。该命令的时间性能为`O（1）`。'
- en: '`SETRANGE`: This command overwrites the string at the given offset. Time-based
    performance for this command is `O (1)`, provided the length of the new string
    does not take long time to copy.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SETRANGE`：此命令在给定的偏移位置上覆盖字符串。该命令的时间性能为`O（1）`，前提是新字符串的长度不会花费太长时间来复制。'
- en: '`GETRANGE`: This command gets the substring value from the given offsets. Time-based
    performance for this command is `O (1)`, provided the length of the new substring
    is not too big.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GETRANGE`：此命令从给定的偏移量获取子字符串值。该命令的时间性能为`O（1）`，前提是新子字符串的长度不会太大。'
- en: A sample program to demonstrate the simple usage of commands for a string is
    given as follows. Execute the program and analyze the result yourself.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个演示字符串命令简单用法的示例程序。执行程序并自行分析结果。
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The commands in Redis for the integer and float can be categorized in the following
    parts:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Redis中的整数和浮点数的命令可以分为以下部分：
- en: '**Setters and getters commands**: The set of commands is same as what is mentioned
    for string.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置器和获取器命令**：命令集与字符串中提到的相同。'
- en: '**Data clean commands**: The set of commands is same as what is mentioned for
    string.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据清理命令**：命令集与字符串中提到的相同。'
- en: '**Utility commands**: The commands here will help to manipulate the integer
    and float values. For integers, this operation is limited to 64 bit signed integers:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实用命令**：这里的命令将帮助操作整数和浮点值。对于整数，此操作仅限于64位有符号整数：'
- en: '**APPEND**: This will concatenate the existing integer with the new integer.
    Time-based performance for this command is `O (1)`.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**APPEND**：这将将现有整数与新整数连接。该命令的时间性能为`O（1）`。'
- en: '**DECR**: This will decrement the value by one. Time-based performance for
    this command is `O (1)`.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DECR**：这将使值减少一。该命令的时间性能为`O（1）`。'
- en: '**DECRBY**: This will decrement the value by the given value. Time-based performance
    for this command is `O (1)`.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DECRBY**：这将使值减少给定的值。该命令的时间性能为`O（1）`。'
- en: '**INCR**: This will increment the value by one. Time-based performance for
    this command is `O (1)`.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**INCR**：这将使值增加一。该命令的时间性能为`O（1）`。'
- en: '**INCRBY**: This will increment the value by the given value. Time-based performance
    for this command is `O (1)`.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**INCRBY**：这将使值增加给定的值。该命令的时间性能为`O（1）`。'
- en: '**INCRBYFLOAT**: This will increment the value by the given floating value.
    Time-based performance for this command is `O (1)`.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**INCRBYFLOAT**：这将使值增加给定的浮点值。该命令的时间性能为`O（1）`。'
- en: Apart from regular number, string, and so on, string data type can store a special
    type of data structure called **BitSet** or **bitmap.** Let's learn a bit more
    about them and see their usage.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规数字、字符串等，字符串数据类型可以存储一种称为**BitSet**或**bitmap**的特殊数据结构。让我们更多地了解它们并看看它们的用法。
- en: The BitSet or bitmap data type
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BitSet或位图数据类型
- en: 'These are special space-efficient types of data structure used to store special
    kind of information. Bitmaps are specially used for real-time analytics work.
    Though bitmap can only store values in binary (1 or 0) but the fact that they
    consume less space and the performance for getting value is `O (1)`, makes them
    very attractive for real-time analytics:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是特殊的高效利用空间的数据结构类型，用于存储特殊类型的信息。位图特别用于实时分析工作。尽管位图只能存储二进制值（1或0），但它们占用的空间较少，获取值的性能为`O（1）`，这使它们对实时分析非常有吸引力：
- en: '![The BitSet or bitmap data type](img/1794_0123OS_03_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![BitSet或位图数据类型](img/1794_0123OS_03_02.jpg)'
- en: Representation of Bitmap
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 位图的表示
- en: The key can be any date-based key. Let's say that the key here represents the
    bitmap about the users who purchased a book on December 12, 2014.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥可以是任何基于日期的密钥。假设这里的密钥表示了2014年12月12日购买书籍的用户的位图。
- en: For example, `12/12/2014-user_purchased_book_learning_redis`. Offset here represents
    a unique integer ID associated with a user. Here we have users associated with
    number 0, 1, 2...n and so on. Whenever a user makes a purchase, we find the corresponding
    unique ID of the user, and at that offset position, change the value to `1`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`12/12/2014-user_purchased_book_learning_redis`。这里的偏移量表示与用户关联的唯一整数ID。这里我们有与数字0、1、2...n等关联的用户。每当用户购买商品时，我们找到用户的相应唯一ID，并在该偏移位置将值更改为`1`。
- en: 'The following questions can be answered with the help of this space optimizing,
    high performance bitmap:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题可以借助这个空间优化、高性能的位图来回答：
- en: How many purchases were made on December 12, 2014?
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2014年12月12日有多少次购买？
- en: 'Answer: Count the number of 1 in the bitmap, which is the number of users who
    made the purchase, say 9.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：计算位图中的1的数量，即进行购买的用户数量，例如9。
- en: Did user associated with ID (offset number) 15 make a purchase?
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与ID（偏移编号）为15的用户是否进行了购买？
- en: 'Answer: The value at offset 15 is 0, so the user did not make a purchase.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：偏移量为15的值为0，因此用户没有购买。
- en: 'Collection of these bitmaps can be used in union to find answers to more complicated
    analytics. Let''s add another bitmap to an existing sample and let''s call it
    `12/12/2014-user_browsed_book_learning_redis`, for example. Using these two bitmaps,
    we can find answers to the following questions:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些位图的集合可以用于联合，以找到更复杂的分析答案。让我们向现有样本添加另一个位图，例如称为`12/12/2014-user_browsed_book_learning_redis`。使用这两个位图，我们可以找到以下问题的答案：
- en: How many users browsed the product (*Learning Redis*) page?
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览产品（*学习Redis*）页面的用户有多少？
- en: How many users purchased the product (*Learning Redis*) page?
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购买产品（*学习Redis*）页面的用户有多少？
- en: How many users who browsed the product page purchased the book?
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览产品页面的用户中有多少人购买了这本书？
- en: How many users who did not browse the product page purchased the book?
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有浏览产品页面的用户购买了这本书有多少？
- en: Use case scenario
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用情况场景
- en: Redis string can be used to store object IDs. For example, session ID, configuration
    values as XML, JSON, and so on. Redis string (storing integer) can be used as
    atomic counters. Redis string (storing bitmaps) can be used as real-time analytics
    engine.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Redis字符串可用于存储对象ID。例如，会话ID、XML、JSON等配置值。Redis字符串（存储整数）可用作原子计数器。Redis字符串（存储位图）可用作实时分析引擎。
- en: The Hashes data type
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希数据类型
- en: 'Hashes are Redis version of what a map would do in Java. Hashes in Redis are
    used to store map of attributes and their values against a key. To understand
    it better, let''s say we have an object called *Learning Redis*; this object will
    have many properties, such as author, publisher, ISBN number, and so on. To represent
    this in a storage system, we can store the information as XML, JSON against our
    key *Learning Redis*. If we require some particular value, for example, author
    stored against *Learning Redis*, then the entire dataset has to be retrieved and
    required value has to be filtered out. Doing work this way will not be efficient
    because lot of data needs to travel via network, and the processing at the client
    side would increase. Redis provides hashes data structures which can be used for
    storing such kinds of data. The following figure give a diagrammatic representation
    of the preceding example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希是Redis中类似Java中的映射的版本。Redis中的哈希用于存储属性和它们的值的映射。为了更好地理解，假设我们有一个名为*学习Redis*的对象；这个对象将有许多属性，比如作者、出版商、ISBN号等。为了在存储系统中表示这些信息，我们可以将信息存储为XML、JSON等，并与我们的键*学习Redis*相关联。如果我们需要某个特定的值，例如存储在*学习Redis*中的作者，那么就必须检索整个数据集，并筛选出所需的值。以这种方式工作将不高效，因为需要大量数据通过网络传输，并且客户端的处理会增加。Redis提供了哈希数据结构，可以用于存储这种类型的数据。以下图示出了前面示例的图解表示：
- en: '![The Hashes data type](img/1794_0123OS_03_03.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![哈希数据类型](img/1794_0123OS_03_03.jpg)'
- en: The HAshes data types
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希数据类型
- en: Hashes are stored in such a way that they take up less space and each Hash in
    Redis can store up to 2^(32)–one field-value pairs, that is more than 4 billion.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希以占用更少的空间存储，Redis中的每个哈希可以存储多达2^(32)个字段-值对，即超过40亿。
- en: 'The commands in Hashes start with `H` and the commands in Redis for the Hashes
    can be categorized in the following parts:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希中的命令以`H`开头，Redis中哈希的命令可以分为以下几部分：
- en: '**Setters and getters commands**: Following are the commands for this:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置器和获取器命令**：以下是此命令：'
- en: '`HGET`: This command gets the value of a field for a key. Time-based performance
    for this command is `O (1)`.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HGET`：该命令获取键的字段的值。该命令的基于时间的性能为`O(1)`。'
- en: '`HGETALL`: This command gets all the values and fields for a key. Time-based
    performance for this command is `O (1)`.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HGETALL`：该命令获取键的所有值和字段。该命令的基于时间的性能为`O(1)`。'
- en: '`HSET`: This command sets the value of a field for a key. Time-based performance
    for this command is `O (1)`.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HSET`：该命令为键的字段设置值。该命令的基于时间的性能为`O(1)`。'
- en: '`HMGET`: This command gets the values for the fields for a key. Time-based
    performance for this command is `O (N),` where `N` is the number of fields. However,
    it''s `O (1)` if `N` is small.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HMGET`：该命令获取键的字段的值。该命令的基于时间的性能为`O(N)`，其中`N`是字段的数量。但是，如果`N`很小，则为`O(1)`。'
- en: '`HMSET`: This command sets multiple values for respective fields for a key.
    Time-based performance for this command is `O (N),` where `N` is the number of
    fields. However, it''s `O (1)` if `N` is small.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HMSET`：该命令为键的各个字段设置多个值。该命令的基于时间的性能为`O(N)`，其中`N`是字段的数量。但是，如果`N`很小，则为`O(1)`。'
- en: '`HVALS`: This command gets all the values in the Hash for the key. Time-based
    performance for this command is `O (N),` where `N` is the number of fields. However,
    it''s `O (1)` if N is small.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HVALS`：该命令获取键的哈希中的所有值。该命令的基于时间的性能为`O(N)`，其中`N`是字段的数量。但是，如果`N`很小，则为`O(1)`。'
- en: '`HSETNX`: This command sets the value against the field for the key provided
    the field does not exist. Time-based performance for this command is `O (1)`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HSETNX`：该命令为提供的键设置字段的值，前提是该字段不存在。该命令的基于时间的性能为`O(1)`。'
- en: '`HKEYS`: This command gets all the fields in the Hash for the key. Time-based
    performance for this command is `O (1)`.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HKEYS`：该命令获取键的哈希中的所有字段。该命令的基于时间的性能为`O(1)`。'
- en: '**Data clean commands**: Following is the command for this:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据清理命令**：以下是此命令：'
- en: '`HDEL`: This command deletes the fields for a key. Time-based performance for
    this command is `O (N),` where `N` is the number of fields. However, it''s `O
    (1)` if `N` is small.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HDEL`：该命令删除键的字段。该命令的基于时间的性能为`O(N)`，其中`N`是字段的数量。但是，如果`N`很小，则为`O(1)`。'
- en: '**Utility commands**: Following are the commands for this:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实用命令**：以下是此命令：'
- en: '`HEXISTS`: This command checks for the existence of a field for a key. Time-based
    performance for this command is `O (1)`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HEXISTS`：该命令检查键的字段是否存在。该命令的基于时间的性能为`O(1)`。'
- en: '`HINCRBY`: This command increments the value (provided the value is an integer)
    of a field for a key. Time-based performance for this command is `O (1)`.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HINCRBY`：此命令递增键的字段的值（假设该值是整数）。此命令的基于时间的性能为`O(1)`。'
- en: '`HINCRBYFLOAT`: This command increments the value (provided the value is a
    float) of a field for a key. Time-based performance for this command is `O (1)`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HINCRBYFLOAT`：此命令递增键的字段的值（假设该值是浮点数）。此命令的基于时间的性能为`O(1)`。'
- en: '`HLEN`: This command gets the number of fields for the key. Time-based performance
    for this command is `O (1)`.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HLEN`：此命令获取键的字段数。此命令的基于时间的性能为`O(1)`。'
- en: A sample program to demonstrate the simple usage of commands for Hashes is given
    as follows. Execute the program and analyze the result yourself.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个演示哈希命令简单用法的示例程序。执行程序并自行分析结果。
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Use case scenario
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用案例场景
- en: Hashes provide a sematic interface to store simple and complex data objects
    in the Redis server. For example, user profile, product catalogue, and so on.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希提供了一种语义接口，用于在Redis服务器中存储简单和复杂的数据对象。例如，用户配置文件，产品目录等。
- en: The Lists data type
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表数据类型
- en: Redis lists are similar to what linked lists are in Java. This Redis list can
    have elements added to the head or tail. The performance of doing that is constant
    or can be expressed as `O (1)`. What it means is that suppose you have a list
    with 100 elements, the time taken to add elements to the list is equal to the
    time taken to add elements to a list of 10,000 elements. But on the flip side,
    accessing elements in the Redis list would result in the scanning of the entire
    list which means that the performance degrades if the number of items in the list
    is high.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Redis列表类似于Java中的链表。Redis列表可以在头部或尾部添加元素。执行此操作的性能是恒定的，或者可以表示为`O(1)`。这意味着，假设您有一个包含100个元素的列表，添加元素到列表所需的时间等于添加元素到包含10,000个元素的列表所需的时间。但另一方面，访问Redis列表中的元素将导致整个列表的扫描，这意味着如果列表中的项目数量较多，则性能会下降。
- en: The advantage of the Redis list getting implemented as a linked list rather
    than an array list is because Redis list as a data type was designed to have faster
    writes than reads (a trait shown by all data stores).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Redis列表以链表形式实现的优势在于，Redis列表作为一种数据类型，设计为具有比读取更快的写入速度（这是所有数据存储所显示的特性）。
- en: '![The Lists data type](img/1794_0123OS_03_04.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![列表数据类型](img/1794_0123OS_03_04.jpg)'
- en: The Lists Data types
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表数据类型
- en: 'The commands in Redis for the lists normally start with `L`. This can also
    be interpreted that all the commands will execute from *Left or head of the list*,
    and where the commands are executed from *Right or tail of the list*, they start
    with R. The commands can be categorized in the following parts:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Redis中的列表命令通常以`L`开头。这也可以解释为所有命令将从*列表的左侧或头部*执行，而从*列表的右侧或尾部*执行的命令则以R开头。这些命令可以分为以下几个部分：
- en: '**Setters and getters commands**: Following are the examples for this type
    of commands:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置器和获取器命令**：以下是此类命令的示例：'
- en: '`LPUSH`: This command prepends the values to the list from the left of the
    list. Time-based performance for this command is `O (1)`.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LPUSH`：此命令从列表的左侧添加值。此命令的基于时间的性能为`O(1)`。'
- en: '`RPUSH`: This command prepends the values to the list from the right of the
    list. Time-based performance for this command is `O (1)`.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RPUSH`：此命令从列表的右侧添加值。此命令的基于时间的性能为`O(1)`。'
- en: '`LPUSHX`: This command prepends the values to the list from the left of the
    list if the key exists. Time-based performance for this command is `O (1)`.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LPUSHX`：此命令如果键存在，则从列表的左侧添加值。此命令的基于时间的性能为`O(1)`。'
- en: '`RPUSHX`: This command prepends the values to the list from the right of the
    list if the key exists. Time-based performance for this command is `O (1)`.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RPUSHX`：此命令如果键存在，则从列表的右侧添加值。此命令的基于时间的性能为`O(1)`。'
- en: '`LINSERT`: This command inserts a value in the list after the *pivot* position.
    This pivot position is calculated from the left. Time-based performance for this
    command is `O (N)`.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LINSERT`：此命令在*枢轴*位置之后插入一个值。此枢轴位置是从左边计算的。此命令的基于时间的性能为`O(N)`。'
- en: '`LSET`: This command sets the value of an element in a list based on the index
    mentioned. Time-based performance for this command is `O (N)`.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LSET`：此命令根据指定的索引在列表中设置元素的值。此命令的基于时间的性能为`O(N)`。'
- en: '`LRANGE`: This command gets the sub list of elements based on the start index
    and the end index. Time-based performance for this command is *O (S+N)*. Here
    *S* is the start of the offset and *N* is the number of elements we are asking
    for in the list. What this means is that the time taken to find the element will
    increase if the offset is farther away from the head and the length of the range
    is higher.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LRANGE`：此命令根据起始索引和结束索引获取元素的子列表。此命令的基于时间的性能为*O(S+N)*。这里*S*是偏移的起始位置，*N*是我们在列表中请求的元素数量。这意味着，如果偏移离头部越远，范围的长度越大，查找元素所需的时间就会增加。'
- en: '**Data clean commands**: Following are the example of this type of commands:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据清理命令**：以下是此类命令的示例：'
- en: '`LTRIM`: This command deletes the elements outside the range specified. Time-based
    performance for this command is `O (N)`. Here `N` is the length of the list.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LTRIM`：此命令删除指定范围之外的元素。此命令的基于时间的性能为`O(N)`。这里的`N`是列表的长度。'
- en: '`RPOP`: This command removes the last element. Time-based performance for this
    command is `O (1)`.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RPOP`：此命令删除最后一个元素。此命令的基于时间的性能为`O(1)`。'
- en: '`LREM`: This command removes the element at the index point specified. Time-based
    performance for this command is `O (N)`. Here `N` is the length of the list.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LREM`：此命令删除指定索引点的元素。此命令的基于时间的性能为`O(N)`。这里的`N`是列表的长度。'
- en: '`LPOP`: This command removes the first element of the list. Time-based performance
    for this command is `O (1)`.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LPOP`：此命令删除列表的第一个元素。此命令的基于时间的性能为`O(1)`。'
- en: '**Utility commands**: Following are the commands that come under this type:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实用命令**：以下是此类命令的示例：'
- en: '`LINDEX`: This command gets the element from the list based on the index mentioned.
    Time-based performance for this command is `O (N)`. Here `N` is the number of
    elements it has to traverse to reach the element at the desired index.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LINDEX`：此命令根据指定的索引获取列表中的元素。该命令的时间性能为`O（N）`。这里的`N`是要遍历以达到所需索引处的元素数量。'
- en: '`LLEN`: This command gets the length of the list. Time-based performance for
    this command is `O (1)`.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LLEN`：此命令获取列表的长度。该命令的时间性能为`O（1）`。'
- en: '**Advanced command**: Following commands come under this type:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级命令**：此类型包括以下命令：'
- en: '`BLPOP`: This command gives the element from the index, which is nonempty,
    in the sequence of lists mentioned or blocks the call if there is no value in
    the head till the time at least a value is set or timeout occurs. The alphabet
    `B` in `BLPOP` hints this call to be blocking. Time-based performance for this
    command is `O (1)`.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BLPOP`：此命令从所述列表序列中的非空索引处获取元素，如果头部没有值，则阻止调用，直到至少设置一个值或超时发生。`BLPOP`中的字母`B`提示此调用是阻塞的。该命令的时间性能为`O（1）`。'
- en: '`BRPOP`: This command gives the element from the trail which is nonempty in
    the sequence of lists mentioned or blocks the call if there is no value in the
    head till the time at least a value is set or timeout occurs. Time-based performance
    for this command is `O (1)`.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BRPOP`：此命令从所述列表序列中的尾部获取元素，如果头部没有值，则阻止调用，直到至少设置一个值或超时发生。该命令的时间性能为`O（1）`。'
- en: '`RPOPLPUSH`: This command operates on two lists. Let''s say source list and
    destination list, where it will take the last element on the source list and push
    it to the first element of the destination list. Time-based performance for this
    command is `O (1)`.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RPOPLPUSH`：此命令作用于两个列表。假设源列表和目标列表，它将获取源列表的最后一个元素并将其推送到目标列表的第一个元素。该命令的时间性能为`O（1）`。'
- en: '`BRPOPLPUSH`: This command is the *blocking* variety of the `RPOPLPUSH` command.
    In this, if the source list is empty then Redis will block the operation until
    a value is pushed into the list or a timeout is reached. These commands can be
    used to create queues. Time-based performance for this command is `O (1)`.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BRPOPLPUSH`：此命令是`RPOPLPUSH`命令的*阻塞*变体。在这种情况下，如果源列表为空，则Redis将阻止操作，直到将一个值推送到列表中或达到超时。这些命令可用于创建队列。该命令的时间性能为`O（1）`。'
- en: 'A sample program to demonstrate the simple usage of commands for lists is given
    as follows. Execute the program and analyze the result yourself:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个演示列表命令简单用法的示例程序。执行程序并自行分析结果：
- en: '[PRE3]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Use case scenario
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用例场景
- en: List provides with a sematic interface to store data sequentially in a Redis
    server where the *write* speeds are more desirable than *read* performance. For
    example, log messages.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表提供了一个语义接口，用于在Redis服务器中按顺序存储数据，其中*写*速度比*读*性能更可取。例如，日志消息。
- en: The Sets data type
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合数据类型
- en: Redis Sets are data structures that are an unordered collection of SDS. The
    values in Sets are unique and cannot have duplicate value. One of the interesting
    aspects in terms of performance of Redis Sets is that they show constant timing
    for adding, removing, and checking for existence of an element. The maximum number
    of entries that can be in a Set is 2^32,–that is 4 billion per Set. These Set
    values are unordered in nature. From the look of it, Sets might look like lists,
    but then they have a different implementation, which makes them perfect candidates
    for solving problems around Set theory.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Redis集合是无序的SDS的数据结构集合。集合中的值是唯一的，不能有重复值。在Redis集合的性能方面，一个有趣的方面是，它们在添加、删除和检查元素存在方面显示出恒定的时间。集合中可以有的最大条目数为2^32，即每个集合最多有40亿个条目。这些集合值是无序的。从外观上看，集合可能看起来像列表，但它们有不同的实现，这使它们成为解决集合理论问题的完美候选者。
- en: '![The Sets data type](img/1794_0123OS_03_05.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![集合数据类型](img/1794_0123OS_03_05.jpg)'
- en: The Sets data types
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 集合数据类型
- en: 'The commands in Redis for the Sets can be categorized in the following parts:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Redis中用于集合的命令可以分为以下几部分：
- en: '**Setters and getters commands**: This type includes the following command:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置器和获取器命令**：此类型包括以下命令：'
- en: '`SADD`: This command adds one or more elements to the Set. Time-based performance
    for this command is `O (N)`. Here `N` is the number of elements that needs to
    be added.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SADD`：此命令向集合中添加一个或多个元素。该命令的时间性能为`O（N）`。这里的`N`是需要添加的元素数量。'
- en: '**Data clean commands**: Following are some commands that come under this category:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据清理命令**：以下是属于此类别的一些命令：'
- en: '`SPOP`: This command removes and returns a random element from the set. Time-based
    performance for this command is `O (1)`.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SPOP`：此命令从集合中移除并返回一个随机元素。该命令的时间性能为`O（1）`。'
- en: '`SREM`: This command removes and returns the specified elements from the set.
    Time-based performance for this command is `O (N)`.Here `N` is the number of elements
    to be removed.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SREM`：此命令从集合中移除并返回指定的元素。该命令的时间性能为`O（N）`。这里的`N`是要移除的元素数量。'
- en: '**Utility Commands**: Following are the commands that come under this type:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实用命令**：以下是属于此类型的命令：'
- en: '`SCARD`: This command gets the number of elements in a Set. Time-based performance
    for this command is `O (1)`.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCARD`：此命令获取集合中的元素数量。该命令的时间性能为`O（1）`。'
- en: '`SDIFF`: This command gets the list of elements from the first set after subtracting
    its elements from the other mentioned sets. Time-based performance for this command
    is `O (N)`. Here `N` is the number of elements in all the sets.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SDIFF`：此命令从其他所述集合中减去其元素后获取第一个集合的元素列表。该命令的时间性能为`O（N）`。这里的`N`是所有集合中的元素数量。'
- en: '`SDIFFSTORE`: This command gets the list of elements from the first set after
    subtracting its elements from the other mentioned sets. This set is pushed into
    another Set. Time-based performance for this command is `O (N)`. Here `N` is the
    number of elements in all the sets.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SDIFFSTORE`：此命令从其他指定的集合中减去第一个集合的元素后获取元素列表。然后将这个集合推送到另一个集合中。该命令的基于时间的性能为`O(N)`。这里的`N`是所有集合中元素的数量。'
- en: '`SINTER`: This command gets the common elements in all the sets mentioned.
    Time-based performance for this command is `O (N * M)`. Here `N` is the cardinality
    of the smallest set and `M` is the number of sets. What basically is happening
    here is that Redis will take the smallest set and look for common elements between
    this set and other sets. The resultant sets are again compared for common elements,
    such as the preceding process, until only one set remains with the desired result.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SINTER`：此命令获取所有指定集合中的公共元素。该命令的基于时间的性能为`O(N*M)`。这里的`N`是最小集合的基数，`M`是集合的数量。基本上是Redis将取最小集合，并查找该集合与其他集合之间的公共元素。然后再次比较结果集中的公共元素，如前述过程，直到只剩下一个集合包含所需的结果。'
- en: '`SINTERSTORE`: This command works in the same way as command `SINTER` but here
    the result is stored in a mentioned set. Time-based performance for this command
    is `O (N * M)`. Here `N` is the cardinality of the smallest set and `M` is the
    number of sets.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SINTERSTORE`：此命令与`SINTER`命令的工作方式相同，但结果存储在指定的集合中。该命令的基于时间的性能为`O(N*M)`。这里的`N`是最小集合的基数，`M`是集合的数量。'
- en: '`SISMEMBER`: This command finds if the value is a member of set. Time-based
    performance for this command is `O (1)`.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SISMEMBER`：此命令查找值是否是集合的成员。该命令的基于时间的性能为`O(1)`。'
- en: '`SMOVE`: This command moves members from one set to another set. Time-based
    performance for this command is `O (1)`.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SMOVE`：此命令将成员从一个集合移动到另一个集合。该命令的基于时间的性能为`O(1)`。'
- en: '`SRANDMEMBER`: This command gets one or multiple random members from the set.
    Time-based performance for this command is `O (N)`. Here `N` is the number of
    members passed.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SRANDMEMBER`：此命令从集合中获取一个或多个随机成员。该命令的基于时间的性能为`O(N)`。这里的`N`是传递的成员数量。'
- en: '`SUNION`: This command adds multiple sets. Time-based performance for this
    command is `O (N)`. Here `N` is the number of elements in all the sets.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SUNION`：此命令添加多个集合。该命令的基于时间的性能为`O(N)`。这里的`N`是所有集合中元素的数量。'
- en: '`SUNIONSTORE`: This command adds multiple sets and stores the result in a set.
    Time-based performance for this command is `O (N)`. Here `N` is the number of
    elements in all the sets.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SUNIONSTORE`：此命令将多个集合添加到一个集合中并将结果存储在一个集合中。该命令的基于时间的性能为`O(N)`。这里的`N`是所有集合中元素的数量。'
- en: 'A sample program to demonstrate the simple usage of commands for sets is given
    as follows. Execute the program and analyze the result yourself:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于集合的简单用法的示例程序。执行程序并自行分析结果：
- en: '[PRE4]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Use case scenario
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用情景
- en: Sets provides with a sematic interface to store data as a set in Redis server.
    The use cases for this kind of data would be more for an analytics purpose, for
    example how many people browse the product page and how many end up purchasing
    the product.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 集合提供了一种语义接口，可以将数据存储为Redis服务器中的一个集合。这种类型数据的用例更多用于分析目的，例如有多少人浏览了产品页面，有多少最终购买了产品。
- en: The Sorted Sets data type
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有序集合数据类型
- en: 'Redis Sorted Sets are very much like Redis Sets in the way that they don''t
    store duplicate values, but the area where they differ from Redis Sets is that
    the values are sorted on the basis of a score, or integer, float values. These
    values are provided while setting a value in the Set. The performance of these
    Sorted Sets is proportional to the logarithm of the number of elements. The data
    is always kept in a sorted way. This concept is diagrammatically explained in
    the following figure:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Redis有序集合与Redis集合非常相似，它们都不存储重复值，但它们与Redis集合不同的地方在于，它们的值是根据分数或整数、浮点值进行排序的。在设置集合中的值时提供这些值。有序集合的性能与元素数量的对数成正比。数据始终以排序的方式保存。这个概念在下图中以图表的方式解释：
- en: '![The Sorted Sets data type](img/1794_0123OS_03_06.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![有序集合数据类型](img/1794_0123OS_03_06.jpg)'
- en: The concept of Sorted Sets
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有序集合的概念
- en: 'The commands in Redis for the Sorted Sets can be categorized in the following
    parts:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Redis中有关有序集合的命令可以分为以下几个部分：
- en: '**Setters and getters commands**: Following are the commands that come under
    this category:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置器和获取器命令**：以下是属于此类别的命令：'
- en: '`ZADD`: This command adds or updates one or more members to a Sorted Set. Time-based
    performance for this command is `O (log (N))`. Here `N` is the number of elements
    in the Sorted Sets.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZADD`：此命令向有序集合中添加或更新一个或多个成员。该命令的基于时间的性能为`O(log(N))`。这里的`N`是有序集合中的元素数量。'
- en: '`ZRANGE`: This command gets the specified range by rank of elements in the
    Sorted Set. Time-based performance for this command is *O (log (N) +M)*. Here
    `N` is the number of elements and `M` is the number of elements returned.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZRANGE`：此命令根据有序集合中元素的排名获取指定范围。该命令的基于时间的性能为`O(log(N)+M)`。这里的`N`是元素的数量，`M`是返回的元素的数量。'
- en: '`ZRANGEBYSCORE`: This command gets elements from the Sorted Sets within the
    range by score given. The values in the default Set are ascending by nature. Time-based
    performance for this command is `O (log (N) +M)`. Here `N` is the number of elements
    and `M` is the number of elements returned.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZRANGEBYSCORE`：此命令根据给定的分数范围从有序集合中获取元素。默认集合中的值是按升序排列的。该命令的基于时间的性能为`O(log(N)+M)`。这里的`N`是元素的数量，`M`是返回的元素的数量。'
- en: '`ZREVRANGEBYSCORE`: This command gets elements from the Sorted Sets within
    the score given. Time-based performance for this command is `O (log (N) +M)`.
    Here `N` is the number of elements and `M` is the number of elements removed.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZREVRANGEBYSCORE`：此命令根据给定的分数从有序集合中获取元素。该命令的基于时间的性能为`O(log(N)+M)`。这里的`N`是元素的数量，`M`是被移除的元素的数量。'
- en: '`ZREVRANK`: This command returns the rank of the member in the Sorted Set.
    Time-based performance for this command is `O (log (N))`.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZREVRANK`：此命令返回有序集合中成员的排名。该命令的基于时间的性能为`O(log(N))`。'
- en: '`ZREVRANGE`: This command returns the specified range of elements in the Sorted
    Set. Time-based performance for this command is `O (log (N) + M)`.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZREVRANGE`：此命令返回有序集合中指定范围的元素。该命令的基于时间的性能为`O(log(N) + M)`。'
- en: '**Data clean commands**: Following are the commands that come under this category:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据清理命令**：以下是属于此类别的命令：'
- en: '`ZREM`: This command removes the specified members in the Sorted Set. Time-based
    performance for this command is `O (M*log (N))`. Here `M` is number of elements
    removed and `N` is the number of elements in the Sorted Set.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZREM`：此命令从有序集合中移除指定的成员。该命令的基于时间的性能为`O(M*log(N))`。这里的`M`是移除的元素数量，`N`是有序集合中的元素数量。'
- en: '`ZREMRANGEBYRANK`: This command removes the members in a Sorted Set within
    the given indexes. Time-based performance for this command is `O (log (N) * M)`.
    Here `N` is the number of elements and `M` is the number of elements removed.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZREMRANGEBYRANK`：此命令在给定的索引范围内移除有序集合中的成员。该命令的基于时间的性能为`O(log(N)*M)`。这里的`N`是元素数量，`M`是被移除的元素数量。'
- en: '`ZREMRANGEBYSCORE`: This command removes the members in a Sorted Set within
    the given scores. Time-based performance for this command is `O (log (N) * M)`.
    Here `N` is the number of elements and `M` is the number of elements removed.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZREMRANGEBYSCORE`：此命令在给定分数范围内移除有序集合中的成员。该命令的基于时间的性能为`O(log(N)*M)`。这里的`N`是元素数量，`M`是被移除的元素数量。'
- en: '**Utility commands**: Following are the commands that come under this category:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实用命令**：以下是属于此类别的命令：'
- en: '`ZCARD`: This command gets the number of members in a Sorted Set. Time-based
    performance for this command is `O (1))`.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZCARD`：此命令获取有序集合中成员的数量。该命令的基于时间的性能为`O(1)`。'
- en: '`ZCOUNT`: This command gets the number of members in a Sorted Set within the
    score boundaries. Time-based performance for this command is `O (log (N) * M)`.
    Here `N` is the number of elements and `M` is the result.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZCOUNT`：此命令获取有序集合中在分数范围内的成员数量。该命令的基于时间的性能为`O(log(N)*M)`。这里的`N`是元素数量，`M`是结果。'
- en: '`ZINCRBY`: This command increases the score of an element in the Sorted Set.
    Time-based performance for this command is `O (log (N))`. Here `N` is the number
    of elements in the Sorted Set.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZINCRBY`：此命令增加有序集合中元素的分数。该命令的基于时间的性能为`O(log(N))`。这里的`N`是有序集合中的元素数量。'
- en: '`ZINTERSTORE`: This command calculates the common elements in the Sorted Sets
    given by the specified keys, and stores the result in destination Sorted Set.
    Time based performance for this command is `O (N*K) + O (M*log (M))`. Here `N`
    is the smallest Sorted Set, `K` is the number of input Set, and `M` is the number
    of elements in the result Sorted Set.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZINTERSTORE`：此命令计算由指定键给出的有序集合中的公共元素，并将结果存储在目标有序集合中。该命令的基于时间的性能为`O(N*K) + O(M*log(M))`。这里的`N`是最小的有序集合，`K`是输入集的数量，`M`是结果有序集合中的元素数量。'
- en: '`ZRANK`: This command gets the index of the element in the Sorted Set. Time-based
    performance for this command is `O (log (N))`.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZRANK`：此命令获取有序集合中元素的索引。该命令的基于时间的性能为`O(log(N))`。'
- en: '`ZSCORE`: This command returns the score of the member. Time-based performance
    for this command is `O (1)`.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZSCORE`：此命令返回成员的分数。该命令的基于时间的性能为`O(1)`。'
- en: '`ZUNIONSTORE`: This command computes the union of keys in the given Sorted
    Set and stores the result in the resultant Sorted Set. Time-based performance
    for this command is `O (N) +O (M log (M))`. Here `N` is the sum of sizes of input
    Sorted Set and `M` is the number of elements in the Sorted Set.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZUNIONSTORE`：此命令计算给定有序集合中键的并集，并将结果存储在结果有序集合中。该命令的基于时间的性能为`O(N) + O(M log(M))`。这里的`N`是输入有序集合大小的总和，`M`是有序集合中的元素数量。'
- en: 'A sample program to demonstrate the simple usage of commands for Sorted Sets
    is given as follows. Execute the program and analyze the result yourself:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个演示有序集合命令简单用法的示例程序。执行程序并自行分析结果：
- en: '[PRE5]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Use case scenario
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用情景
- en: Sorted Sets provide with a sematic interface to store data as a Sorted Set in
    Redis server. The use cases for this kind of data would be more in analytics purpose
    and in the gaming world. For example, how many people played a particular game
    and categorizing them on the basis of their score.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有序集合提供了一个语义接口，可以将数据存储为Redis服务器中的有序集合。这种数据的用例更多地用于分析目的和游戏世界中。例如，有多少人玩了特定的游戏，并根据他们的得分对他们进行分类。
- en: Communication protocol – RESP
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信协议 - RESP
- en: 'Redis in principle works on a client-server model. So like in every client-server
    model, the client and the server need to have a protocol to communicate with.
    Communication protocol can be understood as a message exchange taking place between
    client and the server (and vice versa) based on some fixed agreement or rule between
    them. So every communication protocol has to adhere to some syntax and semantics,
    which should be followed by both the parties (client and server) for the communication
    to be successful. There is also another dimension to this communication protocol,
    which is the network layer interaction, or better known as TCP/IP Model. The TCP/IP
    Model can be divided into four parts:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Redis原则上是基于客户端-服务器模型工作的。因此，就像在每个客户端-服务器模型中一样，客户端和服务器需要有一个通信协议。通信协议可以理解为基于客户端和服务器之间的某种固定协议或规则进行的消息交换。因此，每个通信协议都必须遵循一些语法和语义，这些语法和语义应该由双方（客户端和服务器）遵循，以便通信成功。此外，还有另一个维度的通信协议，即网络层交互，或者更为人所熟知的TCP/IP模型。TCP/IP模型可以分为四个部分：
- en: Application layer
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用层
- en: Transport layer
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输层
- en: Internet layer
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网层
- en: Network interface
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络接口
- en: 'Since the communication protocol between two applications is at application
    layer, so we intend to focus only on the application layer. The following diagram
    is a representation of what happens in the communication protocol level at application
    layer:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两个应用程序之间的通信协议位于应用层，因此我们打算只关注应用层。以下图表是应用层通信协议级别上发生的事情的表示：
- en: '![Communication protocol – RESP](img/1794_0123OS_03_07.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![通信协议 - RESP](img/1794_0123OS_03_07.jpg)'
- en: Representation of communication protocol at application layer
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层通信协议的表示
- en: In any application protocol, we will have a header and body. The header will
    contain Meta information about the protocol, that is protocol name, version, security
    related details, Meta information about the request (number of arguments, type
    of arguments), and so on, and the body will contain the actual data. The first
    thing any server will do is to parse the header information. If the header gets
    successfully parsed, then only rest of the body gets processed. In a way, the
    server and the client need to have a pipe-like architecture to process header
    messages.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何应用程序协议中，我们都会有头部和主体。头部将包含有关协议的元信息，即协议名称、版本、安全相关细节、关于请求的元信息（参数数量、参数类型）等等，而主体将包含实际的数据。任何服务器的第一件事就是解析头部信息。如果头部成功解析，那么才会处理主体的其余部分。在某种程度上，服务器和客户端需要具有类似管道的架构来处理头部消息。
- en: 'The protocol used for Redis is fairly simple to understand. This section will
    focus on the communication protocol used in Redis. By the end of this section,
    we would have understood the protocol and created a client that connects to Redis
    server, sends the request, and gets the response from the server. Like in any
    other protocol, the Redis protocol also has a header (Meta information) and a
    body part (request data). The request data part consists of information such as
    command and command data. In response, it will contain parts such as Meta information
    (if the request was a success or failure) and actual response data payload. The
    following explains this concept:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Redis使用的协议相当简单易懂。本节将重点介绍Redis中使用的通信协议。在本节结束时，我们将了解协议并创建一个连接到Redis服务器的客户端，发送请求并从服务器获取响应。与任何其他协议一样，Redis协议也有一个头部（元信息）和一个主体部分（请求数据）。请求数据部分包括命令和命令数据等信息。在响应中，它将包含元信息（如果请求成功或失败）和实际的响应数据负载。以下解释了这个概念：
- en: '![Communication protocol – RESP](img/1794_0123OS_03_08.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![通信协议 - RESP](img/1794_0123OS_03_08.jpg)'
- en: Representation of Meta information and request data
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 元信息和请求数据的表示
- en: 'Any request in Redis basically constitutes of two parts, and they are discussed
    as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Redis中的任何请求基本上由两部分组成，并且它们如下所述：
- en: Meta information about the request, say, **Number of arguments**.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于请求的元信息，比如**参数数量**。
- en: 'Body part will further have three more pieces of information:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Body部分还将有三个更多的信息：
- en: Number of bytes for every argument
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个参数的字节数
- en: The actual argument
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际参数
- en: '**Carriage Return and Line Feeds** (**CRLF**)'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回车和换行**（**CRLF**）'
- en: '![Communication protocol – RESP](img/1794_0123OS_03_09.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![通信协议 - RESP](img/1794_0123OS_03_09.jpg)'
- en: Representation of the body part of a request
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的主体部分的表示
- en: So the information that we will hold in the Meta information will be two, since
    this is the number of the arguments we will be passing as indicative, as shown
    in the preceding figure. In the body part, we will capture information, such as
    what is the number of bytes of argument we are sending, that is if the name of
    the argument is `GET`, then the number of bytes would be `3`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将在元信息中保存的信息将是两个，因为这是我们将传递的参数的数量，如前图所示。在主体部分，我们将捕获信息，例如我们发送的参数的字节数是多少，即如果参数的名称是`GET`，那么字节数将是`3`。
- en: 'The response in Redis can be segregated into two types:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Redis中的响应可以分为两种类型：
- en: 'Response for commands which will go and add or manipulate data (no return value
    is expected):'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将去添加或操作数据的命令的响应（不期望返回值）：
- en: '`+` sign suggesting the request was success'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`符号表示请求成功'
- en: '`-` sign suggesting the request was failure'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-`符号表示请求失败'
- en: 'Response for commands which will go and fetch data (string type return value
    is expected):'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将去获取数据的命令的响应（期望返回字符串类型的值）：
- en: '`$-1` will be the response if error is the response'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果错误是响应，则`$-1`将是响应
- en: '`$` and the size of the response if the response is a success followed by the
    actual string data'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$`以及如果响应成功则响应的大小，然后是实际的字符串数据'
- en: 'As an exercise, let''s make a small test client in Java code and record our
    interactions with the Redis server. The client is just a sample to educate on
    the Redis protocol and does not intend to replace the client we will use in the
    book, that is Jedis. Let''s get a brief overview of the classes participating
    in the small test client. For starters, from a design patterns perspective, we
    will be using command pattern for this sample:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，让我们用Java代码制作一个小型测试客户端，并记录我们与Redis服务器的交互。该客户端只是一个示例，用于教育Redis协议，并不打算替换我们在本书中将使用的客户端，即Jedis。让我们简要概述参与小型测试客户端的类。首先，从设计模式的角度来看，我们将为此示例使用命令模式：
- en: '`Command`: This class is the abstract class and all the command classes will
    be extended from this class.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Command`：这个类是抽象类，所有的命令类都将从这个类扩展。'
- en: '`GetCommand`: This is the class which will fetch the string value for the key
    given and print the server response and response values.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetCommand`：这是一个类，将获取给定键的字符串值并打印服务器响应和响应值。'
- en: '`SetCommand`: This is the class which will set the key and the value data for
    the command and print the server response.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetCommand`：这是一个类，将为命令设置键和值数据并打印服务器响应。'
- en: '`ConnectionProperties`: This is the interface which will hold the host and
    the port address. (This is going to behave more like a properties file.)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConnectionProperties`：这是将保存主机和端口地址的接口。（这将更像是一个属性文件。）'
- en: '`TestClient`: This is the class that is going to call all the commands.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestClient`：这是将调用所有命令的类。'
- en: 'Following is the domain diagram for the simple test client application. Here
    the command objects are doing the bulk of the job:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是简单测试客户端应用程序的领域图。这里命令对象承担了大部分工作：
- en: '![Communication protocol – RESP](img/1794_0123OS_03_10.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![通信协议 - RESP](img/1794_0123OS_03_10.jpg)'
- en: Domain diagram for a simple client application
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 简单客户端应用程序的领域图
- en: 'A look into the code will give more idea and clarity about the simple test
    client for Redis:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 查看代码将更清楚地了解Redis的简单测试客户端：
- en: '`ConnectionProperties.java`: This is the class that will hold the configuration
    value for the host and the port.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConnectionProperties.java`：这是将保存主机和端口的配置值的类。'
- en: '[PRE6]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`TestClient.java`: As shown, this is the client which will execute the commands
    for setting the value and fetching the value.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestClient.java`：如图所示，这是客户端，将执行设置值和获取值的命令。'
- en: '[PRE7]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If everything goes right, following is the message that you should see in your
    console. Please remember this is a successful operation and your console should
    look similar to the following screenshot:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该在控制台中看到以下消息。请记住，这是一个成功的操作，您的控制台应该类似于以下截图：
- en: '![Communication protocol – RESP](img/1794_0123OS_03_11.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![通信协议 - RESP](img/1794_0123OS_03_11.jpg)'
- en: 'Here in this sample, we executed two commands consecutively:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们连续执行了两个命令：
- en: '`SetCommand`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetCommand`'
- en: '`GetCommand`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetCommand`'
- en: The result of `SetCommand` is `+OK`. The `+` sign indicates that the server
    has returned a success result followed by the message `OK`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetCommand`的结果是`+OK`。`+`符号表示服务器返回了成功的结果，后跟消息`OK`。'
- en: 'The result of `GetCommand` is a multi line result. The first line is a string
    `$32`, which means the size of the result is 32 bytes long, followed by the result
    `Hello world : simple test client`.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetCommand`的结果是多行结果。第一行是字符串`$32`，表示结果的大小为32个字节，后跟结果`Hello world : simple test
    client`。'
- en: 'Now, let''s attempt to pass a key that does not exist in the `Get` command.
    The code snippet will look something like shown next (key passed in `wrong-key`,
    which does not exist):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试传递一个在`Get`命令中不存在的键。代码片段将看起来像下面显示的样子（在`wrong-key`中传递的键不存在）：
- en: '[PRE8]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The result of the preceding code should look something like the `$-1` command.
    Here the return value is null since the key does not exist. So the length is `-1`.
    Going forward, we will wrap this message with something more human readable, like
    `This key does not exist!` Following are some of the classes discussed:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的结果应该看起来像`$-1`命令。这里返回值为null，因为键不存在。因此长度为`-1`。接下来，我们将用更易读的方式包装这条消息，比如`This
    key does not exist!`以下是一些讨论过的类：
- en: '`Command.java`: This is the abstract class to which all the commands would
    extend to. This class has the responsibility to instantiate a socket for the implementing
    commands and create a proper payload to be sent to the Redis server. Understanding
    this will give us a hint of how actually the Redis server accepts requests.![Communication
    protocol – RESP](img/1794_0123OS_03_12.jpg)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Command.java`：这是所有命令都将扩展的抽象类。该类负责为实现命令实例化套接字，并创建要发送到Redis服务器的适当有效负载。了解这一点将给我们一个提示，即Redis服务器实际上是如何接受请求的。![通信协议
    - RESP](img/1794_0123OS_03_12.jpg)'
- en: Representation of Command.java
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Command.java的表示
- en: 'The first character is the `*` character followed by **number of arguments**
    that we will pass. This means that if we intend to do a **Set** command, that
    is **SET MSG Hello** `,` then the total number of arguments is three here. If
    we intend to pass a **Get** command such as **GET MSG,** then the number of arguments
    is two. Followed by the number of arguments, we will use **CRLF** as a separator.
    The subsequent messages will follow a pattern which will get repeated. The pattern
    is very simple to understand, that is **$** followed by the length of the argument
    in bytes followed by **CRLF** followed by argument itself. If we have more arguments,
    then the same pattern is followed, but then they are separated by CRLF separator.
    Following is the code for `Command.java`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字符是`*`字符，后跟**我们将传递的参数数量**。这意味着如果我们打算执行**Set**命令，即**SET MSG Hello**，那么这里的参数总数是三。如果我们打算传递**Get**命令，比如**GET
    MSG**，那么参数数量是两。在参数数量之后，我们将使用**CRLF**作为分隔符。随后的消息将遵循一个重复的模式。这个模式非常简单易懂，即**$**后跟参数的字节长度，后跟**CRLF**，后跟参数本身。如果有更多的参数，那么将遵循相同的模式，但它们将由CRLF分隔符分隔。以下是`Command.java`的代码：
- en: '[PRE9]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code is simple to understand and it does preparation and formatting of the
    message payload. The `Command` class has two methods that are abstract and need
    to be implemented by the implementing command. Apart from this, `Command` class
    creates a new socket based on the properties set in `ConnectionProperties.java`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 代码简单易懂，它对消息有效负载进行准备和格式化。`Command`类有两个抽象方法，需要由实现命令来实现。除此之外，`Command`类根据`ConnectionProperties.java`中设置的属性创建一个新的套接字。
- en: '`GetCommand.java`: This is the class that implements the `GET KEY` command.
    The class extends the `Command.java`. Following is the source code for `GetCommand`:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetCommand.java`：这是实现`GET KEY`命令的类。该类扩展了`Command.java`。以下是`GetCommand`的源代码：'
- en: '[PRE10]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The implementing class does two things in principle. First it passes the argument
    array with a proper value to the super class, which formats it the way Redis will
    understand, and then, it sends the payload to the Redis server and prints the
    result.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 实现类原则上做两件事。首先，它将参数数组传递给超类，并将其格式化为Redis能理解的方式，然后将有效负载发送到Redis服务器并打印结果。
- en: '`SetCommand`: This is similar to the previous command but in this, we will
    be setting the value. The class will extend the `Command.java` class. Following
    is the source code for `SetCommand`:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetCommand`：这与前一个命令类似，但在这个类中，我们将设置值。该类将扩展`Command.java`类。以下是`SetCommand`的源代码：'
- en: '[PRE11]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This command is similar to the previous command in that it does two things in
    principle. First it passes the argument array in with a proper value to the super
    class, which formats it the way Redis will understand, and it then, passes the
    payload to the Redis server and prints the result.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令与之前的命令类似，原则上有两个作用。首先，它将参数数组传递给超类，并使用适当的值对其进行格式化，以便Redis能够理解，然后将有效负载传递给Redis服务器并打印结果。
- en: Have fun compiling the program and running it; add more commands and extend
    it to suit your business requirements. I would strongly recommend using Jedis
    as it is stable, its community is very active, and it provides implementation
    for newer commands getting introduced with newer versions of Redis.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 编译程序并运行它时要玩得开心；添加更多命令并扩展它以满足您的业务需求。我强烈建议使用Jedis，因为它很稳定，社区非常活跃，并且提供了对Redis新版本引入的新命令的实现。
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we brushed with various data structures or data types which
    Redis provides. We also wrote a few programs to see them working and made an attempt
    to understand how and where these data types can be used. Finally, we understood
    how Redis communicates with the clients and vice versa.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涉及了Redis提供的各种数据结构或数据类型。我们还编写了一些程序来查看它们的工作原理，并尝试理解这些数据类型可以如何使用。最后，我们了解了Redis如何与客户端进行通信，以及反之亦然。
- en: In the next chapter, we will take our understanding a notch higher and make
    an attempt to understand Redis Server and the functionality that'll handle it.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步加深对Redis服务器的理解，并尝试理解将处理它的功能。
