- en: Chapter 4. Functions in the Redis Server
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。Redis服务器中的功能
- en: In the previous chapters, we saw some features of Redis Server that make it
    a key-value NoSQL. We also saw that Redis, apart from storing vanilla key-values,
    also provides semantics to store data in a structured way. This feature in itself
    makes Redis stand out in the crowd, since most of the other databases (RDBMS and
    other NoSQL) don't provide interfaces which programmers can use. Other data stores
    have a fixed way of storing information, such as documents or maps, and programmers
    have to convert their data into these semantics to hold information. However,
    in Redis, programmers can store information in the same sematic that they use
    in their programs, such as a map, list, and so on. This in way provides a better
    and an easier way of understanding the program. Apart from that, Redis provides
    functions which elevate Redis from being just a data store to more like a framework
    builder, or in other words, more like a Swiss army knife. In this chapter, we
    will explore these functions and try to understand them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们看到了Redis服务器的一些特性，使其成为键值NoSQL。我们还看到Redis除了存储原始键值之外，还提供了以结构化方式存储数据的语义。这个特性使Redis在众多数据库中脱颖而出，因为大多数其他数据库（关系型数据库和其他NoSQL）都没有提供程序员可以使用的接口。其他数据存储有固定的存储信息方式，如文档或映射，程序员必须将他们的数据转换为这些语义来保存信息。然而，在Redis中，程序员可以以与他们在程序中使用的相同语义存储信息，如映射，列表等。这种方式提供了更好更容易理解程序的方式。除此之外，Redis提供了功能，使其不仅仅是一个数据存储，更像是一个框架构建者，或者换句话说，更像是一把瑞士军刀。在本章中，我们将探讨这些功能并试图理解它们。
- en: 'Following are the functionalities that we would be discussing:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将讨论的功能：
- en: Real time messaging (Publish/Subscribe)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时消息传递（发布/订阅）
- en: Pipeline
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道
- en: Transaction
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务
- en: Scripting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本
- en: Connection management
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接管理
- en: Real-time messaging (PUB/SUB)
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时消息传递（发布/订阅）
- en: 'Enterprises and social media solutions use messaging in a similar way, and
    in a way, this forms the backbone of any framework or any solution. Messaging
    also enables us to have architectures which are loosely coupled where components
    interact via messages and events. Redis provides mechanism to have real time messaging
    between components. Unlike other messaging systems, the big difference in the
    messaging model provided in Redis is as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 企业和社交媒体解决方案以类似的方式使用消息传递，从某种程度上说，这构成了任何框架或解决方案的支柱。消息传递还使我们能够拥有松散耦合的架构，其中组件通过消息和事件进行交互。Redis提供了在组件之间进行实时消息传递的机制。与其他消息系统不同，Redis中提供的消息模型的最大区别如下：
- en: It does not store the message after delivering it
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在传递消息后不会存储消息
- en: It does not store the message if the client (subscriber) was unable to consume
    it
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果客户端（订阅者）无法消费消息，则不会存储消息
- en: This can be a disadvantage if compared to a traditional messaging system but
    is advantageous where data has importance in real time and need not be stored.
    The message is always sent sequentially. Apart from that, Redis messaging system
    is simplistic and easy to learn, and does not have the fluff of some of the other
    messaging systems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统消息系统相比，这可能是一个缺点，但在数据实时重要且无需存储的情况下是有利的。消息始终按顺序发送。除此之外，Redis消息系统简单易学，没有一些其他消息系统的多余内容。
- en: '![Real-time messaging (PUB/SUB)](img/0123OS_04_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![实时消息传递（发布/订阅）](img/0123OS_04_01.jpg)'
- en: Publish subscribe model of Redis
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Redis的发布订阅模型
- en: 'Following are the commands in Redis that can be used for creating a messaging
    framework:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Redis中可用于创建消息框架的命令：
- en: '`PUBLISH`: This will post a message to a given channel or pattern.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUBLISH`：这将向给定的频道或模式发布消息。'
- en: The time complexity for this command is given by `O (N+M)`, where `N` is the
    number of clients who have subscribed to this channel and `M` is the number of
    patterns the client is subscribed to.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的时间复杂度由`O（N+M）`给出，其中`N`是订阅此频道的客户端数，`M`是客户端订阅的模式数。
- en: '`SUBSCRIBE`: This subscribes a client to a channel for messages. For example,
    if a client is subscribed to channel `news.headlines`, then it will get any message
    published for `news.headlines` channel.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SUBSCRIBE`：这将订阅客户端以接收频道的消息。例如，如果客户端订阅了频道`news.headlines`，那么它将收到为`news.headlines`频道发布的任何消息。'
- en: The time complexity for this command is given by `O (N)`, where `N` is the number
    of channels the client is subscribed to.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的时间复杂度由`O（N）`给出，其中`N`是客户端订阅的频道数。
- en: '`PSUBSCRIBE`: This subscribes a client to channels where the pattern name matches
    the channel name. For example, suppose the channels are registered by the following
    names:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSUBSCRIBE`：这将订阅客户端到模式名称与频道名称匹配的频道。例如，假设频道由以下名称注册：'
- en: '`news.sports.cricket`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`news.sports.cricket`'
- en: '`news.sports.tennis`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`news.sports.tennis`'
- en: Then, for a pattern like `news.sports.*`, the subscriber will be getting messages
    for channels `news.sports.cricket` and `news.sports.tennis`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于像`news.sports.*`这样的模式，订阅者将收到`news.sports.cricket`和`news.sports.tennis`频道的消息。
- en: The time complexity for this command is `O (N)`, where `N` is the number of
    patterns the client is subscribed to.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的时间复杂度为`O（N）`，其中`N`是客户端订阅的模式数。
- en: '`PUBSUB`: This is a command which along with some sub-command helps to take
    a stock of patterns and channels registered in Redis.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUBSUB`：这是一个命令，结合一些子命令，可以帮助了解Redis中注册的模式和频道的情况。'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is only available as of Redis 2.8.0\. The Windows version of Redis is based
    on the 2.6 branch and does not support this command.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅适用于Redis 2.8.0版本。Windows版本的Redis基于2.6分支，不支持此命令。
- en: 'Other `PUBSUB` related commands which help in finding information regarding
    publishers and subscribers are listed as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 其他与`PUBSUB`相关的命令，可帮助查找有关发布者和订阅者的信息，如下所示：
- en: '`PUBSUB CHANNELS [pattern]`: This lists the currently active channels'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUBSUB CHANNELS [pattern]`：这列出当前活动的频道'
- en: '`PUBSUB NUMSUB [channel]`: This lists the number of subscribers to the mentioned
    channels'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUBSUB NUMSUB [channel]`：这将列出订阅指定频道的订阅者数量。'
- en: '`PUBSUB NUMPAT`: This lists the number of subscriptions to all the patterns'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布订阅 NUMPAT：这列出了对所有模式的订阅数量
- en: '`PUNSUBSCRIBE`: This command unsubscribes the client from a pattern'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUNSUBSCRIBE`：此命令取消订阅客户端的模式'
- en: '`UNSUBSCRIBE`: This command unsubscribes the client from a channel'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNSUBSCRIBE`：此命令取消订阅客户端的频道'
- en: 'Let''s have a simple program in Java using Jedis to demonstrate a simple PUB/SUB
    program. Jedis exposes interface for publishing and has all the functionalities
    supported by Redis. The interface exposed for subscribing to a message is a bit
    tricky since the subscriber should be in a ready state before the publisher publishes
    a message. This is because Redis cannot store message if the subscriber is unavailable.
    The code for publisher: `SubscriberProcessor.java`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Jedis编写一个简单的Java程序来演示一个简单的PUB/SUB程序。Jedis公开了发布的接口，并且支持Redis的所有功能。订阅消息的接口有点棘手，因为订阅者在发布者发布消息之前应该处于就绪状态。这是因为如果订阅者不可用，Redis无法存储消息。发布者的代码：`SubscriberProcessor.java`：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The subscriber processor needs to subscribe to a channel. For doing so, it
    needs to have an instance which is always in a listening mode. In this sample,
    `Subscriber.java` is the class which does so by extending Jedis PUB/SUB. This
    abstract class provides methods to manage the life cycle of the subscriber. Next
    is the code which provides necessary hooks to subscribe to a channel pattern and
    listen to messages for a channel or a pattern. The code to subscribe to a pattern
    is commented; to see it in action, we need to uncomment it and comment the code
    which is subscribing to a channel:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者处理器需要订阅一个频道。为此，它需要一个始终处于监听模式的实例。在此示例中，`Subscriber.java`是通过扩展Jedis PUB/SUB来实现的类。这个抽象类提供了管理订阅者生命周期的方法。接下来是提供必要钩子来订阅频道模式并监听频道或模式消息的代码。订阅模式的代码已被注释；要看到它的实际效果，我们需要取消注释它并注释订阅频道的代码：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Before you start the publisher to send messages to a channel, it's better to
    start the subscriber processor, which is going to listen to any message posted
    to its subscribed channel or pattern. In this case, the subscriber processor will
    be listening to a news channel or will subscribe to pattern `[news.*]`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '在启动发布者发送消息到频道之前，最好先启动订阅者处理器，该处理器将监听发布到其订阅频道或模式的任何消息。在这种情况下，订阅者处理器将监听新闻频道或将订阅模式`[news.*]`。 '
- en: 'A common class used in these samples is connection manager and the code for
    the same is listed as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中使用的一个常见类是连接管理器，其代码如下所示：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To fire the publishers, use the following code for publisher. The code for
    publisher, `Publisher.java`, is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要触发发布者，请使用以下发布者代码。发布者的代码`Publisher.java`如下：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this sample, the code will publish a message to a channel called `news`,
    and to see it working make sure that the subscriber is ready and to publish the
    message to a pattern, comment the code which publishes to a channel, and uncomment
    the code which publishes the message to a pattern.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，该代码将向名为`news`的频道发布消息，要查看其工作情况，请确保订阅者已准备就绪，并且要发布消息到模式，请注释发布到频道的代码，并取消注释发布消息到模式的代码。
- en: Pipelines in Redis
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redis中的管道
- en: Redis provides a mechanism for faster execution, called *pipeline*. This groups
    up all the commands as one command block and sends it to the server for execution.
    The results of all the commands get queued in a response block and sent back.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Redis提供了一种更快执行的机制，称为*管道*。它将所有命令组合成一个命令块，并将其发送到服务器进行执行。所有命令的结果都排队在一个响应块中并发送回来。
- en: Comparing the way pipeline works with multiple individual commands sent across
    a connection will give us an idea of how pipeline is more efficient and where
    it needs to be used. Let's assume a scenario where we have to send three commands
    to Redis. The time taken to send any command to Redis is *X* seconds, so the same
    amount of time is required to send the response. The total time spent in going
    and return journey is *2X* seconds. Let's also assume that the time taken for
    execution is another *X* seconds. Now in the pipeline commands, since we are sending
    three commands as one block, the time taken for going to Redis is around *X* seconds
    , the time taken for processing all the three commands is *3X* seconds, and the
    time taken for the return journey is also *X* seconds. The total time taken in
    pipeline commands is *5X* seconds. Compare this with a scenario where we have
    to send individual commands. The time taken for sending a single command and its
    return journey is equal to *2X* and time taken for including execution is *3X*.
    Since we are talking of three commands, the total time is equal to *9X*. This
    *9X* seconds time compared to *5X* seconds proves its efficiency.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将管道工作方式与通过连接发送多个单独命令的方式进行比较，可以让我们了解管道更有效的地方以及需要使用管道的地方。假设我们必须向Redis发送三个命令的情况。发送任何命令到Redis的时间为*X*秒，因此发送响应需要相同的时间。去程和回程所花费的总时间为*2X*秒。还假设执行所需的时间为另外*X*秒。现在在管道命令中，由于我们将三个命令作为一个块发送，因此去Redis所需的时间约为*X*秒，处理所有三个命令所需的时间为*3X*秒，回程所需的时间也为*X*秒。管道命令所需的总时间为*5X*秒。将其与必须发送单独命令的情况进行比较。发送单个命令及其回程所需的时间等于*2X*，包括执行所需的时间为*3X*。由于我们谈论的是三个命令，因此总时间等于*9X*。与*5X*秒相比，*9X*秒的时间证明了它的效率。
- en: 'One thing we have to keep in mind is that pipeline does guarantee atomicity
    but only executes multiple commands and returns response in one response block.
    Following is a simple representation of commands invoked in a pipeline:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记住的一件事是，管道确保原子性，但只执行多个命令并在一个响应块中返回响应。以下是管道中调用的命令的简单表示：
- en: '![Pipelines in Redis](img/0123OS_04_02.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![Redis中的管道](img/0123OS_04_02.jpg)'
- en: Pipeline in Redis
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Redis中的管道
- en: 'Next is the representation of multiple commands sent across multiple connections.
    As we can see, the time taken for sending the response back is saved in case of
    pipelining the commands:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是跨多个连接发送的多个命令的表示。正如我们所看到的，通过使用管道命令，可以节省发送响应的时间：
- en: '![Pipelines in Redis](img/0123OS_04_03.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![Redis中的管道](img/0123OS_04_03.jpg)'
- en: Multiple commands using individual connections in Redis
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Redis中使用单独连接的多个命令
- en: 'This way of sending bulk command can be seen in RDBMS also, where we have the
    provision for sending bulk JDBC as a *batch*. To check this fact, let''s write
    a program and check the time difference between running a program in pipeline
    and without pipeline:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种批量发送命令的方式在RDBMS中也可以看到，我们可以将批量JDBC作为*批处理*发送。为了验证这一点，让我们编写一个程序，并检查在使用管道和不使用管道运行程序之间的时间差异：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The result in my computer is as follows, which of course, may vary depending
    upon machine configurations used:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的计算机上的结果如下，当然，这可能会根据所使用的机器配置而有所不同：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Pipeline gives the advantage of faster execution but comes with some limitations.
    This works only when target Redis instance is same, that is, it won't work in
    a Sharded environment since the connection will be different for every Redis instance.
    Pipeline also has a lacuna when the commands are not inter-dependent or where
    custom logic has to be written to form a compound command. In this case also,
    Redis provides a mechanism of *scripting*, which we will be covering later in
    the chapter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 管道提供了更快执行的优势，但也带来了一些限制。这仅在目标Redis实例相同时有效，也就是说，在分片环境中不起作用，因为每个Redis实例的连接都是不同的。当命令不相互依赖或需要编写自定义逻辑以形成复合命令时，管道也存在不足。在这种情况下，Redis还提供了一种*脚本*的机制，我们将在本章后面进行介绍。
- en: Transactions in Redis
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redis中的事务
- en: 'Redis as a NOSQL data store provides a loose sense of transaction. As in a
    traditional RDBMS, the transaction starts with a `BEGIN` and ends with either
    `COMMIT` or `ROLLBACK`. All these RDBMS servers are multithreaded, so when a thread
    locks a resource, it cannot be manipulated by another thread unless and until
    the lock is released. Redis by default has `MULTI` to start and `EXEC` to execute
    the commands. In case of a transaction, the first command is always `MULTI`, and
    after that all the commands are stored, and when `EXEC` command is received, all
    the stored commands are executed in sequence. So inside the hood, once Redis receives
    the `EXEC` command, all the commands are executed as a single isolated operation.
    Following are the commands that can be used in Redis for transaction:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 作为NOSQL数据存储的Redis提供了一种宽松的事务。与传统的RDBMS一样，事务以`BEGIN`开始，以`COMMIT`或`ROLLBACK`结束。所有这些RDBMS服务器都是多线程的，因此当一个线程锁定资源时，除非释放了锁，否则另一个线程无法操作它。Redis默认使用`MULTI`开始，`EXEC`执行命令。在事务中，第一个命令始终是`MULTI`，之后所有的命令都被存储，当接收到`EXEC`命令时，所有存储的命令都按顺序执行。因此，在内部，一旦Redis接收到`EXEC`命令，所有命令都将作为单个隔离的操作执行。以下是Redis中可用于事务的命令：
- en: '`MULTI`: This marks the start of a transaction block'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MULTI`：这标志着事务块的开始'
- en: '`EXEC`: This executes all the commands in the pipeline after `MULTI`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXEC`：这在`MULTI`之后执行管道中的所有命令'
- en: '`WATCH`: This watches the keys for conditional execution of a transaction'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WATCH`：这会监视键以条件执行事务'
- en: '`UNWATCH`: This removes the `WATCH` keys of a transaction'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNWATCH`：这会移除事务的`WATCH`键'
- en: '`DISCARD`: This flushes all the previously queued commands in the pipeline'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DISCARD`：这会刷新管道中之前排队的所有命令'
- en: 'The following figure represents how transaction in Redis works:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示了Redis中事务的工作原理：
- en: '![Transactions in Redis](img/0123OS_04_04.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![Redis中的事务](img/0123OS_04_04.jpg)'
- en: Transaction in Redis
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Redis中的事务
- en: Pipeline versus transaction
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道与事务
- en: As we have seen for many generic terms in pipeline the commands are grouped
    and executed, and the responses are queued in a block and sent. But in transaction,
    until the `EXEC` command is received, all the commands received after `MULTI`
    are queued and then executed. To understand that, it is important to take a case
    where we have a multithreaded environment and see the outcome.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在管道中看到的，命令被分组并执行，并且响应被排队并发送。但是在事务中，直到接收到`EXEC`命令，`MULTI`之后接收到的所有命令都会被排队，然后执行。为了理解这一点，重要的是要考虑一个多线程环境，并观察结果。
- en: 'In the first case, we take two threads firing pipelined commands at Redis.
    In this sample, the first thread fires a pipelined command, which is going to
    change the value of a key multiple number of times, and the second thread will
    try to read the value of that key. Following is the class which is going to fire
    the two threads at Redis: `MultiThreadedPipelineCommandTest.java`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们使用两个线程向Redis发送管道命令。在这个示例中，第一个线程发送了一个管道命令，它将多次更改一个键的值，第二个线程将尝试读取该键的值。以下是将在Redis中启动两个线程的类：`MultiThreadedPipelineCommandTest.java`：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The code for the client which is going to read the value of the key when pipeline
    is executed is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行管道时，用于读取键的客户端的代码如下：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The result will vary as per machine configuration but by changing the thread
    sleep time and running the program couple of times, the result will be similar
    to the one shown as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将根据机器配置而异，但通过更改线程休眠时间并多次运行程序，结果将与下面显示的结果类似：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please fire `FLUSHDB` command every time you run the test, otherwise you end
    up seeing the value of the previous test run, that is 300,000
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请在每次运行测试时执行`FLUSHDB`命令，否则您将看到上一次测试运行的值，即300,000
- en: Now we will run the sample in a transaction mode, where the command pipeline
    will be preceded by `MULTI` keyword and succeeded by `EXEC` command. This client
    is similar to the previous sample where two clients in separate threads will fire
    commands to a single key on Redis.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将以事务模式运行示例，其中命令管道将以`MULTI`关键字开头，并以`EXEC`命令结尾。这个客户端类似于之前的示例，其中两个客户端在单独的线程中向Redis发送命令。
- en: 'The following program is a test client that gives two threads one with commands
    in transaction mode and the second thread will try to read and modify the same
    resource:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序是一个测试客户端，它给两个线程，一个处于事务模式的命令，第二个线程将尝试读取和修改相同的资源：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This program will try to modify the resource and read the resource while the
    transaction is going on:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将尝试修改资源并在事务进行时读取资源：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This program will start with `MULTI` command, try to modify the resource, end
    it with `EXEC` command, and later read the value of the resource:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将以`MULTI`命令开始，尝试修改资源，以`EXEC`命令结束，并稍后读取资源的值：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result of the preceding program will vary as per machine configuration
    but by changing the thread sleep time and running the program couple of times,
    the result will be similar to the one shown as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序的结果将根据机器配置而有所不同，但通过更改线程休眠时间并运行程序几次，结果将与下面显示的结果类似：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Fire the `FLUSHDB` command every time you run the test. The idea is that the
    program should not pick up a value obtained because of a previous run of the program.
    The proof that the single command program is able to write to the key is if we
    see the following line: `The return code is [1]`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行测试时都要执行`FLUSHDB`命令。这个想法是程序不应该获取由于上一次运行程序而获得的值。单个命令程序能够写入键的证据是如果我们看到以下行：`返回代码是[1]`。
- en: 'Let''s analyze the result. In case of pipeline, a single command reads the
    value and the pipeline command sets a new value to that key as evident in the
    following result:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下结果。在管道的情况下，一个单独的命令读取该键的值，而管道命令则为该键设置一个新值，如下结果所示：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now compare this with what happened in case of transaction when a single command
    tried to read the value but it was blocked because of the transaction. Hence the
    value will be `NULL` or 300,000.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将这与在事务的情况下发生的情况进行比较，当一个单独的命令尝试读取值但因事务而被阻塞时。因此该值将是`NULL`或300,000。
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So the difference in output can be attributed to the fact that in a transaction,
    if we have started a `MULTI` command, and are still in the process of queueing
    commands (that is, we haven't given the server the `EXEC` request yet), then any
    other client can still come in and make a request, and the response would be sent
    to the other client. Once the client gives the `EXEC` command, then all other
    clients are blocked while all of the queued transaction commands are executed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，输出结果的差异可以归因于在事务中，如果我们已经开始了`MULTI`命令，并且仍在排队命令的过程中（也就是说，我们还没有给服务器`EXEC`请求），那么任何其他客户端仍然可以进来并发出请求，并且响应将发送给其他客户端。一旦客户端发出`EXEC`命令，那么所有其他客户端在所有排队的事务命令执行时都会被阻止。
- en: Pipeline and transaction
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道和事务
- en: 'To have a better understanding, let''s analyze what happened in case of pipeline.
    When two different connections made requests to the Redis for the same resource,
    we saw a result where client-2 picked up the value while client-1 was still executing:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，让我们分析一下在管道的情况下发生了什么。当两个不同的连接向Redis请求相同的资源时，我们看到了一个结果，即客户端-2在客户端-1仍在执行时获取了该值：
- en: '![Pipeline and transaction](img/0123OS_04_05.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![管道和事务](img/0123OS_04_05.jpg)'
- en: Pipeline in Redis in a multi connection environment
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Redis中的管道在多连接环境中
- en: What it tells us is that requests from the first connection which is pipeline
    command is stacked as one command in its execution stack, and the command from
    the other connection is kept in its own stack specific to that connection. The
    Redis execution thread time slices between these two executions stacks, and that
    is why client-2 was able to print a value when the client-1 was still executing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉我们的是，来自第一个连接的请求（即管道命令）被堆叠为一个命令在其执行堆栈中，而来自另一个连接的命令则保留在其自己的与该连接相关的堆栈中。Redis执行线程在这两个执行堆栈之间进行时间切片，这就是为什么当客户端-1仍在执行时，客户端-2能够打印一个值的原因。
- en: Let's analyze what happened in case of transaction here. Again the two commands
    (transaction commands and `GET` commands) were kept in their own execution stacks,
    but when the Redis execution thread gave time to the `GET` command, and it went
    to read the value, seeing the lock it was not allowed to read the value and was
    blocked. The Redis execution thread again went back to executing the transaction
    commands, and again it came back to `GET` command where it was again blocked.
    This process kept happening until the transaction command released the lock on
    the resource and then the `GET` command was able to get the value. If by any chance,
    the `GET` command was able to reach the resource before the transaction lock,
    it got a null value.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下在事务的情况下发生了什么。同样，两个命令（事务命令和`GET`命令）被保留在它们自己的执行堆栈中，但当Redis执行线程给予`GET`命令时间并去读取值时，看到锁定，它被禁止读取值并被阻塞。Redis执行线程再次回到执行事务命令，然后再次回到`GET`命令，它再次被阻塞。这个过程一直持续，直到事务命令释放了对资源的锁定，然后`GET`命令才能获取值。如果`GET`命令碰巧在事务锁定之前能够到达资源，它会得到一个空值。
- en: Please bear in mind that Redis does not block execution to other clients while
    queuing transaction commands but blocks only during executing them.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Redis在排队事务命令时不会阻止其他客户端的执行，但在执行它们时会阻止。
- en: '![Pipeline and transaction](img/0123OS_04_06.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![管道和事务](img/0123OS_04_06.jpg)'
- en: Transaction in Redis multi connection environment
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Redis多连接环境中的事务
- en: This exercise gave us an insight into what happens in the case of pipeline and
    transaction.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习让我们了解了在管道和事务的情况下会发生什么。
- en: Scripting in Redis
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redis中的脚本编写
- en: '**Lua** is a high performing scripting language with interpreter written in
    C. Redis provides mechanism to extend the functionality of Redis by providing
    support for Lua in the server side. Since Redis is implemented in C, it gives
    a natural synergy for Lua to be offered along with Redis as a server add on. The
    Lua interpreter shipped along with Redis is with limited capability and following
    libraries are shipped along with it:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lua**是一种性能优越的脚本语言，解释器是用C编写的。Redis提供了一种机制，通过在服务器端提供对Lua的支持来扩展Redis的功能。由于Redis是用C实现的，因此Lua作为服务器附加组件与Redis一起提供是很自然的。随Redis一起提供的Lua解释器具有有限的功能，并且随其一起提供以下库：'
- en: The `base` library
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base`库'
- en: The `table` library
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`table`库'
- en: The `string` library
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`库'
- en: The `math` library
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`math`库'
- en: The `debug` library
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug`库'
- en: The `cjson` library
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cjson`库'
- en: The `cmsgpack` library
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmsgpack`库'
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Libraries which can do File I/O and Networking are not included, so you cannot
    send a message from LUA script in REDIS to another external system.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 不能执行文件I/O和网络操作的库未包含在内，因此无法从REDIS中的LUA脚本向另一个外部系统发送消息。
- en: Before we start with fun stuff, it's always better to have a hang of the language.
    LUA has its own dedicated site and tons of resources are available to LUA, but
    the next section concentrates on just enough LUA to get started for Redis.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始有趣的事情之前，最好先了解一下这种语言。LUA有自己专门的网站，并且有大量资源可供LUA使用，但下一节专注于了解Redis的LUA的足够内容。
- en: Brief introduction on Lua
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lua简介
- en: 'Okay, by now we all know that LUA is an interpreted language and it has support
    in Redis. To make use of the capability of Redis, let''s learn couple of things
    about LUA. Types and values supported in LUA are as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，到目前为止，我们都知道LUA是一种解释性语言，并且它在Redis中得到了支持。为了利用Redis的功能，让我们学习一些关于LUA的东西。LUA中支持的类型和值如下：
- en: '**Nil**: Nil is a type with single value *nil*. On comparing it with Java,
    it can be taken as *null*.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nil**：Nil是具有单个值*nil*的类型。将其与Java进行比较，可以将其视为*null*。'
- en: '**Booleans**: These will have either true or false as values.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布尔值**：这些将具有true或false作为值。'
- en: '**Numbers**: These represent double precession floating point numbers. So we
    can write our numbers as 1, 1.1, 2e+10, and so on.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字**：这些表示双精度浮点数。因此，我们可以将我们的数字写为1、1.1、2e+10等。'
- en: '**String**: These represent a sequence of characters as is common in most of
    the scripting and programming languages. In LUA, strings are immutable in nature;
    for example, `"Learning Redis"` and `''Learning Redis''`. LUA provides methods
    in string library to find substring, replace characters, and so on.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串**：这些表示字符序列，与大多数脚本和编程语言中的常见情况相同。在LUA中，字符串是不可变的；例如，`“Learning Redis”`和`''Learning
    Redis''`。LUA提供了字符串库中的方法来查找子字符串，替换字符等。'
- en: '**Tables**: These are like arrays which can be indexed with numbers and strings
    except *nil*.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表**：这些类似于可以使用数字和字符串索引的数组，除了*nil*。'
- en: 'Control statements and loops in LUA are as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: LUA中的控制语句和循环如下：
- en: 'The `if then else` statement: As in Java, where we have only `if`/`else`, LUA
    supports something similar in the form of `if`/`then`/`else`. Following is the
    code example for it:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if then else`语句：与Java中的`if`/`else`类似，LUA支持类似`if`/`then`/`else`的形式。以下是其代码示例：'
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `while` loop: This is similar to Java where looping has a similar syntax:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while`循环：这类似于Java中的循环，其语法类似：'
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `repeat` statement: This is similar to `do`/`while` in Java. This will
    guarantee at least one time iteration:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repeat`语句：这类似于Java中的`do`/`while`。这将保证至少进行一次迭代：'
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `for` loop: This is similar to the `for` loop in Java:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`循环：这类似于Java中的`for`循环：'
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Two keywords in LUA that you will use frequently while executing control statements
    are `return` and `break`. Following is a simple sample to demonstrate return keyword,
    getting used in a function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行控制语句时，LUA中经常使用的两个关键字是`return`和`break`。以下是一个简单的示例，演示了在函数中使用return关键字：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next is a simple sample to demonstrate break keyword getting used in a function:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个简单的示例，演示了在函数中使用break关键字：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With this minimal understanding of how LUA works, let's run a sample in Redis,
    and then take the understanding forward. But before that, let's understand how
    LUA works in Redis.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有了对LUA工作原理的最基本理解，让我们在Redis中运行一个示例，然后继续深入了解。但在此之前，让我们了解一下LUA在Redis中的工作原理。
- en: 'The following figure describes how LUA works with Redis. To understand how
    things happen internally, it is important to remember that Redis works in a single
    thread model and that all the Redis command and LUA logic would execute in a sequence:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图描述了LUA如何与Redis一起工作。要了解内部发生的事情，重要的是要记住Redis以单线程模型工作，所有Redis命令和LUA逻辑都将按顺序执行：
- en: '![Brief introduction on Lua](img/0123OS_04_07.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![Lua简介](img/0123OS_04_07.jpg)'
- en: LUA scripting in Redis
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Redis中的LUA脚本
- en: When a client sends the script to the Redis server, the script gets validated
    for its syntax and is stored in an internal map in Redis against a SHA-1 digest.
    The SHA-1 digest is returned to the client.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端将脚本发送到Redis服务器时，脚本会被验证其语法，并存储在Redis内部映射中与SHA-1摘要对应。SHA-1摘要会返回给客户端。
- en: 'Let''s try a simple program in LUA which will basically read a value for a
    key and check if the value is equal to the argument passed. If yes, then it will
    set it to the second argument passed or else it will set it to the third argument
    passed to the script. Okay, let''s prepare the test environment. Open your Redis
    command line client and set the value of `msg` key to `"Learning Redis"`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在LUA中编写一个简单的程序，基本上是读取一个键的值，并检查该值是否等于传递的参数。如果是，则将其设置为传递的第二个参数，否则将其设置为传递给脚本的第三个参数。好的，让我们准备测试环境。打开Redis命令行客户端，并将`msg`键的值设置为`“Learning
    Redis”`：
- en: '![Brief introduction on Lua](img/0123OS_04_08.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![Lua简介](img/0123OS_04_08.jpg)'
- en: Preparing for the test executing LUA script
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 准备测试执行LUA脚本
- en: 'Now with the value of `msg` set, let''s execute the Java program listed as
    follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`msg`的值已设置好，让我们执行以下列出的Java程序：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The code for `Reader` is a simple Java program which reads program from file
    location:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reader`的代码是一个简单的Java程序，它从文件位置读取程序：'
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now let''s take a look at the LUA script written in the file `LuaScript.txt`
    that we would be passing to the Java program:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下写在文件`LuaScript.txt`中的LUA脚本，我们将把它传递给Java程序：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The first run of the program should give you the following result:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第一次运行应该给您以下结果：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The second run of the program should give you the following result:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第二次运行应该给您以下结果：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'So if you see the messages printed as shown in the preceding code then you
    actually have successfully executed your first LUA program in Redis. The following
    are the learnings that we have got with this sample:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您看到如前面的代码中所示的消息打印，那么您实际上已成功在Redis中执行了您的第一个LUA程序。以下是我们从这个示例中学到的内容：
- en: Redis treats LUA script as one function.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis将LUA脚本视为一个函数。
- en: LUA script uses `Redis.call()` method to fire Redis commands.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LUA脚本使用`Redis.call()`方法来触发Redis命令。
- en: Redis commands which return values can be assigned to a local variable. Over
    here we are assigning the value to a variable called `data`.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值的Redis命令可以赋值给本地变量。在这里，我们将值赋给一个名为`data`的变量。
- en: Arrays in LUA start index from `1` not `0`. So you will never have array index
    such as `ARGV[0]` or `KEYS[0]`.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LUA中的数组从`1`开始索引，而不是`0`。因此，您永远不会有数组索引，比如`ARGV[0]`或`KEYS[0]`。
- en: 'There are some further restrictions that Redis imposes on the Lua scripting
    engine which are as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Redis对Lua脚本引擎施加了一些进一步的限制，如下所示：
- en: In Redis, LUA scripts cannot have global variables.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Redis中，LUA脚本不能有全局变量。
- en: In Redis, LUA scripts cannot call transaction commands such as `MULTI` or `EXEC`.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Redis中，LUA脚本不能调用诸如`MULTI`或`EXEC`之类的事务命令。
- en: In Redis, LUA scripts cannot access external systems using I/O libraries that
    come in LUA. The only way it can communicate to external system is via Redis commands
    such as `PUBLISH`.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Redis中，LUA脚本不能使用LUA中的I/O库访问外部系统。它与外部系统通信的唯一方式是通过诸如`PUBLISH`之类的Redis命令。
- en: LUA scripts to access system time are not supported via LUA. Instead, use `TIME`
    command, that is `Redis.call('TIME')`.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持通过LUA访问系统时间的脚本。而是使用`TIME`命令，即`Redis.call('TIME')`。
- en: Functions such as `Redis.call('TIME')` are non-deterministic in nature and so
    are not allowed before a `WRITE` command.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诸如`Redis.call('TIME')`之类的函数是非确定性的，因此在`WRITE`命令之前不允许使用。
- en: Nesting of conditions is not allowed since nested condition will end with `END`
    keyword which impacts the outer conditions which again has to end with `END`.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许嵌套条件，因为嵌套条件将以`END`关键字结束，这会影响外部条件，外部条件也必须以`END`结束。
- en: 'The following commands are supported for managing the LUA scripts in Redis.
    Let''s have a look at it and understand how they can be used:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令支持在Redis中管理LUA脚本。让我们来看看它，并了解它们如何使用：
- en: '`EVAL`: This command will process the Redis script and the response would be
    the result of the executed script.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EVAL`：此命令将处理Redis脚本，并响应将是执行脚本的结果。'
- en: '`EVALSHA`: This command will process the cached script based on SHA-1 digest
    of the script and the response would be the result of the executed script.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EVALSHA`：此命令将根据脚本的SHA-1摘要处理缓存的脚本，并响应将是执行脚本的结果。'
- en: '`SCRIPT EXISTS`: This command will check for the existence of script in the
    script cache. This check is done by passing SHA-1 digest of the script.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCRIPT EXISTS`：此命令将检查脚本在脚本缓存中的存在。通过传递脚本的SHA-1摘要来进行此检查。'
- en: '`SCRIPT FLUSH`: This will flush the LUA script from the script cache.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCRIPT FLUSH`：这将从脚本缓存中清除LUA脚本。'
- en: '`SCRIPT KILL`: This command will kill the script whose execution is taking
    a lot of time.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCRIPT KILL`：此命令将终止执行时间较长的脚本。'
- en: '`SCRIPT LOAD`: This command will load the script in the cache and return the
    SHA-1 digest of the script.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCRIPT LOAD`：此命令将加载脚本到缓存中，并返回脚本的SHA-1摘要。'
- en: Use case – reliable messaging
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例 - 可靠的消息传递
- en: By using PUB/SUB capability of Redis, we can create a real time messaging framework
    but the problem with this is that if the intended subscriber is not available
    then the message is lost. To overcome this problem, we can take the help of LUA
    scripting which will store the message if the subscriber is not available.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Redis的PUB/SUB功能，我们可以创建一个实时消息传递框架，但问题是，如果预期的订阅者不可用，那么消息就会丢失。为了解决这个问题，我们可以借助LUA脚本来存储消息，如果订阅者不可用。
- en: 'The implementation of this will vary depending upon the framework design of
    the solution, but in our case we will take a simplistic approach where every subscriber
    and publisher will agree upon a channel. When the subscriber goes down, the publisher
    will store the message in a message box unique to the subscriber. When the subscriber
    again comes up, it will start consuming the lost messages, as well as the real
    time messages coming from the publisher. The following figure is representing
    the steps that we will have to follow to achieve reliable messaging:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现将根据解决方案的框架设计而有所不同，但在我们的情况下，我们将采取一种简单的方法，即每个订阅者和发布者都将就一个频道达成一致。当订阅者下线时，发布者将把消息存储在一个唯一的消息框中，以便订阅者再次上线时，它将开始消费丢失的消息，以及来自发布者的实时消息。以下图表示了我们将要遵循的步骤以实现可靠的消息传递：
- en: '![Use case – reliable messaging](img/0123OS_04_09.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![用例 - 可靠的消息传递](img/0123OS_04_09.jpg)'
- en: Simple reliable messaging
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 简单可靠的消息传递
- en: To begin with, the publisher will send the message to a channel client-1, oblivious
    to the fact whether the subscriber is in a receiving mode or not. Assuming that
    the subscriber is running, the messages from the publisher will be consumed in
    real-time. Then if we bring down the subscriber for a while and publish few more
    messages, in our case the publisher will be intelligent enough to know if the
    subscriber is running or not, and sensing that the subscriber is down, it will
    store the message in a `MSGBOX`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，发布者将向频道client-1发送消息，不知道订阅者是否处于接收模式。假设订阅者正在运行，则发布者的消息将实时消耗。然后，如果我们将订阅者关闭一段时间并发布更多消息，在我们的情况下，发布者将足够智能，以知道订阅者是否正在运行，并且感知到订阅者已关闭，它将在`MSGBOX`中存储消息。
- en: 'In the meantime, the moment the subscriber is up and running, the first thing
    it will do is get the missed messages from the `MSGBOX` and publish it to self.
    The code for publisher is as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，订阅者运行起来后，它将首先从`MSGBOX`中获取错过的消息，并将其发布给自己。发布者的代码如下：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The code for the LUA script is as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: LUA脚本的代码如下：
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Following is a brief explanation of the step written in LUA:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是LUA中编写的步骤的简要解释：
- en: In the first line we get the message and convert it into a table object. Array
    index starts with `1` in LUA.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一行中，我们获取消息并将其转换为表对象。在LUA中，数组索引从`1`开始。
- en: We publish the message in the second line and get the result. The result tells
    us how many subscribers consumed the message.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在第二行中发布消息并获取结果。结果告诉我们有多少订阅者消费了消息。
- en: If the result is equal to `0`, then all the listeners were down and we need
    to persist it. The data type used here is a `Set` and it subsequently returns
    a message back to the server (this return is optional).
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果结果等于`0`，则所有侦听器都已关闭，我们需要将其持久化。此处使用的数据类型是`Set`，随后将消息返回给服务器（此返回是可选的）。
- en: If the message was consumed by the subscriber, then the statement in the `Else`
    is executed.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果消息被订阅者消费，则执行`Else`中的语句。
- en: Finally, we `end` the function. (Make sure there is only one `end` in the script.
    LUA in Redis will not compile if there is more than one `end`.)
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们`end`函数。（确保脚本中只有一个`end`。如果有多个`end`，Redis中的LUA将无法编译。）
- en: 'Redis will wrap the code in LUA as one function in LUA. The code for `Subscriber`
    is as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Redis将在LUA中将代码包装为一个函数。`Subscriber`的代码如下：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The program has following responsibilities and a brief explanation of the program
    is as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序有以下职责，并对程序进行了简要解释：
- en: When it starts it should check if it has any messages in the message box, such
    as `MSGBOX`, while it was down. If it has messages then its job is to publish
    it to self.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动时应检查是否有消息在消息框中，例如`MSGBOX`，当它关闭时。如果有消息，则其工作是将其发布给自己。
- en: The second thing it should do is to listen for messages it has subscribed to.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该做的第二件事是监听其订阅的消息。
- en: For better performance, run the `SCRIPT LOAD` command which will load the script
    and return a SHA-1 digest, and instead of using `EVAL`, use the `EVALSHA` command,
    where you pass the same SHA-1 digest. This will prevent the script getting checked
    for syntax correctness and will be executed directly.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了获得更好的性能，运行`SCRIPT LOAD`命令，该命令将加载脚本并返回SHA-1摘要，而不是使用`EVAL`，使用`EVALSHA`命令，其中传递相同的SHA-1摘要。这将防止脚本被检查语法正确性，并将直接执行。
- en: Connection management
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接管理
- en: 'In this section we will be focusing on the way we can manage the connection
    to Redis. The functions provided under connection management in Redis help us
    to do the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点关注如何管理与Redis的连接。Redis中提供的连接管理功能帮助我们执行以下操作：
- en: '`AUTH`: This command with the password allows the request to be processed if
    the password matches the configured password. Redis server can be configured with
    `requirepass` in the `config` file along with the password.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AUTH`：此命令允许请求在密码匹配配置的密码时被处理。Redis服务器可以在`config`文件中配置`requirepass`以及密码。'
- en: '`ECHO`: This command echoes back the text sent to a Redis instance.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ECHO`：此命令将回显发送到Redis实例的文本。'
- en: '`PING`: This command replies with `PONG` when sent to a Redis instance.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PING`：当发送到Redis实例时，此命令将回复`PONG`。'
- en: '`QUIT`: This command kills the connection held by the Redis instance for a
    client.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QUIT`：此命令将终止Redis实例为客户端持有的连接。'
- en: '`SELECT`: This command helps in selecting a database in Redis for executing
    the command. Data in Redis can have separation of concern and this is achieved
    by creating a silo and storing the data in that. The data in each silo don''t
    interfere and are isolated.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT`：此命令有助于在Redis中选择要执行命令的数据库。Redis中的数据可以有关注点的分离，通过创建一个筒仓并将数据存储在其中来实现。每个筒仓中的数据不会相互干扰，而是被隔离的。'
- en: Redis authentication
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redis身份验证
- en: 'Adding a simple password to your Redis server via Redis client and testing
    it via Java client is explained in following steps:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Redis客户端向Redis服务器添加简单密码，并通过Java客户端进行测试，具体步骤如下所述：
- en: Open the Redis client and type `CONFIG SET requirepass "Learning Redis"`. You
    have set the password for your Redis server as `"Learning Redis"`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Redis客户端并键入`CONFIG SET requirepass "Learning Redis"`。您已将Redis服务器的密码设置为`"Learning
    Redis"`。
- en: 'Write the following program in Java using Jedis, which will perform some simple
    getter and setter without authenticating against the Redis server:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Jedis在Java中编写以下程序，该程序将在不对Redis服务器进行身份验证的情况下执行一些简单的getter和setter：
- en: '[PRE29]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The outcome in the console would be `ERR operation not permitted`, or based
    upon version, you might get `NOAUTH Authentication required`, which is indicative
    of the fact that since the password was not passed in the request, the operation
    could not be permitted. To make the program work, the client need, to pass the
    password for authentication:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制台中的结果将是`ERR operation not permitted`，或者根据版本，您可能会得到`NOAUTH Authentication required`，这表明由于未在请求中传递密码，无法允许操作。为使程序工作，客户端需要传递密码进行身份验证：
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The outcome of the program in the console would be `bar`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台中程序的结果将是`bar`。
- en: Redis SELECT
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redis SELECT
- en: Redis provides a mechanism of segregating the Redis server into databases. Instead
    of an elaborate naming mechanism in some of the databases, Redis has a simple
    process of dividing the database into separate key spaces, and each key space
    is represented by an integer.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Redis提供了一种将Redis服务器分隔成数据库的机制。在一些数据库中，Redis没有复杂的命名机制，而是有一个简单的过程将数据库分成单独的键空间，每个键空间由一个整数表示。
- en: '![Redis SELECT](img/0123OS_04_10.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![Redis SELECT](img/0123OS_04_10.jpg)'
- en: Multiple database in Redis
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Redis中的多个数据库
- en: The program here attempts to store some data in a database and tries to successfully
    retrieve the data from it. It then changes the database and attempts to retrieve
    the same data, which of course ends up in failure. Remember to remove any authentication
    that might be set in the previous program for this code to run or just restart
    Redis server.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序试图将一些数据存储在数据库中，并尝试成功地从中检索数据。然后更改数据库并尝试检索相同的数据，这当然会以失败告终。请记住，为了使此代码运行，请删除之前程序中设置的任何身份验证，或者只需重新启动Redis服务器。
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The outcome of this program should be as following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的结果应该如下所示：
- en: '[PRE32]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Redis ECHO and PING
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redis ECHO和PING
- en: Redis provides some utility functions, such as `ECHO` and `PING`, which can
    be used to check if the server is responding or not, and how much time is it taking
    in responding to a request. This gives an idea on the latency at network and I/O
    level.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Redis提供了一些实用功能，比如`ECHO`和`PING`，可以用来检查服务器是否响应，以及响应请求所花费的时间。这可以让我们了解网络和I/O级别的延迟。
- en: 'The following program will demonstrate a sample usage where the `ECHO` and
    `PING` commands will be fired when no other connections are made to the server,
    and then again it will fire these commands (`ECHO` and `PING`) when the Redis
    server is under the load of 100 connections. The outcome when no other connections
    are made is as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序将演示一个示例用法，当服务器没有其他连接时，将触发`ECHO`和`PING`命令，然后当Redis服务器承受100个连接的负载时，再次触发这些命令（`ECHO`和`PING`）。没有其他连接时的结果如下：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The outcome when 100 other connections are doing activity on the server is
    as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器上有100个其他连接在进行活动时，结果如下：
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The outcome when 50 other connections are doing activity on the server is as
    follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器上有50个其他连接在进行活动时，结果如下：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This proves that it is immaterial the amount of activity the Redis server is
    doing, but depends on the availability of the I/O and network resources. The following
    program is for reference:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了Redis服务器的活动量并不重要，而取决于I/O和网络资源的可用性。以下程序仅供参考：
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The code for `LoadGenerator` is noted as follows for reference:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadGenerator`的代码如下所示，仅供参考：'
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can play around with this program by changing the number of threads and commenting
    the thread start code in the `TestEchoAndPing`, and seeing the result ourselves.
    The result is going to show the same consistency as shown in the preceding code.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更改线程数量并在`TestEchoAndPing`中注释线程启动代码来玩弄这个程序，并自己看到结果。结果将显示与前面代码中显示的一致性。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw how to use Redis, not simply as a datastore, but also
    as pipeline the commands which is so much more like bulk processing. Apart from
    that, we covered areas such as transaction, messaging, and scripting. We also
    saw how to combine messaging and scripting, and create reliable messaging in Redis.
    This capability of Redis makes it different from some of the other datastore solutions.
    In the next chapter, we will focus on data handling capabilities of Redis.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用Redis，不仅仅作为数据存储，还可以作为管道来处理命令，这更像是批量处理。除此之外，我们还涵盖了事务、消息传递和脚本等领域。我们还看到了如何结合消息传递和脚本，并在Redis中创建可靠的消息传递。这使得Redis的能力与其他一些数据存储解决方案不同。在下一章中，我们将专注于Redis的数据处理能力。
