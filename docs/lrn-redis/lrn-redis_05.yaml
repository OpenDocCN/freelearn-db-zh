- en: Chapter 5. Handling Data in Redis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。在Redis中处理数据
- en: Data in business defines the business. What it means is that the way we define,
    store, interpret, and use data, forms the data platform of our business. It seldom
    happens that a single piece of data has meaning on its own; it only forms business
    functionality when combined with other data. So it becomes important that the
    data is connected, grouped, and filtered in such a way that the same dataset can
    be used for various aspects of the business.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 业务中的数据定义了业务。这意味着我们定义、存储、解释和使用数据的方式构成了我们业务的数据平台。很少有单独的数据具有意义；只有当与其他数据结合时，它才构成业务功能。因此，重要的是将数据连接、分组和过滤，以便同一数据集可以用于业务的各个方面。
- en: In order to have a platform which can sustain future requirements, it is pertinent
    that we define and classify the data in a way which gives us indications on the
    kind of expectation we have from that data. Data has many facets and it's important
    to understand those facets to extract full business value from it. For example,
    stock price of a company is important for the real-time systems to decide whether
    to buy or sell, and it loses its importance after a few seconds or milliseconds.
    However, it becomes important for the analytics system to predict its trends.
    So in a way, the same piece of data at different times has different usage. So
    it's good practice to take into account the various expectations from the data
    while strategizing the data architecture.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了拥有一个能够满足未来需求的平台，我们有必要以一种方式定义和分类数据，这种方式能够给我们指示我们对数据的期望。数据有许多方面，重要的是要了解这些方面，以从中提取出完整的商业价值。例如，公司的股票价格对于实时系统来说很重要，以决定是买入还是卖出，在几秒或几毫秒后就失去了重要性。然而，对于分析系统来说，预测其趋势变得重要。因此，在不同的时间点上，相同的数据具有不同的用途。因此，在制定数据架构时，考虑数据的各种期望是一个良好的做法。
- en: Classifying data
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分类数据
- en: 'A general tendency has been to think only in terms of a data model which fits
    the relational model. This might be a good model for certain classes of data but
    might prove to be ineffective for another class of data. Since this book is on
    Redis, we will attempt to classify the data based on certain behaviors and make
    an attempt to see where Redis fits:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 人们普遍倾向于只考虑适合关系模型的数据模型。这可能是某些类别数据的良好模型，但对于另一类数据可能会证明是无效的。由于本书是关于Redis的，我们将尝试根据某些行为对数据进行分类，并尝试看看Redis适用于哪些情况：
- en: '**Message and event data**: The data classified as message data in business
    show the following properties:'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息和事件数据**：在业务中分类为消息数据的数据具有以下特性：'
- en: '**Data complexity**: Message data has low data complexity as they are usually
    flat in structure'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据复杂性**：消息数据具有低数据复杂性，因为它们通常是扁平结构的'
- en: '**Data quantity**: Message data usually has high volumes'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据数量**：消息数据通常具有大量数据'
- en: '**Persistence**: Message data can be stored in disk and memory'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：消息数据可以存储在磁盘和内存中'
- en: '**CAP property**: Message data needs to be at least available and partition
    tolerant'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CAP属性**：消息数据至少需要可用和分区容错'
- en: '**Usability**: Message data can have usability in real-time, soft real-time,
    and offline and show the property of heavy writes and low reads'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：消息数据可以在实时、软实时和离线中使用，并显示出重写入和低读取的特性'
- en: If the requirement for message data is for real-time and soft real-time activity,
    and the data quantity is not very high then Redis and its messaging capability
    can be used.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果消息数据的需求是实时和软实时活动，并且数据量不是很大，那么可以使用Redis及其消息传递能力。
- en: '**Cache data**: The data classified as cache data in business shows the following
    properties:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存数据**：在业务中分类为缓存数据的数据具有以下特性：'
- en: '**Data complexity**: Cache data has low data complexity and is mostly stored
    as name value pair'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据复杂性**：缓存数据具有低数据复杂性，大多以名称值对的形式存储'
- en: '**Data quantity**: Cache data usually has low to medium volumes'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据数量**：缓存数据通常具有较少到中等的数据量'
- en: '**Persistence**: Data can be stored in cache memory'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：数据可以存储在缓存内存中'
- en: '**CAP property**: Cache data needs to be at least available and consistent'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CAP属性**：缓存数据至少需要可用和一致'
- en: '**Usability**: Cache data can have usability in real-time, and show low writes
    and heavy reads'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：缓存数据可以在实时中使用，并显示低写入和高读取'
- en: Redis is the perfect fit for cache data since it provides data structures which
    can be used directly by the program for storing the data. Also, the keys in Redis
    have time to live option which can be used to clean the data in Redis at regular
    intervals.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Redis是缓存数据的完美选择，因为它提供了可以直接被程序用于存储数据的数据结构。此外，Redis中的键具有生存时间选项，可以用于定期清理Redis中的数据。
- en: '**Meta data**: The data classified as meta data in business shows the following
    properties:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元数据**：在业务中分类为元数据的数据具有以下特性：'
- en: '**Data complexity**: Meta data has low data complexity and is mostly stored
    as name value pair'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据复杂性**：元数据具有低数据复杂性，大多以名称值对的形式存储'
- en: '**Data quantity**: Meta data usually has low volumes'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据数量**：元数据通常具有较少的数据量'
- en: '**Persistence**: Meta data can be stored in memory'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：元数据可以存储在内存中'
- en: '**CAP property**: Meta data needs to be at least available and consistent'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CAP属性**：元数据至少需要可用和一致'
- en: '**Usability**: Meta data can have usability in real-time and usually show low
    writes and low to heavy reads'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：元数据可以在实时中使用，并且通常显示出低写入和低到高读取的特性'
- en: 'Redis is the perfect fit for meta data since it provides data structures which
    can be used directly by the program for storing the data. Since Redis is fast
    and has messaging capability, it can be used for runtime manipulation of the meta
    data and also act as a central meta data repository. The following figure is a
    representation of how Redis can be used as meta data store:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Redis是元数据的完美选择，因为它提供了可以直接被程序用于存储数据的数据结构。由于Redis速度快且具有消息传递能力，因此可以用于运行时操作元数据，并且还可以作为中央元数据存储库。以下图表示了Redis如何作为元数据存储使用：
- en: '![Classifying data](img/0123OS_05_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![分类数据](img/0123OS_05_01.jpg)'
- en: Redis as a meta data store
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Redis作为元数据存储
- en: '**Transactional data**: The data classified as transactional data in business
    shows the following properties:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务数据**：在业务中分类为事务数据的数据显示以下属性：'
- en: '**Data complexity**: Transactional data has medium to high data complexity
    and is mostly relational'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据复杂性**：事务数据具有中等到高的数据复杂性，大多是关系型的'
- en: '**Data quantity**: Transactional data usually has medium to high volumes'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据量**：事务数据通常具有中等到高的数据量'
- en: '**Persistence**: Transactional data can be stored in memory and disk'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：事务数据可以存储在内存和磁盘中'
- en: '**CAP property**: Transactional data needs to be at least consistent and partition
    tolerant'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CAP属性**：事务数据至少需要是一致的和分区容错的'
- en: '**Usability**: Transactional data need to show `CRUD` behavior, capabilities
    that Redis does not have'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：事务数据需要显示`CRUD`行为，而Redis没有这些功能'
- en: Redis is not the right datastore for this kind of data. Another point which
    we can figure out here is that wherever we need partition tolerance as a CAP feature,
    Redis should not be used.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Redis不是这种类型数据的正确数据存储。我们还可以看到，无论何时需要CAP特性的分区容错，都不应该使用Redis。
- en: '**Analytical data**: The data classified as analytical data in business shows
    the following properties:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析数据**：在业务中分类为分析数据的数据显示以下属性：'
- en: '**Data complexity**: Data complexity can be further segregated on the basis
    of online analytics and offline analytics. Online analytical data has low to medium
    data complexity as they can contain graph like relation. Offline analytics have
    very high data complexity.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据复杂性**：数据复杂性可以根据在线分析和离线分析进一步分离。在线分析数据的数据复杂性低至中等，因为它们可能包含类似图形的关系。离线分析具有非常高的数据复杂性。'
- en: '**Data quantity**: Data here usually has low to high volumes depending upon
    the kind of analytics we want. Online analytics can have a lower amount of data
    as compared to offline analytics.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据量**：这里的数据通常具有低到高的数据量，取决于我们想要的分析类型。与离线分析相比，在线分析的数据量可能较低。'
- en: '**Persistence**: Data can be stored in disk and memory. If online analytics
    is the requirement, the data is persisted in memory but if the analytics is offline
    then data needs to persist in the disk.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：数据可以存储在磁盘和内存中。如果需要在线分析，则数据存储在内存中，但如果分析是离线的，则数据需要持久存储在磁盘中。'
- en: '**CAP property**: In case of offline analytics, the data needs to be at least
    available and partition tolerant, and in case of online analytics, the data needs
    to be available and consistent.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CAP属性**：在离线分析的情况下，数据至少需要是可用的和分区容错的，在在线分析的情况下，数据需要是可用的和一致的。'
- en: '**Usability**: Message data can have usability in real-time, soft real-time,
    and offline.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：消息数据可以在实时、软实时和离线中使用。'
- en: If the requirement is for online analytics, Redis can be used provided the complexity
    of the data is low.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要进行在线分析，可以使用Redis，前提是数据的复杂性较低。
- en: In the preceding classification of data, we saw some areas where Redis is a
    good fit and areas where Redis can be avoided. But for Redis to be taken seriously
    in the business solution environment, it has to show capability for fault tolerance
    and fault management, replication, and so on. In the next section, we will do
    in-depth study of how redundancy and fault management can be taken care of.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面对数据的分类中，我们看到了Redis适合的一些领域以及应该避免使用Redis的领域。但是，要使Redis在业务解决方案环境中受到认真对待，它必须具备容错和故障管理、复制等能力。在接下来的部分中，我们将深入研究如何处理冗余和故障管理。
- en: Master-slave data replication
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主从数据复制
- en: In any business application, it is paramount that data is kept in a replicated
    manner since hardware can break at any time without giving any warning. In order
    to have continuance of the business, it becomes necessary that when the master
    database goes down, the replicated database can be used instead, which in a way
    guarantees quality of service. Another advantage of having replicated data is
    realized when the traffic on one database goes up and it negatively impacts the
    performance of the solution. In order to provide the performance, it is important
    to load balance the traffic and reduce the load on each node.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何业务应用程序中，数据以复制的方式保存是至关重要的，因为硬件随时可能损坏而不会发出任何警告。为了保持业务的连续性，当主数据库崩溃时，可以使用复制的数据库，这在某种程度上保证了服务的质量。拥有复制数据的另一个优势是当一个数据库的流量增加并且对解决方案的性能产生负面影响时。为了提供性能，重要的是要平衡流量并减少每个节点的负载。
- en: Datastores such as Cassandra provide master-master configuration where all the
    nodes in the topology are like masters and the replication of data takes place
    based on token hash generated on the basis of key, and for that to happen nodes
    in the topology are partitioned based on token ranges.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如Cassandra之类的数据存储提供了主-主配置，其中拓扑中的所有节点都像主节点一样，并且数据的复制是基于基于密钥生成的令牌哈希进行的，为了实现这一点，拓扑中的节点根据令牌范围进行分区。
- en: Redis, unlike master-master breed of datastores, has a simpler master-slave
    arrangement. What it means is that master is the node which will write all the
    data and then replicate the data into all the slave nodes. The replication takes
    place asynchronously which means that the moment a data is written into the master,
    the slaves are not written synchronously but a separate process writes them asynchronously,
    so the update is not immediate; in other words **eventual consistency**. But there
    is advantage in this kind of arrangement in terms of performance. If the replication
    is synchronous then when an update is made to the master, the master has to update
    all the slaves and then only the update will be marked as a success. So if there
    are more slaves then the updates become more time consuming.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与主主数据存储系统不同，Redis具有更简单的主从安排。这意味着主节点将写入所有数据，然后将数据复制到所有从节点。复制是异步进行的，这意味着一旦数据被写入主节点，从节点并不会同步写入，而是由一个单独的过程异步写入，因此更新并不是立即的；换句话说是**最终一致性**。但是这种安排在性能方面有优势。如果复制是同步的，那么当对主节点进行更新时，主节点必须更新所有从节点，然后更新才会被标记为成功。因此，如果有更多的从节点，更新就会变得更加耗时。
- en: The following figure represents the process of master-slave replication in Redis.
    To have a better understanding of the process, let's say that at time **T0**,
    the value of a Set represented by **Msg** is **"Hello"** in the master node as
    well as in all the slave nodes (**S1**, **S2**, **S3**). When an insert command
    **SADD** is made to insert value (**"Hello again"**) to the Set at time **T1**,
    the value **Msg** becomes **Hello Hello again** at time **T2** but the value of
    **Msg** at slave nodes is still **"Hello"**. The new value is successfully inserted
    into the master node and the reply code for a successful insertion is sent back
    to the client. Meanwhile, the master will start inserting all the slaves with
    the new value and this happens in time **T3**. So at time **T3**, all the nodes
    (master and slaves) are updated with the new value. The time lag between the master
    getting updated and the slaves getting updated is very small (in milliseconds).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下图表示了Redis中主从复制的过程。为了更好地理解这个过程，假设在时间**T0**，由**Msg**表示的Set的值在主节点以及所有从节点（**S1**，**S2**，**S3**）中都是**"Hello"**。在时间**T1**进行插入命令**SADD**插入值（**"Hello
    again"**）到Set中，那么在时间**T2**，值**Msg**变成了**Hello Hello again**，但是从节点的**Msg**值仍然是**"Hello"**。新值成功插入到主节点，并且成功插入的回复代码被发送回客户端。与此同时，主节点将开始向所有从节点插入新值，这发生在时间**T3**。因此，在时间**T3**，所有节点（主节点和从节点）都更新为新值。主节点更新和从节点更新之间的时间差非常小（毫秒级）。
- en: To have a better understanding of how master-slave would work in Redis, let's
    revisit the previous chapter where we discussed real-time messaging in Redis.
    To apply the same functionality in this case, we can think that all the slave
    nodes have been subscribed to the master node and when the master node gets updated,
    it publishes the new data to all the slave nodes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解Redis中主从是如何工作的，让我们回顾一下之前讨论的Redis中实时消息传递的章节。为了在这种情况下应用相同的功能，我们可以认为所有的从节点都已经订阅了主节点，当主节点更新时，它会将新数据发布到所有的从节点。
- en: '![Master-slave data replication](img/0123OS_05_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![主从数据复制](img/0123OS_05_02.jpg)'
- en: Data replication in master-slave
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 主从数据复制
- en: So what happens when a slave is down and an update happens in the master? Well,
    in that case, the particular slave misses the update and still carries the older
    value. However, when the slave again connects back to the master, the first thing
    it does is fire a `SYNC` command to the master. This command sends the data to
    the slave nodes wherein it can update itself.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当从节点宕机并且主节点发生更新时会发生什么呢？在这种情况下，特定的从节点会错过更新，仍然保留旧值。然而，当从节点再次连接到主节点时，它首先会向主节点发送一个`SYNC`命令。这个命令将数据发送到从节点，从而使其更新自身。
- en: Setting master and slave nodes
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置主节点和从节点
- en: Setting up master slave nodes is pretty simple in Redis. What we will do here
    is set up a master and a slave node for Redis in our local machine. The first
    thing we do here is to copy the Redis folder (in our case `redis 2.6`) to a suitable
    location. So now we have Redis distribution in two separate locations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在Redis中设置主从节点非常简单。我们在本地机器上为Redis设置一个主节点和一个从节点。我们首先要做的是将Redis文件夹（在我们的例子中是`redis
    2.6`）复制到一个合适的位置。现在我们在两个不同的位置有了Redis分发。
- en: '![Setting master and slave nodes](img/0123OS_05_03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![设置主节点和从节点](img/0123OS_05_03.jpg)'
- en: Master node folder and slave node folder
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 主节点文件夹和从节点文件夹
- en: For the sake of better understanding, we will refer to **Redis-2.6** as the
    master node and **Redis-2.6.slave** as the slave node. Now open the master node
    and go to the `bin/release`" folder and start the Redis-server. This will start
    the Redis server in the localhost and with port address 6379\. Now open the slave
    node and open the `Redis.conf` file in a suitable text editor. There are at least
    two properties that need to be changed in order to start our slave node. The first
    property which needs to be edited is `port`. In our case, let's change the value
    from 6379 to 6380\. Since the master node is going to listen for requests at 6379,
    the slave has to listen at a different port (we are going to launch both the master
    and the slave from the same machine). The second property change that needs to
    be done is `slaveof`, the value of which is going to be `127.0.0.1 6379`. This
    is basically telling the slave where and what port the master is running. This
    is helpful since the slave is going to use this address to send `SYNC` and other
    commands to the master. With these minimal changes we are good to go. Now go to
    the `bin/release` folder of the slave node and start the Redis-server.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，我们将**Redis-2.6**称为主节点，**Redis-2.6.slave**称为从节点。现在打开主节点，转到`bin/release`文件夹并启动Redis-server。这将在本地主机上以端口地址6379启动Redis服务器。现在打开从节点，并在适当的文本编辑器中打开`Redis.conf`文件。至少需要更改两个属性才能启动从节点。需要编辑的第一个属性是`port`。在我们的情况下，让我们将值从6379更改为6380。由于主节点将在6379端口监听请求，从节点必须在不同的端口监听请求（我们将从同一台机器上启动主节点和从节点）。需要进行的第二个属性更改是`slaveof`，其值将是`127.0.0.1
    6379`。这基本上告诉从节点主节点在何处以及在哪个端口运行。这很有帮助，因为从节点将使用此地址向主节点发送`SYNC`和其他命令。进行这些最小更改后，我们就可以开始了。现在转到从节点的`bin/release`文件夹并启动Redis-server。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When you start the Redis-server, provide the path of `Redis.conf` of the slave
    node, that is Redis-server `F:\path\to\config-file\Redis.conf`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当启动Redis-server时，请提供从节点的`Redis.conf`路径，即Redis-server `F:\path\to\config-file\Redis.conf`。
- en: The first thing we would see when we fire the slave node is that it will try
    to connect to the master. From its `Redis.conf`, the slave node will figure out
    the host and port of the master node. One thing again which is different in Redis
    as compared to other datastores is that it uses one port for catering to business
    requests as well as catering to `SYNC` and other ports for similar request from
    slave nodes. This is primarily because Redis is a single threaded server and the
    thread only listens to the messages coming to the socket.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动从节点时，我们会看到的第一件事是它会尝试连接到主节点。从其`Redis.conf`中，从节点将找出主节点的主机和端口。Redis与其他数据存储相比的另一件事是，它使用一个端口来处理业务请求，同时还使用`SYNC`和其他端口来处理从节点的类似请求。这主要是因为Redis是单线程服务器，线程只监听传入套接字的消息。
- en: 'The following figure represents how your command prompt might look when the
    slave node starts (please make sure your master node is up and running):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示从节点启动时命令提示符的外观（请确保主节点正在运行）：
- en: '![Setting master and slave nodes](img/0123OS_05_04.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![设置主节点和从节点](img/0123OS_05_04.jpg)'
- en: Slave node starting at port 6380
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从节点在端口6380启动
- en: There are a couple of things that need to be noted here. The first thing is
    that the moment the slave node starts, it fires a `SYNC` command to the master.
    The command is a nonblocking command which means that the single thread will not
    hold other requests in order to cater to this request. What basically the master
    does is put it in a request stack for that connection and time slices it with
    the other connections, and when the activity is complete for that command of that
    connection (in our case `SYNC` for slave) it sends it to slave. In this case,
    what it sends back is the command and the data that the slave needs to have to
    become at par with the master. This command is executed with the data and it is
    then subsequently loaded in the slave's database. All the commands that the master
    sends are the commands which alter the data and not the data `getter` commands.
    The protocol used by the master to connect to the slaves is the **Redis protocol**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几件事需要注意。第一件事是，从节点启动时，它会向主节点发送`SYNC`命令。该命令是非阻塞命令，这意味着单个线程不会阻止其他请求以满足此请求。主要是主节点将其放入该连接的请求堆栈中，并将其与其他连接的时间片进行切割，当该连接的命令活动完成时（在我们的情况下是从节点的`SYNC`），它将其发送到从节点。在这种情况下，它发送回的是命令和从节点需要的数据，以使其与主节点保持一致。该命令与数据一起执行，然后随后加载到从节点的数据库中。主节点发送的所有命令都是更改数据而不是获取数据的命令。主用于连接到从节点的协议是**Redis协议**。
- en: 'Let''s look into some scenarios and see how Redis behaves in the master slave
    mode:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些场景，并看看Redis在主从模式下的行为：
- en: 'Master is up and a telnet session connects to the master:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主节点正在运行，telnet会话连接到主节点：
- en: Make sure Redis master node is up.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Redis主节点正在运行。
- en: Make sure Redis client for the master is running.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保主Redis客户端正在运行。
- en: Open your command prompt and connect to the master using the command `telnet
    127.0.0.1 6379`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符，并使用命令`telnet 127.0.0.1 6379`连接到主机。
- en: Type the command `SYNC` in the telnet client. The following text should appear
    in the command prompt:![Setting master and slave nodes](img/0123OS_05_05.jpg)
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在telnet客户端中键入`SYNC`命令。命令提示符中应出现以下文本：![设置主节点和从节点](img/0123OS_05_05.jpg)
- en: Master pinging telnet client
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 主节点ping telnet客户端
- en: Go to your master client prompt and type the command `SET MSG "Learning Redis
    master slave replication"` and execute it. Immediately shift to the telnet command
    prompt and you will see the following output:![Setting master and slave nodes](img/0123OS_05_06.jpg)
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到主客户端提示符，并键入命令`SET MSG "Learning Redis master slave replication"`并执行它。立即切换到telnet命令提示符，您将看到以下输出：![设置主节点和从节点](img/0123OS_05_06.jpg)
- en: Master sending the data to telnet client
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 主节点向telnet客户端发送数据
- en: Now execute the `GET MSG` command at the client prompt of the master node
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在主节点的客户端提示符中执行`GET MSG`命令
- en: 'Master is up and the slave connects for the first time:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主节点已启动，从节点首次连接：
- en: The slave console is similar to the previous figure.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从节点控制台与上一图类似。
- en: Fire a command from master Redis-cli as `SET MSG "Learning Redis"`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主节点的Redis-cli中发出命令`SET MSG "学习Redis"`。
- en: Fire a command from slave Redis-cli as `GET MSG`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从从节点的Redis-cli中发出命令`GET MSG`。
- en: Make sure you give the host and port addresses; in our case since we have configured
    it in localhost and port is configured at 6380, the command would look like `Redis-cli.exe
    -h localhost -p 6380`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您提供主机和端口地址；在我们的情况下，因为我们已将其配置为localhost并且端口配置为6380，命令看起来像`Redis-cli.exe -h
    localhost -p 6380`。
- en: The result should be `"Learning Redis"`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果应该是`“学习Redis”`。
- en: 'Master is up and slave comes up again after being disconnected for a while:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主节点已启动，从节点再次连接：
- en: Kill the slave node and the client.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 杀死从节点和客户端。
- en: Go to the master's client command prompt and write the command `SET MSG "Slave
    node is down"`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到主节点的客户端命令提示符并编写命令`SET MSG "从节点已关闭"`。
- en: Now start the slave node and its client (provide host and port information).
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在启动从节点及其客户端（提供主机和端口信息）。
- en: Execute the command `GET MSG` from slave's client command prompt and the result
    should be `"Slave node is down"`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从从节点的客户端命令提示符执行命令`GET MSG`，结果应该是`“从节点已关闭”`。
- en: 'Master is up and is executing a pipeline command and we are reading the value
    from slave:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主节点已启动并正在执行管道命令，我们正在从从节点读取值：
- en: Make sure master and slave are up and running.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保主节点和从节点正在运行。
- en: Write the `SCARD MSG` command in slave client's command prompt but do not execute
    it. We are going to get the number of members in the set `MSG`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在从节点客户端的命令提示符中写入`SCARD MSG`命令，但不要执行它。我们将得到集合`MSG`中成员的数量。
- en: 'Open you Java client and write the following program:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的Java客户端并编写以下程序：
- en: '[PRE0]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Execute this command and immediately switch to your slave client command prompt
    and execute the command you had written. The result will be similar to the figure
    shown next. What it tells us is that the moment a command is executed in the master
    node which changes the dataset, the master starts buffering these commands and
    sends them to the slave. In our case, when we did a `SCARD` on the set, we saw
    results in an incremental way.![Setting master and slave nodes](img/0123OS_05_07.jpg)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此命令，立即切换到从节点客户端命令提示符并执行您编写的命令。结果将类似于下图所示。它告诉我们的是，当在更改数据集的主节点中执行命令时，主节点开始缓冲这些命令并将它们发送到从节点。在我们的情况下，当我们对集合执行`SCARD`时，我们以递增的方式看到结果。![设置主节点和从节点](img/0123OS_05_07.jpg)
- en: Result of SCARD command on slave node
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从节点上`SCARD`命令的结果
- en: Master is up and is executing a transaction command and we are reading the value
    from slave.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主节点已启动，并正在执行事务命令，我们正在从从节点读取值。
- en: 'Promoting slave as master when the master goes down and restarting master as
    slave:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当主节点关闭并重新启动为从节点时提升从节点为主节点：
- en: Start master and slave Redis servers.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动主节点和从节点Redis服务器。
- en: 'Execute the following Java program from your IDE:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的IDE执行以下Java程序：
- en: '[PRE1]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When the program goes to sleep for the first time, quickly go to the command
    prompt of the master and restart it (don't touch the slave node). Allow the program
    to finish and the output is going to be similar to the following image:![Setting
    master and slave nodes](img/0123OS_05_08.jpg)
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当程序第一次进入睡眠状态时，快速转到主节点的命令提示符并重新启动它（不要触摸从节点）。允许程序完成，输出将类似于以下图像：![设置主节点和从节点](img/0123OS_05_08.jpg)
- en: Master becomes slave and slave becomes master
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 主节点变为从节点，从节点变为主节点
- en: The second sleep in the program is meant for the master to sync up with the
    new master.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序中的第二次睡眠是为了主节点与新主节点同步。
- en: When the old master attempts to write against the key, it fails since slaves
    cannot write.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当旧主节点尝试写入密钥时，它会失败，因为从节点无法写入。
- en: Server messages when the old slave became new master.![Setting master and slave
    nodes](img/0123OS_05_09.jpg)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器消息，旧奴隶成为新主人时。![设置主节点和从节点](img/0123OS_05_09.jpg)
- en: Slave becomes master
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从奴隶变成主人
- en: Server messages when the old master is started as a new slave. We can also see
    that the moment the old master restarts, the first thing it does as a slave is
    to sync with the new master and update its datasets.![Setting master and slave
    nodes](img/0123OS_05_10.jpg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旧主节点作为新从节点启动时的服务器消息。我们还可以看到，旧主节点重新启动时，作为从节点的第一件事是与新主节点同步并更新其数据集。![设置主节点和从节点](img/0123OS_05_10.jpg)
- en: Master becomes slave
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 主节点变为从节点
- en: If we don't give the second sleep in the program, the old master will not get
    time to sync with the new master and if there is a client request for a key then
    it will end up showing the old value for the key
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在程序中不给第二次睡眠，旧主节点将没有时间与新主节点同步，如果有客户端请求一个密钥，那么它将最终显示密钥的旧值
- en: Until now we have learnt the master-slave capabilities of Redis and how it behaves
    in cases where master goes down or slave goes down. We also discussed that master
    sends data to slave and replicates the dataset. But still the question is what
    does Redis master send when it has to send data to the slaves? To find out, let's
    run a small experiment which will clarify the behind the scene activities.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了Redis的主从能力以及在主节点关闭或从节点关闭时它的行为。我们还讨论了主节点向从节点发送数据并复制数据集。但问题仍然是，当Redis主节点必须向从节点发送数据时，它发送了什么？为了找出答案，让我们进行一个小实验，这将澄清幕后的活动。
- en: Performance pattern – high reads
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能模式 - 高读取
- en: In a production environment, it becomes important to have some kind of a strategy
    when the concurrency is high. Having a replication pattern surely helps to distribute
    the load across the environment. The replication pattern followed in this pattern
    is to write to the master and read from the slaves.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，当并发性高时，拥有某种策略变得很重要。采用复制模式肯定有助于在环境中分发负载。在这种模式中遵循的复制模式是向主节点写入并从从节点读取。
- en: '![Performance pattern – high reads](img/0123OS_05_11.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![性能模式 - 高读取](img/0123OS_05_11.jpg)'
- en: Replication strategy in master and slaves
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 主节点和从节点中的复制策略
- en: The sample we will run will not be a proper replication of the previous mentioned
    solution since the master and the slave will run from the same machine (my laptop).
    By running the master and the slave nodes in the same machine, we are utilizing
    common memory and processing power. On top of it, the client program also uses
    the same resources. But still the difference will be observed because of server
    I/O happenings at two different ports, which means that at least a separate socket
    memory bound to two separate server threads (Redis is a single thread server)
    are processing the read requests.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行的示例不会是之前提到的解决方案的正确复制，因为主节点和从节点将从同一台机器（我的笔记本电脑）运行。通过在同一台机器上运行主节点和从节点，我们利用了共同的内存和处理能力。此外，客户端程序也使用相同的资源。但仍然会观察到差异，因为服务器I/O在两个不同的端口上发生，这意味着至少有两个独立的服务器线程（Redis是单线程服务器）处理读取请求时绑定到两个独立的套接字内存。
- en: In a production environment, it is better if every node works out of its own
    core since Redis cannot make use of multi-core.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，最好是每个节点都在自己的核心上工作，因为Redis无法利用多核。
- en: In this sample, we will use one master and two slave nodes. In the first use
    case, we will use the master to write data into and the slaves to read data from.
    We will take the total time taken for the reads only and compare it with a scenario
    where the reads will be done entirely on the master node.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用一个主节点和两个从节点。在第一个用例中，我们将使用主节点写入数据，并使用从节点读取数据。我们将记录仅读取所需的总时间，并将其与完全在主节点上进行读取的情况进行比较。
- en: 'To prepare for the sample we need to prepare for the environment and the following
    diagram depicts in brief what the setup shall be for this sample. Here note that
    all the resources are from a single machine:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备示例，我们需要准备环境，以下图表简要描述了这个示例的设置应该是什么。在这里请注意，所有资源都来自一台单独的机器：
- en: '![Performance pattern – high reads](img/0123OS_05_12.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![性能模式 - 高读取](img/0123OS_05_12.jpg)'
- en: Setup for the sample
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 示例设置
- en: 'The following written program can accommodate both the scenarios discussed
    earlier. To work in the **USECASE-1** mode (write to master and read from master
    node), call the following functions:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下编写的程序可以适应之前讨论过的两种情况。要在**USECASE-1**模式下工作（从主节点写入并从主节点读取），请调用以下函数：
- en: Call `test.setup()` in the first run.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一次运行中调用`test.setup()`。
- en: Call `test.readFromMasterNode()` in the second run
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二次运行中调用`test.readFromMasterNode()`
- en: Please comment the following function call this will not allow **USECASE-2**
    to run `// test.readFromSlaveNodes();`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注释以下函数调用，这将不允许**USECASE-2**运行`// test.readFromSlaveNodes();`。
- en: 'To work in the **USECASE-2** mode (write to master and read from two slaves),
    call the following functions, but before that, execute `FLUSHDB` command to clean
    up the data or don''t execute the `test.setup();` function:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要在**USECASE-2**模式下工作（从主节点写入并从两个从节点读取），请调用以下函数，但在此之前，执行`FLUSHDB`命令清理数据，或者不执行`test.setup();`函数：
- en: Call `test.setup();` in the first run (optional).
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一次运行中调用`test.setup();`（可选）。
- en: Call `test.readFromSlaveNodes();` in the second run.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二次运行中调用`test.readFromSlaveNodes();`
- en: Please comment the following function call this will not allow **USECASE-1**
    to run `// test.readFromMasterNode();`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注释以下函数调用，这将不允许**USECASE-1**运行`// test.readFromMasterNode();`。
- en: 'The code has three simple classes and a brief description of the classes is
    as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 代码有三个简单的类，类的简要描述如下：
- en: '`MasterSlaveLoadTest`: This class has the following characteristics:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MasterSlaveLoadTest`：这个类具有以下特点：'
- en: This is the main class
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是主类
- en: This class coordinates the flow for **USECASE-1** and **USECASE-2**
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类协调**USECASE-1**和**USECASE-2**的流程
- en: This class is responsible for creating threads for **USECASE-1** and **USECASE-2**
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类负责为**USECASE-1**和**USECASE-2**创建线程
- en: 'Following is the code for `MasterSlaveLoadTest`:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是`MasterSlaveLoadTest`的代码：
- en: '[PRE2]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`PumpData`: This class has the following characteristics:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PumpData`：这个类具有以下特点：'
- en: This is the class responsible for pushing the data into the main node
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类负责将数据推送到主节点
- en: The data pushing is single threaded
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据推送是单线程的
- en: 'The code for `PumpData` is as follows:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PumpData`的代码如下：'
- en: '[PRE3]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`FetchData`: This class has the following characteristics:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FetchData`：这个类具有以下特点：'
- en: This is the class responsible for fetching the data from the Redis nodes
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类负责从Redis节点中获取数据
- en: This class is called in a multi-threaded mode
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类以多线程模式调用
- en: This class is passed at start time so the last result returned will indicate
    the total time the execution has taken place
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类在启动时传递，因此返回的最后结果将指示执行所花费的总时间
- en: 'The code for `FetchData` is as follows:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FetchData`的代码如下：'
- en: '[PRE4]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Run the preceding program for a few iterations and take out the best and worst
    record, and then take out the average result. For the iterations that I ran, I
    got the following results:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行前面的程序几次，并取出最好和最差的记录，然后取出平均结果。在我运行的迭代中，我得到了以下结果：
- en: For USECASE-1, the average time was 95609 milliseconds
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于USECASE-1，平均时间为95609毫秒
- en: For USECASE-2, the average time was 72622 milliseconds
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于USECASE-2，平均时间为72622毫秒
- en: Though the results in your machines will be different in terms of number, but
    the results will be similar. This clearly shows that reading from slave nodes
    and writing to master node clearly is better performing.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管在您的机器上结果可能不同，但结果将是相似的。这清楚地表明从从节点读取并写入主节点明显更好。
- en: Performance pattern – high writes
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能模式 - 高写入
- en: In a production environment, it becomes important to have some kind of a strategy
    when the demand for concurrency is high for writes. Having a replication pattern
    surely helps to distribute the load across the environment but replication pattern
    alone is not helpful when the need for concurrency in writes is high. Also, in
    Redis the slave nodes cannot have write capability. In order to make the data
    write highly concurrent in the database, it is important to shard the dataset
    across many database nodes in the environment. Many databases come with the in-built
    capability to shard the data accordingly across nodes. The advantage of having
    the dataset sharded, apart from high concurrency in writes, is to provide mechanism
    of partial failure tolerance. In other words, even if one of the nodes goes down,
    it will make the dataset contained in it unavailable but the other nodes can still
    cater to the requests for the data they hold.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，当对写入的并发需求很高时，有一种策略变得很重要。复制模式确实有助于在环境中分发负载，但是当对写入的并发需求很高时，仅有复制模式是不够的。此外，在Redis中，从节点无法进行写入。为了使数据库中的数据写入高并发，重要的是在环境中将数据集分片到许多数据库节点上。许多数据库都具有内置的能力，可以根据需要在节点之间分片数据。除了写入的高并发性外，将数据集分片的优势在于提供部分故障容忍的机制。换句话说，即使其中一个节点宕机，它将使其中包含的数据不可用，但其他节点仍然可以处理它们持有的数据的请求。
- en: Redis as a database lacks the capability to shard the data across many nodes.
    But it is possible to have some sort of intelligence built on top of Redis which
    can do the work of sharding, thus enabling high concurrent writes for Redis. The
    whole idea here is to take the responsibility out of the Redis nodes and keep
    it in a separate location.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 作为数据库，Redis缺乏在许多节点之间分片数据的能力。但是可以在Redis之上构建某种智能，来完成分片的工作，从而实现对Redis的高并发写入。整个想法是将责任从Redis节点中移出，并保留在一个单独的位置。
- en: '![Performance pattern – high writes](img/0123OS_05_13.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![性能模式-高写入](img/0123OS_05_13.jpg)'
- en: Distributing the data across nodes based on sharding logic
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 基于分片逻辑在节点之间分发数据
- en: There are various logics that can be built on top of Redis which can be used
    to distribute the write load. Logic can be based on a round robin where the data
    can be distributed on sequentially arranged nodes; for example, data will go to
    **M1**, then **M2**, then **M3**, and so on and so forth. But the problem in this
    mechanism is that if one of the nodes were to go down, the round robin logic cannot
    factor in the lost node and it will continue to send data to the defective node
    which will end up in data loss. Even if we build logic to skip the defective node
    and put the data in the subsequent node, this strategy will result in that node
    having its own share of data, and the data of the defective node thus fills up
    its memory resources very fast.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在Redis之上构建各种逻辑，用于分发写入负载。逻辑可以基于循环轮询，其中数据可以在顺序排列的节点上分发；例如，数据将会先到**M1**，然后到**M2**，然后到**M3**，依此类推。但是这种机制的问题在于，如果其中一个节点宕机，循环轮询逻辑无法考虑到丢失的节点，它将继续向有问题的节点发送数据，导致数据丢失。即使我们构建逻辑来跳过有问题的节点并将数据放入后续的节点，这种策略将导致该节点拥有自己的数据份额，并且有问题的节点的数据将迅速填满其内存资源。
- en: Consistent Hashing is one of the algorithms which can come in handy when equally
    distributing data amongst the nodes. What basically we do here is that based on
    algorithms we generate, a Hash which distributes the key equally amongst the entire
    set of available Redis server.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性哈希是一种算法，可以在节点之间平均分发数据时非常有用。基本上，我们根据算法生成一个哈希，将密钥平均分布在整个可用的Redis服务器集合中。
- en: 'The Redis client for Java already has the algorithm for consistent Hashing
    built into it to distribute the writes. This is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Java的Redis客户端已经内置了一致性哈希算法来分发写入。具体如下：
- en: '[PRE5]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Persistence handling in Redis
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redis中的持久化处理
- en: 'Redis provides a wide range of options for persisting data. These mechanisms
    help in deciding what kind of persistence model we need for our data, and that
    solely depends on the kind of data we want to store in Redis. The four options
    that we have in Redis are as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Redis提供了各种持久化数据的选项。这些机制有助于决定我们的数据需要什么样的持久化模型，这完全取决于我们想要在Redis中存储的数据类型。Redis中有四种选项：
- en: Persisting via the RDB option
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过RDB选项进行持久化
- en: Persisting via the AOF option
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过AOF选项进行持久化
- en: Persisting via combination of AOF and RDB option
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过AOF和RDB选项的组合进行持久化
- en: Not persisting at all
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根本不进行持久化
- en: 'Let''s run a simple program and see the importance of persistence mechanism,
    because then only we can appreciate the importance of persistence. Follow the
    steps and see for yourself how lack of persistence can cause data loss:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一个简单的程序，看看持久化机制的重要性，因为只有这样我们才能意识到持久化的重要性。按照步骤操作，亲自看看缺乏持久化会导致数据丢失：
- en: Start your Redis server.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Redis服务器。
- en: Open a Redis client command prompt.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Redis客户端命令提示符。
- en: Execute the command `SET msg 'temporary value'`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行命令`SET msg 'temporary value'`。
- en: Quickly kill the Redis server manually, either by **Kill-9** option in Linux
    or through **close** option in Command Prompt in windows.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动快速关闭Redis服务器，可以在Linux中使用**Kill-9**选项，也可以在Windows的命令提示符中使用**close**选项。
- en: Restart your Redis server.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动Redis服务器。
- en: Execute the command `get msg`.![Persistence handling in Redis](img/0123OS_05_14.jpg)
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行命令`get msg`。
- en: Get msg without persistence handling
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 没有持久化处理的msg
- en: Persisting via the RDB option
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过RDB选项进行持久化
- en: '**Redis database file** (**RDB**) is an option where the Redis server persists
    the dataset at regular interval or in other words, snapshots the data in memory
    at regular intervals. The format is a single, very compact file which is useful
    for keeping data as backups. This file can act as a saving grace in case of a
    disaster and thus is very important. The Redis server can be configured to take
    snapshots at various intervals. From a performance perspective, this way of persisting
    data will result in higher performance since the Redis server will fork a child
    process to do this in a nonblocking manner. Another advantage is that since it
    is the dataset only that is stored in the RDB files, the server start-ups are
    very fast in case of RDB files. But storing dataset in RDB comes with its own
    disadvantage since chances of data loss is possible if Redis were to fail in between
    two snapshots. Another problem might crop up if the dataset is very high in volume
    because in that case the Redis server''s forked child process will take time to
    load up the data and this time taken can block client requests for that duration.
    This problem will not come in production scenarios as there is always a time lag
    between the servers to restart and for the server to process the client request.
    From a hardware perspective, a machine with a faster processor will always do
    the trick.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**Redis数据库文件**（**RDB**）是Redis服务器在定期间隔内持久化数据集的选项，换句话说，定期间隔内在内存中对数据进行快照。该格式是一个单一的、非常紧凑的文件，对于保留数据作为备份非常有用。在灾难发生时，该文件可以充当救命稻草，因此非常重要。Redis服务器可以配置为在各种间隔内拍摄快照。从性能的角度来看，这种持久化数据的方式将导致更高的性能，因为Redis服务器将fork一个子进程以非阻塞的方式执行此操作。另一个优点是，由于RDB文件中仅存储数据集，因此在RDB文件的情况下，服务器的启动非常快。但是，将数据集存储在RDB中也有其缺点，因为如果Redis在两个快照之间失败，可能会发生数据丢失的可能性。如果数据集的体积非常大，可能会出现另一个问题，因为在这种情况下，Redis服务器的fork子进程将花费时间来加载数据，而这段时间可能会阻塞客户端请求。在生产场景中，这个问题不会出现，因为服务器重新启动和服务器处理客户端请求之间总是有时间差的。从硬件的角度来看，具有更快处理器的机器总是可以解决问题的。'
- en: Configuring Redis for RDB persistence
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为RDB持久性配置Redis
- en: 'Here we will learn how to persist data on a RDB file. Well in Redis, the RDB
    persistence mechanism can be configured by editing the `Redis.conf` file or through
    the client prompt. When we open our `Redis.conf` file and go to the `snapshotting`
    section, we see the following options:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将学习如何将数据持久化到RDB文件中。在Redis中，可以通过编辑`Redis.conf`文件或通过客户端提示来配置RDB持久性机制。当我们打开我们的`Redis.conf`文件并转到`快照`部分时，我们会看到以下选项：
- en: '`Save 900 1`: Save in 15 minutes if one key has changed'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Save 900 1`：如果一个键已更改，则在15分钟内保存'
- en: '`Save 300 10`: Save in 5 minutes if 10 keys have changed'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Save 300 10`：如果10个键已更改，则在5分钟内保存'
- en: '`Save 60 10000`: Save in 1 minute if 10,000 keys have changed'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Save 60 10000`：如果有10,000个键已更改，则在1分钟内保存'
- en: Apart from these preconfigured options, we can add our own options by tweaking
    the value in the `Redis.conf` file. Clients can also be used to add configurations
    at runtime for dataset snapshotting. For example, `CONFIG SET SAVE "900 2 300
    10"` will set snapshotting as `Save in 15 minutes if 2 keys have changed` and
    `Save in 10 minutes if one key has changed`, and this will override the previous
    values.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些预配置的选项之外，我们还可以通过调整`Redis.conf`文件中的值来添加我们自己的选项。客户端还可以用于在运行时为数据集快照添加配置。例如，`CONFIG
    SET SAVE "900 2 300 10"`将设置快照为`如果2个键已更改，则在15分钟内保存`，`如果一个键已更改，则在10分钟内保存`，这将覆盖先前的值。
- en: 'Let''s run a simple program like the previous program wherein we see data loss
    due to lack of persistence and we will configure the Redis to have persistence
    mechanism:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一个简单的程序，就像之前的程序一样，我们会看到由于缺乏持久性而导致的数据丢失，我们将配置Redis以具有持久性机制：
- en: Start your Redis server.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动您的Redis服务器。
- en: Open a Redis client command prompt.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个Redis客户端命令提示符。
- en: Execute the command `Set msg 'temp value'`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行命令`Set msg 'temp value'`。
- en: Quickly kill the Redis server manually, either by **Kill-9** option in Linux
    or through **close** option in command prompt in windows.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速手动关闭Redis服务器，可以通过Linux中的**Kill-9**选项或Windows命令提示符中的**close**选项。
- en: Restart your Redis server.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动您的Redis服务器。
- en: Execute the command `get msg`.![Configuring Redis for RDB persistence](img/0123OS_05_15.jpg)
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行命令`get msg`。![为RDB持久性配置Redis](img/0123OS_05_15.jpg)
- en: Get msg without persistence handling
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 没有持久性处理的获取msg
- en: Now execute the command `CONFIG SET SAVE "60 1"`, which tells the Redis server
    to save the data in one minute if one key has changed.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在执行命令`CONFIG SET SAVE "60 1"`，这告诉Redis服务器，如果一个键已更改，则在一分钟内保存数据。
- en: Execute the command `Set msg 'temp value'`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行命令`Set msg 'temp value'`。
- en: Wait for a minute or go and grab a cup of your favorite beverage.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待一分钟或去拿您最喜欢的饮料。
- en: Kill the server.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭服务器。
- en: Restart your Redis server.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动您的Redis服务器。
- en: Open a new client connection and execute the command `get msg`, which would
    result in the following display:![Configuring Redis for RDB persistence](img/0123OS_05_16.jpg)
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的客户端连接并执行命令`get msg`，将显示如下内容：![为RDB持久性配置Redis](img/0123OS_05_16.jpg)
- en: Get msg RDB persistence handling
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 获取msg RDB持久性处理
- en: Instead of waiting for one minute, you can also use the `save` command which
    will immediately push the data in memory into the RDB file.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您也可以使用`save`命令，而不是等待一分钟，该命令将立即将内存中的数据推送到RDB文件中。
- en: 'The parameters that you need to give attention to for persisting your data
    into a RDB file are as follows:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您需要注意的参数为了将数据持久化到RDB文件中，如下所示：
- en: '`dbfilename`: Give the name of you RDB file'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dbfilename`：给出您的RDB文件的名称'
- en: '`dir`: Give the path of the RDB file only'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dir`：只给出RDB文件的路径'
- en: '`rdbchecksum yes`: This is default value which adds CRC64 checksum placed at
    the end of the file to make it resistant to corruption but has a minor performance
    penalty on server restarts'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rdbchecksum yes`：这是默认值，它在文件末尾添加CRC64校验和，以使其抵抗损坏，但在服务器重新启动时会有轻微的性能损失'
- en: Use case for using RDB persistence
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用RDB持久性的用例
- en: Redis can be configured to have RDB persistence mechanism in cases where data
    is stateless. What I want to convey here is that if the data is a piece of information
    that has no relation to the data stored before or the next piece of data it is
    going to store, then it becomes a perfect candidate for RDB persistence. Moreover,
    the relation can be in terms of sequence, time, rank, and so on, or the data itself
    can contain information of state. Take for example where the data stored is `START`,
    `PAUSE`, `RESUME`, and `STOP`. In this case, if we were to lose data such as `PAUSE`
    or `RESUME` during snapshotting, then it might bring the entire system to an unstable
    mode.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Redis可以在数据是无状态的情况下配置RDB持久化机制。我想要传达的是，如果数据是一条信息，与之前存储的数据或即将存储的数据没有关系，那么它就是RDB持久化的完美候选者。此外，关系可以是序列、时间、排名等，或者数据本身可以包含状态信息。例如，存储的数据是`START`、`PAUSE`、`RESUME`和`STOP`。在这种情况下，如果我们在快照期间丢失`PAUSE`或`RESUME`等数据，那么可能会使整个系统变得不稳定。
- en: Let's take a use case where the website records the URLs the user visits in
    a browsing session. This data is analyzed for profiling the user behavior in order
    to give the user a better service. In this case, the data, that is the URL of
    the page visited, is not related to the data stored previously or the data to
    be stored in future, so it does not have a state. So even in a case of failure
    between two snapshots, if some amount of data is lost it is not going to impact
    the overall analysis.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个使用情况，网站记录用户在浏览会话中访问的URL。这些数据被分析以对用户行为进行个人资料化，以便为用户提供更好的服务。在这种情况下，访问的页面的URL与之前存储的数据或将来存储的数据没有关系，因此它没有状态。因此，即使在两个快照之间发生故障，如果丢失了一些数据，也不会影响整体分析。
- en: Another use case where RDB persistence can be used is when we want to use Redis
    as a caching engine where there will be fewer data writes and data reads are going
    to be very frequent.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以使用RDB持久化的使用情况是当我们想要将Redis用作缓存引擎时，数据写入较少，而数据读取非常频繁。
- en: Persisting via the AOF option
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过AOF选项进行持久化
- en: '**Append only file** (**AOF**) is a durable mechanism of storing data in the
    Redis datastore. When AOF is enabled, Redis will append all the commands (that
    write into the dataset) and the associated data, so that when the Redis server
    is restarted it will rebuild the dataset to the correct state. This mode of persistence
    is useful when we are storing data that have states. This is because when we are
    doing state management or have a state associated with a dataset in the eventuality
    of a server shutdown the information (the state information stored in the memory)
    will be lost. This in turn would result in some sort of state mismatch. Let''s
    say that we have a piece of information at state A and subsequent activities on
    that information change its state from A to B and from B to C, and so on and so
    forth. Now from a user''s perspective, the last state change brought the information
    in the D state, which in principle would be in memory, and in the case of a server
    shutdown (crash), the information will be lost, so the state change information
    D will be lost. So when the server restarts, and if the user changes the state
    of that information to E, the state change history will look like A to B, B to
    C, and C to E. This in certain scenarios would result in corrupt data. The AOF
    way of persisting takes care of the problems that may arise due to this.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**追加文件**（**AOF**）是在Redis数据存储中存储数据的持久机制。启用AOF后，Redis将追加所有写入数据集的命令和相关数据，因此当Redis服务器重新启动时，它将重建数据集到正确的状态。这种持久性模式在存储具有状态的数据时非常有用。这是因为当我们进行状态管理或者数据集与状态相关联时，在服务器关闭的情况下，存储在内存中的信息（状态信息）将会丢失。这反过来会导致某种状态不匹配。假设我们有一条信息处于状态A，并且随后对该信息进行的活动将其状态从A变为B，从B变为C，依此类推。现在从用户的角度来看，最后的状态变化将信息带入了D状态，这个状态原则上应该在内存中，并且在服务器关闭（崩溃）的情况下，信息将会丢失，因此状态变化信息D也将会丢失。因此，当服务器重新启动时，如果用户将该信息的状态更改为E，状态变化历史将看起来像A到B，B到C，C到E。在某些情况下，这可能导致数据损坏。AOF持久化方式解决了由此可能引起的问题。'
- en: Configuring Redis for AOF persistence
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置Redis进行AOF持久化
- en: AOF can be enabled by making a change in the `Redis.conf` file. The property
    `appendonly` needs to be set to `yes`. By setting it to true, we signal Redis
    to record the write commands and the data into a file which will reply itself
    when the server restarts, bringing it to the same state in which it was before
    shutdown.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过更改`Redis.conf`文件来启用AOF。需要将属性`appendonly`设置为`yes`。通过将其设置为true，我们告诉Redis记录写命令和数据到一个文件中，当服务器重新启动时，它将重新加载这些数据，使其恢复到关闭之前的状态。
- en: Redis provides three flavors or strategies to mitigate problems arising due
    to inconsistent states. The first strategy is to record every write event in the
    AOF file. This mechanism is the safest but not very good in performance. The way
    this can be achieved is via `appendfsync always`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Redis提供了三种策略来缓解由不一致状态引起的问题。第一种策略是记录AOF文件中的每个写入事件。这种机制是最安全的，但性能不是很好。可以通过`appendfsync
    always`来实现这一点。
- en: The second mechanism is time-based wherein we instruct the Redis server to buffer
    every write command and schedule an AOF append every second. This technique is
    more efficient since this is happening in every second and not on every write.
    The way it can be achieved is by telling Redis to `appendfsync everysec`. Here
    in this mechanism, there is a miniscule chance of state loss.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种机制是基于时间的，我们指示Redis服务器缓冲每个写入命令，并安排每秒进行一次AOF追加。这种技术更有效，因为它是每秒发生一次，而不是在每次写入时。可以通过告诉Redis`appendfsync
    everysec`来实现这一点。在这种机制中，状态丢失的可能性非常小。
- en: The third mechanism is more like a delegation where the control to append is
    given to the underlying operating server to flush the write commands from the
    buffer to the AOF file. The frequency of append is once every few seconds (in
    a Linux-based machine, the frequency is close to once every 30 seconds). The performance
    is the fastest in this technique since this is happening every 30 seconds. However,
    the chances and amount of data loss is also high in this mechanism. This way of
    appending can be achieved by telling Redis to `appendfsync no`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种机制更像是一种委托，其中将附加控制权交给底层操作服务器，以将写命令从缓冲区刷新到AOF文件。附加的频率是每隔几秒一次（在基于Linux的机器上，频率接近每30秒一次）。这种技术的性能是最快的，因为这是每30秒发生一次。然而，在这种机制中，数据丢失的机会和数量也很高。可以通过告诉Redis
    `appendfsync no` 来实现这种附加方式。
- en: 'Let''s run a simple program like the previous program wherein we see data loss
    due to a lack of persistence and we will configure the Redis to have AOF persistence
    mechanism:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一个简单的程序，就像之前的程序一样，其中由于缺乏持久性而导致数据丢失，我们将配置Redis以具有AOF持久性机制：
- en: Start your Redis server.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Redis服务器。
- en: Open a Redis client command prompt.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Redis客户端命令提示符。
- en: Execute the command `Set msg 'temp value'`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行命令`Set msg 'temp value'`。
- en: Quickly kill the Redis server manually, either by **Kill-9** option in Linux
    or through **close** option in command prompt in windows.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速手动关闭Redis服务器，可以在Linux中使用**Kill-9**选项，或者在Windows命令提示符中使用**close**选项。
- en: Restart your Redis server.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动Redis服务器。
- en: Execute the command `get msg`.![Configuring Redis for AOF persistence](img/0123OS_05_17.jpg)
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行命令`get msg`。![为AOF持久性配置Redis](img/0123OS_05_17.jpg)
- en: Get msg without persistence handling
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 没有持久性处理的获取消息
- en: Open your `Redis.conf` file and go to the section `APPEND ONLY MODE` and change
    the `appendonly no` to `appendonly yes`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的`Redis.conf`文件，转到`APPEND ONLY MODE`部分，并将`appendonly no`更改为`appendonly yes`。
- en: Uncomment the `appendfilename appendonly.aof` property. Here, you can choose
    to provide your own name but the default name is `appendonly.aof`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消注释`appendfilename appendonly.aof`属性。在这里，您可以选择提供自己的名称，但默认名称是`appendonly.aof`。
- en: Change the append mechanism to `appendfsync always`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将附加机制更改为`appendfsync always`。
- en: Start your Redis server with the following argument `--appendonly yes --appendfilename
    C:\appendonly.aof` (use this technique if you do not want to make the change in
    the `Redis.conf` file).
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下参数启动Redis服务器 `--appendonly yes --appendfilename C:\appendonly.aof`（如果不想在`Redis.conf`文件中进行更改，则使用此技术）。
- en: Execute the command `Set msg 'temp value'`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行命令`Set msg 'temp value'`。
- en: Quickly kill the Redis server manually, either by **Kill-9** option in Linux
    or through **close** option in Command Prompt in windows.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速手动关闭Redis服务器，可以在Linux中使用**Kill-9**选项，或者在Windows命令提示符中使用**close**选项。
- en: Restart your Redis server with the following argument `--appendonly yes --appendfilename
    C:\appendonly.aof` (use this technique if you do not want to make the change in
    the `Redis.conf` file).
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下参数重新启动Redis服务器 `--appendonly yes --appendfilename C:\appendonly.aof`（如果不想在`Redis.conf`文件中进行更改，则使用此技术）。
- en: Execute the command `get msg`.![Configuring Redis for AOF persistence](img/0123OS_05_18.jpg)
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行命令`get msg`。![为AOF持久性配置Redis](img/0123OS_05_18.jpg)
- en: Get msg with AOF persistence handling
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AOF持久性处理获取消息
- en: Open file from `C:\appendonly.aof` and see the following:![Configuring Redis
    for AOF persistence](img/0123OS_05_19.jpg)
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`C:\appendonly.aof`打开文件并查看以下内容：![为AOF持久性配置Redis](img/0123OS_05_19.jpg)
- en: Opening the appendonly.aof
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`appendonly.aof`
- en: One thing that can be observed here is that there is no `get` command which
    gets recorded since they do not change the dataset. A problem that should be kept
    in mind is that if the writes are very frequent then AOF file will get bigger
    and bigger and the server restarts are going to take longer.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可以观察到的一件事是，没有记录`get`命令，因为它们不会改变数据集。需要记住的一个问题是，如果写入非常频繁，那么AOF文件将变得越来越大，服务器重新启动将需要更长的时间。
- en: Use case for using AOF persistence
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用AOF持久性的用例
- en: Redis can be configured to have AOF persistence mechanism in cases where data
    is state full. What I want to convey here is that if the data is a piece of information
    that has relation to the data stored before, or the next piece of data it is going
    to store, then it becomes a perfect candidate for AOF persistence. Suppose we
    are building a workflow engine where every state is responsible for the next state;
    in this kind of situation, using a AOF persistence is the best option.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Redis可以配置为在数据是有状态时具有AOF持久性机制。我想在这里传达的是，如果数据是与之前存储的数据有关，或者下一个要存储的数据与之有关，那么它就成为AOF持久性的完美候选者。假设我们正在构建一个工作流引擎，其中每个状态都负责下一个状态；在这种情况下，使用AOF持久性是最佳选择。
- en: Dataset handling commands in Redis
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redis中的数据集处理命令
- en: 'We have seen commands used by the client program to either set data or get
    data in Redis but there are some useful commands that are needed to handle Redis
    as a datastore. These commands help in maintaining Redis in the production environment
    and are usually the domain of the Redis administration. Since these commands have
    an impact on the data stored in Redis, one should be careful in executing them.
    Following are some of the commands:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到客户端程序使用的命令，要么设置数据，要么获取Redis中的数据，但是还有一些有用的命令需要处理Redis作为数据存储。这些命令有助于在生产环境中维护Redis，并且通常是Redis管理的领域。由于这些命令对Redis中存储的数据产生影响，因此在执行它们时应该小心。以下是一些命令：
- en: '`FLUSHDB`: This command deletes all the keys (and their held data) in the chosen
    database. As we have seen, in Redis we can create a database which is more like
    a SILO wherein we can store data in a segregated manner (more like separation
    of concern). This command never fails.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FLUSHDB`：此命令删除所选数据库中的所有键（及其保存的数据）。正如我们所见，在Redis中，我们可以创建一个更像是SILO的数据库，可以以分离的方式存储数据（更像是关注点的分离）。此命令永远不会失败。'
- en: '`FLUSHALL`: This command deletes all of the keys in all the databases in Redis
    node. This command never fails.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FLUSHALL`：此命令删除Redis节点中所有数据库中的所有键。此命令永远不会失败。'
- en: '`MONITOR`: This command is a debugging command that relays all the commands
    that the Redis server is processing. You can either use the Redis-cli or the telnet
    to monitor what the server is doing.![Dataset handling commands in Redis](img/0123OS_05_20.jpg)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`监视器`：这个命令是一个调试命令，它传递了Redis服务器正在处理的所有命令。您可以使用Redis-cli或telnet来监视服务器正在执行的操作。![Redis中的数据集处理命令](img/0123OS_05_20.jpg)'
- en: Using telnet to monitor commands
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用telnet监视命令
- en: Here we have used telnet to monitor the Redis server and whatever command is
    issued in the client is replicated here. Monitoring commands gives an inside look
    into the working of Redis but has a performance penalty. You can use this command
    to even monitor the slave nodes.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用telnet来监视Redis服务器，并且客户端发出的任何命令都会在这里复制。监视命令可以让我们深入了解Redis的工作方式，但会有性能损失。您可以使用此命令来监视从节点。
- en: '`SAVE`: This is a synchronous blocking call save to snapshot all the data in
    the memory to a RDB file. This command in a production environment should be used
    carefully because this will block every client command and perform this task.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SAVE`：这是一个同步阻塞调用，将内存中的所有数据保存到RDB文件中。在生产环境中，应谨慎使用此命令，因为它会阻塞每个客户端命令并执行此任务。'
- en: '`BGSAVE`: This command is more like a background save. The previous command
    `SAVE` is a blocking call but this command does not block the client calls. By
    issuing this command, Redis forks another process which starts to persist the
    data to a RDB file in the background. Issuing this command immediately returns
    the `OK` code but the client can check the result by issuing the `LASTSAVE` command.
    Let''s try a small example and see if it''s working:'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BGSAVE`：这个命令更像是后台保存。之前的`SAVE`命令是一个阻塞调用，但是这个命令不会阻塞客户端调用。通过发出这个命令，Redis会fork另一个进程，该进程开始在后台持久化数据到RDB文件中。发出此命令会立即返回`OK`代码，但客户端可以通过发出`LASTSAVE`命令来检查结果。让我们尝试一个小例子，看看它是否有效：'
- en: Start the Redis server and a client.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Redis服务器和一个客户端。
- en: Execute `LASTSAVE` command from the client; in my case the value it showed was
    an integer **1391918354** but in your case it might show a different time.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从客户端执行`LASTSAVE`命令；在我的情况下，它显示的值是整数**1391918354**，但在您的情况下可能显示不同的时间。
- en: Open your telnet prompt and execute `MONITOR` command (this is done on purpose
    to retard the performance of your Redis server).
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的telnet提示符并执行`MONITOR`命令（这是故意为了减缓Redis服务器的性能）。
- en: 'Open your Java editor and type in the following program which will insert lots
    of values into the Redis server:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的Java编辑器，并输入以下程序，它将向Redis服务器插入大量值：
- en: '[PRE6]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the client prompt I issued the following commands and the result is as follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端提示符中，我发出了以下命令，结果如下：
- en: '![Dataset handling commands in Redis](img/0123OS_05_21.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![Redis中的数据集处理命令](img/0123OS_05_21.jpg)'
- en: Checking nonblocking nature of BGSAVE
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 检查BGSAVE的非阻塞特性
- en: I issued the `TIME` command after the `BGSAVE` command but when I issued `LASTSAVE`,
    the time I got was later to `BGSAVE` command. So we can conclude that `BGSAVE`
    is a nonblocking way of saving data. Since the command `FLUSHALL` manipulates
    the entire dataset, it automatically calls the `SAVE` command after execution.
    See the `LASTSAVE` command which shows time as **1391920265** and the previous
    `LASTSAVE` before `FLUSHALL`, which shows time as **1391920077** prove that `FLUSHALL`
    does as save.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`BGSAVE`命令之后发出了`TIME`命令，但当我发出`LASTSAVE`时，我得到的时间比`BGSAVE`命令晚。所以我们可以得出结论，`BGSAVE`是一种非阻塞保存数据的方式。由于`FLUSHALL`命令操作整个数据集，它在执行后会自动调用`SAVE`命令。查看`LASTSAVE`命令，显示时间为**1391920265**，以及在`FLUSHALL`之前的上一个`LASTSAVE`，显示时间为**1391920077**，证明了`FLUSHALL`确实进行了保存。
- en: '`LASTSAVE`: This command is similar to `BGSAVE` command, and it shows when
    the last time the data was persisted to the RDB file.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LASTSAVE`：这个命令类似于`BGSAVE`命令，它显示了数据上次持久化到RDB文件的时间。'
- en: '`SHUTDOWN SAVE`/`NOSAVE`: This command basically quits the server but before
    doing that it closes the connection of the entire set of clients and performs
    a blocking save, and then flushes the AOF if it is enabled.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHUTDOWN SAVE`/`NOSAVE`：这个命令基本上退出服务器，但在这之前会关闭整个客户端集合的连接并执行一个阻塞保存，然后如果启用了AOF，会刷新AOF。'
- en: '`DBSIZE`: This returns the number of keys in the database.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DBSIZE`：返回数据库中键的数量。'
- en: '`BGREWRITEAOF`: This instructs the Redis server to start a back ground write
    to an AOF. If this instruction fails, the old AOF file is retained.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BGREWRITEAOF`：这指示Redis服务器启动后台写入AOF。如果此指令失败，旧的AOF文件将被保留。'
- en: '`CLIENT SETNAME`: This sets the name of a client and we can see the name set
    when we do a `CLIENT LIST`. Execute the following command in the client prompt
    `CLIENT SETNAME "myclient"`, and you should see something thing similar to the
    following image:![Dataset handling commands in Redis](img/0123OS_05_22.jpg)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLIENT SETNAME`：这个命令设置客户端的名称，当我们执行`CLIENT LIST`时可以看到设置的名称。在客户端提示符中执行以下命令`CLIENT
    SETNAME "myclient"`，您应该看到类似以下图像的东西:![Redis中的数据集处理命令](img/0123OS_05_22.jpg)'
- en: Naming a client
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 给客户端命名
- en: '`CLIENT LIST`: This gets the list of clients connected to the IP address and
    the `PORT` address. Let''s do a simple experiment:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLIENT LIST`：获取连接到IP地址和`PORT`地址的客户端列表。让我们做一个简单的实验：'
- en: Open a telnet client to a Redis server with `telnet localhost 6379` and execute
    the `MONITOR` command.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`telnet localhost 6379`打开到Redis服务器的telnet客户端，并执行`MONITOR`命令。
- en: 'Open a Redis server master node client prompt and execute the command `CLIENT
    LIST`. The command prompt should look similar to the following image:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Redis服务器主节点客户端提示符并执行`CLIENT LIST`命令。命令提示符应该类似于以下图像：
- en: '![Dataset handling commands in Redis](img/0123OS_05_23.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![Redis中的数据集处理命令](img/0123OS_05_23.jpg)'
- en: Getting client list
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 获取客户端列表
- en: '`CLIENTKILL`: This kills the client. Now, to the previous experiment, issue
    the following command in the client that we have opened up:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLIENTKILL`：这个命令杀死客户端。现在，对于之前的实验，在我们打开的客户端中发出以下命令：'
- en: Execute the command `CLIENT KILL 127.0.0.1:1478`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行命令`CLIENT KILL 127.0.0.1:1478`。
- en: Execute the command `CLIENT LIST` we will see the number of lines displayed
    to go down by one.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`CLIENT LIST`命令，我们将看到显示的行数减少了一行。
- en: '`DEBUG sEGFAULT`: This crashes the Redis server. The utility can be used to
    simulate bugs during development. This command can be used to simulate the scenario
    where we want to check the fault tolerance of the system by purposefully bringing
    the Redis server down. It would be interesting to see how the slave node behaves,
    how fault tolerance is handled by the clients, and so on.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEBUG sEGFAULT`：这会导致Redis服务器崩溃。该实用程序可用于在开发过程中模拟错误。此命令可用于模拟我们想要通过故意使Redis服务器宕机来检查系统的容错性的场景。有趣的是看到从节点的行为，客户端如何处理容错等。'
- en: '`SLOWLOG`: This command shows which commands took time during execution. Execute
    the program that you wrote in the *Performance pattern – high reads* section,
    and after the execution open a client for the master and execute this command.
    The result seen in the following image is a snapshot and is not the full result
    of what you might get in your command prompt:![Dataset handling commands in Redis](img/0123OS_05_24.jpg)'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SLOWLOG`：此命令显示执行过程中哪些命令花费了时间。执行你在*性能模式 - 高读取*部分编写的程序，并在执行后打开主机的客户端并执行此命令。以下图像中所见的结果是一个快照，不是您在命令提示符中可能得到的完整结果：![Redis中的数据集处理命令](img/0123OS_05_24.jpg)'
- en: Slowlog command
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Slowlog命令
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw and learnt how to handle the entire dataset in Redis.
    Apart from that, we learnt patterns for performance in a production environment.
    We also learnt commands to manage the Redis server ecosystem.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们看到并学习了如何在Redis中处理整个数据集。除此之外，我们还学习了在生产环境中提高性能的模式。我们还学习了管理Redis服务器生态系统的命令。
- en: In the next chapter, we will apply the knowledge we have learnt until now to
    develop common components in web programming and see how Redis fits as a great
    tool to take care of some of the problems in this space.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将应用我们到目前为止学到的知识来开发Web编程中的常见组件，并看看Redis如何成为解决这一领域中一些问题的强大工具。
