- en: Chapter 6. Redis in Web Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。Web应用中的Redis
- en: Web in the present scenario is the ubiquitous platform through which the world
    today communicates. From a simple portal to massively scalable e-commerce, collaborative
    web sites, banking, social media, web applications over mobile networks, and so
    on, everyone uses web protocols as an interface to interact with the outside world.
    What we normally see as web platform is just a small part of the application that
    is under web operations, backend web applications, such as supply chain management,
    order management, online, offline analytics, and so on, are also web applications
    or use web protocols to integrate for example HTTP, SOAP, REST and so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前情况下，Web是世界今天进行交流的普遍平台。从简单的门户到大规模可扩展的电子商务，协作网站，银行业，社交媒体，移动网络上的Web应用等等，每个人都使用Web协议作为与外部世界交互的接口。我们通常看到的Web平台只是Web操作下的一个小部分应用，后端Web应用，如供应链管理，订单管理，在线，离线分析等等，也是Web应用，或者使用Web协议进行集成，例如HTTP，SOAP，REST等等。
- en: One of the reasons for the web's success is its effective simplicity, open standards,
    and multiple channels through which it can operate. The fact that it's popular
    is forcing people and companies to come out with solutions that are simple, cost
    effective, high performing, and easy to maintain and develop. This new breed of
    software should have intrinsic or extrinsic capabilities to scale and perform
    well.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Web成功的原因之一是其有效的简单性，开放标准以及多个渠道的操作。它的流行正在迫使人们和公司提出简单，成本效益高，性能卓越，易于维护和开发的解决方案。这种新型软件应该具有内在或外在的能力来扩展和表现良好。
- en: Redis, the datastore that is more like a Swiss army knife, is multi-faceted
    and a proof to those capabilities we saw in previous chapters. In this chapter,
    we will extend and map the capabilities of Redis for components used in web domain
    and a create few proof of concept for components which form an inherent part of
    any web application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Redis，这种更像瑞士军刀的数据存储，是多面手，是我们在前几章中看到的那些能力的证明。在本章中，我们将扩展和映射Redis的能力，用于Web领域中使用的组件，并为任何Web应用程序的固有部分创建一些概念验证。
- en: To understand the concepts of Redis better, let's make a sample web application
    and use Redis as a datastore. This sample web application is no way a complete
    end-to-end web application but intends to highlight the areas where Redis can
    come in handy. The solution itself is not complete in terms of functionality but
    intends to be a demo which practitioners can take forward and extend.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解Redis的概念，让我们制作一个示例Web应用程序，并将Redis用作数据存储。这个示例Web应用程序无论如何都不是一个完整的端到端Web应用程序，但意在突出Redis可以派上用场的领域。解决方案本身在功能上并不完整，但意在成为一个从业者可以继续扩展的演示。
- en: '**Simple E-Commerce**, as we intend to call this demo website, is a Redis backed
    website which does not have a web page but communicates via simple services. The
    idea is to expose simple services and not bring in webpages (containing HTML,
    CSS and so on) to decouple services from the presentation layer. As we are moving
    more towards the era of single page application, it becomes imperative that we
    take an approach where the application residing in the client browser memory does
    all the coordination and the traditional web server does the job of serving the
    request via services it exposes. The advantage of this mechanism is that development
    and testing becomes easy as every service is independent of other service and
    there is no tight coupling with the presentation aspect of a web app. As we all
    have been involved in web development at one time or another, we can understand
    the frustration we face when we see a bug and when a considerable amount of time
    is spent in debugging whether the problem arose because of the client side code
    or the business methods it was calling. With the rising capabilities of single
    page application, this problem can be taken care of to a large extent since the
    business methods are exposed as independent services and can be tested separately
    from the presentation component. One of the salient features of a single page
    application is that it takes away a lot of compute activity from the server side
    to the client side (browser) which results in more compute resource for the server.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**Simple E-Commerce**，正如我们打算称呼这个演示网站，是一个由Redis支持的网站，它没有网页，而是通过简单的服务进行通信。这个想法是暴露简单的服务，而不是引入网页（包含HTML，CSS等），以将服务与呈现层解耦。随着我们更多地向单页面应用的时代迈进，我们需要采取一种方法，其中驻留在客户端浏览器内存中的应用程序进行所有协调，而传统的Web服务器则通过其提供的服务来处理请求。这种机制的优势在于开发和测试变得容易，因为每个服务都独立于其他服务，并且与Web应用程序的呈现方面没有紧密耦合。由于我们都曾经参与过Web开发，我们可以理解当我们看到一个错误时所面临的挫败感，以及当花费大量时间来调试问题是因为客户端代码还是它调用的业务方法。随着单页面应用程序的能力不断增强，这个问题在很大程度上可以得到解决，因为业务方法被公开为独立的服务，并且可以与呈现组件分开测试。单页面应用程序的一个显着特点是它将大量的计算活动从服务器端转移到客户端（浏览器），这导致服务器获得更多的计算资源。'
- en: Simple e-commerce – a Redis backed e-commerce site
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的电子商务-一个由Redis支持的电子商务网站
- en: 'This sample e-commerce site, like other e-commerce sites, has products which
    the registered user can browse, purchase, and so on. The website also recommends
    products based on the users'' browsing and purchasing habits. In parallel, the
    website gives real time statistics of the activities happening in the website
    and provides you with capabilities to do real-time and soft-real-time analytics.
    So, let''s get cracking and build this website, and like in any design, let''s
    divide the requirement into commands, which are listed as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例电子商务网站，像其他电子商务网站一样，有产品，注册用户可以浏览，购买等等。该网站还根据用户的浏览和购买习惯推荐产品。同时，该网站实时统计网站上发生的活动，并提供实时和软实时分析的功能。因此，让我们开始构建这个网站，就像在任何设计中一样，让我们将需求分成命令，列举如下：
- en: '**Session and catalogue management**: The following commands are offered as
    service:'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话和目录管理：以下命令作为服务提供：
- en: '**Register user**: Command name is `register`; this command will register the
    user to the system.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注册用户**：命令名称为`register`；此命令将用户注册到系统中。'
- en: '**See my data**: Command name is `mydata`; this command will allow the user
    to see his/her data.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查看我的数据**：命令名称为`mydata`；此命令将允许用户查看自己的数据。'
- en: '**Edit my data**: Command name is `editmydata`; this command will allow the
    user to edit his data.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑我的数据**：命令名称为`editmydata`；此命令将允许用户编辑自己的数据。'
- en: '**Login user**: Command name is `login`; this command will log in the user
    and generates a session-ID for the user to communicate with the server.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**登录用户**：命令名称为`login`；此命令将登录用户并为用户生成会话ID，以便与服务器通信。'
- en: '**Relogin user**: Command name is `relogin`; this command will again log the
    user but the session-ID will remain the same. All the session or profile data
    of the user will also remain the same.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重新登录用户**：命令名称为`relogin`；此命令将再次登录用户，但会话ID将保持不变。用户的所有会话或配置文件数据也将保持不变。'
- en: '**Logout user**: Command name is `logout`; this command will log out the user
    and kill his session or profile data.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注销用户**：命令名称为`logout`；此命令将注销用户并终止其会话或配置文件数据。'
- en: '**Add to cart**: Command name is `add2cart`; this command will add the item
    to the shopping cart.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加入购物车**：命令名称为`add2cart`；此命令将商品添加到购物车中。'
- en: '**See my shopping cart**: Command name is `showmycart`; this command will show
    the items in the shopping cart.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查看我的购物车**：命令名称为`showmycart`；此命令将显示购物车中的商品。'
- en: '**Edit my shopping cart**: Command name is `editcart`; this command will edit
    user preference in the shopping cart.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑我的购物车**：命令名称为`editcart`；此命令将编辑用户在购物车中的偏好设置。'
- en: '**Buy products**: Command name is `buy`; this command will buy the items in
    the shopping cart of the user. For the current application, we will not take you
    to some merchant''s site but instead we will generate a sample receipt for you.
    The idea is to have analysis, so when somebody buys the product we give credit
    points for that product which will help us for our recommendation service. The
    credit point for buying is `10`.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**购买产品**：命令名称为`buy`；此命令将购买用户购物车中的商品。对于当前应用程序，我们不会将您带到某个商家的网站，而是为您生成一个样本收据。理念是进行分析，所以当有人购买产品时，我们为该产品提供信用积分，这将有助于我们的推荐服务。购买的信用积分为`10`。'
- en: '**Commission product**: Command name is `commission`; this command will commission
    the product and create its profile in the system.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**委托产品**：命令名称为`commission`；此命令将委托产品并在系统中创建其配置文件。'
- en: '**Display product**: Command name is `display`; this command will display the
    product.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示产品**：命令名称为`display`；此命令将显示产品。'
- en: '**Browse products**: Command name is `browse`; this command will log the product
    the user is currently browsing. The idea is that when somebody browses the product,
    we give credit points for the product which will help us for our recommendation
    service. The credit point for browsing is `1`.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浏览产品**：命令名称为`browse`；此命令将记录用户当前浏览的产品。理念是当有人浏览产品时，我们为该产品提供信用积分，这将有助于我们的推荐服务。浏览的信用积分为`1`。'
- en: '**Online Analytics**: Following commands come under this:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在线分析**：以下命令属于此类：'
- en: '**Recommend**: Command name is `recommendbyproduct`; this command will recommend
    other products similar to the current product based on their popularity which
    the user is browsing.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推荐**：命令名称为`recommendbyproduct`；此命令将根据用户正在浏览的产品的热度推荐其他类似产品。'
- en: '**User''s statistics**: Command name is `stats`; this command will show the
    user''s statistics.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户统计**：命令名称为`stats`；此命令将显示用户的统计信息。'
- en: '**Display by category**: Command name is `displaytag`; this command will display
    the products under a category.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按类别显示**：命令名称为`displaytag`；此命令将显示某一类别下的产品。'
- en: '**Display by category history**: Command name is `taghistory`; this command
    will display the history by category.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按类别显示历史记录**：命令名称为`taghistory`；此命令将按类别显示历史记录。'
- en: '**Visits for a book**: Command name is `visittoday`; this will give total number
    of unique visitors in a day.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**书籍访问量**：命令名称为`visittoday`；这将给出一天内独立访客的总数。'
- en: '**Purchases for a book**: Command name is `purchasestoday`; this will give
    the total number of unique visitors who purchased the item in a day.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**购买书籍**：命令名称为`purchasestoday`；这将给出一天内购买该物品的独立访客总数。'
- en: 'The design is kept very simple for this simple e-commerce site. To understand
    the entire application, have a look at the following figure:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为这个简单的电子商务网站保持了非常简单的设计。要了解整个应用程序，请查看以下图表：
- en: '![Simple e-commerce – a Redis backed e-commerce site](img/0123OS_06_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![简单电子商务-基于Redis的电子商务网站](img/0123OS_06_01.jpg)'
- en: Simple design for out simple e-commerce site
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 简单设计适用于我们简单的电子商务网站
- en: 'The prerequisites for this exercise are as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的先决条件如下：
- en: '**Client**: Any browser with a `REST` plugin or HTTP client plugin. I will
    be using Chrome browser with a `REST` client plugin called `POSTMAN`. If you are
    comfortable with any other plugin then be my guest. The application would work
    without any problem if we replace this client with a pure Java program, for example
    Apache Http Client. The services in this simple e-commerce application are `Get`
    based. In production system, we should have `POST` but for display purposes, `Get`
    is chosen here.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：任何带有`REST`插件或HTTP客户端插件的浏览器。我将使用带有名为`POSTMAN`的`REST`客户端插件的Chrome浏览器。如果您对其他插件感到满意，也可以使用其他插件。如果我们将此客户端替换为纯Java程序，例如Apache
    Http Client，应用程序将可以正常工作。此简单电子商务应用程序中的服务是基于`Get`的。在生产系统中，我们应该使用`POST`，但出于显示目的，这里选择了`Get`。'
- en: '**Server**: Any web application server. We will be using Tomcat. You can use
    any web application server of your choice but creation of servlets should be done
    accordingly. If you want to use something like Node.js, then code will change
    accordingly but design philosophy would remain the same.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器**：任何Web应用程序服务器。我们将使用Tomcat。您可以使用您选择的任何Web应用程序服务器，但应相应地创建Servlet。如果您想使用类似Node.js的东西，那么代码将相应更改，但设计理念将保持不变。'
- en: '**Datastore**: Needless to say that Redis will be the datastore here.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据存储**：毋庸置疑，Redis将是这里的数据存储。'
- en: 'Before we dive into the code, it is important to understand the evolution process
    that led to a state wherein we are using Redis. As discussed earlier, the two
    categories on the basis of which this web application is segregated are stated
    as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，了解导致我们使用Redis的演变过程是很重要的。如前所述，基于这个Web应用程序被分为两类，如下所述：
- en: Session and catalogue management
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话和目录管理
- en: Online analytics
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线分析
- en: Let's spend some time and understand how they have evolved over a period of
    time and how Redis comes into picture. We will understand the code for this application
    thereafter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间了解它们是如何随着时间的推移发展的，以及Redis是如何出现的。之后我们将了解这个应用程序的代码。
- en: Session management
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话管理
- en: Every web application has session in one way or another. Session management
    captures information of user activity which can be used for the user and by the
    user. Information for the shopping cart or the wish list can be used by the user,
    and the same information can be used by the back-end systems to analyze user preferences
    and pass promotional and campaign management schemes back to the user. This is
    one of the common use cases in the e-commerce platform. Information stored in
    session management is always the recent information and the end user expects performance
    around it, or in other words, the user outsources his recent memory to the system
    and expects the system to take care of it. The end user might not know the level
    of detailing and activity that happens behind the scene but expects the information
    stored in a session to be acted upon fast and as efficiently as his brain.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Web应用程序都以某种方式具有会话。会话管理捕获用户活动的信息，这些信息可以被用户使用，也可以被用户使用。购物车或愿望清单的信息可以被用户使用，后端系统也可以使用相同的信息来分析用户偏好，并将促销和活动管理方案传递给用户。这是电子商务平台中的常见用例之一。存储在会话管理中的信息始终是最新的信息，最终用户期望围绕它进行性能，换句话说，用户将他最近的记忆外包给系统，并期望系统照顾好它。最终用户可能不知道幕后发生的详细和活动水平，但期望会话中存储的信息能够快速和高效地被处理。
- en: In some cases, the user expects even more than what his brain can process; be
    it shopping cart purchases, or putting things in a wish list, or reminding him
    of a certain activity which he might have forgotten. In other words, the end users
    are closest to this data as compared to any other data. They remember this data
    and expect the system to match it, which results in more personalized involvement
    of the user with the system or the website.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，用户的期望甚至超出了他的大脑可以处理的范围；无论是购物车购买，还是把物品放入愿望清单，或者提醒他某个可能已经忘记的活动。换句话说，与任何其他数据相比，最终用户最接近这些数据。他们记住这些数据，并期望系统与之匹配，这导致用户与系统或网站的更个性化的参与。
- en: '![Session management](img/0123OS_06_02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![会话管理](img/0123OS_06_02.jpg)'
- en: User and his interaction with an e-commerce platform
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 用户及其与电子商务平台的互动
- en: The previous diagram is a representation of how the user interacts with the
    system (website). When the user browses a website, he/she has an idea of what
    he is looking for. Let's say in our case it's some music he is looking for and
    after searching for the music, the user will put the music tracks in the shopping
    cart. It is also possible that the user might be interested in some other music
    CD of the same genre or interested in the comments of the other buyers in the
    *comments section*. At this point, the user might be interested in buying his/her
    music CD in the shopping cart or keeping it in the shopping cart to buy it in
    near future. One thing the user expects here is that when he logs into the system
    again, the system should remember the products that he had put in the shopping
    cart.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 上图是用户与系统（网站）互动的表示。当用户浏览网站时，他/她知道自己在寻找什么。比如在我们的案例中，他正在寻找一些音乐，搜索音乐后，用户将音乐曲目放入购物车。用户也可能对同一流派的其他音乐CD感兴趣，或者对*评论部分*的其他买家的评论感兴趣。在这一点上，用户可能有兴趣购买他/她的音乐CD，或者将其放在购物车中以便将来购买。用户在这里期望的一件事是，当他再次登录系统时，系统应该记住他放在购物车中的产品。
- en: There are couple of things that are happening here. Firstly, the user is interacting
    with the system and the system is responding by storing the user's choices, recording
    the user's activities, and so on. Secondly, the user has pushed information which
    he might find interesting, thus offering him wide choices as well as educating
    him about what people are commenting about the product, thereby helping him take
    a decision. In this section, we will be talking more about the part where the
    user is storing his information, and call it session management.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了几件事。首先，用户与系统互动，系统通过存储用户的选择、记录用户的活动等方式做出响应。其次，用户已经推送了他可能会感兴趣的信息，从而为他提供了广泛的选择，同时也教育他关于其他人对产品的评论，从而帮助他做出决定。在这一部分，我们将更多地讨论用户存储信息的部分，并称之为会话管理。
- en: Session data has high importance and stays in the users' mind, but the lifespan
    of this data is short (until the time the product is delivered or until the attention
    shifts to another product). This is where session management comes into picture
    and in this section we are going to go a bit deeper as to how Redis can help us
    in solving this highly critical problem.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 会话数据非常重要，留存在用户的记忆中，但这些数据的生命周期很短（直到产品交付或者注意力转移到另一个产品为止）。这就是会话管理的作用所在，在本节中，我们将深入探讨Redis如何帮助我们解决这个非常关键的问题。
- en: To handle session data, the earliest and easiest option has been using the memory
    of the application server itself. Back in the day the web application had limited
    capability and offered limited services. Usage of application server memory was
    the order of the day. But as the web became more accessible, and people started
    to use web more in their daily lives, websites grew rapidly and to survive competition
    between web applications had to exist. This required the web application to have
    more compute and memory resources.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理会话数据，最早和最简单的选择是使用应用服务器本身的内存。在过去，Web应用程序的能力有限，提供的服务也有限。使用应用服务器内存是当时的常规。但随着Web变得更加普及，人们开始在日常生活中更多地使用Web，网站迅速增长，为了在Web应用程序之间生存下来，必须具备更多的计算和内存资源。
- en: '![Session management](img/0123OS_06_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![会话管理](img/0123OS_06_03.jpg)'
- en: Scaling web application with memory to store session data
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内存存储会话数据来扩展Web应用程序
- en: The common technique was to replicate the data and load balance the system so
    that all the web servers were in the same state and requests could be catered
    from any of the web applications. This technique had some issues as the session
    management was tightly coupled with the web servers, it provided limited scalability,
    and when concurrency increased this pattern became an anti-pattern. Another limitation
    this technique had was that as data in session management grew, this pattern proved
    problematic since session data was stored in the memory and the amount of memory
    that could be allocated for session management was contested by the memory requirement
    of business logic.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的技术是复制数据并平衡系统，以便所有Web服务器处于相同状态，并且可以从任何Web应用程序中处理请求。这种技术存在一些问题，因为会话管理与Web服务器紧密耦合，它提供了有限的可扩展性，当并发性增加时，这种模式变成了反模式。这种技术的另一个局限性是，随着会话管理中的数据增长，这种模式变得有问题，因为会话数据存储在内存中，而为会话管理分配的内存量受到业务逻辑内存需求的限制。
- en: The next logical step was to decouple the session management from the web application
    servers executing business logic. This step was in the right direction since now
    it provided more scalability as the web servers were free from doing the session
    management which required syncing up state with peers frequently.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个合乎逻辑的步骤是将会话管理与执行业务逻辑的Web应用程序服务器分离。这一步是正确的，因为现在它提供了更多的可扩展性，因为Web服务器不再需要进行会话管理，这需要频繁地与对等方同步状态。
- en: '![Session management](img/0123OS_06_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![会话管理](img/0123OS_06_04.jpg)'
- en: Scaling web application with RDBMS to store session data
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RDBMS存储会话数据来扩展Web应用程序
- en: This approach, though in the right direction, had some problems—mainly with
    the choice of datastore used. RDBMS are used to store relational data and are
    very efficient in dealing with those types of data. Session data on the other
    hand is more like key value pair and does not have the kind of relationship that
    is expected out of transactional data. The problem with storing session data in
    RDBMS was that performance took a hit since RDBMS was never engineered for this
    kind of data though scaling out of web application server was much easier.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法是朝着正确的方向发展的，但也存在一些问题，主要是选择使用的数据存储。RDBMS用于存储关系数据，并且在处理这些类型的数据时非常高效。另一方面，会话数据更像是键值对，而不具有事务数据所期望的那种关系。将会话数据存储在RDBMS中的问题在于性能受到影响，因为RDBMS从未为这种类型的数据而设计，尽管Web应用程序服务器的扩展更加容易。
- en: The next step in this evolution process was using a datastore which provided
    the scalability and also performance. The obvious choice was to use a cache engine
    which stores information in the memory so that performance becomes faster and
    the scalability remains good, because session data decoupled from web application
    server.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演进过程的下一步是使用一个既提供可扩展性又提供性能的数据存储。显而易见的选择是使用一个缓存引擎，它将信息存储在内存中，以便性能更快，可扩展性保持良好，因为会话数据与Web应用程序服务器分离。
- en: '![Session management](img/0123OS_06_05.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![会话管理](img/0123OS_06_05.jpg)'
- en: Scaling web application with cache as front end over RDBMS to store session
    data
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用缓存作为前端，通过RDBMS存储会话数据来扩展Web应用程序
- en: The problem with this approach is from functional requirements and from maintainability
    perspective. From a maintainability perspective, the cache engine depends upon
    RDBMS for data persistence since most of the caching engines do not have disk
    persistence and depend upon RDBMS for fault management. There are some cache engines
    that provide persistence mechanisms, but the big problem comes from a functional
    perspective since they store everything as a key value where value is a string.
    It is the responsibility of the program to convert the data in string to the information
    pattern they are interested in and then take the value out. Take for example the
    value stored for a user profile which has hundreds of attributes stored in the
    session data. If the user were to take few attributes out, then in that case the
    user has to fetch the entire dataset, construct the object, and then fetch the
    required attributes. Another problem is that many a times we need session data
    for a fixed duration of time and after that the usability of the data is not there.
    In those cases, cache engines and RDBMS do not prove beneficial since they do
    not have a in-built mechanism of *time to live* for data then to store. To achieve
    this feature, we have to write a trigger to clean the data from RDBMS and then
    from the cache.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的问题在于功能需求和可维护性的角度。从可维护性的角度来看，缓存引擎依赖于RDBMS进行数据持久化，因为大多数缓存引擎没有磁盘持久性，并依赖于RDBMS进行故障管理。有一些缓存引擎提供持久性机制，但从功能的角度来看，存在一个大问题，因为它们将所有内容存储为键值，其中值是一个字符串。程序的责任是将字符串数据转换为他们感兴趣的信息模式，然后取出值。例如，存储在用户配置文件中的值，其中会话数据中存储了数百个属性。如果用户想要取出一些属性，那么用户必须获取整个数据集，构造对象，然后获取所需的属性。另一个问题是，很多时候我们需要会话数据在固定的时间段内可用，之后数据的可用性就不存在了。在这种情况下，缓存引擎和RDBMS都不会证明有益，因为它们没有内置的数据存储的*生存时间*机制。为了实现这个功能，我们必须编写触发器来从RDBMS和缓存中清除数据。
- en: Redis comes in handy in these cases, where we store information the way we want
    to use, as it provides data structures to hold values. In case of session management,
    we can have a map to logically group attributes under it. If we need to take values
    out, we can select the values that we want to change or add more attributes to
    it. Moreover, the performance aspect in Redis also makes it suitable for session
    management. Redis also has features called **time to live** (**TTL**) feature
    to clean the data after the time is over. This way we can have separate TTL for
    the keys we require depending upon the requirement and also change the TTL at
    runtime. Redis can be used to have scalable and high performing session management.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Redis在这些情况下非常方便，因为它提供了存储信息的方式，可以根据我们的需求使用数据结构来保存值。在会话管理的情况下，我们可以使用映射来逻辑地将属性分组在一起。如果我们需要取出值，我们可以选择要更改的值或向其添加更多属性。此外，Redis中的性能方面也使其适用于会话管理。Redis还具有称为**生存时间**（**TTL**）的功能，以在时间结束后清除数据。这样，我们可以根据需求为所需的键设置单独的TTL，并且可以在运行时更改TTL。Redis可用于具有可扩展和高性能的会话管理。
- en: '![Session management](img/0123OS_06_06.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![会话管理](img/0123OS_06_06.jpg)'
- en: Scaling web application with cache as front end over RDBMS to store session
    data
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用缓存作为前端的Web应用程序扩展RDBMS以存储会话数据
- en: Catalogue management
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录管理
- en: Catalogue management is the information about the products and items which the
    website is keen to offer. The information stored under catalogue management can
    be a product's cost, dimension, color, and so on, that is meta information of
    a product. This information, unlike session information, is read centric. But
    like session data, catalogue data has seen evolution starting with RDBMS systems
    which were the natural choice back then because of lack of choices to store data.
    The problem with RDBMS system was that it did not offer performance. Also, the
    fixed schema centric systems added to the problems since the meta information
    of products changed with the products themselves. Some products had color, length,
    breadth, and height whereas some had author, number of pages, and ISBN. Creating
    schemas to accommodate this requirement was always cumbersome and, at some point
    or another we have faced this problem.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 目录管理是关于网站希望提供的产品和项目的信息。目录管理下存储的信息可以是产品的成本、尺寸、颜色等，即产品的元信息。与会话信息不同，目录数据是以读为中心的。但与会话数据一样，目录数据也经历了演变，从RDBMS系统开始，当时由于缺乏存储数据的选择，RDBMS系统是当时的自然选择。RDBMS系统的问题在于它没有提供性能。此外，固定的基于模式的系统也增加了问题，因为产品的元信息随着产品本身的变化而变化。一些产品有颜色、长度、宽度和高度，而一些产品有作者、页数和ISBN。创建适应这一需求的模式总是很麻烦，而且在某个时候我们都面临过这个问题。
- en: '![Catalogue management](img/0123OS_06_07.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![目录管理](img/0123OS_06_07.jpg)'
- en: Catalogue management with RDBMS as datastore
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RDBMS作为数据存储的目录管理
- en: The natural evolution process to overcome this fixed schema problem was to store
    the information in XML format and to cache this information in some caching engine.
    This mechanism helped the designers and architects to overcome the problem of
    fixed schema and performance. But this technique came with its own share of problems;
    the data which was in XML had to be converted to a programming language object
    before usage. The other problem was that if a property value had to be changed,
    then either the value was changed in the XML first and then changed in the RDBMS,
    or the value was changed in the RDBMS first and then in the cache. These techniques
    had problems in maintaining consistent state across RDBMS and the cache engines,
    and it required special attention especially if the property was related to the
    cost of the product.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 克服固定模式问题的自然演化过程是以XML格式存储信息，并将此信息缓存到某个缓存引擎中。这种机制帮助设计师和架构师克服了固定模式和性能的问题。但这种技术也带来了自己的问题；在XML中的数据在使用之前必须转换为编程语言对象。另一个问题是，如果要更改属性值，那么要么首先在XML中更改值，然后在关系数据库管理系统中更改值，要么首先在关系数据库管理系统中更改值，然后在缓存中更改值。这些技术在维护关系数据库管理系统和缓存引擎之间的一致状态方面存在问题，特别是如果属性与产品成本相关。
- en: '![Catalogue management](img/0123OS_06_08.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![目录管理](img/0123OS_06_08.jpg)'
- en: Handling state management between cache engine and RDBMS
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在缓存引擎和关系数据库管理系统之间处理状态管理
- en: Redis once again comes in handy to store catalogue data. Redis being schema
    less and as a datastore provides data structures, such as maps which can be used
    to store as many properties as the product requires. Apart from that, it also
    provides capability to change, add, and read the properties without bringing the
    entire dataset to work upon. Another advantage of having Redis is that we need
    not do *object to data* conversions, and vice versa, as this does away the very
    need to have hundreds of data objects in the system; thus making the code base
    smaller and development faster.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Redis再次派上用场，用于存储目录数据。Redis是无模式的，作为数据存储提供了数据结构，比如可以用来存储产品所需的许多属性的映射。除此之外，它还提供了改变、添加和读取属性的能力，而无需将整个数据集带到工作中。拥有Redis的另一个优势是我们无需进行*对象到数据*的转换，反之亦然，因为这消除了系统中需要数百个数据对象的必要性；从而使代码库更小，开发更快。
- en: Online analytics
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线分析
- en: Online analytics or real-time analytics is a relatively new requirement that
    is gaining popularity. The whole idea behind online analytics is to provide a
    richer and engaging user experience to the user. Online analytics works in a way
    where data is collected, analyzed, and crunched in real-time.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在线分析或实时分析是一个相对较新的需求，正在变得流行。在线分析的整个理念是为用户提供更丰富和吸引人的用户体验。在线分析的工作方式是实时收集、分析和处理数据。
- en: In good old early days of web revolution, analytics had only one principle stake
    holder which was the website management team. They used to collect the data and
    do analysis in the offline mode, and then used to apply it for business usage.
    This technique of offline analysis is still needed. However, in today's world
    when everything is connected to social media, it is imperative that the user's
    views, his/her social group, and his/her opinion should be reflecting in his/her
    shopping experience. For example, let's say a user and his social group are talking
    favorably about some music or book. When the user checks into his favorite e-commerce
    site, the home page of that site has this product in the recommendation section.
    This gives high probability that the user might end up buying the product. This
    degree of personalization is very important for the website to be successful.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的网络革命时代，分析只有一个主要的利益相关者，那就是网站管理团队。他们过去会在离线模式下收集数据并进行分析，然后应用于业务。离线分析技术仍然是必要的。然而，在今天的世界，当一切都与社交媒体相连时，用户的观点、他/她的社交群体和他/她的意见应该反映在他/她的购物体验中。例如，假设一个用户及其社交群体对某种音乐或书籍持有积极看法。当用户登录到他最喜欢的电子商务网站时，该网站的主页上会在推荐部分显示这种产品。这很可能会导致用户最终购买该产品。这种程度的个性化对于网站的成功非常重要。
- en: The kind of analysis that is happening in this case is in soft real-time, that
    is when the user is interacting with his social group, data in parallel is getting
    crunched and the context is getting created which is used by the website to create
    a personalized shopping experience for the user.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下发生的分析是软实时的，也就是当用户与他的社交群体互动时，数据同时被处理并创建上下文，网站利用这一上下文为用户创建个性化的购物体验。
- en: Another kind of analysis that happens is based on the context the user creates
    while browsing products in the website. This context creation is collaborative
    in nature though the users might be unaware of this fact. The higher the number
    of users searching for a product or buying the product, the more popular the product
    becomes. The complexity in this type of analytics is that it's real-time and performance
    is paramount.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种发生的分析是基于用户在网站浏览产品时创建的上下文。这种上下文的创建是协作性的，尽管用户可能对此并不知情。搜索某种产品或购买某种产品的用户数量越多，该产品就越受欢迎。这种类型的分析的复杂性在于它是实时的，性能至关重要。
- en: 'In a way, if we compare the offline analytics engine with real-time analytics,
    the difference is that the analytics engine which was outside the realm of business
    logic becomes a part of the business logic, practically sharing the same compute
    resource. Another difference is that the amount of data is relatively small in
    case of real-time analytics but its contextual data from a user''s shopping perspective
    is what makes it important from a business perspective. The following figure explains
    the difference between offline and online (real-time) analytics in a concise manner:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，如果我们将离线分析引擎与实时分析进行比较，不同之处在于，原本不属于业务逻辑范围的分析引擎实际上成为业务逻辑的一部分，实际上共享相同的计算资源。另一个不同之处在于，实时分析的数据量相对较小，但从用户的购物角度来看，它的上下文数据对于业务来说非常重要。以下图表简明地解释了离线和在线（实时）分析之间的差异：
- en: '![Online analytics](img/0123OS_06_09.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![在线分析](img/0123OS_06_09.jpg)'
- en: Offline and online analytics in web application
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序中的离线和在线分析
- en: Now if the same real-time were to be done using a datastore such as RDBMS, the
    problem would be in performance because this kind of crunching will consume a
    lot of computing resources, and other business use cases executing in parallel
    might take a hit because of this. RDBMS such as Oracle, can provide the capability
    of scaling but they come with a price, that is they are pretty expensive.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果要使用RDBMS等数据存储来进行实时处理，问题将在于性能，因为这种处理将消耗大量的计算资源，并且并行执行的其他业务用例可能会受到影响。例如，Oracle等RDBMS可以提供扩展的能力，但它们的价格相当昂贵。
- en: Redis can be a very good datastore which can be used for online analytics. As
    Redis is memory-based, it's very fast and achieving scalability in Redis is much
    easier. On top of it, Redis provides data structures such as Set and Sorted set,
    which can be very helpful for segregating and aggregating data for real-time analytics.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Redis可以是一个非常好的数据存储，可以用于在线分析。由于Redis是基于内存的，它非常快速，并且在Redis中实现可伸缩性要容易得多。此外，Redis提供了诸如Set和Sorted
    set之类的数据结构，对于实时分析来说非常有帮助。
- en: Another advantage Redis has to offer is that it's open source and runtime resource
    requirement of Redis is very less. Moreover, the concurrent calls handling capability
    in Redis is pretty impressive.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Redis提供的另一个优势是它是开源的，而且Redis的运行时资源需求非常少。此外，Redis在处理并发调用方面的能力非常令人印象深刻。
- en: In the sample application that we will develop, we will see some real-time analytics
    in form of a recommendation engine which will recommend products based on its
    popularity.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将开发的示例应用程序中，我们将看到一些实时分析，例如基于其流行度推荐产品的推荐引擎。
- en: Implementation – simple e-commerce
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施-简单的电子商务
- en: 'Let''s begin with some code to get a clear understanding of how to use Redis
    for our session, catalogue management, and online analytics. But before we do
    that, let''s finalize on the buckets which we will be creating to store data:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些代码开始，以便清楚地了解如何使用Redis进行会话、目录管理和在线分析。但在这之前，让我们确定要创建的存储数据的桶：
- en: '**Bucket name "<username>@userdata"**: This bucket will store user profile
    data such as name, email, phone number, address, and so on. From the application''s
    perspective, this bucket will be `sessionID` of the user which will bind this
    bucket to `"<sessionID>@sessiondata"`. The data structure used here is Map.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “<username>@userdata”桶：该桶将存储用户配置文件数据，例如姓名、电子邮件、电话号码、地址等。从应用程序的角度来看，这个桶将是用户的`sessionID`，它将把这个桶与`"<sessionID>@sessiondata"`绑定在一起。这里使用的数据结构是Map。
- en: '**Bucket name "<sessionID>@sessiondata"**: This bucket will store session data
    of the user such as lastlogin and loginstatus. Apart from session data, this will
    also store the user name as this is the key which will bind `"<username>@userdata"`
    bucket to this bucket. The data structure used here is Map.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “<sessionID>@sessiondata”桶：该桶将存储用户的会话数据，例如上次登录和登录状态。除了会话数据，这里还将存储用户名，因为这是将`"<username>@userdata"`桶绑定到该桶的关键。这里使用的数据结构是Map。
- en: '**Bucket name "<sessionID>@browsinghistory"**: This bucket will store the browsing
    history of the user based on his session ID. Data structure used here is Sorted
    Set.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “<sessionID>@browsinghistory”桶：该桶将根据用户的会话ID存储用户的浏览历史。这里使用的数据结构是Sorted Set。
- en: '**Bucket name "<name>@purchasehistory"**: This will give the purchase history
    of the user. Data structure used here is Sorted Set.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “<name>@purchasehistory”桶：这将提供用户的购买历史。这里使用的数据结构是Sorted Set。
- en: '**Bucket name "<sessionID>@shoppingcart"**: This bucket will store the shopping
    cart items of the user. Data structure used here is Map.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “<sessionID>@shoppingcart”桶：该桶将存储用户的购物车项目。这里使用的数据结构是Map。
- en: '**Bucket name "sessionIdTracker"**: This will track the total number of users
    in the system. Data structure used here is Bitmap.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “sessionIdTracker”桶：这将跟踪系统中的用户总数。这里使用的数据结构是Bitmap。
- en: '**Bucket name "<productname>"**: This will store the product attributes. Being
    schemaless, it can store any number of attributes for the product. Data structure
    used here is Map.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “<productname>”桶：这将存储产品属性。由于无模式，它可以存储产品的任意数量的属性。这里使用的数据结构是Map。
- en: '**Bucket name "<tags>"**: This will store the product mapped to this tag. For
    example, `"Learning Redis"` can be tagged under tags such as Redis, NoSQL, database,
    and so on. Data structure used here is Sorted Set.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “<tags>”桶：这将存储与该标签相关联的产品。例如，“学习Redis”可以被标记为Redis、NoSQL、数据库等标签。这里使用的数据结构是Sorted
    Set。
- en: '**Bucket name "<productname>@visit"**: This will store the number of unique
    visitors. In production system, this can be made on a daily basis to give a statistics
    of how many people visited this product on a day-to-day basis and help calculate
    how many people visited the site on a monthly basis. Data structure used here
    is Bitmap.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “<productname>@visit”桶：这将存储独立访问者的数量。在生产系统中，这可以每天进行一次，以便统计每天有多少人访问了该产品，并帮助计算每月有多少人访问了该网站。这里使用的数据结构是Bitmap。
- en: '**Bucket name "<productname>@purchase"**: This will store the number of unique
    visitors who purchased the product. Like the previous bucket, this bucket can
    be made on a daily basis to give an aggregate count for a week or month. Data
    structure used here is Bitmap.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bucket name "<productname>@purchase"**：这将存储购买产品的独立访问者数量。与之前的桶一样，可以每天制作这个桶，以便为一周或一个月提供聚合计数。这里使用的数据结构是位图。'
- en: Now that we have a hang of how our database is going to look like, let's get
    to the servlets which are going to accept service request from the browser and
    send a HTTP response back to the client.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了我们的数据库将会是什么样子，让我们来看看将要接受来自浏览器的服务请求并向客户端发送HTTP响应的servlet。
- en: 'There are two servlets in this simple e-commerce website. They will be accepting
    all the commands and are listed as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的电子商务网站中有两个servlet。它们将接受所有命令，并列在下面：
- en: '**UserApp servlet**: This will cater to all the commands pertaining to the
    user'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UserApp servlet**：这将处理与用户相关的所有命令'
- en: '**ProductApp servlet**: This will cater to all the commands pertaining to the
    user'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ProductApp servlet**：这将处理与用户相关的所有命令'
- en: One thing that we have to keep in mind is that the order of execution is not
    dependent upon the order in which the servlets or the command within the servlet
    is listed. For example, there is no point in registering or logging in unless
    we have provisioned a few products in the system, or there is no point seeing
    recommendation unless we have browsed or bought few products as this will create
    the graph data for the recommendation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记住的一件事是，执行的顺序不依赖于servlet或servlet中的命令的顺序。例如，除非我们在系统中提供了一些产品，否则注册或登录是没有意义的，或者除非我们浏览或购买了一些产品，否则查看推荐是没有意义的，因为这将为推荐创建图形数据。
- en: 'Let''s get a hang of all the utility class that will be used in the code listing
    in the rest of the chapter. The list of all such classes is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先了解一下在本章节的其余部分中将在代码清单中使用的所有实用类。所有这些类的列表如下：
- en: '**Commands**: This is the parent and abstract class for all the commands that
    will be implemented in the application:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Commands**：这是所有将在应用程序中实现的命令的父类和抽象类：'
- en: '[PRE0]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Default command**: This is default command which will get into action if
    the command passed in the URL is not recognized by the application:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认命令**：这是默认命令，如果URL中传递的命令未被应用程序识别，将会执行该命令：'
- en: '[PRE1]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Argument**: The primary goal of this class is to wrap all the name value
    attributes coming in the request and to put it in a map which can be used in the
    program later on:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Argument**：这个类的主要目标是封装请求中传入的所有名称值属性，并将其放入一个地图中，以便以后在程序中使用：'
- en: '[PRE2]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we have covered the utility classes across the application, let's get
    to the classes which will be instrumental in giving a shape to the application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了应用程序中的所有实用类，让我们来看看将对应用程序形成的类。
- en: ProductApp
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ProductApp
- en: 'ProductApp servlet will contain commands around product management. The code
    for ProductApp servlet is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ProductApp servlet将包含围绕产品管理的命令。ProductApp servlet的代码如下：
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we have the first servlet ready, let''s look into the commands which
    we are implementing for this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了第一个servlet，让我们来看看我们为此实现的命令：
- en: '`CommisionProductCommand`: This will implement the `commission` command. The
    implementation of the command is as follows:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CommisionProductCommand`：这将实现`委托`命令。命令的实现如下：'
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Test URL: `http://localhost:8080/simple-ecom/productApp?command=commission&args=name=Redisbook-1:cost=10:catagory=book:author=vinoo:tags=Redis@5,NoSql@3,database@2,technology@1`.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 测试URL：`http://localhost:8080/simple-ecom/productApp?command=commission&args=name=Redisbook-1:cost=10:catagory=book:author=vinoo:tags=Redis@5,NoSql@3,database@2,technology@1`。
- en: 'Description: This, for all reasons, is the first command that should get called
    since this command is going to provision products into the system. The two parts
    in the URL that need to be focused on are the `command` which is equal to `commission`,
    and the argument part, that is `args`. Here `args` contains the attributes of
    the book, for example `name=Redisbook-1`. The attribute `tags` represents the
    words the book will be associated with. The tags for this book are `Redis@5`,
    `NoSQl@3`, `database@2`, and `technology@1`. The tags are associated with the
    weights that will come into play whenever recommendation engine kicks in. Whenever
    a user is browsing for `Redisbook-1`, he will be shown more recommendations for
    Redis books. Here the user will be shown five books on Redis, three books on NoSQL,
    and so on and so forth. For the sake of simplicity in this application, the sum
    total of weights should be 10.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：出于所有原因，这应该是第一个应该调用的命令，因为这个命令将在系统中提供产品。需要关注URL中的两个部分，即等于`commission`的`command`和`args`部分。这里`args`包含书的属性，例如`name=Redisbook-1`。属性`tags`表示书将关联的单词。这本书的标签是`Redis@5`，`NoSQl@3`，`database@2`和`technology@1`。标签与权重相关，当推荐引擎启动时，权重将发挥作用。每当用户浏览`Redisbook-1`时，他将看到更多关于Redis书籍的推荐。在这里，用户将看到关于Redis的五本书，关于NoSQL的三本书，依此类推。为了简化这个应用程序，权重的总和应该是10。
- en: '![ProductApp](img/0123OS_06_10.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![ProductApp](img/0123OS_06_10.jpg)'
- en: Screenshot for successful product commissioning
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 成功产品委托的截图
- en: To create test data, commission few test books with different weights, few with
    the same tags, and few with slightly different tags. Make sure that the sum total
    of weights is equal to 10.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建测试数据，使用不同权重委托几本测试书籍，其中一些具有相同的标签，另一些具有略有不同的标签。确保权重的总和等于10。
- en: '`Display command`: This will implement the `display` command. The implementation
    of the command is as follows:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`显示命令`：这将实现`显示`命令。命令的实现如下：'
- en: '[PRE5]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Test URL: `http://localhost:8080/simple-ecom/productApp?command=display&args=name=Redisbook-1`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 测试URL：`http://localhost:8080/simple-ecom/productApp?command=display&args=name=Redisbook-1`。
- en: 'Description: This program will display the attributes of the book. The two
    parts in the URL that need to be focused on are the command which is equal to
    display, and the argument part, that is args. Here, args contains a single attribute
    called name.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：该程序将显示书的属性。需要关注URL中的两个部分，即等于显示的命令和参数部分，即args。这里，args包含一个名为name的属性。
- en: '![ProductApp](img/0123OS_06_11.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![ProductApp](img/0123OS_06_11.jpg)'
- en: Screenshot for successful displaying of a product attributes
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 成功显示产品属性的屏幕截图
- en: '`DisplayTagCommand`: This will implement the `browse` command. The implementation
    of the command is as follows:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DisplayTagCommand`：这将实现`browse`命令。命令的实现如下：'
- en: '[PRE6]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Test URL: `http://localhost:8080/simple-com/productApp?command=displaytag&args=tagname=nosql`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 测试URL：`http://localhost:8080/simple-com/productApp?command=displaytag&args=tagname=nosql`。
- en: 'Description: This program will display books on the basis of hits for a book.
    The two parts in the URL that need to be focused on are the `command`, which is
    equal to `displaytag`, and the argument part, that is `args`. Here `args` contains
    a single attribute called `tagname`. Since I have already commissioned a book
    into the system, the output is as shown in the next image. Visit this tag later
    when a user starts browsing for products; the order will change when you fire
    the same command.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：该程序将根据书的点击量显示书籍。需要关注URL中的两个部分，即`command`，等于`displaytag`，以及参数部分，即`args`。这里`args`包含一个名为`tagname`的属性。由于我已经将一本书委托给系统，输出如下图所示。当用户开始浏览产品时，请稍后访问此标签；当您执行相同的命令时，顺序将发生变化。
- en: '![ProductApp](img/0123OS_06_12.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![ProductApp](img/0123OS_06_12.jpg)'
- en: Screenshot for successful displaying of a products belonging to a tag that is
    NoSQL
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 成功显示属于NoSQL标签的产品的屏幕截图
- en: '`UpdateTag`: This will implement the `UpdateTagCommand` command. The implementation
    of the command is as follows:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdateTag`：这将实现`UpdateTagCommand`命令。命令的实现如下：'
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Test URL: `http://localhost:8080/simple-ecom/productApp?command=updatetag&args=sessionid=<sessionID
    of the user>:productname=<product name which the user is browsing or has bought>:action=<browse
    or buy>`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 测试URL：`http://localhost:8080/simple-ecom/productApp?command=updatetag&args=sessionid=<用户的sessionID>:productname=<用户正在浏览或已购买的产品名称>:action=<浏览或购买>`。
- en: 'Description: This command is called when a user is browsing a product or purchasing
    a product. The idea behind this command is that when a user is browsing a product
    or purchasing a product, it is gaining popularity, and so proportionally, the
    popularity of the product should increase among other products in the same tag.
    So in short, it helps calculate the most popular product in its category (tags).
    To test this command, make sure you create some dummy users and make them log
    into the system and then hit the `browse` command URL or `buy` command URL.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：当用户浏览产品或购买产品时，将调用此命令。该命令背后的想法是，当用户浏览产品或购买产品时，该产品正在变得受欢迎，因此，该产品在同一标签下的其他产品中的受欢迎程度应该相应增加。简而言之，它有助于计算其类别（标签）中最受欢迎的产品。要测试此命令，请确保创建一些虚拟用户并使其登录系统，然后点击`browse`命令URL或`buy`命令URL。
- en: '`VisitTodayCommand`: This will implement the `browse` command. The implementation
    of the command is as follows:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VisitTodayCommand`：这将实现`browse`命令。命令的实现如下：'
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Test URL: `http://localhost:8080/simple-ecom/productApp?command=visitstoday&args=productname=Redisbook-1`.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 测试URL：`http://localhost:8080/simple-ecom/productApp?command=visitstoday&args=productname=Redisbook-1`。
- en: 'Description: This command can be executed if we want to check how many unique
    users visited the product. The data structure implementing this use case is a
    Bitmap. Bitmap in Redis has a consistent performance irrespective of the data
    it holds.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：如果我们想要检查有多少独立用户访问了该产品，可以执行此命令。实现此用例的数据结构是位图。 Redis中的位图具有一致的性能，不受其持有的数据影响。
- en: '![ProductApp](img/0123OS_06_13.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![ProductApp](img/0123OS_06_13.jpg)'
- en: Screenshot for displaying total number of viewers in a day for the product redisbook-1
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 显示产品redisbook-1每天的观看者总数的屏幕截图
- en: '`PurchasesTodayCommand`: This will implement the `purchasestoday` command.
    The implementation of the command is as follows:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PurchasesTodayCommand`：这将实现`purchasestoday`命令。命令的实现如下：'
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Test URL: `http://localhost:8080/simple-ecom/productApp?command=purchasestoday&args=productname=Redisbook-1`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 测试URL：`http://localhost:8080/simple-ecom/productApp?command=purchasestoday&args=productname=Redisbook-1`。
- en: 'Description: This command can be executed if we want to check how many unique
    users purchased the given product. The data structure implementing this use case
    is a Bitmap. Bitmap in Redis has a consistent performance irrespective of the
    data it holds.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：如果我们想要检查有多少独立用户购买了给定的产品，可以执行此命令。实现此用例的数据结构是位图。 Redis中的位图具有一致的性能，不受其持有的数据影响。
- en: '![ProductApp](img/0123OS_06_14.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![ProductApp](img/0123OS_06_14.jpg)'
- en: Screenshot for displaying total number of buyers in a day for the product redisbook-1
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 显示产品redisbook-1每天的买家总数的屏幕截图
- en: '`TagHistoryCommand`: This will implement the `browse` command. The implementation
    of the command is as follows:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TagHistoryCommand`：这将实现`browse`命令。命令的实现如下：'
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Test URL: `http://localhost:8080/simple-ecom/productApp?command=taghistory&args=tagname=Redis`.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 测试URL：`http://localhost:8080/simple-ecom/productApp?command=taghistory&args=tagname=Redis`。
- en: 'Description: This command can be executed if we want to see the tag history
    of a product. The ranking of the product is based on the points accumulated by
    individual products belonging to the tag. In the following sample we have shown
    the rankings for the tag `Redis`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：如果我们想要查看产品的标签历史记录，可以执行此命令。产品的排名基于属于该标签的各个产品积累的积分。在以下示例中，我们显示了标签`Redis`的排名：
- en: '![ProductApp](img/0123OS_06_15.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![ProductApp](img/0123OS_06_15.jpg)'
- en: Screenshot for displaying tag history for the tag redis
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 显示标签redis的标签历史的屏幕截图
- en: 'Test URL: `http://localhost:8080/simple-ecom/productApp?command=taghistory&args=tagname=nosql`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 测试URL：`http://localhost:8080/simple-ecom/productApp?command=taghistory&args=tagname=nosql`。
- en: 'Description: This command can be executed if we want to see the tag history
    of a product. The ranking of the product is based on the points accumulated by
    individual products belonging to the tag. In the following sample we have shown
    the rankings for the tag `nosql` to showcase the difference:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：如果我们想要查看产品的标签历史记录，可以执行此命令。产品的排名基于属于该标签的各个产品积累的积分。在以下示例中，我们展示了标签`nosql`的排名以展示差异：
- en: '![ProductApp](img/0123OS_06_16.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![ProductApp](img/0123OS_06_16.jpg)'
- en: Screenshot for displaying tag history for the tag nosql
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 显示标签`nosql`的历史记录的屏幕截图
- en: UserApp
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UserApp
- en: 'UserApp servlet will contain commands around user management and analytics
    over user. The code for UserApp servlet is as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: UserApp servlet将包含围绕用户管理和用户分析的命令。UserApp servlet的代码如下：
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that we have the first servlet ready, let''s look into the commands which
    we are implementing for this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了第一个servlet，让我们来看看我们为此实现的命令：
- en: '`RegistrationCommand`: This will implement the `register` command. The code
    for the command is as follows:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegistrationCommand`：这将实现`register`命令。命令的代码如下：'
- en: '[PRE12]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=register&args=name=vinoo:password=******:address=test
    address`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 测试URL：`http://localhost:8080/simple-ecom/userApp?command=register&args=name=vinoo:password=******:address=test
    address`。
- en: 'Description: This command will register the user into the system. The two parts
    in the URL that need to be focused on are the `command`, which is equal to `register`,
    and the argument part, that is `args`. This represents attributes in key value
    pairs. Following figure represents the success scenario if the registration is
    a success. The next logical step would be to log in the user.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：此命令将用户注册到系统中。需要关注URL中的两个部分，即`command`，等于`register`，以及参数部分，即`args`。这代表了键值对中的属性。下图表示注册成功的情况。下一个逻辑步骤将是登录用户。
- en: '![UserApp](img/0123OS_06_17.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![UserApp](img/0123OS_06_17.jpg)'
- en: Screenshot for displaying user registration
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 显示用户注册的屏幕截图
- en: '`LoginCommand`: This will implement the `login` command. The code for the command
    is as follows:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoginCommand`：这将实现`login`命令。命令的代码如下：'
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=login&args=name=vinoo:password=******`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 测试URL：`http://localhost:8080/simple-ecom/userApp?command=login&args=name=vinoo:password=******`。
- en: 'Description: This command will log in the user into the system. The two parts
    in the URL that need to be focused on are the `command`, which is equal to `login`,
    and the argument part, that is `args`. The argument will contain the name and
    password. The important part that needs to be focused on is that upon execution,
    this command will return a session ID code. This session ID is needed in most
    of the commands the user will execute. So if you are running a sample of this,
    make sure to store this number in a text pad for later use. In production system,
    this can be stored in the memory of the browser or client. The following figure
    tells me that the session ID generated for me is **26913441**. I will be using
    this for the rest of the samples I execute:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：此命令将用户登录到系统中。需要关注URL中的两个部分，即`command`，等于`login`，以及参数部分，即`args`。参数将包含名称和密码。需要关注的重要部分是，执行此命令将返回一个会话ID代码。大多数用户将执行的命令都需要此会话ID。因此，如果您正在运行此命令的示例，请确保将此数字存储在文本文件中以供以后使用。在生产系统中，可以将其存储在浏览器或客户端的内存中。下图告诉我为我生成的会话ID是**26913441**。我将在执行的其余示例中使用它：
- en: '![UserApp](img/0123OS_06_18.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![UserApp](img/0123OS_06_18.jpg)'
- en: Screenshot for displaying user login and user session ID
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 显示用户登录和用户会话ID的屏幕截图
- en: '`MyDataCommand`: This will implement the `mydata` command. The code for the
    command is as follows:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyDataCommand`：这将实现`mydata`命令。命令的代码如下：'
- en: '[PRE14]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=mydata&args=sessionid=26913441`.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 测试URL：`http://localhost:8080/simple-ecom/userApp?command=mydata&args=sessionid=26913441`。
- en: 'Description: This command will show user''s data from the system. The two parts
    in the URL that need to be focused on are the `command`, which is equal to `mydata`,
    and the argument part, that is `args`. The argument has only session ID as the
    key value pair in the URL. The following figure shows the outcome of the command.
    Some of the attributes are not shown as they could not be accommodated in the
    figure.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：此命令将显示系统中用户的数据。需要关注URL中的两个部分，即`command`，等于`mydata`，以及参数部分，即`args`。参数在URL中只有会话ID作为键值对。下图显示了命令的结果。由于某些属性无法在图中显示，因此未显示。
- en: '![UserApp](img/0123OS_06_19.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![UserApp](img/0123OS_06_19.jpg)'
- en: Screenshot for displaying user data
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 显示用户数据的屏幕截图
- en: '`EditMyDataCommand`: This will implement the `editmydata` command. The code
    for the command is as follows:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EditMyDataCommand`：这将实现`editmydata`命令。命令的代码如下：'
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=editmydata&args=name=vinoo:password=******:address=changed
    address:phone=9111111119:sessionid=26913441`.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 测试URL：`http://localhost:8080/simple-ecom/userApp?command=editmydata&args=name=vinoo:password=******:address=changed
    address:phone=9111111119:sessionid=26913441`。
- en: 'Description: This command will show user''s data from the system. The two parts
    in the URL that need to be focused on are the `command`, which is equal to `mydata`,
    and the argument part, that is `args`. The argument has new and edited key value
    pairs. Make sure that the session ID is correct in the URL. The following figure
    is what you should be seeing in the output. Now you can always go back and execute
    the previous command `mydata` which will show the newer values.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：此命令将显示系统中用户的数据。需要关注URL中的两个部分，即`command`，等于`mydata`，以及参数部分，即`args`。参数具有新的和编辑后的键值对。确保URL中的会话ID是正确的。下图是您应该在输出中看到的内容。现在您可以随时返回并执行以前的`mydata`命令，这将显示更新后的值。
- en: '![UserApp](img/0123OS_06_20.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![UserApp](img/0123OS_06_20.jpg)'
- en: Screenshot for successful editing of user data
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 成功编辑用户数据的屏幕截图
- en: '`BrowseCommand`: This will implement the `browse` command. The implementation
    of the command is as follows:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BrowseCommand`：这将实现`browse`命令。命令的实现如下：'
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=browse&args=sessionid=26913441:browse=Redisbook-1`.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 测试URL：`http://localhost:8080/simple-ecom/userApp?command=browse&args=sessionid=26913441:browse=Redisbook-1`。
- en: 'Description: This command will show the product''s data from the system. The
    two parts in the URL that need to be focused on are the `command`, which is equal
    to `browse`, and the argument part, that is `args`. The argument has session ID
    of the user and name of the product that the user is browsing. There are a couple
    of things that are happening here. The user gets to see the product details and
    in the background a request is sent to the `updatetag` command to increase the
    popularity of the respective product. In our case, the product is `Redisbook-1`.
    For the sake of testing, browse all the products you have commissioned into the
    system multiple numbers of times.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：此命令将显示系统中产品的数据。需要关注的URL中的两个部分是`command`，它等于`browse`，以及参数部分，即`args`。参数包含用户的会话ID和用户正在浏览的产品的名称。这里发生了几件事情。用户可以查看产品详情，同时后台会发送请求到`updatetag`命令，以增加相应产品的热度。在我们的案例中，产品是`Redisbook-1`。为了测试，多次浏览您已经委托到系统中的所有产品。
- en: '![UserApp](img/0123OS_06_21.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![UserApp](img/0123OS_06_21.jpg)'
- en: Screenshot when user wants to browse a product and see its details
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 用户想要浏览产品并查看其详情时的屏幕截图
- en: '`RecommendByProductCommand`: This will implement the `recommendbyproduct` command.
    The code for the command is as follows:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecommendByProductCommand`：这将实现`recommendbyproduct`命令。命令的代码如下：'
- en: '[PRE17]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=recommendbyproduct&args=sessionid=26913441:productname=Redisbook-1`.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 测试URL：`http://localhost:8080/simple-ecom/userApp?command=recommendbyproduct&args=sessionid=26913441:productname=Redisbook-1`。
- en: 'Description: This command will recommend products based on the product being
    browsed. The two parts in the URL that need to be focused on are the `command`,
    which is equal to `recommendbyproduct`, and the argument part, that is `args`.
    The argument has session ID of the user and product `Redisbook-1`.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：此命令将基于正在浏览的产品为用户推荐产品。需要关注的URL中的两个部分是`command`，它等于`recommendbyproduct`，以及参数部分，即`args`。参数包含用户的会话ID和产品`Redisbook-1`。
- en: This command will recommend top products for the user based on the purchase
    and browse history of the product. This will factor in what categories the product
    belongs to and the weight that needs to be factored for product display. This
    in a way is the online real-time analytics that kicks into action when the user
    is browsing a product. In the figure, maximum number of results are for `Redis`
    tag as that is the tag that has got the maximum weight. In production, some filtering
    needs to be done for duplicate results that might occur for similar products that
    share the same tags. This filtering can be done at the client side, thus saving
    the compute resource at the server side.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将基于产品的购买和浏览历史为用户推荐热门产品。这将考虑产品所属的类别以及需要考虑产品展示的权重。这在用户浏览产品时是实时在线分析的一种方式。在图中，最大数量的结果是`Redis`标签，因为该标签具有最大权重。在生产中，需要对可能出现相似产品的重复结果进行一些过滤。这种过滤可以在客户端完成，从而节省服务器端的计算资源。
- en: '![UserApp](img/0123OS_06_22.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![UserApp](img/0123OS_06_22.jpg)'
- en: Screenshot when user wants to browse a product and see other recommended products
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 用户想要浏览产品并查看其他推荐产品时的屏幕截图
- en: '`Add2CartCommand`: This will implement the `add2cart` command. The implementation
    of the command is as follows:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add2CartCommand`：这将实现`add2cart`命令。命令的实现如下：'
- en: '[PRE18]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=add2cart&args=sessionid=26913441:product=Redisbook-1@2,Redisbook-4@1`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 测试URL：`http://localhost:8080/simple-ecom/userApp?command=add2cart&args=sessionid=26913441:product=Redisbook-1@2,Redisbook-4@1`。
- en: 'Description: This command will put products and their quantities into the shopping
    cart. The two parts in the URL that need to be focused on are the `command`, which
    is equal to `add2cart`, and the argument part, that is `args`. The argument contains
    two key value pairs. First is the session ID and second is the name of the product
    and the quantity separated by special character `@`. The following figure shows
    that I have successfully added the products in my shopping cart:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：此命令将产品及其数量放入购物车。需要关注的URL中的两个部分是`command`，它等于`add2cart`，以及参数部分，即`args`。参数包含两个键值对。第一个是会话ID，第二个是产品的名称和数量，用特殊字符`@`分隔。以下图显示了我已成功将产品添加到购物车中：
- en: '![UserApp](img/0123OS_06_23.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![UserApp](img/0123OS_06_23.jpg)'
- en: Screenshot when user wants to add products to his cart
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 用户想要将产品添加到购物车时的屏幕截图
- en: '`ShowMyCartCommand`: This will implement the `showmycart` command. The implementation
    of the command is as follows:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShowMyCartCommand`：这将实现`showmycart`命令。命令的实现如下：'
- en: '[PRE19]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=showmycart&args=sessionid=26913441`.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 测试URL：`http://localhost:8080/simple-ecom/userApp?command=showmycart&args=sessionid=26913441`。
- en: 'Description: This command will put products and their quantities into the shopping
    cart. The two parts in the URL that need to be focused on are the `command`, which
    is equal to `showmycart`, and the argument part, that is `args`. The argument
    contains the session ID only. The following figure shows my shopping cart:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：此命令将产品及其数量放入购物车。需要关注的URL中的两个部分是`command`，它等于`showmycart`，以及参数部分，即`args`。参数只包含会话ID。以下图显示了我的购物车：
- en: '![UserApp](img/0123OS_06_24.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![UserApp](img/0123OS_06_24.jpg)'
- en: Screenshot when user wants to see his cart
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 用户想要查看他的购物车时的屏幕截图
- en: '`EditCartCommand`: This will implement the `editcart` command. The implementation
    of the command is as follows:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EditCartCommand`：这将实现`editcart`命令。命令的实现如下：'
- en: '[PRE20]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=editcart&args=sessionid=26913441:product=Redisbook-4@0,Redisbook-2@1`.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 测试URL：`http://localhost:8080/simple-ecom/userApp?command=editcart&args=sessionid=26913441:product=Redisbook-4@0,Redisbook-2@1`。
- en: 'Description: This command will edit the products and their quantities in the
    shopping cart. The two parts in the URL that need to be focused upon are the `command`,
    which is equal to `editcart`, and the argument part, that is `args`. The argument
    contains key value pairs of the products and their new quantities. If the quantity
    is marked as `0`, then the product will be removed from the shopping cart. On
    executing the `showmycart` command again, the cart should reflect the newer values.
    The following figure shows the newer values:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：此命令将编辑购物车中的产品和它们的数量。需要关注URL中的两个部分，一个是`command`，等于`editcart`，另一个是参数部分，即`args`。参数包含产品及其新数量的键值对。如果数量标记为`0`，则产品将从购物车中移除。再次执行`showmycart`命令，购物车应该反映出更新的值。以下图显示了更新的值：
- en: '![UserApp](img/0123OS_06_25.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![UserApp](img/0123OS_06_25.jpg)'
- en: Screenshot when user wants to see his cart after editing his cart
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 用户在编辑购物车后想要查看购物车的屏幕截图
- en: '`BuyCommand`: This will implement the `browse` command. The implementation
    of the command is as follows:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BuyCommand`：这将实现`browse`命令。命令的实现如下：'
- en: '[PRE21]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=buy&args=sessionid=26913441`.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 测试URL：`http://localhost:8080/simple-ecom/userApp?command=buy&args=sessionid=26913441`。
- en: 'Description: This command will buy the products in the shopping cart. Since
    this is a demo website, there is no connection to the payment gateway, but the
    intention of having this command was to increase the `hit` counter when a purchase
    is made. When a product is bought, the recommendation engine increases its points
    by `10` as compared to `1` when the product is browsed:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：此命令将购买购物车中的产品。由于这是一个演示网站，与支付网关没有连接，但拥有此命令的意图是在进行购买时增加“点击”计数器。购买产品时，推荐引擎的点数会增加10个，而在浏览产品时只增加1个：
- en: '![UserApp](img/0123OS_06_26.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![UserApp](img/0123OS_06_26.jpg)'
- en: Doing dummy purchase
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 进行虚拟购买
- en: 'At this point, it would be pretty interesting to go back and revisit the `recommendbyproduct`
    command. The order in which the products got displayed would change, since every
    buy gives `10` points to the product popularity. The `recommendbyproduct` is for
    the product `Redisbook-1`. And the test URL is as follows: `http://localhost:8080/simple-ecom/userApp?command=recommendbyproduct&args=sessionid=26913441:productname=Redisbook-1`.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，回顾`recommendbyproduct`命令将会非常有趣。产品显示的顺序会改变，因为每次购买都会给产品的受欢迎程度增加10个点。`recommendbyproduct`是针对产品`Redisbook-1`的。测试URL如下：`http://localhost:8080/simple-ecom/userApp?command=recommendbyproduct&args=sessionid=26913441:productname=Redisbook-1`。
- en: '![UserApp](img/0123OS_06_27.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![UserApp](img/0123OS_06_27.jpg)'
- en: Screenshot for rearranged product list after successful purchase (online analytics)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 成功购买后重新排列产品列表的屏幕截图（在线分析）
- en: '`MyStatusCommand`: This will implement the `stats` command. The implementation
    of the command is as follows:'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyStatusCommand`：这将实现`stats`命令。命令的实现如下：'
- en: '[PRE22]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=stats&args=sessionid=26913441`.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 测试URL：`http://localhost:8080/simple-ecom/userApp?command=stats&args=sessionid=26913441`。
- en: 'Description: This command will give the browsing history of the user. Here
    the result will be listed on the basis of frequency at which the user is revisiting
    a particular product. The two parts in the URL that need to be focused on are
    the `command`, which is equal to `stats`, and the argument part, that is `args`.
    The argument contains the session ID of the user. The following figure represents
    the browsing history of the user with session ID **26913441**:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：此命令将给出用户的浏览历史。结果将根据用户重新访问特定产品的频率列出。需要关注URL中的两个部分，一个是`command`，等于`stats`，另一个是参数部分，即`args`。参数包含用户的会话ID。以下图表示了具有会话ID
    **26913441** 的用户的浏览历史：
- en: '![UserApp](img/0123OS_06_28.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![UserApp](img/0123OS_06_28.jpg)'
- en: Screenshot for viewing browsing history of a user
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 查看用户的浏览历史的屏幕截图
- en: '`MyPurchaseHistoryCommand`: This will implement the `mypurchasehistory` command.
    The implementation of the command is as follows:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyPurchaseHistoryCommand`：这将实现`mypurchasehistory`命令。命令的实现如下：'
- en: '[PRE23]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=mypurchasehistory&args=sessionid=26913441`.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 测试URL：`http://localhost:8080/simple-ecom/userApp?command=mypurchasehistory&args=sessionid=26913441`。
- en: 'Description: This command will give the purchasing history of the user. Here
    the result will be listed on the basis of dates on which the user bought particular
    products. The two parts in the URL that need to be focused on are the `command`,
    which is equal to `stats`, and the argument part, that is `args`. The argument
    is session ID of the user:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：此命令将给出用户的购买历史。结果将根据用户购买特定产品的日期列出。需要关注URL中的两个部分，一个是`command`，等于`stats`，另一个是参数部分，即`args`。参数是用户的会话ID：
- en: '![UserApp](img/0123OS_06_29.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![UserApp](img/0123OS_06_29.jpg)'
- en: Screenshot for viewing purchase history of a user
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 查看用户的购买历史的屏幕截图
- en: '`ReloginCommand`: This will implement the `relogin` command. The implementation
    of the command is as follows:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReloginCommand`：这将实现`relogin`命令。命令的实现如下：'
- en: '[PRE24]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=relogin&args=name=vinoo:password=******`.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 测试URL：`http://localhost:8080/simple-ecom/userApp?command=relogin&args=name=vinoo:password=******`。
- en: 'Description: This command will again check the user and password of the user
    and return back the associated session ID of the user. The idea is to have session
    which can exist many shopping and browsing sessions of a user.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：此命令将再次检查用户和用户的密码，并返回用户关联的会话ID。想要有一个会话，可以存在用户的许多购物和浏览会话。
- en: '`LogoutCommand`: This will implement the `logout` command. The implementation
    of the command is as follows:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LogoutCommand`：这将实现`logout`命令。命令的实现如下：'
- en: '[PRE25]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=logout&args=sessionid=26913441`.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 测试URL：`http://localhost:8080/simple-ecom/userApp?command=logout&args=sessionid=26913441`。
- en: 'Description: This command will log out the user from the system, and based
    on the session ID, delete all the datastore of the user, such as purchase history,
    shopping cart, and browsing history.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：此命令将登出用户系统，并根据会话ID删除用户的所有数据存储，如购买历史记录、购物车和浏览历史记录。
- en: Now that we have a hang of the commands, let's look into the package which will
    take care of the connection management and other functional calls with Redis.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了命令，让我们来看看这个包，它将负责管理连接和其他与Redis的功能调用。
- en: RedisDBManager
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RedisDBManager
- en: 'This class is the backbone of this application; it is responsible for connecting
    with the database and managing the connection pool. It also has some utility functions.
    The implementation is explained by the following code snippet:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是这个应用程序的支撑，它负责与数据库连接和管理连接池。它还有一些实用功能。实现如下代码片段所示：
- en: '[PRE26]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ProductDBManager
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ProductDBManager
- en: 'This class extends the `RedisDBManager` and is responsible for product related
    functional calls to the data base. This class is implemented as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类扩展了`RedisDBManager`，负责向数据库发出与产品相关的功能调用。该类的实现如下：
- en: '[PRE27]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: AnalyticsDBManager
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AnalyticsDBManager
- en: 'This class extends the `RedisDBManager` and is responsible for analytics-related
    functional calls to the data base. The class is implemented as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类扩展了`RedisDBManager`，负责向数据库发出与分析相关的功能调用。该类的实现如下：
- en: '[PRE28]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ShoppingCartDBManager
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ShoppingCartDBManager
- en: 'This class extends the `RedisDBManager` and is responsible for shopping cart-related
    functional calls to the data base. The implementation is as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类扩展了`RedisDBManager`，负责向数据库发出与购物车相关的功能调用。实现如下：
- en: '[PRE29]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: UserCartDBManager
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UserCartDBManager
- en: 'This class extends the `RedisDBManager` and is responsible for user related
    functional calls to the data base. The implementation is as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类扩展了`RedisDBManager`，负责向数据库发出与用户相关的功能调用。实现如下：
- en: '[PRE30]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: So in this chapter, we learnt how to make a simple e-commerce site with Redis
    as its backbone. Also, we learnt how Redis can come handy for doing online analytics.
    This sample site lacked the capability for scalability which we learnt in the
    previous chapters. I would urge the readers to add that capability to this code
    base as an exercise and have fun with this awesome datastore.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们学习了如何使用Redis作为其支撑构建一个简单的电子商务网站。此外，我们还学习了Redis如何在进行在线分析时变得方便。这个示例网站缺乏我们在之前章节中学到的可扩展性功能。我建议读者将这种能力添加到这个代码库中作为一种练习，并且享受这个令人敬畏的数据存储。
- en: In the next chapter, I will divulge how to use Redis in business applications,
    and make a few applications that are commonly used in all the business applications.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将透露如何在业务应用程序中使用Redis，并制作一些在所有业务应用程序中常用的应用程序。
