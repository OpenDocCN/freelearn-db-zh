# 第二章：命令行操作和索引

在本章中，我们将涵盖以下主题：

+   创建测试数据

+   从 Mongo shell 执行简单的查询、投影和分页

+   从 shell 中更新和删除数据

+   创建索引并查看查询计划

+   在 shell 中创建背景和前景索引

+   创建和理解稀疏索引

+   使用 TTL 索引在固定间隔后过期文档

+   使用 TTL 索引在给定时间过期文档

# 介绍

在本章中，我们将使用 mongo shell 执行简单的查询。在本章后面，我们将详细了解常用的 MongoDB 索引。

# 创建测试数据

这个配方是为本章的一些配方以及本书后面的章节创建测试数据。我们将演示如何使用 mongo 导入实用程序将 CSV 文件加载到 mongo 数据库中。这是一个基本的配方，如果读者了解数据导入实用程序，他们可以直接从 Packt 网站下载 CSV 文件(`pincodes.csv`)，自己将其加载到集合中，并跳过其余的配方。我们将使用默认数据库`test`，集合将被命名为`postalCodes`。

## 准备工作

这里使用的数据是印度的邮政编码。从 Packt 网站下载`pincodes.csv`文件。该文件是一个包含 39,732 条记录的 CSV 文件；成功导入后应该创建 39,732 个文档。我们需要让 Mongo 服务器处于运行状态。参考第一章中的*安装单节点 MongoDB*配方，了解如何启动服务器的说明。服务器应该开始监听默认端口`27017`上的连接。

## 如何做…

1.  从 shell 中使用以下命令执行要导入的文件：

```sql
$ mongoimport --type csv -d test -c postalCodes --headerline --drop pincodes.csv

```

1.  通过在命令提示符上输入`mongo`来启动 mongo shell。

1.  在 shell 中，执行以下命令：

```sql
> db.postalCodes.count()

```

## 它是如何工作的…

假设服务器正在运行，CSV 文件已经下载并保存在本地目录中，我们在其中执行导入实用程序。让我们看看`mongoimport`实用程序中给出的选项及其含义：

| 命令行选项 | 描述 |
| --- | --- |
| `--type` | 这指定输入文件的类型为 CSV。它默认为 JSON；另一个可能的值是 TSV。 |
| `-d` | 这是要加载数据的目标数据库。 |
| `-c` | 这是前面提到的数据库中要加载数据的集合。 |
| `--headerline` | 这只在 TSV 或 CSV 文件的情况下相关。它指示文件的第一行是标题。相同的名称将用作文档中字段的名称。 |
| `--drop` | 在导入数据之前删除集合。 |

在给出所有选项后，命令提示符上的最终值是文件名`pincodes.csv`。

如果导入成功，您应该在控制台上看到类似以下内容的输出：

```sql
2015-05-19T06:51:54.131+0000	connected to: localhost
2015-05-19T06:51:54.132+0000	dropping: test.postalCodes
2015-05-19T06:51:54.810+0000	imported 39732 documents

```

最后，我们启动 mongo shell 并查找集合中文档的计数；正如在前面的导入日志中所看到的，它应该确实是 39,732。

### 注意

邮政编码数据来自[`github.com/kishorek/India-Codes/`](https://github.com/kishorek/India-Codes/)。这些数据不是来自官方来源，可能不准确，因为它是手动编译的，供公众免费使用。

## 另请参阅

*在 Mongo shell 中执行简单的查询、投影和分页*配方是关于在导入的数据上执行一些基本查询。

# 从 Mongo shell 执行简单的查询、投影和分页

在这个配方中，我们将通过一些查询来选择我们在前一个配方*创建测试数据*中设置的测试数据中的文档。在这个配方中没有什么奢侈的东西，熟悉查询语言基础知识的人可以跳过这个配方。其他不太熟悉基本查询或想要进行小小复习的人可以继续阅读配方的下一部分。此外，这个配方旨在让您感受到前一个配方中设置的测试数据。

## 准备工作

要执行简单的查询，我们需要有一个正在运行的服务器。一个简单的单节点就是我们需要的。请参考第一章中的*安装单节点 MongoDB*配方，了解如何启动服务器的说明。我们将要操作的数据需要导入到数据库中。导入数据的步骤在前一个配方*创建测试数据*中给出。您还需要启动 mongo shell 并连接到在本地主机上运行的服务器。一旦这些先决条件完成，我们就可以开始了。

## 如何做…

1.  让我们首先找到集合中文档的数量：

```sql
> db.postalCodes.count()

```

1.  让我们从`postalCodes`集合中找到一个文档：

```sql
> db.postalCodes.findOne()

```

1.  现在，我们按如下方式在集合中找到多个文档：

```sql
> db.postalCodes.find().pretty()

```

1.  前面的查询检索了前 20 个文档的所有键，并在 shell 上显示它们。在结果的末尾，您会注意到一行，上面写着`键入"it"以获取更多内容`。通过键入`"it"`，mongo shell 将遍历结果游标。现在让我们做一些事情；我们将只显示`city`、`state`和`pincode`字段。此外，我们想显示集合中编号为 91 到 100 的文档。让我们看看如何做到这一点：

```sql
> db.postalCodes.find({}, {_id:0, city:1, state:1, pincode:1}).skip(90).limit(10)

```

1.  让我们再进一步，编写一个稍微复杂的查询，在其中按照城市名称找到古吉拉特邦的前 10 个城市，并且与上一个查询类似，我们只选择`city`、`state`和`pincode`字段：

```sql
> db.postalCodes.find({state:'Gujarat'},{_id:0, city:1, state:1, pincode:1}).sort({city:1}).limit(10)

```

## 工作原理…

这个配方非常简单，让我们感受到了我们在前一个配方中设置的测试数据。尽管如此，和其他配方一样，我确实需要向大家解释一下我们在这里做了什么。

我们首先使用`db.postalCodes.count()`找到了集合中文档的数量，应该有 39,732 个文档。这应该与我们在导入邮政编码集合数据时看到的日志保持一致。接下来，我们使用`findOne`从集合中查询一个文档。这个方法返回查询结果集中的第一个文档。在没有查询或排序顺序的情况下，就像在这种情况下一样，它将是按其自然顺序排序的集合中的第一个文档。

接下来，我们执行`find`而不是`findOne`。它们之间的区别在于`find`操作返回结果集的迭代器，我们可以使用它来遍历`find`操作的结果，而`findOne`返回一个文档。对`find`操作添加一个 pretty 方法调用将以漂亮或格式化的方式打印结果。

### 提示

请注意，`pretty`方法只对`find`有效，而对`findOne`无效。这是因为`findOne`的返回值是一个文档，而返回的文档上没有`pretty`操作。

现在我们将在 mongo shell 上执行以下查询：

```sql
> db.postalCodes.find({}, {_id:0, city:1, state:1, pincode:1}).skip(90).limit(10) 

```

在这里，我们向`find`方法传递了两个参数：

+   第一个是`{}`，这是选择文档的查询，在这种情况下，我们要求 mongo 选择所有文档。

+   第二个参数是我们想要在结果文档中的字段集，也被称为**投影**。请记住，`_id`字段默认存在，除非我们明确指定`_id:0`。对于所有其他字段，我们需要说`<field_name>:1`或`<field_name>:true`。具有投影的查找部分与在关系世界中说`select field1``, field2 from table`是一样的，而不指定要选择的字段在查找中说`select * from table`在关系世界中。

接下来，我们只需要看一下`skip`和`limit`的作用：

+   `skip`函数从结果集中跳过给定数量的文档，直到最后一个文档

+   `limit`函数然后将结果限制为给定数量的文档

让我们通过一个例子来看看这意味着什么。通过执行.`skip(90).limit(10)`，我们说我们要跳过结果集中的前 90 个文档，并从第 91 个文档开始返回。然而，limit 表示我们将只从第 91 个文档返回 10 个文档。

现在，这里有一些边界条件，我们需要知道。如果 skip 提供的值大于集合中的文档总数会怎么样？在这种情况下，将不会返回任何文档。此外，如果提供给 limit 函数的数字大于集合中剩余的实际文档数量，则返回的文档数量将与集合中剩余的文档数量相同，并且在任一情况下都不会抛出异常。

# 从 shell 更新和删除数据

这将是一个简单的示例，将在测试集合上执行删除和更新。我们不会处理导入的相同测试数据，因为我们不想更新/删除任何数据，而是我们将在仅为此示例创建的测试集合上工作。

## 准备工作

对于此示例，我们将创建一个名为`updAndDelTest`的集合。我们需要服务器运行。有关如何启动服务器的说明，请参阅第一章中的*安装单节点 MongoDB*示例，*安装和启动服务器*。使用加载了`UpdAndDelTest.js`脚本的 shell 启动。此脚本可在 Packt 网站上下载。要了解如何使用预加载的脚本启动 shell，请参阅第一章中的*使用 JavaScript 连接 Mongo shell 中的单个节点*示例，*安装和启动服务器*。

## 操作步骤…

1.  启动 MongoDB shell 并预加载脚本：

```sql
$ mongo --shell updAndDelTest.js

```

1.  使用启动的 shell 和加载的脚本，在 shell 中执行以下操作：

```sql
> prepareTestData()

```

1.  如果一切顺利，您应该在控制台上看到`在 updAndDelTest 中插入了 20 个文档`的打印：

1.  为了了解集合的情况，让我们查询如下：

```sql
> db.updAndDelTest.find({}, {_id:0})

```

1.  我们应该看到对于`x`的每个值为`1`和`2`，我们有`y`从 1 到 10 递增的值。

1.  我们将首先更新一些文档并观察结果。执行以下更新：

```sql
> db.updAndDelTest.update({x:1}, {$set:{y:0}})

```

1.  执行以下`find`命令并观察结果；我们应该得到 10 个文档。对于每个文档，注意`y`的值。

```sql
> db.updAndDelTest.find({x:1}, {_id:0})

```

1.  我们现在将执行以下更新：

```sql
> db.updAndDelTest.update({x:1}, {$set:{y:0}}, {multi:true})

```

1.  再次执行步骤 6 中给出的查询以查看更新后的文档。它将显示我们之前看到的相同文档。再次注意`y`的值，并将其与我们上次执行此查询之前执行步骤 7 中给出的更新时看到的结果进行比较。

1.  我们现在将看看删除是如何工作的。我们将再次选择`x`为`1`的文档进行删除测试。让我们从集合中删除所有`x`为`1`的文档：

```sql
> db.updAndDelTest.remove({x:1})

```

1.  执行以下`find`命令并观察结果。我们将不会得到任何结果。似乎`remove`操作已删除所有`x`为`1`的文档。

```sql
> db.updAndDelTest.find({x:1}, {_id:0})

```

### 注意

当您在 mongo shell 中，并且想要查看函数的源代码时，只需输入函数名称而不带括号。例如，在这个示例中，我们可以通过输入函数名称`prepareTestData`（不带括号）来查看我们自定义函数的代码，并按下*Enter*键。

## 它是如何工作的...

首先，我们设置将用于更新和删除`test`的数据。我们已经看到了数据并知道它是什么。一个有趣的观察是，当我们执行更新操作，比如`db.updAndDelTest.update({x:1}, {$set:{y:0}})`，它只会更新与作为第一个参数提供的查询匹配的第一个文档。这是我们在此更新后查询集合时将观察到的事情。更新函数的格式如下：`db.<collection name>.update(query, update object, {upsert: <boolean>, multi:<boolean>})`。

我们将在后面的示例中看到 upsert 是什么。multi 参数默认设置为`false`。这意味着`update`方法不会更新多个文档；只有第一个匹配的文档会被更新。然而，当我们使用`db.updAndDelTest.update({x:1}, {$set:{y:0}}, {multi:true})`并将 multi 设置为`true`时，集合中匹配给定查询的所有文档都会被更新。这是我们在查询集合后可以验证的事情。

另一方面，删除的行为不同。默认情况下，`remove`操作会删除所有与提供的查询匹配的文档。然而，如果我们只想删除一个文档，我们可以将第二个参数明确传递为`true`。

### 注意

更新和删除的默认行为是不同的。默认情况下，`update`调用只会更新*第一个*匹配的文档，而`remove`会删除与查询匹配的*所有*文档。

# 创建索引并查看查询计划

在这个示例中，我们将查看如何查询数据，通过解释查询计划来分析其性能，然后通过创建索引来优化它。

## 准备工作

对于索引的创建，我们需要运行一个服务器。一个简单的单节点就是我们需要的。请参考第一章中的*安装单节点 MongoDB*示例，了解如何启动服务器的说明。我们将要操作的数据需要导入到数据库中。导入数据的步骤在前一个示例*创建测试数据*中给出。一旦这个先决条件完成，我们就可以开始了。

## 如何做...

我们正在尝试编写一个查询，该查询将找到给定州中的所有邮政编码。

1.  执行以下查询以查看此查询的计划：

```sql
> db.postalCodes.find({state:'Maharashtra'}).explain('executionStats')

```

在解释计划操作的结果中，注意以下字段：`stage`、`nReturned`、`totalDocsExamined`、`docsExamined`和`executionTimeMillis`。

1.  让我们再次执行相同的查询，但这次，我们将结果限制为仅 100 个结果：

```sql
> db.postalCodes.find({state:'Maharashtra'}).limit(100).explain()

```

1.  在结果中注意以下字段：`nReturned`、`totalDocsExamined`、`docsExamined`和`executionTimeMillis`。

1.  我们现在在`state`和`pincode`字段上创建索引，如下所示：

```sql
> db.postalCodes.createIndex({state:1, pincode:1})

```

1.  执行以下查询：

```sql
> db.postalCodes.find({state:'Maharashtra'}).explain()

```

注意以下字段：`stage`、`nReturned`、`totalDocsExamined`、`docsExamined`和`executionTimeMillis`。

1.  因为我们只想要邮政编码，所以我们修改查询如下并查看其计划：

```sql
> db.postalCodes.find({state:'Maharashtra'}, {pincode:1, _id:0}).explain()

```

在结果中注意以下字段：`stage`、`nReturned`、`totalDocsExamined`、`docsExamined`和`executionTimeMillis`。

## 它是如何工作的...

这里有很多要解释的地方。我们将首先讨论我们刚刚做的事情以及如何分析统计数据。接下来，我们将讨论索引创建时需要注意的一些要点和一些注意事项。

### 分析计划

好的，让我们看看我们执行的第一步并分析输出：

```sql
db.postalCodes.find({state:'Maharashtra'}).explain()

```

在我的机器上的输出如下：（我现在跳过了不相关的字段。）

```sql
{
        "stage" : "COLLSCAN",
...
        "nReturned" : 6446,
        "totalDocsExamined " : 39732, 
          …
    "docsExamined" : 39732, 
          …

        "executionTimeMillis" : 12,
…        
}
```

结果中`stage`字段的值为`COLLSCAN`，这意味着为了在整个集合中搜索匹配的文档，进行了完整的集合扫描（所有文档一个接一个地扫描）。`nReturned`的值为`6446`，这是与查询匹配的结果数量。`totalDocsExamined`和`docsExamined`字段的值为`39,732`，这是扫描集合以检索结果的文档数量。这也是集合中存在的文档总数，所有文档都被扫描以获取结果。最后，`executionTimeMillis`是检索结果所用的毫秒数。

### 提高查询执行时间

到目前为止，就性能而言，查询看起来并不太好，有很大的改进空间。为了演示应用于查询的限制如何影响查询计划，我们可以再次找到没有索引但有限制子句的查询计划，如下所示：

```sql
> db.postalCodes.find({state:'Maharashtra'}).limit(100).explain()

{
 "stage" : "COLLSCAN",…
 "nReturned" : 100,
 "totalDocsExamined" : 19951,

 …
 "docsExamined" : 19951,
 …
 "executionTimeMillis" : 8,
 …
}

```

这次的查询计划很有趣。虽然我们仍然没有创建索引，但我们确实看到了查询执行所需的时间和检索结果所需的对象数量有所改善。这是因为一旦达到了`limit`函数中指定的文档数量，mongo 就会忽略剩余文档的扫描。因此，我们可以得出结论，建议您使用`limit`函数来限制结果的数量，其中已知要访问的文档数量是有限的。这可能会提高查询性能。`可能`这个词很重要，因为在没有索引的情况下，如果匹配的文档数量不足，集合仍然可能被完全扫描。

### 使用索引进行改进

接着，我们在 state 和 pincode 字段上创建了一个复合索引。在这种情况下，索引的顺序是升序（因为值为 1），除非我们计划执行多键排序，否则这并不重要。这是一个决定性因素，决定了结果是否可以仅使用索引进行排序，还是 mongo 需要在返回结果之前在内存中对其进行排序。就查询计划而言，我们可以看到有了显著的改进：

```sql
{
"executionStages" : {
 "stage" : "FETCH",
…
"inputStage" : {
 "stage" : "IXSCAN",
…
 "nReturned" : 6446,
 "totalDocsExamined" : 6446,
 "docsExamined" : 6446,
 …
 "executionTimeMillis" : 4,
…
}

```

`inputStage`字段现在具有`IXSCAN`值，这表明现在确实使用了索引。结果的数量保持不变，仍为`6446`。在索引中扫描的对象数量和集合中扫描的文档数量现在已经减少到与结果中的文档数量相同。这是因为我们现在使用了一个索引，它给出了我们要扫描的起始文档，然后只扫描所需数量的文档。这类似于使用书的索引查找单词或扫描整本书以搜索单词。如预期的那样，`executionTimeMillis`中的时间也减少了。

### 使用覆盖索引进行改进

这留下了一个字段，`executionStages`，它是`FETCH`，我们将看看这意味着什么。要了解这个值是什么，我们需要简要了解索引是如何操作的。

索引存储了集合中原始文档的字段子集。索引中存在的字段与创建索引的字段相同。然而，这些字段按照在索引创建期间指定的顺序在索引中保持排序。除了字段之外，索引中还存储了一个额外的值，作为指向集合中原始文档的指针。因此，每当用户执行查询时，如果查询包含索引存在的字段，就会查询索引以获取一组匹配项。然后，与查询匹配的索引条目一起存储的指针被用于进行另一个 IO 操作，以从集合中获取完整的文档，然后返回给用户。

`executionStages`的值为`FETCH`，表示用户在查询中请求的数据并不完全存在于索引中，而是需要进行额外的 IO 操作，从索引指向的集合中检索整个文档。如果值本身存在于索引中，则不需要额外的操作来从集合中检索文档，而是会返回索引中的数据。这称为覆盖索引，在这种情况下，`executionStages`的值将是`IXSCAN`。

在我们的情况下，我们只需要邮政编码。那么，为什么不在我们的查询中使用投影来检索我们需要的内容呢？这也会使索引成为覆盖索引，因为索引条目只包含州名和邮政编码，所需的数据可以完全提供，而无需从集合中检索原始文档。在这种情况下，查询的计划也很有趣。

执行以下命令：

```sql
db.postalCodes.find({state:'Maharashtra'}, {pincode:1, _id:0}).explain()

```

这给我们带来了以下计划：

```sql
{
"executionStages" : {
 "stage" : "PROJECTION",
…
"inputStage" : {
 "stage" : "IXSCAN",
…
 "nReturned" : 6446,
 "totalDocsExamined" : 0,
 "totalKeysExamined": 6446
 "executionTimeMillis" : 4,
…
}

```

观察`totalDocsExamined`和`executionStage: PROJECTION`字段的值。如预期的那样，我们在投影中请求的数据可以仅从索引中提供。在这种情况下，我们扫描了索引中的 6446 个条目，因此`totalKeysExamined`的值为`6446`。

由于整个结果都是从索引中获取的，我们的查询没有从集合中获取任何文档。因此，`totalDocsExamined`的值为`0`。

由于这个集合很小，我们没有看到查询执行时间的显着差异。这在更大的集合上将更加明显。使用索引是很好的，可以给我们良好的性能。使用覆盖索引可以给我们更好的性能。

### 注意

MongoDB 版本 3.0 的解释结果功能进行了重大改进。我建议花几分钟阅读其文档：[`docs.mongodb.org/manual/reference/explain-results/`](http://docs.mongodb.org/manual/reference/explain-results/)。

还要记住的一件事是，如果您的文档有很多字段，请尝试使用投影仅检索我们需要的字段数量。默认情况下，`_id`字段会被检索。除非我们打算使用它，否则将`_id:0`设置为不检索它，如果它不是索引的一部分。执行覆盖查询是查询集合的最有效方式。

### 索引创建的一些注意事项

现在我们将看到索引创建中的一些陷阱以及在索引中使用数组字段时的一些事实。

一些不高效使用索引的运算符是`$where`，`$nin`和`$exists`运算符。每当在查询中使用这些运算符时，应该牢记，当数据量增加时可能会出现性能瓶颈。

同样，`$in`运算符必须优先于`$or`运算符，因为两者都可以用来实现或多或少相同的结果。作为练习，尝试在`postalCodes`集合中找到马哈拉施特拉邦和古吉拉特邦的邮政编码。编写两个查询：一个使用`$or`，一个使用`$in`运算符。解释这两个查询的计划。

当数组字段用于索引时会发生什么？

Mongo 为文档的数组字段中的每个元素创建一个索引条目。因此，如果文档的数组中有 10 个元素，将会有 10 个索引条目，每个数组中的元素都有一个。然而，在创建包含数组字段的索引时有一个约束。在使用多个字段创建索引时，不能有超过一个字段是数组类型，这是为了防止在数组中添加一个元素时可能导致索引数量激增。如果我们仔细考虑一下，我们会发现每个数组元素都会创建一个索引条目。如果允许多个数组字段成为索引的一部分，那么索引中的条目数量将会很大，这将是这些数组字段长度的乘积。例如，如果一个文档添加了两个长度为 10 的数组字段，如果允许使用这两个数组字段创建一个索引，将会向索引中添加 100 个条目。

这应该足够了，现在，来初步了解一个简单的、普通的索引。在接下来的几个配方中，我们将看到更多的选项和类型。

# 在 shell 中创建后台和前台索引

在我们之前的配方中，我们看到了如何分析查询，如何决定需要创建什么索引，以及如何创建索引。这本身是直接的，看起来相当简单。然而，对于大型集合，随着索引创建时间的增加，情况开始变得更糟。这个配方的目标是为这些概念扔一些光，避免在创建索引时遇到这些陷阱，特别是在大型集合上。

## 准备工作

为了创建索引，我们需要一个正在运行的服务器。一个简单的单节点就是我们需要的。请参考第一章中的*安装单节点 MongoDB*配方，了解如何启动服务器的说明。

通过在操作系统 shell 中键入`mongo`来连接两个 shell 到服务器。它们都将默认连接到`test`数据库。

我们的邮政编码测试数据太小，无法展示在大型集合上创建索引时遇到的问题。我们需要更多的数据，因此，我们将开始创建一些数据来模拟在创建索引过程中遇到的问题。这些数据没有实际意义，但足够测试概念。在其中一个已启动的 shell 中复制以下内容并执行：（这是一个相当容易输入的片段。）

```sql
for(i = 0; i < 5000000 ; i++) {
  doc = {}
  doc._id = i
  doc.value = 'Some text with no meaning and number ' + i + ' in between'
  db.indexTest.insert(doc)
}
```

这个集合中的文档看起来是这样的：

```sql
{ _id:0, value:"Some text with no meaning and number 0 in between" }
```

执行将需要相当长的时间，所以我们需要耐心等待。一旦执行完成，我们就可以开始操作了。

### 注意

如果你想知道集合中当前加载的文档数量，可以定期从第二个 shell 中评估以下内容：

```sql
db.indexTest.count()
```

## 如何做…

1.  在文档的`value`字段上创建索引，如下所示：

```sql
> db.indexTest.createIndex({value:1})

```

1.  在索引创建过程中，这应该需要相当长的时间，切换到第二个控制台并执行以下操作：

```sql
> db.indexTest.findOne()

```

1.  索引创建 shell 和我们执行`findOne`的 shell 都将被阻塞，直到索引创建完成，两者都不会显示提示。

1.  现在，这是默认的前台索引创建。我们想看看后台索引创建的行为。按照以下方式删除已创建的索引：

```sql
> db.indexTest.dropIndex({value:1})

```

1.  再次创建索引，但这次是在后台进行，如下所示：

```sql
> db.indexTest.createIndex({value:1}, {background:true})

```

1.  在第二个 mongo shell 中，执行以下`findOne`：

```sql
> db.indexTest.findOne()

```

1.  这应该返回一个文档，这与第一个实例不同，那里的操作会一直被阻塞，直到前台的索引创建完成。

1.  在第二个 shell 中，反复执行以下解释操作，每次解释计划调用之间间隔四到五秒，直到索引创建过程完成：

```sql
> db.indexTest.find({value:"Some text with no meaning and number 0 in between"}).explain()

```

## 它是如何工作的…

让我们现在分析一下我们刚刚做的事情。我们创建了大约五百万个没有实际重要性的文档，但我们只是想获取一些数据，这将花费大量时间来构建索引。

索引可以通过两种方式构建，前台和后台。在任何一种情况下，shell 在`createIndex`操作完成之前都不会显示提示，并且会阻塞所有操作，直到索引创建完成。为了说明前台和后台索引创建之间的区别，我们执行了第二个 mongo shell。

我们首先在前台创建了索引，这是默认行为。这个索引构建不允许我们查询集合（从第二个 shell）直到索引构建完成。`findOne`操作在整个索引构建完成之前（从第一个 shell）都会被阻塞。另一方面，在后台构建的索引不会阻塞`findOne`操作。如果您想在索引构建过程中尝试向集合中插入新文档，这应该能很好地工作。随时删除索引并在后台重新创建它，同时向`indexTest`集合中插入一个文档，您会注意到它可以顺利进行。

那么，这两种方法之间有什么区别，为什么不总是在后台构建索引？除了作为第二个参数传递给`createIndex`调用的额外参数`{background:true}`（也可以是`{background:1}`）之外，还有一些区别。后台索引创建过程将比前台创建的索引稍慢。此外，在内部——虽然与最终用户无关——在前台创建的索引将比在后台创建的索引更紧凑。

除此之外，没有其他显著的区别。实际上，如果系统正在运行并且需要在为最终用户提供服务时创建索引（虽然不建议，但有时可能需要在活动系统中进行索引创建），那么在后台创建索引是唯一的方法。有其他策略可以执行此类管理活动，我们将在管理部分的一些示例中看到。

对于前台索引创建来说，mongo 在索引创建期间获取的锁不是在集合级别，而是在数据库级别。为了解释这意味着什么，我们将不得不删除`indexTest`集合上的索引，并执行以下小练习：

1.  首先通过从 shell 执行以下命令来在前台创建索引：

```sql
> db.indexTest.createIndex({value:1})

```

1.  现在，将一个文档插入到 person 集合中，该集合此时可能存在，也可能不存在于测试数据库中，如下所示：

```sql
> db.person.insert({name:'Amol'})

```

我们将看到，person 集合中的此插入操作将在`indexTest`集合的索引创建过程中被阻塞。但是，如果此插入操作是在索引构建期间的不同数据库中的集合上执行的，它将正常执行而不会阻塞。（您也可以尝试一下。）这清楚地表明锁是在数据库级别而不是在集合或全局级别获取的。

### 注意

在 mongo 的 2.2 版本之前，锁是在全局级别，即在 mongod 进程级别，而不是在我们之前看到的数据库级别。当处理旧于 2.2 版本的 mongo 分布时，您需要记住这一点。

# 创建和理解稀疏索引

Mongo 的无模式设计是 Mongo 的基本特性之一。这允许集合中的文档具有不同的字段，一些文档中存在一些字段，而其他文档中不存在。换句话说，这些字段可能是稀疏的，这可能已经给你一个关于稀疏索引是什么的线索。在这个示例中，我们将创建一些随机测试数据，并查看稀疏索引在普通索引中的行为。我们将看到使用稀疏索引的优势和一个主要的缺陷。

## 准备工作

对于这个示例，我们需要创建一个名为`sparseTest`的集合。我们需要一个正在运行的服务器。有关如何启动服务器的说明，请参阅第一章中的*安装单节点 MongoDB*示例，*安装和启动服务器*。使用加载了`SparseIndexData.js`脚本的 shell 启动。此脚本可在 Packt 网站上下载。要了解如何使用预加载的脚本启动 shell，请参阅第一章中的*使用 JavaScript 在 Mongo shell 中连接到单个节点*示例，*安装和启动服务器*。

## 如何做…

1.  通过调用以下方法加载集合中的数据。这应该会在`sparseTest`集合中导入 100 个文档。

```sql
> createSparseIndexData()

```

1.  现在，通过执行以下查询来查看数据，注意顶部几个结果中的`y`字段：

```sql
> db.sparseTest.find({}, {_id:0})

```

1.  我们可以看到`y`字段不存在，或者如果存在的话是唯一的。然后执行以下查询：

```sql
> db.sparseTest.find({y:{$ne:2}}, {_id:0}).limit(15)

```

1.  注意结果；它包含符合条件的文档以及不包含给定字段`y`的字段。

1.  由于`y`的值似乎是唯一的，让我们按照以下方式在`y`字段上创建一个新的唯一索引：

```sql
> db.sparseTest.createIndex({y:1}, {unique:1})

```

这会抛出一个错误，抱怨值不是唯一的，冒犯的值是 null 值。

1.  我们将通过以下方式将此索引设置为稀疏：

```sql
> db.sparseTest.createIndex({y:1}, {unique:1, sparse:1})

```

1.  这应该解决我们的问题。为了确认索引已创建，请在 shell 上执行以下操作：

```sql
> db.sparseTest.getIndexes()

```

这应该显示两个索引，一个是默认的`_id`索引，另一个是我们刚刚在上一步中创建的索引。

1.  现在，再次执行我们在步骤 3 中执行的查询，并查看结果。

1.  查看结果并将其与创建索引之前看到的结果进行比较。重新执行查询，但使用以下提示强制进行完整集合扫描：

```sql
>db.sparseTest.find({y:{$ne:2}},{_id:0}).limit(15).hint({$natural:1})

```

1.  观察结果。

## 工作原理…

这些是我们刚刚执行的许多步骤。我们现在将深入探讨并解释使用稀疏索引查询集合时看到的奇怪行为的内部和推理。

我们使用 JavaScript 方法创建的测试数据只是创建了一个名为`x`的键的文档，其值是从一开始的数字，一直到 100。只有当`x`是三的倍数时，才设置`y`的值-它的值也是一个从一开始的递增数字，当`x`是`99`时，它应该最多达到 33。

然后执行查询并查看以下结果：

```sql
> db.sparseTest.find({y:{$ne:2}}, {_id:0}).limit(15)
{ "x" : 1 }
{ "x" : 2 }
{ "x" : 3, "y" : 1 }
{ "x" : 4 }
{ "x" : 5 }
{ "x" : 7 }
{ "x" : 8 }
{ "x" : 9, "y" : 3 }
{ "x" : 10 }
{ "x" : 11 }
{ "x" : 12, "y" : 4 }
{ "x" : 13 }
{ "x" : 14 }
{ "x" : 15, "y" : 5 }
{ "x" : 16 }

```

结果中缺少`y`为`2`的值，这正是我们想要的。请注意，结果中仍然可以看到`y`不存在的文档。我们现在计划在`y`字段上创建一个索引。由于该字段要么不存在，要么具有唯一值，因此唯一索引应该能够正常工作。

在内部，索引默认情况下会在索引中添加一个条目，即使原始文档中的字段在集合中不存在。然而，进入索引的值将是 null。这意味着索引中将有与集合中文档数量相同的条目。对于唯一索引，值（包括 null 值）应该在整个集合中是唯一的，这解释了为什么在创建稀疏字段的索引时会出现异常（字段不在所有文档中都存在）。

解决这个问题的一个方法是使索引稀疏化，我们所做的就是在选项中添加`sparse:1`以及`unique:1`。如果文档中不存在该字段，则不会在索引中放入条目。因此，索引现在将包含更少的条目。它只包含那些字段存在于文档中的条目。这不仅使索引变小，易于放入内存，而且解决了添加唯一约束的问题。我们最不希望的是，拥有数百万文档的集合的索引有数百万条目，而只有少数几百条目有一些值定义。

虽然我们可以看到创建稀疏索引确实使索引更有效，但它引入了一个新问题，即一些查询结果不一致。我们之前执行的相同查询产生了不同的结果。请参见以下输出：

```sql
> db.sparseTest.find({y:{$ne:2}}, {_id:0}).hint({y:1}).limit(15)
{ "x" : 3, "y" : 1 }
{ "x" : 9, "y" : 3 }
{ "x" : 12, "y" : 4 }
{ "x" : 15, "y" : 5 }
{ "x" : 18, "y" : 6 }
{ "x" : 21, "y" : 7 }
{ "x" : 24, "y" : 8 }
{ "x" : 27, "y" : 9 }
{ "x" : 30, "y" : 10 }
{ "x" : 33, "y" : 11 }
{ "x" : 36, "y" : 12 }
{ "x" : 39, "y" : 13 }
{ "x" : 42, "y" : 14 }
{ "x" : 45, "y" : 15 }
{ "x" : 48, "y" : 16 }

```

为什么会发生这种情况？答案在于这个查询的查询计划。执行以下操作查看此查询的计划：

```sql
>db.sparseTest.find({y:{$ne:2}}, {_id:0}). hint({y:1}).limit(15).explain()

```

这个计划表明它使用索引来获取匹配的结果。由于这是一个稀疏索引，所有没有`y`字段的文档都不在其中，它们也没有出现在结果中，尽管它们应该出现。这是一个我们在查询使用稀疏索引的集合时需要小心的陷阱。它会产生意想不到的结果。一个解决方案是强制进行全集合扫描，我们可以使用`hint`函数为查询分析器提供提示。提示用于强制查询分析器使用用户指定的索引。尽管通常不建议这样做，因为你真的需要知道你在做什么，但这是真正需要的情况之一。那么，我们如何强制进行全表扫描呢？我们只需在`hint`函数中提供`{$natural:1}`。集合的自然排序是指它在磁盘上存储的特定集合的顺序。这个`hint`强制进行全表扫描，现在我们得到了之前的结果。然而，对于大集合，查询性能会下降，因为现在使用了全表扫描。

如果字段存在于许多文档中（对于什么是*很多*没有正式的标准；对于一些人来说可能是 50%，对于其他人来说可能是 75%），并且不是真正稀疏的，那么使索引稀疏化除了当我们想要使其唯一之外就没有太多意义了。

### 注意

如果两个文档对于相同字段具有空值，唯一索引创建将失败，并且将其创建为稀疏索引也不会有帮助。

# 使用 TTL 索引在固定间隔后过期文档

Mongo 中一个有趣的特性是在预定的时间后自动删除集合中的数据。当我们想要清除一些比特定时间段更旧的数据时，这是一个非常有用的工具。对于关系数据库来说，通常不会有人设置每晚运行的批处理作业来执行此操作。

有了 Mongo 的 TTL 功能，您不必担心这个问题，因为数据库会自动处理。让我们看看如何实现这一点。

## 准备就绪

让我们在 Mongo 中创建一些数据，以便使用 TTL 索引进行操作。我们将为此目的创建一个名为`ttlTest`的集合。我们需要一个服务器正在运行。有关如何启动服务器的说明，请参阅第一章中的*安装单节点 MongoDB*配方，*安装和启动服务器*。使用加载了`TTLData.js`脚本的 shell 启动。此脚本可在 Packt 网站上下载。要了解如何使用预加载的脚本启动 shell，请参阅第一章中的*使用 JavaScript 在 Mongo shell 中连接到单节点*配方，*安装和启动服务器*。

## 如何做…

1.  假设服务器已启动，并且提供的脚本已加载到 shell 中，请从 mongo shell 中调用以下方法：

```sql
> addTTLTestData()

```

1.  在`createDate`字段上创建 TTL 索引如下：

```sql
> db.ttlTest.createIndex({createDate:1}, {expireAfterSeconds:300})

```

1.  现在，按以下方式查询集合：

```sql
> db.ttlTest.find()

```

1.  这应该给我们三个文件。重复这个过程，并且在大约 30-40 秒内执行`find`查询，以便看到三个文件被删除，直到整个集合中没有文件为止。

## 它是如何工作的...

让我们从打开`TTLData.js`文件开始，看看里面发生了什么。代码非常简单，它只是使用 new `Date()`获取当前日期。然后在这个脚本中的`addTTLTestData()`方法的执行中，我们有三个文档在`ttlTest`集合中，每个文档的创建时间相差一分钟。

下一步是 TTL 功能的核心：创建 TTL 索引。它类似于使用`createIndex`方法创建任何其他索引，只是它还接受一个 JSON 对象作为第二个参数。这两个参数如下：

+   第一个参数是`{createDate:1}`；这将告诉 mongo 在`createDate`字段上创建一个索引，索引的顺序是升序的，因为值是`1`（`-1`将是降序的）。

+   第二个参数`{expireAfterSeconds:300}`是使该索引成为 TTL 索引的关键，它告诉 Mongo 在 300 秒（五分钟）后自动使文档过期。

好吧，但是从什么时候开始的五分钟？它是它们被插入集合的时间还是其他时间戳？在这种情况下，它认为`createTime`字段是基础，因为这是我们创建索引的字段。

现在引发一个问题：如果一个字段被用作时间计算的基础，那么它的类型必须受到一定的限制。在一个`char`字段上创建 TTL 索引就没有意义，比如说，保存一个人名字的字段。

是的；正如我们猜测的那样，字段的类型可以是 BSON 类型的日期或日期数组。在数组中有多个日期的情况下会发生什么？在这种情况下会考虑什么？

结果是 Mongo 使用数组中可用的日期的最小值。尝试这种情况作为练习。

在一个文档中，对`updateField`字段放入两个相隔大约五分钟的日期，然后在这个字段上创建一个 TTL 索引，使文档在 10 分钟（600 秒）后过期。查询集合，看看文档何时从集合中删除。它应该在`updateField`数组中的最小时间值之后大约 10 分钟后被删除。

除了字段类型的约束外，还有一些其他约束：

+   如果一个字段已经有了索引，你就不能创建 TTL 索引。因为集合的`_id`字段已经默认有了索引，这实际上意味着你不能在`_id`字段上创建 TTL 索引。

+   TTL 索引不能是涉及多个字段的复合索引。

+   如果字段不存在，它将永远不会过期。（我想这很合乎逻辑。）

+   它不能在封闭集合上创建。如果你不知道封闭集合，它们是 Mongo 中的特殊集合，它们有一个大小限制，按照 FIFO 插入顺序删除旧文档，以便为新文档腾出空间。

### 注意

TTL 索引仅支持 Mongo 版本 2.2 及以上。请注意，文档不会在字段中给定的确切时间被删除。周期将以一分钟的粒度进行，这将删除自上次运行周期以来符合删除条件的所有文档。

## 另请参阅

使用情况可能不要求在固定时间间隔后删除所有文档。如果我们想要自定义文档在集合中停留的时间，也可以实现，这将在下一个示例“使用 TTL 索引在特定时间到期的文档”中进行演示。

# 使用 TTL 索引在特定时间到期的文档

在上一个示例“使用 TTL 索引在固定时间间隔后到期的文档”中，我们已经看到文档在固定时间段后到期的情况。但是，可能存在一些情况，我们希望文档在不同时间到期。这与上一个示例中所看到的情况不同。在本示例中，我们将看到如何指定文档可以到期的时间，对于不同的文档可能是不同的。

## 准备就绪

对于本示例，我们将创建一个名为`ttlTest2`的集合。我们需要一个正在运行的服务器。有关如何启动服务器的说明，请参阅第一章中的*安装单节点 MongoDB*示例，*安装和启动服务器*。使用加载了`TTLData.js`脚本的 shell。此脚本可在 Packt 网站上下载。要了解如何使用预加载脚本启动 shell，请参阅第一章中的*使用 JavaScript 连接 Mongo shell 中的单节点*示例，*安装和启动服务器*。

## 如何操作…

1.  使用`addTTLTestData2`方法在集合中加载所需的数据。在 mongo shell 上执行以下操作：

```sql
> addTTLTestData2()

```

1.  现在，按照以下步骤在`ttlTest2`集合上创建 TTL 索引：

```sql
> db.ttlTest2.createIndex({expiryDate :1}, {expireAfterSeconds:0})

```

1.  执行以下`find`查询以查看集合中的三个文档：

```sql
> db.ttlTest2.find()

```

1.  现在，大约四、五和七分钟后，查看 ID 为 2、1 和 3 的文档是否分别被删除。

## 工作原理…

让我们开始打开`TTLData.js`文件，看看里面发生了什么。我们本次示例感兴趣的方法是`addTTLTestData2`。该方法简单地在`tllTest2`集合中创建了三个文档，其`_id`分别为`1`、`2`和`3`，其`exipryDate`字段分别设置为当前时间之后的`5`、`4`和`7`分钟。请注意，与上一个示例中给出的创建日期不同，该字段具有未来日期。

接下来，我们创建一个索引：`db.ttlTest2.createIndex({expiryDate :1}, {expireAfterSeconds:0})`。这与我们在上一个示例中创建索引的方式不同，其中对象的`expireAfterSeconds`字段设置为非零值。这是`expireAfterSeconds`属性值的解释方式。如果值为非零，则这是文档将在 Mongo 中从集合中删除的基准时间之后经过的秒数。此基准时间是索引创建的字段中保存的值（如上一个示例中的`createTime`）。如果此值为零，则索引创建的日期值（在本例中为`expiryDate`）将是文档到期的时间。

总之，如果要在到期后删除文档，则 TTL 索引效果很好。有很多情况下，我们可能希望将文档移动到存档集合中，存档集合可能是基于年份和月份创建的。在任何这种情况下，TTL 索引都没有帮助，我们可能需要自己编写一个外部作业来完成这项工作。这样的作业还可以读取一系列文档，将它们添加到目标集合中，并从源集合中删除它们。MongoDB 的开发人员已经计划发布一个解决这个问题的功能。

## 另请参阅

在这个和前一个教程中，我们看了看 TTL 索引以及如何使用它们。然而，如果在创建了 TTL 索引之后，我们想要修改 TTL 值怎么办？这是可以通过使用`collMod`选项来实现的。在管理部分可以了解更多关于这个选项的信息。
