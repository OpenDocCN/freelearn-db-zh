- en: Chapter 3. Programming Language Drivers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。编程语言驱动程序
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Executing query and insert operations with PyMongo
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PyMongo执行查询和插入操作
- en: Executing update and delete operations using PyMongo
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PyMongo执行更新和删除操作
- en: Implementing aggregation in Mongo using PyMongo
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PyMongo在Mongo中实现聚合
- en: Executing MapReduce in Mongo using PyMongo
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PyMongo在Mongo中执行MapReduce
- en: Executing query and insert operations using a Java client
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java客户端执行查询和插入操作
- en: Executing update and delete operations using a Java client
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java客户端执行更新和删除操作
- en: Implementing aggregation in Mongo using a Java client
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java客户端在Mongo中实现聚合
- en: Executing MapReduce in Mongo using a Java client
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java客户端在Mongo中执行MapReduce
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: So far, we have executed the majority of operations in the shell using Mongo.
    The Mongo shell is a great tool for administrators to perform administrative tasks
    and for developers who would like to quickly test things by querying the data
    before coding the logic in the application. However, how do we write application
    code that will allow us to query, insert, update, and delete (among other things)
    the data in MongoDB? There has to be a library for the programming language that
    we write our application in. We should be able to instantiate something or invoke
    methods from the program to perform some operations on the remote Mongo process.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在shell中使用Mongo执行了大部分操作。Mongo shell是管理员执行管理任务和开发人员在编写应用程序逻辑之前通过查询数据快速测试事物的绝佳工具。然而，我们如何编写应用程序代码来允许我们在MongoDB中查询、插入、更新和删除（以及其他操作）数据？我们编写应用程序的编程语言应该有一个库。我们应该能够实例化一些东西或从程序中调用方法来执行一些操作在远程Mongo进程上。
- en: How would this happen unless there is some bridge that understands the protocol
    of communication with the remote server and is able to transmit the operation
    over the wire that we require in order to execute on the Mongo server process
    and get the result back to the client. This bridge, simply put, is called the
    **driver**, also referred to as client libraries. Drivers form the backbone of
    Mongo's programming language interface; in their absence, it would have been the
    responsibility of the application to communicate with the Mongo server using a
    low-level protocol that the server understands. This would have been a lot of
    work, not only to develop, but also to test and maintain. Though the communication
    protocol is standard, there cannot be one implementation that works for all the
    languages. A variety of programming languages need to have their own implementations
    exposing similar sets of programming interfaces to all the languages. The core
    concepts of client APIs, which we will see in this chapter, holds good for all
    the languages.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除非有一个理解与远程服务器通信协议并能够传输我们需要的操作的桥梁，以便在Mongo服务器进程上执行并将结果传回客户端。简单地说，这个桥梁被称为**驱动程序**，也称为客户端库。驱动程序构成了Mongo的编程语言接口的支柱；如果没有它们，应用程序将负责使用服务器理解的低级协议与Mongo服务器通信。这不仅需要开发，还需要测试和维护。尽管通信协议是标准的，但不能有一个适用于所有语言的实现。各种编程语言需要有自己的实现，向所有语言公开类似的编程接口。我们将在本章中看到的客户端API的核心概念对所有语言都适用。
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Mongo has support for all major programming and is supported by MongoDB Inc.
    There is even a huge array of programming languages supported by the community.
    You can take a look at the various platforms supported by Mongo by visiting [http://docs.mongodb.org/ecosystem/drivers/community-supported-drivers/](http://docs.mongodb.org/ecosystem/drivers/community-supported-drivers/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Mongo支持所有主要编程语言，并得到MongoDB Inc的支持。社区还支持大量的编程语言。您可以访问[http://docs.mongodb.org/ecosystem/drivers/community-supported-drivers/](http://docs.mongodb.org/ecosystem/drivers/community-supported-drivers/)查看Mongo支持的各种平台。
- en: Executing query and insert operations with PyMongo
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PyMongo执行查询和插入操作
- en: This recipe is all about executing basic query and `insert` operations using
    PyMongo. This is similar to what we did with the Mongo shell earlier in the book.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是关于使用PyMongo执行基本查询和“插入”操作的。这与我们在本书前面使用Mongo shell所做的类似。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To execute simple queries, we need to have a server up and running. A simple
    single node is what we need. Refer to the *Installing single node MongoDB* recipe
    from [Chapter 1](ch01.html "Chapter 1. Installing and Starting the Server"), *Installing
    and Starting the Server* for instructions on how to start the server. The data
    that we will be operating on needs to be imported in the database. The steps to
    import the data are given in the *Creating test data* recipe from [Chapter 2](ch02.html
    "Chapter 2. Command-line Operations and Indexes"), *Command-line Operations and
    Indexes*. Python 2.7, or higher, has to be present on the host operating system
    along with MongoDB's Python client, PyMongo. Look at the earlier recipe, *Connecting
    to a single node using a Python client*, in [Chapter 1](ch01.html "Chapter 1. Installing
    and Starting the Server"), *Installing and Starting the Server* on how to install
    PyMongo for your host operating system. Additionally, in this recipe, we will
    execute `insert` operations and provide a write concern to use.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行简单的查询，我们需要一个正在运行的服务器。我们需要一个简单的单节点。有关如何启动服务器的说明，请参阅[第1章](ch01.html "第1章。安装和启动服务器")中的*安装单节点MongoDB*配方，*安装和启动服务器*。我们将操作的数据需要导入数据库。有关导入数据的步骤，请参阅[第2章](ch02.html
    "第2章。命令行操作和索引")中的*创建测试数据*配方，*命令行操作和索引*。主机操作系统上必须安装Python 2.7或更高版本，以及MongoDB的Python客户端PyMongo。如何在主机操作系统上安装PyMongo，请参阅[第1章](ch01.html
    "第1章。安装和启动服务器")中的早期配方*使用Python客户端连接到单节点*，*安装和启动服务器*。此外，在这个配方中，我们将执行“插入”操作并提供写关注。
- en: How to do it…
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Let's start with querying for Mongo in the Python shell. This will be identical
    to what we do in the mongo shell except that this is in the Python programming
    language, as opposed to the JavaScript that we have in the mongo shell. We can
    use the basics that we will see here to write big production systems that run
    on Python and use mongo as a data store.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Python shell中查询Mongo开始。这将与我们在mongo shell中所做的完全相同，只是这是用Python编程语言而不是我们在mongo
    shell中使用的JavaScript。我们可以使用这里将看到的基础知识来编写在Python上运行并使用mongo作为数据存储的大型生产系统。
- en: 'Let''s begin by starting the Python shell from the operating system''s command
    prompt. All these steps are independent of the host operating system. Perform
    the following steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从操作系统的命令提示符开始启动Python shell。所有这些步骤都与主机操作系统无关。执行以下步骤：
- en: 'Type the following in the shell and the Python shell should start:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在shell中输入以下内容，Python shell应该启动：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, import the `pymongo` package and create the client as follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，导入`pymongo`包，并创建客户端如下：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This works well and achieves the same result. Now that we have the client,
    our next step is to get the database that we will be performing the operations
    on. This is unlike some of the programming languages where we have a `getDatabase()`
    method to get an instance of the database. We will get a reference to the database
    object that we will be performing the operations on, `test` in this case. We will
    do this in the following way:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样做效果很好，可以实现相同的结果。现在我们有了客户端，下一步是获取我们将执行操作的数据库。这与一些编程语言不同，在那里我们有一个`getDatabase()`方法来获取数据库的实例。我们将获取一个对数据库对象的引用，我们将在其上执行操作，在这种情况下是`test`。我们将以以下方式执行此操作：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will query the `postalCodes` collection. We will limit our results to 10
    items.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将查询`postalCodes`集合。我们将将结果限制为10项。
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Iterate over the results. Watch out for the indentation of the print after
    the `for` statement. The following fragment should print 10 documents as returned:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历结果。注意`for`语句后的缩进。以下片段应该打印出返回的10个文档：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To find one document, execute the following:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查找一个文档，请执行以下操作：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Print the `state` and `city` of the returned result as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下方式打印返回结果的`state`和`city`：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s query top 10 cities in the state of Gujarat sorted by the name of the
    city and, additionally, we just select the `city`, `state`, and `pincode`. Execute
    the following query in the Python shell:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们查询古吉拉特邦前10个城市，按城市名称排序，并且额外选择`city`、`state`和`pincode`。在Python shell中执行以下查询：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding cursor's results can be printed in the same way that we printed
    the results in step 5.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 前面游标的结果可以以与我们在第5步中打印结果相同的方式打印出来。
- en: 'Let''s sort the data that we query. We want to sort in a descending order of
    state and then by ascending order of the city. We will write the query as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们对我们查询的数据进行排序。我们希望按州的降序和城市的升序进行排序。我们将编写以下查询：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Iterating through this cursor should print out five results to the console.
    Refer to step 5 on how we iterate over a cursor returned to print the results.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过迭代这个游标，应该在控制台上打印出五个结果。参考第5步，了解如何迭代返回的游标以打印结果。
- en: 'So, we have played a bit to find documents and covered the basic operations
    in Python as far as the querying of MongoDB is concerned. Now, let''s see a bit
    about the `insert` operation. We will use a test collection to perform these operations
    and not disturb our postal codes test data. We will use a `pymongoTest` collection
    for this purpose and add documents in a loop to it as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们已经玩了一会儿，找到了文档，并涵盖了Python中与查询MongoDB有关的基本操作。现在，让我们稍微了解一下`insert`操作。我们将使用一个测试集合来执行这些操作，而不会干扰我们的邮政编码测试数据。我们将使用`pymongoTest`集合来实现这个目的，并按以下方式向其中添加文档：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `insert` can take a list of dictionary objects and perform a bulk insert.
    So now, something similar to the following `insert` is perfectly valid:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`insert`可以接受一个字典对象列表并执行批量插入。因此，现在类似以下的`insert`是完全有效的：'
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Any guesses on the return value? In case of a single document insert, the return
    value is the value of `_id` for the newly created document. In this case, it is
    a list of IDs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对返回值有什么猜测吗？在单个文档插入的情况下，返回值是新创建文档的`_id`的值。在这种情况下，它是一个ID列表。
- en: How it works…
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In step 2, we instantiate the client and get the reference to the `MongoClient`
    object that will be used to access the database. There are a couple of ways to
    get this reference. The first option is more convenient, unless your database
    name has some special character, such as a hyphen (-). For example, if the name
    is `db-test`, we would have no option other than to use the `[]` operator to access
    the database. Using either of the alternatives, we now have an object for the
    test database in the `db` variable. After we get the `client` and `db` instances
    in Python, we query to find the top 10 documents in the natural order from the
    collection in step 3\. The syntax is identical to how this query would have been
    executed in the shell. Step 4 simply prints out the results, 10 of them in this
    case. Generally, if you need instant help on a particular class using the class
    name or an instance of this class from the Python interpreter, simply perform
    `dir(<class_name>)` or `dir(<object of a class>)`, which gives you a list of attributes
    and functions defined in the module passed. For example, `dir('pymongo.MongoClient')`
    or `dir(client)`, where the client is the variable holding reference to an instance
    of `pymongo.MongoClient`, can be used to get the list of all the supported attributes
    and functions. The `help` function is more informative, prints out the module's
    documentation, and is a great source of reference just in case you need instant
    help. Try typing `help('pymongo.MongoClient')` or `help(client)`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步，我们实例化客户端并获取对`MongoClient`对象的引用，该对象将用于访问数据库。有几种方法可以获取这个引用。第一个选项更方便，除非你的数据库名称中有一些特殊字符，比如连字符(-)。例如，如果名称是`db-test`，我们将不得不使用`[]`运算符来访问数据库。使用任何一种替代方案，我们现在都有了一个指向`db`变量中测试数据库的对象。在Python中获取`client`和`db`实例之后，我们查询以自然顺序从第3步的集合中找到前10个文档。语法与在shell中执行此查询的方式完全相同。第4步只是简单地打印出结果，这种情况下有10个结果。通常，如果您需要在Python解释器中使用类名或该类的实例获得特定类的即时帮助，只需执行`dir(<class_name>)`或`dir(<object
    of a class>)`，这将给出模块中定义的属性和函数的列表。例如，`dir('pymongo.MongoClient')`或`dir(client)`，其中`client`是持有`pymongo.MongoClient`实例引用的变量，可以用来获取所有支持的属性和函数的列表。`help`函数更具信息性，打印出模块的文档，并且在需要即时帮助时是一个很好的参考来源。尝试输入`help('pymongo.MongoClient')`或`help(client)`。
- en: In steps 3 and 4, we query the `postalCodes` collection, limit the result to
    the top 10 results, and print them. The returned object is of a type `pymongo.cursor.Cursor`
    class. The next step gets just one document from the collection using the `find_one()`
    function. This is synonymous to the `findOne()` method on the collection invoked
    in the shell. The value returned by this function is an inbuilt object, `dict`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3和第4步，我们查询`postalCodes`集合，将结果限制为前10个结果，并将它们打印出来。返回的对象是`pymongo.cursor.Cursor`类的一个实例。下一步使用`find_one()`函数从集合中获取一个文档。这相当于在shell中调用集合的`findOne()`方法。这个函数返回的值是一个内置对象，`dict`。
- en: 'In step 6, we execute another `find` to query the data. In step 8, we pass
    two Python dicts. The first dict is the query, similar to the query parameter
    we use in mongo shell. The second dictionary is used to provide the fields to
    be returned in the result. A value, one, for a field indicates that the value
    is to be selected and returned in the result. This is synonymous with the `select`
    statement in a relational database with a few sets of columns provided explicitly
    to be selected. The `_id` field is selected by default unless it is explicitly
    set to zero in the selector `dict` object. The selector provided here is `{''_id'':0,
    ''city'':1, ''state'':1, ''pincode'':1}`, which selects the city, state, and pincode
    and suppresses the `_id` field. We have a sort method as well. This method has
    two formats as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6步，我们执行另一个`find`来查询数据。在第8步，我们传递了两个Python字典。第一个字典是查询，类似于我们在mongo shell中使用的查询参数。第二个字典用于提供要在结果中返回的字段。对于一个字段，值为1表示该值将被选择并返回在结果中。这与在关系数据库中使用`select`语句并显式提供要选择的几组列是相同的。`_id`字段默认被选择，除非在选择器`dict`对象中明确设置为零。这里提供的选择器是`{'_id':0,
    'city':1, 'state':1, 'pincode':1}`，它选择了城市、州和邮政编码，并抑制了`_id`字段。我们也有一个排序方法。这个方法有两种格式，如下所示：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first one is used when we want to sort by one field only. The second representation
    accepts a list of pairs of the sort field and sort directions and is used when
    we want to sort by multiple fields. We used the first form in the query in step
    8 and the second format in our query in step 9 as we sort first by the state `name`
    and then, by `city`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个用于只按一个字段排序。第二种表示接受一个排序字段和排序方向的对列表，并且用于按多个字段排序。我们在第8步的查询中使用了第一种形式，在第9步的查询中使用了第二种形式，因为我们首先按州名排序，然后按城市排序。
- en: If we look at the way we invoke `sort`, it is invoked on the `Cursor` instance.
    Similarly, the `limit` function is also on the `Cursor` class. The evaluation
    is lazy and deferred until the iteration is performed in order to retrieve the
    results from the cursor. Until this point of time, the `Cursor` object is not
    evaluated on the server.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下我们调用`sort`的方式，它是在`Cursor`实例上调用的。同样，`limit`函数也是在`Cursor`类上的。评估是延迟的，直到进行迭代以从游标中检索结果为止。在这个时间点之前，`Cursor`对象不会在服务器上进行评估。
- en: In step 11, we insert a document 20 times in a collection. Each insert, as we
    can see in the Python shell, will return a generated `_id` field. In terms of
    the syntax of insert, it is exactly identical to the operation that we perform
    in the shell. The parameter passed for the insert is an object of type `dict`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11步，我们在集合中插入一个文档20次。每次插入，正如我们在Python shell中看到的那样，都会返回一个生成的`_id`字段。在插入的语法方面，它与我们在shell中执行的操作完全相同。传递给插入的参数是一个`dict`类型的对象。
- en: In step 12, we pass a list of documents to insert in the collection. This is
    referred to as a bulk insert operation, which inserts multiple documents in a
    single call to the server. The return value in this case is a list of IDs, one
    for each document inserted, and the order is the same as those passed in the input
    list. However, as MongoDB doesn't support transactions, each insert will be independent
    of each other, and a failure of one insert doesn't roll back the entire operation
    automatically.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在第12步中，我们将一个文档列表传递给集合进行插入。这被称为批量插入操作，它可以在一次调用中向服务器插入多个文档。在这种情况下，返回值是一个ID列表，每个插入的文档都有一个ID，并且顺序与输入列表中的顺序相同。然而，由于MongoDB不支持事务，每次插入都是相互独立的，一个插入的失败不会自动回滚整个操作。
- en: 'Adding the functionality of inserting multiple documents demanded another parameter
    for the behavior. When one of the inserts in the list given fails, should the
    remaining inserts continue or the insertion stop as soon as the first error is
    encountered? The name of the parameter to control this behavior is `continue_on_error`
    and its default value is `False`, that is, stop as soon as the first error is
    encountered. If this value is `True` and multiple errors occur during insertion,
    only the latest error will be available, and hence the default option with `False`
    as the value is sensible. Let''s look at a couple of examples. In the Python shell,
    execute the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 添加插入多个文档的功能需要另一个参数来控制行为。在给定的列表中，如果其中一个插入失败，剩余的插入是否应该继续，还是在遇到第一个错误时停止插入？控制此行为的参数名称是`continue_on_error`，其默认值为`False`，即遇到第一个错误时停止插入。如果此值为`True`，并且在插入过程中发生多个错误，那么只有最新的错误将可用，因此默认选项为`False`是明智的。让我们看几个例子。在Python
    shell中，执行以下操作：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The count that we will get is `1`, which is for the first document with the
    `_id` field as `1`. The moment another document with the same value of the `_id`
    field is found, `1` in this case, an error is thrown and the bulk insert stops.
    Now execute the following `insert` operation:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到的计数是`1`，这是第一个具有`_id`字段为`1`的文档。一旦找到另一个具有相同`_id`字段值的文档，即在本例中为`1`，就会抛出错误并停止批量插入。现在执行以下`insert`操作：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we have passed an additional parameter, `continue_on_error`, whose value
    is `True`. What this does is ensures that the `insert` operation will continue
    with the next document even if an intermediate `insert` operation fails. The second
    insert with `_id:1` fails, yet the next insert goes through before another insert
    with `_id:2` fails (as one document with this `_id` is already present). Additionally,
    the error reported is for the last failure, the one with `_id:2`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们传递了一个额外的参数`continue_on_error`，其值为`True`。这样做可以确保`insert`操作会在中间的`insert`操作失败时继续进行下一个文档的插入。第二个具有`_id:1`的插入失败，但在另一个具有`_id:2`的插入失败之前，下一个插入会继续进行（因为已经存在一个具有此`_id`的文档）。此外，报告的错误是最后一个失败的错误，即具有`_id:2`的错误。
- en: See also
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The next recipe, *Executing update and delete operations using PyMongo*, picks
    up where this leaves off and introduces the update, remove, and atomic find operations.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个配方，*使用PyMongo执行更新和删除操作*，接着介绍了更新、删除和原子查找操作。
- en: Executing update and delete operations using PyMongo
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PyMongo执行更新和删除操作
- en: In the previous recipe, we saw how to execute `find` and `insert` operations
    in MongoDB using PyMongo. In this recipe, we will see how update and delete work
    in Python. We will also see what atomic find and update/delete is and how to execute
    them. We then conclude by revisiting find operations and looking at some interesting
    functions of the `cursor` object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个配方中，我们看到了如何使用PyMongo在MongoDB中执行`find`和`insert`操作。在本配方中，我们将看到如何在Python中执行更新和删除操作。我们还将看到原子查找和更新/删除是什么，以及如何执行它们。最后，我们将重新审视查找操作，并了解`cursor`对象的一些有趣的功能。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you have already seen and completed the previous recipe, you are all set
    to go. If not, it is recommended that you first complete that recipe before going
    ahead with this one. Additionally, if you are not sure what read preference and
    write concern are, refer to the two recipes, *Read preference for querying* and
    *Write concern and its significance*, in [Appendix](apa.html "Appendix A. Concepts
    for Reference"), *Concepts for Reference* of the book.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经看过并完成了上一个配方，那么您就可以开始了。如果没有，建议您在继续本配方之前先完成那个配方。此外，如果您不确定读取偏好和写入关注是什么，请参考本书的[附录](apa.html
    "附录A.参考概念")中的两个配方，*用于查询的读取偏好*和*写入关注及其重要性*。
- en: 'Before we get started, let''s define a small function that iterates through
    the cursor and shows the results of a cursor on the console. We will use this
    function whenever we want to display the results of a query on the `pymongoTests`
    collection. The following is the function body:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们定义一个小函数，它通过游标迭代并在控制台上显示游标的结果。每当我们想要在`pymongoTests`集合上显示查询结果时，我们将使用这个函数。以下是函数体：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can refer to steps 1 and 2 in the previous recipe on how to create a connection
    to the MongoDB server and the `db` object that is used to perform CRUD operations
    on this database. Additionally, refer to step 8 in the previous recipe on how
    to insert the required test data in the `pymongoTest` collection. You can confirm
    the data in this collection by executing the following in the Python shell once
    the data is present:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考上一个配方中的步骤1和步骤2，了解如何连接到MongoDB服务器以及用于在该数据库上执行CRUD操作的`db`对象。此外，还可以参考上一个配方中的第8步，了解如何在`pymongoTest`集合中插入所需的测试数据。一旦数据存在，您可以在Python
    shell中执行以下操作来确认该集合中的数据：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For a part of the recipe, one is also expected to know how to start a replica
    set instance. Refer to the *Starting multiple instances as part of a replica set*
    and *Connecting to the replica set in the shell to query and insert data* recipes
    in the first chapter for more details on a replica set and how to start one.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于食谱的一部分，人们也应该知道如何启动一个副本集实例。有关副本集的更多细节以及如何启动副本集，请参阅第一章中的*作为副本集的一部分启动多个实例*和*在shell中连接到副本集以查询和插入数据*食谱。
- en: How to do it…
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'We will begin by running the following commands in the Python shell:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从Python shell中运行以下命令开始：
- en: 'We will set a field named `gtTen` specified with a Boolean value `True` if
    the `i` field has a value greater than 10\. Let''s execute the following update:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`i`字段的值大于10，则我们将设置一个名为`gtTen`的字段，并指定一个布尔值`True`。让我们执行以下更新：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Query the collection, view its data by executing the following, and check the
    data that got updated:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询集合，通过执行以下操作查看其数据，并检查已更新的数据：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The results displayed confirm that only one document got updated. We will now
    execute the same update again, but this time around, we will update all the documents
    that match the provided query. Execute the following update in the Python shell.
    Note that this update is identical to the one we performed in step 1 except for
    the additional parameter called multi whose value is given as `True`. Note the
    value of n in the response, which is `10` this time.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示的结果证实只有一个文档被更新。现在我们将再次执行相同的更新，但这一次，我们将更新所有与提供的查询匹配的文档。在Python shell中执行以下更新。注意响应中的n的值，这次是`10`。
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Execute the operation that we did in step 2 again to view the contents in the
    `pymongoTest` collection and verify the documents that got updated.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次执行我们在步骤2中进行的操作，查看`pymongoTest`集合中的内容，并验证已更新的文档。
- en: 'Let''s look at how `upsert` operations can be performed. Upserts are updates
    plus inserts, and they update a document if one exists, just as an update would
    do, or else they insert a new document. We will look at an example. Consider the
    following update on a document that doesn''t exist in the collection:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看如何执行`upsert`操作。Upserts是更新加插入，如果文档存在则更新文档，就像更新操作一样，否则插入一个新文档。我们将看一个例子。考虑对集合中不存在的文档进行以下更新：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The update here will not update anything and will return the number of updated
    documents as zero. However, consider that we want to update a document if it exists,
    or else insert a new document and apply the update to it atomically, then we perform
    an `upsert` operation. In this case, the `upsert` operation is executed as follows.
    Note that the return result mentions `upsert`, `ObjectId` of the newly inserted
    document, and the `updatedExisting` value, which is `False`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里的更新不会更新任何内容，并且返回更新的文档数为零。但是，如果我们想要更新一个文档（如果存在），否则插入一个新文档并原子性地应用更新，那么我们执行一个`upsert`操作。在这种情况下，`upsert`操作执行如下。请注意返回结果中提到的`upsert`，新插入文档的`ObjectId`和`updatedExisting`值，这个值是`False`：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s see how to delete documents from the collection using the `remove` method:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`remove`方法从集合中删除文档：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If we look at the value of `n` in the preceding response, we can see that it
    is `1`. This means that one document has been removed.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们查看前面响应中`n`的值，我们可以看到它是`1`。这意味着已删除一个文档。
- en: 'To remove multiple documents from the collection, we use the `delete_many`
    method:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从集合中删除多个文档，我们使用`delete_many`方法：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will look at the find and modify operations now. We can look at these operations
    as a way to find a document and update/remove it, and both of these operations
    are performed atomically. Once the operation is performed, the document returned
    is either the one before or after the update operation was done. (In case of `remove`,
    there will be no document after the operation.) In the absence of this operation,
    we cannot guarantee atomicity where multiple client connections could be performing
    a similar operation on the same document. The following is an example of how to
    perform this find and modify operation in Python:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将看一下查找和修改操作。我们可以将这些操作视为查找文档并更新/删除它的一种方式，这两种操作都是原子性执行的。操作完成后，返回的文档要么是更新操作之前的文档，要么是更新操作之后的文档。（在`remove`的情况下，操作后将没有文档。）在没有这种操作的情况下，我们无法保证在多个客户端连接可能对同一文档执行类似操作的情况下的原子性。以下是如何在Python中执行此查找和修改操作的示例：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The previous result shows us that the resulting document returned is the one
    before the update was applied.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的结果告诉我们，在应用更新之前返回的文档是之前的文档。
- en: 'Execute the following `find` method to query and view the document that we
    updated in the last step. The resulting document would contain the newly added
    in the `Words` field:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下`find`方法来查询并查看我们在上一步中更新的文档。结果文档将包含在`Words`字段中新增的内容：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will execute the `find` and `modify` operation again, but this time around,
    we return the updated document rather than the document before the update that
    we saw in step 9\. Execute the following in the Python shell:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将再次执行`find`和`modify`操作，但这一次，我们返回更新后的文档，而不是在步骤9中看到的更新前的文档。在Python shell中执行以下操作：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We saw how to use queries with PyMongo in the previous recipe. Here, we will
    continue with the query operation. We saw how the `sort` and `limit` functions
    were chained to the find operation. The prototype of the call on the `postalCodes`
    collection is as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在上一个食谱中看到了如何使用PyMongo进行查询。在这里，我们将继续进行查询操作。我们看到`sort`和`limit`函数是如何链接到find操作的。对`postalCodes`集合的调用原型如下：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There is an alternate way to achieve this same result. Execute the following
    query in the Python shell:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一种实现相同结果的替代方法。在Python shell中执行以下查询：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Print the preceding cursor using the `showResult` function already defined.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用已定义的`showResult`函数打印前面的游标。
- en: How it works…
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'Let''s look at what all we did in this recipe; we started with updating the
    documents in a collection in step 1\. The update operation, however, updates only
    the first matching document by default and the rest of the matching documents
    are not updated. In step 2, we added a parameter called `multi` with a value `True`
    to update multiple documents as part of the same update operation. Note that all
    these documents are not updated atomically as part of one transaction. Looking
    at the update done in the Python shell, we see a striking resemblance to what
    we would have done in the Mongo shell. If we want to name the arguments of the
    update operation, the names of the parameter are called `spec` and `document`
    for the document provided as a query to be used in order to select the documents
    to update and the update document, respectively. For instance, the following update
    is valid:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在这个示例中我们做了什么；我们从在步骤1中更新集合中的文档开始。但是，默认情况下，更新操作只更新第一个匹配的文档，其余匹配的文档不会被更新。在步骤2中，我们添加了一个名为`multi`的参数，其值为`True`，以便在同一更新操作中更新多个文档。请注意，所有这些文档不会作为一个事务的一部分被原子更新。在Python
    shell中查看更新后，我们看到与在Mongo shell中所做的操作非常相似。如果我们想要为更新操作命名参数，那么提供为查询使用的文档的参数名称称为`spec`，而更新文档的参数名称称为`document`。例如，以下更新是有效的：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In step 6, we did an `upsert` (update plus insert) operation. All we had was
    an additional parameter, `upsert`, with a value, `True`. However, what exactly
    happens in the case of an upsert? Mongo tries to update the document matching
    the provided condition, and if it finds one, then this would be a regular update.
    However, in this case (`upsert` in step 6), the document was not found. The server
    inserted the document given as the spec (the first parameter) parameter in the
    collection and then applied the update to it with both these operations taking
    place atomically.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6步，我们进行了`upsert`（更新加插入）操作。我们只有一个额外的参数`upsert`，其值为`True`。但是，在`upsert`的情况下到底发生了什么呢？Mongo尝试更新匹配提供条件的文档，如果找到一个，则这将是一个常规更新。但是，在这种情况下（第6步的`upsert`），未找到文档。服务器将以原子方式将作为查询条件的文档（第一个参数）插入到集合中，然后对其进行更新。
- en: In steps 7 and 9, we saw the `remove` operation. The first variant accepted
    a query and the matching document was removed. The second variant, in step 9,
    removes all the matching documents.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7和第9步，我们看到了`remove`操作。第一个变体接受一个查询，并删除匹配的文档。第二个变体在第9步中删除了所有匹配的文档。
- en: In steps 10 to 12, we executed the `find` and `modify` operations. The gist
    of these operations is pretty straightforward. What we didn't mention was the
    `find_one_and_replace()` method, which, as the name suggests, can be used to search
    a document and completely replace it with another.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10到12步，我们执行了`find`和`modify`操作。这些操作的要点非常简单。我们没有提到的是`find_one_and_replace()`方法，顾名思义，可以用来搜索文档并完全替换它。
- en: All the operations that we saw in this recipe were for a client connected to
    a standalone instance. If you are connected to a replica set, the client is instantiated
    in a different way. We are also aware of the fact that we are not allowed to query
    the secondary nodes for data by default. We need to explicitly do `rs.slaveOk()`
    in the mongo shell connected to a secondary node to query it. It is done in a
    similar way in a Python client as well. If we are connected to a secondary node,
    we cannot query it by default, but the way in which we specify that we are ok
    to query on a secondary node is slightly different. Starting with PyMongo 3.0,
    we can now pass `ReadPreference` when initiating `MongoClient`. This is primarily
    because, starting with PyMongo 3.0, `pymongo.MongoClient()` is the only way to
    connect to a standalone instance, replica set, or sharded cluster. The available
    read preferences are `PRIMARY`, `SECONDARY`, `PRIMARY_PREFERRED`, `SECONDARY_PREFERRED`,
    and `NEAREST`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中看到的所有操作都是针对连接到独立实例的客户端的。如果您连接到一个副本集，客户端将以不同的方式实例化。我们也知道，默认情况下不允许查询副本节点的数据。我们需要在连接到副本节点的mongo
    shell中显式执行`rs.slaveOk()`来查询它。在Python客户端中也是以类似的方式执行。如果我们连接到副本节点，不能默认查询它，但是我们指定我们可以查询副本节点的方式略有不同。从PyMongo
    3.0开始，我们现在可以在初始化`MongoClient`时传递`ReadPreference`。这主要是因为，从PyMongo 3.0开始，`pymongo.MongoClient()`是连接到独立实例、副本集或分片集群的唯一方式。可用的读取偏好包括`PRIMARY`、`SECONDARY`、`PRIMARY_PREFERRED`、`SECONDARY_PREFERRED`和`NEAREST`。
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In addition to the client, PyMongo also allows you to have read preferences
    set at the database or collection level.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 除了客户端之外，PyMongo还允许您在数据库或集合级别设置读取偏好。
- en: By default, `read_preference` for a client initialized without an explicit read
    preference is `PRIMARY` (with value zero). However, if we now get the database
    object from the client initialized previously, the read preference will be `NEAREST`
    (with value `4`).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，未显式设置读取偏好的初始化客户端的`read_preference`为`PRIMARY`（值为零）。但是，如果我们现在从先前初始化的客户端获取数据库对象，则读取偏好将为`NEAREST`（值为`4`）。
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Setting the read preference is as simple as doing the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 设置读取偏好就像做以下操作一样简单：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Again, as the read preference gets inherited from the client to the database
    object, it gets inherited from the database object to the collection object. This
    would be used as the default value for all the queries executed against this collection
    unless the read preference is specified explicitly in the `find` operation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，由于读取偏好从客户端继承到数据库对象，它也从数据库对象继承到集合对象。这将作为针对该集合执行的所有查询的默认值，除非在`find`操作中显式指定读取偏好。
- en: Thus, `db.pymongoTest.find_one()` will have a cursor that uses the read preference
    as `SECONDARY` (as we have just set it previously to `SECONDARY` at the database
    object level).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`db.pymongoTest.find_one()`将使用读取偏好作为`SECONDARY`（因为我们刚刚在数据库对象级别将其设置为`SECONDARY`）。
- en: We will now wrap up the basic operations from a Python driver by trying to do
    some common operations that we do in a mongo shell such as getting all the database
    names, getting a list of collections in a database, and creating an index on a
    collection.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过尝试在Python驱动程序中完成基本操作来结束。这些操作与我们在mongo shell中进行的一些常见操作相似，例如获取所有数据库名称，获取数据库中集合的列表，并在集合上创建索引。
- en: 'In the shell, we do show `dbs` to show all the database names in the mongo
    instance connected. From the Python client, we do the following on the client
    instance:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell中，我们显示`dbs`以显示连接的mongo实例中的所有数据库名称。从Python客户端，我们对客户端实例执行以下操作：
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Similarly, to see the list of collections, we do show collections in the mongo
    shell; in Python, all we do on the database object is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，要查看集合的列表，我们在mongo shell中执行`show collections`；在Python中，我们对数据库对象执行以下操作：
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now for the `index` operations; we first see what all indexes are present in
    the `pymongoTest` collection. Execute the following in the Python shell to view
    the indexes on a collection:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对于`index`操作；我们首先查看`pymongoTest`集合中存在的所有索引。在Python shell中执行以下操作以查看集合上的索引：
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We now will create an index on key `x`, which is sorted in an ascending order
    on the `pymongoTest` collection as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将按照以下方式在`pymongoTest`集合上对键`x`创建一个升序排序的索引：
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can again list the indexes to confirm the creation of the index:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次列出索引以确认索引的创建：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can see that the index has been created. Removing the index is also simple
    as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到索引已经创建。删除索引也很简单，如下所示：
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Another parameter called `CursorType.TAILABLE` is used to denote that the cursor
    returned by `find` is a tailable cursor. Explaining what tailable cursors and
    giving more details is not in the scope of this recipe and will be explained in
    the recipe named *Creating and tailing a capped collection cursors in MongoDB*
    in [Chapter 5](ch05.html "Chapter 5. Advanced Operations"), *Advanced Operations*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个参数叫做`CursorType.TAILABLE`，用于表示`find`返回的游标是一个可追加的游标。解释可追加游标并提供更多细节不在这个配方的范围内，将在[第5章](ch05.html
    "第5章。高级操作")的*创建和追加一个被截断的集合游标在MongoDB中*配方中进行解释。
- en: Implementing aggregation in Mongo using PyMongo
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PyMongo在Mongo中实现聚合
- en: We have already seen PyMongo using Python's client interface for Mongo in previous
    recipes. In this recipe, we will use the postal codes collection and run an aggregation
    example using PyMongo. The intention of this recipe is not to explain aggregation
    but to show how aggregation can be implemented using PyMongo. In this recipe,
    we will aggregate the data based on the state names and get the top five state
    names by the number of documents that they appear in. We will make use of the
    `$project`, `$group`, `$sort`, and `$limit` operators for the process.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的配方中看到了PyMongo使用Python的客户端接口来连接Mongo。在这个配方中，我们将使用邮政编码集合并使用PyMongo运行一个聚合示例。这个配方的目的不是解释聚合，而是展示如何使用PyMongo实现聚合。在这个配方中，我们将根据州名对数据进行聚合，并获取出现次数最多的五个州名。我们将使用`$project`、`$group`、`$sort`和`$limit`操作符进行这个过程。
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To execute the aggregation operation, we need to have a server up and running.
    A simple single node is what we need. Refer to the *Installing single node MongoDB*
    recipe from [Chapter 1](ch01.html "Chapter 1. Installing and Starting the Server"),
    *Installing and Starting the Server* for instructions on how to start the server.
    The data that we will operate on needs to be imported in the database. The steps
    to import the data are mentioned in the *Creating test data* recipe in [Chapter
    2](ch02.html "Chapter 2. Command-line Operations and Indexes"), *Command-line
    Operations and Indexes*. Additionally, refer to the *Connecting to a single node
    using a Python client* recipe in [Chapter 1](ch01.html "Chapter 1. Installing
    and Starting the Server"), *Installing and Starting the Server* on how to install
    PyMongo for your host operating system. As this is a way to implement aggregation
    in Python, it is assumed that the reader is aware of the aggregation framework
    in MongoDB.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行聚合操作，我们需要运行一个服务器。一个简单的单节点就足够了。请参考[第1章](ch01.html "第1章。安装和启动服务器")中的*安装单节点MongoDB*配方，了解如何启动服务器的说明。我们将要操作的数据需要导入到数据库中。导入数据的步骤在[第2章](ch02.html
    "第2章。命令行操作和索引")的*创建测试数据*配方中有提到。此外，请参考[第1章](ch01.html "第1章。安装和启动服务器")中的*使用Python客户端连接到单节点*配方，了解如何为您的主机操作系统安装PyMongo。由于这是在Python中实现聚合的一种方式，假设读者已经了解了MongoDB中的聚合框架。
- en: How to do it…
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤如下：
- en: 'Open the Python terminal by typing the following on the command prompt:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在命令提示符中输入以下内容来打开Python终端：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once the Python shell opens, import `pymongo` as follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Python shell打开，按照以下方式导入`pymongo`：
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create an instance of `MongoClient` as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`MongoClient`的实例如下：
- en: '[PRE40]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Get the test database''s object as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式获取测试数据库的对象：
- en: '[PRE41]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, we execute the aggregation operation on the `postalCodes` collection as
    follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们按照以下步骤在`postalCodes`集合上执行聚合操作：
- en: '[PRE42]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Type the following to view the results:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下内容以查看结果：
- en: '[PRE43]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works…
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理如下：
- en: The steps are pretty straightforward. We have connected to the database running
    on localhost and created a database object. The aggregation operation that we
    invoked on the collection using the aggregate function is very similar to how
    we would invoke aggregation in the shell. The object in the return value, `result`,
    is a cursor, which returns an object of type `dict` on iteration. This `dict`
    contains two keys, each with the name of the state and count of the number of
    their occurrence. In step 6, we are simply iterating over the cursor (result)
    to fetch each result.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤非常简单。我们已经连接到运行在本地主机上的数据库，并创建了一个数据库对象。我们在集合上调用的聚合操作使用了`aggregate`函数，这与我们在shell中调用聚合的方式非常相似。返回值中的对象`result`是一个游标，它在迭代时返回一个`dict`类型的对象。这个`dict`包含两个键，分别是州名和它们出现次数的计数。在第6步中，我们只是简单地迭代游标（result）以获取每个结果。
- en: Executing MapReduce in Mongo using PyMongo
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PyMongo中执行MapReduce
- en: In our previous recipe, *Implementing aggregation in Mongo using PyMongo*, we
    saw how to execute aggregation operations in Mongo using PyMongo. In this recipe,
    we will work on the same use case as we did for the aggregation operation but
    we will use MapReduce. The intent is to aggregate the data based on the state
    names and get the top five state names by the number of documents that they appear
    in.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的配方*使用PyMongo在Mongo中实现聚合*中，我们看到了如何使用PyMongo在Mongo中执行聚合操作。在这个配方中，我们将处理与聚合操作相同的用例，但是我们将使用MapReduce。我们的目的是根据州名对数据进行聚合，并获取出现次数最多的五个州名。
- en: Programming language drivers provide us with an interface to invoke the map
    reduce jobs written in JavaScript on the server.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言驱动程序为我们提供了一个接口，用于在服务器上调用用JavaScript编写的map reduce作业。
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To execute the map reduce operations, we need to have a server up and running.
    A simple single node is what we need. Refer to the *Installing single node MongoDB*
    recipe from [Chapter 1](ch01.html "Chapter 1. Installing and Starting the Server"),
    *Installing and Starting the Server* for instructions on how to start the server.
    The data that we will operate on needs to be imported in the database. The steps
    to import the data are mentioned in the *Creating test data* recipe in [Chapter
    2](ch02.html "Chapter 2. Command-line Operations and Indexes"), *Command-line
    Operations and Indexes*. Additionally, refer to the *Connecting to a single node
    using Python client* recipe in [Chapter 1](ch01.html "Chapter 1. Installing and
    Starting the Server"), *Installing and Starting the Server* on how to install
    PyMongo for your host operating system.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行map reduce操作，我们需要启动并运行一个服务器。一个简单的单节点就是我们需要的。请参考[第1章](ch01.html "第1章。安装和启动服务器")中的*安装单节点MongoDB*配方，了解如何启动服务器的说明。我们将要操作的数据需要导入到数据库中。导入数据的步骤在[第2章](ch02.html
    "第2章。命令行操作和索引")的*创建测试数据*配方中有提到。另外，请参考[第1章](ch01.html "第1章。安装和启动服务器")中的*使用Python客户端连接到单节点*配方，了解如何为您的主机操作系统安装PyMongo。
- en: How to do it…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤如下：
- en: 'Open the Python terminal by typing the following on the command prompt:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在命令提示符上输入以下内容打开Python终端：
- en: '[PRE44]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once the Python shell opens, import the `bson` package as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Python shell打开，导入`bson`包，如下所示：
- en: '[PRE45]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Import the `pymongo` package as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`pymongo`包，如下所示：
- en: '[PRE46]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create an of `MongoClient` as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`MongoClient`对象，如下所示：
- en: '[PRE47]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Get the test database''s object as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取测试数据库的对象，如下所示：
- en: '[PRE48]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Write the following `mapper` function:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下`mapper`函数：
- en: '[PRE49]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Write the following `reducer` function:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下`reducer`函数：
- en: '[PRE50]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Invoke map reduce; the result will be sent to the `pymr_out` collection:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用map reduce；结果将被发送到`pymr_out`集合：
- en: '[PRE51]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Verify the result as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证结果如下：
- en: '[PRE52]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works…
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: Apart from the regular import for `pymongo`, here we import the `bson` package
    as well. This is where we have the `Code` class; it is the `Python` object that
    we use for the JavaScript `map` and `reduce` functions. It is instantiated by
    passing the JavaScript function body as a constructor argument.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规的`pymongo`导入外，这里我们还导入了`bson`包。这就是我们有`Code`类的地方；它是我们用于JavaScript `map`和`reduce`函数的`Python`对象。通过将JavaScript函数体作为构造函数参数来实例化它。
- en: 'Once two instances of the `Code` class are instantiated, one for `map` and
    the other for `reduce`, all we do is invoke the `map_reduce` function on the collection.
    In this case, we passed three parameters: two `Code` instances for the `map` and
    `reduce` functions with parameter names `map` and `reduce`, respectively and one
    string value used to provide the name of the output collection that the results
    are written to.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实例化了两个`Code`类的实例，一个用于`map`，另一个用于`reduce`，我们所做的就是在集合上调用`map_reduce`函数。在这种情况下，我们传递了三个参数：两个`map`和`reduce`函数的`Code`实例，参数名称分别为`map`和`reduce`，以及一个字符串值，用于提供结果写入的输出集合的名称。
- en: 'We won''t be explaining the map reduce JavaScript functions here but it is
    pretty simple, and all it does is emit keys as the names of the states and values
    that are the number of times the particular state name occurs. This result document
    with the key used, the state''s name as the `_id` field, and another field called
    value that is the sum of the times the particular state''s name given in the `_id`
    field appears in the collection is added to the output collection, `pymr_out`.
    For example, in the entire collection, the state `Maharashtra` appeared `6446`
    times, thus the document for the state of Maharashtra is `{u''_id'': u''Maharashtra'',
    u''value'': 6446.0}`. To verify that the result is correct, you can execute the
    following query in the mongo shell and see that the result is indeed `6446`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '我们不会在这里解释map reduce JavaScript函数，但它非常简单，它所做的就是将键作为州名，并将值作为特定州名出现的次数。使用的结果文档，将州名作为`_id`字段，另一个名为value的字段，它是给定在`_id`字段中出现的特定州名的次数的总和，添加到输出集合`pymr_out`中。例如，在整个集合中，州`马哈拉施特拉邦`出现了`6446`次，因此马哈拉施特拉邦的文档是`{u''_id'':
    u''马哈拉施特拉邦'', u''value'': 6446.0}`。要验证结果是否正确，您可以在mongo shell中执行以下查询，并查看结果是否确实为`6446`：'
- en: '[PRE53]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We are still not done as the requirement is to find the top five states by their
    occurrence in the collection; we still have just the states and their occurrences,
    so the final step is to sort the documents by the value field, which is the number
    of times the state's name occurred in descending order and limit the result to
    five documents.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成，因为要求是找到集合中出现次数最多的五个州；我们只有州和它们的出现次数，所以最后一步是按值字段对文档进行排序，即州名出现的次数，按降序排序，并将结果限制为五个文档。
- en: See also
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Refer to [Chapter 8](ch08.html "Chapter 8. Integration with Hadoop"), *Integration
    with Hadoop* for different recipes on executing map reduce jobs in MongoDB using
    the Hadoop connector. This allows us to write the `map` and `reduce` functions
    in languages such as Java, Python, and so on.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考[第8章](ch08.html "第8章。与Hadoop集成")中的*与Hadoop集成*，了解在MongoDB中使用Hadoop连接器执行map
    reduce作业的不同示例。这允许我们在诸如Java、Python等语言中编写`map`和`reduce`函数。
- en: Executing query and insert operations using a Java client
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Java客户端执行查询和插入操作
- en: In this recipe, we will look at executing the query and `insert` operations
    using the Java client for MongoDB. Unlike the Python programming language, Java
    code snippets cannot be executed from an interactive interpreter, and thus we
    will be having some unit test cases already implemented, whose relevant code snippets
    will be shown and explained.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用Java客户端执行MongoDB的查询和`insert`操作。与Python编程语言不同，Java代码片段无法从交互式解释器中执行，因此我们将已经实现了一些单元测试用例，其相关代码片段将被展示和解释。
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will start a standalone instance. Refer to the *Installing
    single node MongoDB* recipe from [Chapter 1](ch01.html "Chapter 1. Installing
    and Starting the Server"), *Installing and Starting the Server* for instructions
    on how to start the server.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将启动一个独立的实例。请参考[第1章](ch01.html "第1章。安装和启动服务器")中的*安装单节点MongoDB*示例，了解如何启动服务器的说明。
- en: The next step is to download the Java project, `mongo-cookbook-javadriver`,
    from the Packt website. This recipe uses a JUnit test case to test out various
    features of the Java client. In this whole process, we will use some of the most
    common API calls and thus learn to use them.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是从Packt网站下载Java项目`mongo-cookbook-javadriver`。这个示例使用一个JUnit测试用例来测试Java客户端的各种功能。在整个过程中，我们将使用一些最常见的API调用，因此学会如何使用它们。
- en: How to do it…
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: To execute the test case, one can either import the project in an IDE-like Eclipse
    and execute the test case or execute the test case from the command prompt using
    Maven.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 执行测试用例，可以在类似Eclipse的IDE中导入项目并执行测试用例，也可以使用Maven从命令提示符中执行测试用例。
- en: The test case that we will execute for this recipe is `com.packtpub.mongo.cookbook.MongoDriverQueryAndInsertTest`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将执行此示例的测试用例是`com.packtpub.mongo.cookbook.MongoDriverQueryAndInsertTest`。
- en: If you are using an IDE, open this test class and execute it as a JUnit test
    case.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您正在使用IDE，请打开此测试类并将其执行为JUnit测试用例。
- en: 'If you are planning to use Maven to execute this test case, go to the command
    prompt, change the directory at the root of the project, and execute the following
    to execute this single test case:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您计划使用Maven来执行此测试用例，请转到命令提示符，更改项目根目录下的目录，并执行以下命令来执行此单个测试用例：
- en: '[PRE54]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Everything should get executed fine and the test case should succeed if the
    Java SDK and Maven are properly set up and the MongoDB server is up and running
    and listening to port `27017` for the incoming connections.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Java SDK和Maven已经正确设置，并且MongoDB服务器已经启动并监听端口`27017`以接收连接，那么一切都应该正常执行，测试用例应该成功。
- en: How it works…
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: We will now open the test class that we executed and see some of the important
    API calls in the `test` method. The super class of our `test` class is `com.packtpub.mongo.cookbook.AbstractMongoTest`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将打开我们执行的测试类，并查看`test`方法中的一些重要的API调用。我们的`test`类的超类是`com.packtpub.mongo.cookbook.AbstractMongoTest`。
- en: 'We start by looking at the `getClient` method in this class. The `client` instance
    that has been created is an instance of the `com.mongodb.MongoClient type`. There
    are several overloaded constructors for this class; however, we use the following
    to instantiate the client:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看一下这个类中的`getClient`方法。已创建的`client`实例是`com.mongodb.MongoClient`类型的实例。对于这个类有几个重载的构造函数；然而，我们使用以下方法来实例化客户端：
- en: '[PRE55]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Another method to look at is `getJavaDriverTestDatabase` in the same abstract
    class that gets us the database instance. This instance is synonymous to the implicit
    variable `db` in the shell. Here in Java, this class is an instance of the `com.mongodb.DB`
    type. We get an instance of this `DB` class by invoking the `getDB()` method on
    the client instance. In our case, we want the `DB` instance for the `javaDriverTest`
    database, which we get as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要看的方法是在同一个抽象类中的`getJavaDriverTestDatabase`，它可以获取数据库实例。这个实例类似于shell中的隐式变量`db`。在Java中，这个类是`com.mongodb.DB`类型的实例。我们通过在客户端实例上调用`getDB()`方法来获取这个`DB`类的实例。在我们的情况下，我们想要`javaDriverTest`数据库的`DB`实例，我们可以通过以下方式获取：
- en: '[PRE56]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Once we get the instance of `com.mongodb.DB`, we use it to get the instance
    of `com.mongodb.DBCollection`, which would be used to perform various operations—`find`
    and `insert`—on the collection. The `getJavaTestCollection` method in the abstract
    test class returns one instance of `DBCollection`. We get an instance of this
    class for the `javaTest` collection by invoking the `getCollection()` method on
    `com.mongodb.DB` as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了`com.mongodb.DB`的实例，我们就可以使用它来获得`com.mongodb.DBCollection`的实例，这将用于执行各种操作——在集合上进行`find`和`insert`操作。抽象测试类中的`getJavaTestCollection`方法返回`DBCollection`的一个实例。我们通过在`com.mongodb.DB`上调用`getCollection()`方法来获取`javaTest`集合的这个类的一个实例，如下所示：
- en: '[PRE57]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Once we get an instance of `DBCollection`, we are now ready to perform the operations
    on it. In the scope of this recipe, it is limited to the `find` and `insert` operations.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了`DBCollection`的实例，我们现在可以对其执行操作。在这个示例的范围内，它仅限于`find`和`insert`操作。
- en: 'Now, we open the main test case class, `com.packtpub.mongo.cookbook.MongoDriverQueryAndInsertTest`.
    Open this class in an IDE or a text editor. We will look at the methods in this
    class. The first method that we will look at is `findOneDocument`. Here, the line
    of our interest is the one that queries for the document with the value of `_id`
    as `3`: `collection.findOne(new BasicDBObject("_id", 3))`.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们打开主测试用例类`com.packtpub.mongo.cookbook.MongoDriverQueryAndInsertTest`。在IDE或文本编辑器中打开这个类。我们将查看这个类中的方法。我们将首先查看的方法是`findOneDocument`。在这里，我们感兴趣的行是查询`_id`值为`3`的文档的行：`collection.findOne(new
    BasicDBObject("_id", 3))`。
- en: This method returns an instance of `com.mongodb.DBObject`, which is a key value
    map returning the fields of a document as a key and the value of this corresponding
    key. For instance, to get the value of `_id` from the returned `DBObject` instance,
    we invoke `result.get("_id")` on the returned result.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回一个`com.mongodb.DBObject`的实例，它是一个键值映射，返回文档的字段作为键和相应键的值。例如，要从返回的`DBObject`实例中获取`_id`的值，我们在返回的结果上调用`result.get("_id")`。
- en: 'Our next method to inspect is `getDocumentsFromTestCollection`. This test case
    executes a `find` operation on the collection and gets all the documents in it.
    The `collection.find()` call executes the `find` operation on the instance of
    `DBCollection`. The return value of the `find` operation is `com.mongodb.DBCursor`.
    An important point to note is that invoking the `find` operation itself doesn''t
    execute the query but just returns the instance of `DBCursor`. This is an inexpensive
    operation that doesn''t consume server-side resources. The actual query gets executed
    on the server side only when the `hasNext` or `next` method is invoked on the
    `DBCursor` instance. The `hasNext()` method is used to check if there are more
    results and the `next()` method is used to navigate to the next `DBObject` instance
    in the result. An example usage of the `DBCursor` instance returned to iterate
    through the results is as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要检查的下一个方法是`getDocumentsFromTestCollection`。这个测试用例在集合上执行了一个`find`操作，并获取其中的所有文档。`collection.find()`调用在`DBCollection`的实例上执行`find`操作。`find`操作的返回值是`com.mongodb.DBCursor`。值得注意的一点是，调用`find`操作本身并不执行查询，而只是返回`DBCursor`的实例。这是一个不消耗服务器端资源的廉价操作。实际查询只有在`DBCursor`实例上调用`hasNext`或`next`方法时才在服务器端执行。`hasNext()`方法用于检查是否有更多的结果，`next()`方法用于导航到结果中的下一个`DBObject`实例。对`DBCursor`实例返回的示例用法是遍历结果：
- en: '[PRE58]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We now look at two methods, `withLimitAndSkip` and `withQueryProjectionAndSort`.
    These methods show us how to sort, limit the number of results, and skip a number
    of initial results. As we can see, the sort, limit, and skip methods are chained
    to each other:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来看一下`withLimitAndSkip`和`withQueryProjectionAndSort`两个方法。这些方法向我们展示了如何对结果进行排序、限制数量和跳过初始结果的数量。正如我们所看到的，排序、限制和跳过方法是链接在一起的：
- en: '[PRE59]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: All these methods return an instance of `DBCursor` itself, which allows us to
    chain the calls. These methods are defined in the `DBCursor` class, which changes
    certain states according to the operation that they perform in the instance and
    has return this at the end of the method to return the same instance.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都返回`DBCursor`的实例本身，允许我们链接调用。这些方法在`DBCursor`类中定义，根据它们在实例中执行的操作更改某些状态，并在方法的末尾返回相同的实例。
- en: Remember that the actual operation is invoked on the server only on invoking
    the `hasNext` or `next` method on `DBCursor`. Invoking any method such as `sort`,
    `limit`, and `skip` after the execution of the query on the server will throw
    `java.lang.IllegalStateException`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，实际操作只有在`DBCursor`上调用`hasNext`或`next`方法时才在服务器上执行。在服务器上执行查询后调用任何方法，如`sort`、`limit`和`skip`，都会抛出`java.lang.IllegalStateException`。
- en: We used two variants of the `find` method. One accepts one parameter for the
    query to be executed and one accepts two parameters—the first one for the query
    and the second is another `DBObject`, which is used for projection that will return
    only a selected set of fields from the document in the result.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`find`方法的两种变体。一个接受一个参数用于执行查询，另一个接受两个参数——第一个用于查询，第二个是另一个`DBObject`，用于投影，将仅返回结果中文档的一组选定字段。
- en: 'For instance, the following query from the `withQueryProjectionAndSort` method
    of the test case selects all the documents as the first argument as `null` and
    the returned `DBCursor` will have documents containing just one field called `value`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，测试用例的`withQueryProjectionAndSort`方法中的以下查询选择所有文档作为第一个参数为`null`，返回的`DBCursor`将包含只包含一个名为`value`的字段的文档：
- en: '[PRE60]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `_id` field is to be explicitly set to `0`, or else it will be returned
    by default.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`_id`字段必须显式设置为`0`，否则默认情况下将返回它。'
- en: 'Finally, we look at two more methods in the test case, `insertDataTest` and
    `insertTestDataWithWriteConcern`. We use a couple of variants of the `insert`
    method in these two methods. All `insert` methods are invoked on the `DBCollection`
    instance and return an instance, `com.mongodb.WriteResult`. The result can be
    used to get the error that occurred during the write operation by invoking the
    `getLastError()` method, the number of documents inserted using the `getN()` method,
    and the write concern for the operation among the few operations. Refer to the
    Javadoc of the MongoDB API for more detail on the methods. The two insert operations
    that we did are as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来看一下测试用例中的另外两个方法，`insertDataTest`和`insertTestDataWithWriteConcern`。在这两种方法中，我们使用了`insert`方法的几种变体。所有`insert`方法都在`DBCollection`实例上调用，并返回一个`com.mongodb.WriteResult`的实例。结果可以用于通过调用`getLastError()`方法获取写操作期间发生的错误，使用`getN()`方法获取插入的文档数量，以及操作的写关注。有关方法的更多详细信息，请参阅MongoDB
    API的Javadoc。我们执行的两个插入操作如下：
- en: '[PRE61]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Both of these accept a `DBObject` instance for the document to be inserted as
    the first parameter. The second method allows us to provide the write concern
    to be used for the `write` operation. There are `insert` methods in the `DBCollection`
    class that allow bulk insert as well. Refer to the Javadocs for more details on
    various overloaded versions of the `insert` method.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法都接受一个`DBObject`实例作为要插入的文档的第一个参数。第二个方法允许我们提供用于`write`操作的写关注。`DBCollection`类中还有允许批量插入的`insert`方法。有关`insert`方法的各种重载版本的更多细节，请参考Javadocs。
- en: See also…
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅…
- en: The Javadocs for the current version of the MongoDB driver can be found at [https://api.mongodb.org/java/current/](https://api.mongodb.org/java/current/).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB驱动当前版本的Javadocs可以在[https://api.mongodb.org/java/current/](https://api.mongodb.org/java/current/)找到。
- en: Executing update and delete operations using a Java client
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Java客户端执行更新和删除操作
- en: In the previous recipe, we saw how to execute `find` and `insert` operations
    in MongoDB using the Java client; in this recipe, we will see how updates and
    deletes work in the Java client.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个配方中，我们看到了如何使用Java客户端在MongoDB中执行`find`和`insert`操作；在这个配方中，我们将看到Java客户端中更新和删除的工作原理。
- en: Getting ready
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will start a standalone instance. Refer to the *Installing
    single node MongoDB* recipe from [Chapter 1](ch01.html "Chapter 1. Installing
    and Starting the Server"), *Installing and Starting the Server* for instructions
    on how to start the server.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将启动一个独立的实例。请参考[第1章](ch01.html "第1章。安装和启动服务器")中的*安装单节点MongoDB*配方，了解如何启动服务器的说明。
- en: The next step is to download the Java project, `mongo-cookbook-javadriver`,
    from the Packt website. This recipe uses a JUnit test case to test out various
    features of the Java client. In this whole process, we will use some of the most
    common API calls and thus learn to use them.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是从Packt网站下载Java项目`mongo-cookbook-javadriver`。这个配方使用一个JUnit测试用例来测试Java客户端的各种功能。在整个过程中，我们将使用一些最常见的API调用，并学会使用它们。
- en: How to do it…
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: To execute the test case, one can either import the project in an IDE-like Eclipse
    and execute the test case or execute the test case from the command prompt using
    Maven.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行测试用例，可以在类似Eclipse的IDE中导入项目并执行测试用例，或者使用Maven从命令提示符中执行测试用例。
- en: The test case that we are going to execute for this recipe is `com.packtpub.mongo.cookbook.MongoDriverUpdateAndDeleteTest`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这个配方执行的测试用例是`com.packtpub.mongo.cookbook.MongoDriverUpdateAndDeleteTest`。
- en: If you are using an IDE, open this test class and execute it as a JUnit test
    case.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用的是IDE，请打开这个测试类并将其作为JUnit测试用例执行。
- en: 'If you are planning to use Maven to execute this test case, go to the command
    prompt, change the directory at the root of the project, and execute the following
    to execute this single test case:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您计划使用Maven执行此测试用例，请转到命令提示符，更改到项目的根目录，并执行以下命令来执行这个单个测试用例：
- en: '[PRE62]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Everything should get executed fine if the Java SDK and Maven are properly set
    up and the MongoDB server is up and running and listening to port `27017` for
    the incoming connections.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Java SDK和Maven已经正确设置，并且MongoDB服务器正在运行并监听端口`27017`以接收连接，则一切都应该正常执行。
- en: How it works…
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: We created a test data for the recipes using a `setupUpdateTestData()` method.
    Here, we simply put documents in the `javaTest` collection in the `javaDriverTest`
    database. We add 20 documents to this collection with the value of `i` ranging
    from 1 to 20\. This test data is used in different test case methods to create
    test data.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`setupUpdateTestData()`方法为配方创建了测试数据。在这里，我们只是将文档放在`javaDriverTest`数据库的`javaTest`集合中。我们向这个集合添加了20个文档，`i`的值范围从1到20。这些测试数据在不同的测试用例方法中用于创建测试数据。
- en: 'Let''s now take a look at the methods in this class. We will first look at
    `basicUpdateTest()`. In this method, we first create the test data and then execute
    the following update:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看这个类中的方法。我们首先看一下`basicUpdateTest()`。在这个方法中，我们首先创建测试数据，然后执行以下更新：
- en: '[PRE63]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `update` method here takes two arguments. The first is the query that would
    be used to select the eligible documents for the update, and the second parameter
    is the actual update. The first parameter looks confusing due to nested `BasicDBObject`
    instances; however, it is the `{''i'' : {''$gt'' : 10}}` condition and the second
    parameter is the update, `{''$set'' : {''gtTen'' : true}}`. The result of the
    update is an instance of `com.mongodb.WriteResult`. The instance of `WriteResult`
    tells us the number of documents that got updated and gets the error that occurred
    while executing the `write` operation and write concern used for the update. Refer
    to the Javadocs of the `WriteConcern` class for more details. This update only
    updates the first matching document by default only if multiple documents match
    the query.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '这里的`update`方法接受两个参数。第一个是用于选择更新的符合条件的文档的查询，第二个参数是实际的更新。第一个参数由于嵌套的`BasicDBObject`实例看起来很混乱；然而，它是`{''i''
    : {''$gt'' : 10}}`条件，第二个参数是更新，`{''$set'' : {''gtTen'' : true}}`。更新的结果是`com.mongodb.WriteResult`的一个实例。`WriteResult`的实例告诉我们更新的文档数量，执行`write`操作时发生的错误以及用于更新的写关注。更多细节请参考`WriteConcern`类的Javadocs。默认情况下，此更新仅更新第一个匹配的文档，如果有多个文档匹配查询，则只更新第一个匹配的文档。'
- en: 'The next method that we will look at is `multiUpdateTest`, which will update
    all the matching documents for the given query instead of the first matching document.
    The method that we used is `updateMulti` on the collection instance. The `updateMulti`
    method is a convenient way to update multiple documents. The following is the
    call that we make to update multiple documents:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的下一个方法是`multiUpdateTest`，它将更新给定查询的所有匹配文档，而不是第一个匹配的文档。我们使用的方法是在集合实例上使用`updateMulti`。`updateMulti`方法是更新多个文档的便捷方式。以下是我们调用的更新多个文档的方法：
- en: '[PRE64]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The next operation that we did was to remove documents. The test case method
    to remove documents is `deleteTest()`. The documents are removed as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来做的操作是删除文档。删除文档的测试用例方法是`deleteTest()`。文档被删除如下：
- en: '[PRE65]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We have two parameters here. The first is the query for which the matching documents
    will be removed from the collection. Note that all matching documents will be
    removed by default unlike update, where only the first matching document will
    be removed by default. The second parameter is the write concern to be used for
    the `remove` operation.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个参数。第一个是查询，匹配的文档将从集合中删除。请注意，默认情况下，所有匹配的文档都将被删除，不像更新，更新默认情况下只会删除第一个匹配的文档。第二个参数是用于`remove`操作的写关注。
- en: 'Note that when the server is started on a 32-bit machine, journaling is disabled
    by default. When you use Write Concern on such machines, it may cause the operation
    to fail with the following exception:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当服务器在32位机器上启动时，默认情况下禁用了日志记录。在这些机器上使用写关注可能会导致操作失败，并出现以下异常：
- en: '[PRE66]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This would require the server to be started with the `--journal` option. On
    64-bit machines, this is not necessary as journaling is enabled by default.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这将需要服务器使用`--journal`选项启动。在64位机器上，默认情况下启用了日志记录，因此这是不必要的。
- en: 'We will look at the `findAndModify` operation next. The test case method to
    perform this operation is `findAndModifyTest`. The following lines of code are
    used to perform this operation:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将看看`findAndModify`操作。执行此操作的测试用例方法是`findAndModifyTest`。以下代码行用于执行此操作：
- en: '[PRE67]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The operation is the query that will find the matching documents and then update
    them. The return type of the operation is an instance of `DBObject` before the
    update is applied. One important feature of the `findAndModify` operation is that
    the `find` and `update` operations are performed atomically.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作是查询将找到匹配的文档，然后更新它们。该操作的返回类型是在应用更新之前的`DBObject`实例。`findAndModify`操作的一个重要特性是`find`和`update`操作是原子执行的。
- en: 'The preceding method is a simple version of the `findAndModify` operation.
    There is an overloaded version of this method with the following signature:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法是`findAndModify`操作的简单版本。有一个重载版本的方法，签名如下：
- en: '[PRE68]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Let''s see what these parameters are in the following table:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下表中这些参数是什么：
- en: '| Parameter | Description |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `query` | This is the query that is used to query the document, which is
    the one that gets updated/deleted. |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `query` | 这是用于查询文档的查询。这是将被更新/删除的文档。 |'
- en: '| `fields` | The `find` method supports the projection of fields that need
    to be selected in the result document(s) selected. The parameter here does the
    same job of selecting the fixed set of fields from the resulting document. |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `fields` | `find`方法支持选择结果文档中需要选择的字段的投影。此处的参数执行相同的操作，从结果文档中选择固定的字段集。 |'
- en: '| `sort` | If you haven''t noticed already, let me tell you that the method
    can perform this atomic operation on only one document and also return one document.
    This `sort` function can be used in cases where the query selects multiple documents
    and only the first gets chosen for the operation. The `sort` function is applied
    on the result before picking up the first document to update. |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `sort` | 如果你还没有注意到，让我告诉你，该方法只能对一个文档执行这个原子操作，并且只返回一个文档。`sort`函数可以用于查询选择多个文档并且只选择第一个文档进行操作的情况。在选择要更新的第一个文档之前，`sort`函数被应用于结果。
    |'
- en: '| `remove` | This is a Boolean flag that indicates whether to remove or update
    the document. If this value is `true`, the document will be removed. |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `remove` | 这是一个布尔标志，指示是删除还是更新文档。如果该值为`true`，则将删除文档。 |'
- en: '| `update` | Unlike the preceding attribute, this is not a Boolean value but
    a `DBObject` instance that will tell what the update needs to be. Note that the
    remove Boolean flag gets precedence over this parameter; if the `remove` attribute
    is `true`, the update will not happen even if one is provided. |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `update` | 与前面的属性不同，这不是一个布尔值，而是一个`DBObject`实例，它将告诉更新需要什么。请注意，`remove`布尔标志优先于此参数；如果`remove`属性为`true`，即使提供了更新，更新也不会发生。
    |'
- en: '| `returnNew` | The find operation returns a document, but which one? The one
    before the update was executed or the one after the update gets executed? This
    Boolean flag, when given as `true`, returns the document after the update is executed.
    |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `returnNew` | 查找操作返回一个文档，但是哪一个？在执行更新之前的文档还是在执行更新之后的文档？当给定为`true`时，这个布尔标志在更新执行后返回文档。
    |'
- en: '| `upsert` | This is a Boolean flag again that executes `upsert` when `true`.
    It is relevant only when the intended operation is update. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `upsert` | 这又是一个布尔标志，当为`true`时执行`upsert`。这仅在预期操作为更新时才相关。 |'
- en: There are more overloaded methods of this operation. Refer to the Javadocs of
    `com.mongodb.DBCollection` for more methods. The `findAndModify` method that we
    used ultimately invokes the method we discussed with the fields and sort parameters
    as null with the remaining parameters, `remove`, `returnNew`, and `upsert` being
    `false`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作还有更多的重载方法。请参考`com.mongodb.DBCollection`的Javadocs以获取更多方法。我们使用的`findAndModify`方法最终调用了我们讨论的方法，其中字段和排序参数为空，其余参数`remove`，`returnNew`和`upsert`都为`false`。
- en: Finally, we look at the query builder support in MongoDB's Java API.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来看看MongoDB的Java API中的查询构建器支持。
- en: 'All the queries in mongo are `DBObject` instances with possibly more nested
    `DBObject` instances in them. Things are simple for small queries, but they start
    getting ugly for more complicated queries. Consider a relatively simple query
    where we want to query for documents with `i > 10` and `i < 15`. The mongo query
    for this is `{$and:[{i:{$gt:10}}`, `{i:{$lt:15}}]}`. Writing this in Java would
    mean using `BasicDBObject` instances, which is even painful and looks as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: mongo中的所有查询都是`DBObject`实例，其中可能包含更多嵌套的`DBObject`实例。对于小查询来说很简单，但对于更复杂的查询来说会变得很丑陋。考虑一个相对简单的查询，我们想查询`i
    > 10`和`i < 15`的文档。这个mongo查询是`{$and:[{i:{$gt:10}}`，`{i:{$lt:15}}]}`。在Java中编写这个查询意味着使用`BasicDBObject`实例，这甚至更加痛苦，如下所示：
- en: '[PRE69]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Thankfully, however, there is a class called `com.mongodb.QueryBuilder`, which
    is a utility class to build the complex queries. The preceding query is built
    using a query builder as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得庆幸的是，有一个名为`com.mongodb.QueryBuilder`的类，这是一个用于构建复杂查询的实用类。前面的查询是使用查询构建器构建的，如下所示：
- en: '[PRE70]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This is less error prone when writing a query and easy to read as well. There
    are a lot of methods in the `com.mongodb.QueryBuilder` class and I would encourage
    you to go through the Javadocs of this class. The basic idea is to start construction
    using the `start` method and the key. We then chain the method calls to add different
    conditions, and when the addition of various conditions is done, the query is
    constructed using the `get()` method, which returns `DBObject`. Refer to the `queryBuilderSample`
    method in the test class for a sample usage of query builder support of the MongoDB
    Java API.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写查询时，这样做错误的可能性较小，而且阅读起来也很容易。`com.mongodb.QueryBuilder`类中有很多方法，我鼓励您阅读该类的Javadocs。基本思想是使用`start`方法和键开始构建，然后链接方法调用以添加不同的条件，当添加各种条件完成时，使用`get()`方法构建查询，该方法返回`DBObject`。请参考测试类中的`queryBuilderSample`方法，了解MongoDB
    Java API的查询构建器支持的示例用法。
- en: See also
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: There are some more operations using the GridFS and geospatial indexes. We will
    see how to use them in the Java application with a small sample in the advanced
    query chapter. Refer to [Chapter 5](ch05.html "Chapter 5. Advanced Operations"),
    *Advanced Operations* for such recipes.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些使用GridFS和地理空间索引的操作。我们将在高级查询章节中看到如何在Java应用程序中使用它们的小样本。请参考[第5章](ch05.html
    "第5章。高级操作")中的*高级操作*了解这样的配方。
- en: The Javadocs for the current version of the MongoDB driver can be found at [https://api.mongodb.org/java/current/](https://api.mongodb.org/java/current/).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本的MongoDB驱动程序的Javadocs可以在[https://api.mongodb.org/java/current/](https://api.mongodb.org/java/current/)找到。
- en: Implementing aggregation in Mongo using a Java client
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Java客户端在Mongo中实现聚合
- en: The intention of this recipe is not to explain aggregation but to show you how
    aggregation can be implemented using the Java client from a Java program. In this
    recipe, we will aggregate the data based on the state names and get the top five
    state names by the number of documents that they appear in. We will use the `$project`,
    `$group`, `$sort`, and `$limit` operators for the process.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的目的不是解释聚合，而是向您展示如何使用Java客户端从Java程序实现聚合。在这个配方中，我们将根据州名对数据进行聚合，并获取出现在其中的文档数量最多的五个州名。我们将使用`$project`、`$group`、`$sort`和`$limit`操作符进行处理。
- en: Getting ready
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The test class used for this recipe is `com.packtpub.mongo.cookbook.MongoAggregationTest`.
    To execute the aggregation operations, we need to have a server up and running.
    A simple single node is what we need. Refer to the *Installing single node MongoDB*
    recipe from [Chapter 1](ch01.html "Chapter 1. Installing and Starting the Server"),
    *Installing and Starting the Server* for instructions on how to start the server.
    The data that we will operate on needs to be imported in the database. The steps
    to import the data are given in the *Creating test data* recipe in [Chapter 2](ch02.html
    "Chapter 2. Command-line Operations and Indexes"), *Command-line Operations and
    Indexes*. The next step is to download the Java project, `mongo-cookbook-javadriver`,
    from the Packt website. Though Maven can be used to execute the test case, it
    is convenient to import the project in an IDE and execute the test case class.
    It is assumed that you are familiar with the Java programming language and comfortable
    using the IDE that the project will be imported to.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此配方的测试类是`com.packtpub.mongo.cookbook.MongoAggregationTest`。要执行聚合操作，我们需要一个正在运行的服务器。一个简单的单节点就是我们需要的。请参考[第1章](ch01.html
    "第1章。安装和启动服务器")中的*安装单节点MongoDB*配方，了解如何启动服务器的说明。我们将操作的数据需要导入到数据库中。有关如何导入数据的步骤，请参阅[第2章](ch02.html
    "第2章。命令行操作和索引")中的*创建测试数据*配方，*命令行操作和索引*。下一步是从Packt网站下载Java项目`mongo-cookbook-javadriver`。虽然可以使用Maven执行测试用例，但将项目导入IDE并执行测试用例类更加方便。假设您熟悉Java编程语言，并且习惯使用要导入的项目的IDE。
- en: How to do it…
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: To execute the test case, one can either import the project in an IDE-like Eclipse
    and execute the test case or execute the test case from the command prompt using
    Maven.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行测试用例，可以将项目导入类似Eclipse的IDE中并执行测试用例，或者使用Maven从命令提示符中执行测试用例。
- en: If you are using an IDE, open the test class and execute it as a JUnit test
    case.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用的是IDE，请打开测试类并将其执行为JUnit测试用例。
- en: 'If you are planning to use Maven to execute this test case, go to the command
    prompt, change the directory at the root of the project, and execute the following
    to execute this single test case:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您计划使用Maven执行此测试用例，请转到命令提示符，更改项目根目录下的目录，并执行以下命令以执行此单个测试用例：
- en: '[PRE71]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Everything should get executed fine if the Java SDK and Maven are properly set
    up and the MongoDB server is up and running and listening to port `27017` for
    the incoming connections.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Java SDK和Maven设置正确，并且MongoDB服务器正在运行并监听端口`27017`以进行传入连接，那么一切都应该正常执行。
- en: How it works…
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The method used for the aggregation functionality is `aggregationTest()` in
    our test class. The aggregation operation is performed on MongoDB from a Java
    client using the `aggregate()` method defined in the `DBCollection` class. The
    method has the following signature:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试类中用于聚合功能的方法是`aggregationTest()`。聚合操作是在Java客户端上使用`DBCollection`类中定义的`aggregate()`方法对MongoDB执行的。该方法具有以下签名：
- en: '[PRE72]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Only the first argument is mandatory, which forms the first operation in the
    pipeline. The second argument is a `varagrs` argument (variable number of arguments
    with zero or more values), which allows more pipeline operators. All these arguments
    are of the `com.mongodb.DBObject` type. In case any exception occurs in the execution
    of the aggregation command, the aggregation operation will throw `com.mongodb.MongoException`
    with the cause of the exception.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 只有第一个参数是必需的，它形成管道中的第一个操作。第二个参数是`varagrs`参数（零个或多个值的可变数量的参数），允许更多的管道操作符。所有这些参数都是`com.mongodb.DBObject`类型。如果在执行聚合命令时发生任何异常，聚合操作将抛出`com.mongodb.MongoException`，并带有异常的原因。
- en: The return type, `com.mongodb.AggregationOutput`, is used to get the result
    of the aggregation operation. From a developer's perspective, we are more interested
    in the `results` field of this instance, which can be accessed using the `results()`
    method of the returned object. The `results()` method returns an object of type,
    `Iterable<DBObject>`, which one can iterate to get the results of the aggregation.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型`com.mongodb.AggregationOutput`用于获取聚合操作的结果。从开发人员的角度来看，我们更感兴趣的是这个实例的`results`字段，可以使用返回对象的`results()`方法来访问。`results()`方法返回一个`Iterable<DBObject>`类型的对象，可以迭代以获取聚合的结果。
- en: 'Let''s look at how we implemented the aggregation pipeline in our test class:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在测试类中实现了聚合管道：
- en: '[PRE73]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'There are four steps in the pipeline in the following order: a `$project` operation,
    followed by `$group`, `$sort`, and then `$limit`.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下顺序中，管道中有四个步骤：`$project`操作，然后是`$group`，`$sort`，然后是`$limit`。
- en: The last two operations look inefficient where we sort all and then just take
    the top five elements. In such scenarios, the MongoDB server is intelligent enough
    to consider the limit operation while sorting, where only the top five results
    need to be maintained rather than sorting all the results.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个操作看起来效率低下，我们首先对所有元素进行排序，然后只取前五个元素。在这种情况下，MongoDB服务器足够智能，可以在排序时考虑限制操作，只需维护前五个结果而不是对所有结果进行排序。
- en: For version 2.6 of MongoDB, the aggregation result can return a cursor. Though
    the preceding code is still valid, the `AggregationResult` object is no longer
    the only way to get the results of the operation. We can use `com.mongodb.Cursor`
    that can be used to iterate the results. Additionally, the preceding format is
    now deprecated in favor of the format that accepts a list of pipeline operators
    rather than `varargs` for the operators. Refer to the Javadocs of the `com.mongodb.DBCollection`
    class and look at the various overloaded `aggregate()` methods.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MongoDB 2.6版本，聚合结果可以返回一个游标。尽管前面的代码仍然有效，但`AggregationResult`对象不再是获取操作结果的唯一方式。我们可以使用`com.mongodb.Cursor`来迭代结果。此外，前面的格式现在已被弃用，而是采用了接受管道操作符列表而不是操作符`varargs`的格式。请参考`com.mongodb.DBCollection`类的Javadocs，并查看各种重载的`aggregate()`方法。
- en: Executing MapReduce in Mongo using a Java client
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java客户端中执行Mongo中的MapReduce
- en: In our previous recipe, *Implementing aggregation in Mongo using a Java client*,
    we saw how to execute aggregation operations in Mongo using the Java client. In
    this recipe, we will work on the same use case as we did for the aggregation operation
    but We will use MapReduce. The intent is to aggregate the data based on the state
    names and get the top five state names by the number of documents that they appear
    in.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的食谱中，*使用Java客户端在Mongo中实现聚合*，我们看到了如何使用Java客户端在Mongo中执行聚合操作。在这个食谱中，我们将处理与聚合操作相同的用例，但我们将使用MapReduce。目的是根据州名对数据进行聚合，并获取出现在其中的文档数量最多的五个州名。
- en: If somebody is not aware of how to write MapReduce code for Mongo from a programming
    language client and is seeing it for the first time, you might be surprised to
    see how it is actually done. You might have imagined that you would be writing
    the `map` and `reduce` function in the programming language that you are writing
    the code in, Java in this case, and then using it to execute the map reduce. However,
    we need to bear in mind that the MapReduce jobs run on the mongo servers and they
    execute JavaScript functions. Hence, irrespective of the programming language
    driver, the map reduce functions are written in JavaScript. The programming language
    drivers just act as a means of letting us invoke and execute the map reduce functions
    (written in JavaScript) on the server.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人不知道如何从编程语言客户端为Mongo编写MapReduce代码，并且是第一次看到它，你可能会惊讶地看到它实际上是如何完成的。你可能想象过，你会在编写代码的编程语言中（在这种情况下是Java）编写`map`和`reduce`函数，然后使用它来执行map
    reduce。然而，我们需要记住，MapReduce作业在mongo服务器上运行，并执行JavaScript函数。因此，无论编程语言驱动程序如何，map reduce函数都是用JavaScript编写的。编程语言驱动程序只是让我们调用和执行服务器上用JavaScript编写的map
    reduce函数的手段。
- en: Getting ready
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The test class used for this recipe is `com.packtpub.mongo.cookbook.MongoMapReduceTest`.
    To execute the map reduce operations, we need to have a server up and running.
    A simple single node is what we need. Refer to the *Installing single node MongoDB*
    recipe from [Chapter 1](ch01.html "Chapter 1. Installing and Starting the Server"),
    *Installing and Starting the Server* for instructions on how to start the server.
    The data that we will operate on needs to be imported in the database. The steps
    to import the data are given in the *Creating test data* recipe in [Chapter 2](ch02.html
    "Chapter 2. Command-line Operations and Indexes"), *Command-line Operations and
    Indexes*. The next step is to download the Java project, `mongo-cookbook-javadriver`,
    from the Packt website. Though Maven can be used to execute the test case, it
    is convenient to import the project in an IDE and execute the test case class.
    It is assumed that you are familiar with the Java programming language and comfortable
    using the IDE that the project will be imported to.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此示例的测试类是`com.packtpub.mongo.cookbook.MongoMapReduceTest`。要执行map reduce操作，我们需要运行一个服务器。我们只需要一个简单的单节点。有关如何启动服务器的说明，请参阅[第1章](ch01.html
    "第1章。安装和启动服务器")中的*安装单节点MongoDB*配方，*安装和启动服务器*。我们将操作的数据需要导入数据库。有关导入数据的步骤，请参阅[第2章](ch02.html
    "第2章。命令行操作和索引")中的*创建测试数据*配方，*命令行操作和索引*。下一步是从Packt网站下载Java项目`mongo-cookbook-javadriver`。虽然可以使用Maven执行测试用例，但将项目导入IDE并执行测试用例类更加方便。假设您熟悉Java编程语言，并且习惯使用将要导入项目的IDE。
- en: How to do it…
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: To execute the test case, one can either import the project in an IDE-like Eclipse
    and execute the test case or execute the test case from the command prompt using
    Maven.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行测试用例，可以在类似Eclipse的IDE中导入项目并执行测试用例，也可以使用Maven从命令提示符中执行测试用例。
- en: If you are using an IDE, open the test class and execute it as a JUnit test
    case.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果使用IDE，打开测试类并将其作为JUnit测试用例执行。
- en: 'If you are planning to use Maven to execute this test case, go to the command
    prompt, change the directory at the root of the project, and execute the following
    to execute this single test case:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您计划使用Maven执行此测试用例，请转到命令提示符，将目录更改为项目的根目录，并执行以下命令以执行此单个测试用例：
- en: '[PRE74]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Everything should get executed fine if the Java SDK and Maven are properly set
    up and the MongoDB server is up and running and listening to port `27017` for
    the incoming connections.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Java SDK和Maven设置正确，并且MongoDB服务器正常运行并监听端口`27017`以接收连接，则一切都应该能够正常执行。
- en: How it works…
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The test case method for our map reduce test is `mapReduceTest()`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们map reduce测试的测试用例方法是`mapReduceTest()`。
- en: Map reduce operations can be done in Mongo from a Java client using the `mapReduce()`
    method defined in the `DBCollection` class. There are a lot of overloaded versions,
    and you can refer to the Javadocs of the `com.mongodb.DBCollection` class for
    more details on the various flavors of this method. The one that we used is `collection.mapReduce(mapper,
    reducer, output collection, query)`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`DBCollection`类中定义的`mapReduce()`方法在Java客户端中对Mongo进行map reduce操作。有很多重载版本，您可以参考`com.mongodb.DBCollection`类的Javadocs，了解此方法的各种用法。我们使用的是`collection.mapReduce(mapper,
    reducer, output collection, query)`。
- en: 'The method accepts the following four parameters:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受以下四个参数：
- en: The `mapper` function is of type String and a JavaScript code that would be
    executed on the mongo database server
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapper`函数的类型为String，是在mongo数据库服务器上执行的JavaScript代码'
- en: The `reducer` function is of type String and a JavaScript code that would be
    executed on the mongo database server
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reducer`函数的类型为String，是在mongo数据库服务器上执行的JavaScript代码'
- en: The name of the collection that the output of the map reduce execution will
    be written to
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: map reduce执行的输出将写入的集合的名称
- en: The query that will be executed by the server and the result of this query will
    be the input to the map reduce job execution
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器将执行的查询，此查询的结果将作为map reduce作业执行的输入
- en: 'As the assumption is that the reader is well-versed with the map reduce operations
    in the shell, we won''t explain the map reduce JavaScript functions that we used
    in the test case method. All it does is emit keys as the names of the states and
    values, which are the number of times the particular state name occurs. This result
    is added to the output collection, `javaMROutput`, in this case. For example,
    in the entire collection, the state `Maharashtra` appears `6446` times; thus,
    the document for the state of `Maharashtra` is `{''_id'': ''Maharashtra'', ''value'':
    6446}`. To confirm that this is the true value or not, you can execute the following
    query in the mongo shell and see that the result is indeed `6446`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '假设读者对shell中的map reduce操作很熟悉，我们不会解释在测试用例方法中使用的map reduce JavaScript函数。它所做的就是将键作为州的名称和值进行发射，这些值是特定州名出现的次数。此结果将添加到输出集合`javaMROutput`中。例如，在整个集合中，州`Maharashtra`出现了`6446`次；因此，`Maharashtra`州的文档是`{''_id'':
    ''Maharashtra'', ''value'': 6446}`。要确认这是否是真实值，可以在mongo shell中执行以下查询，并查看结果是否确实为`6446`：'
- en: '[PRE75]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We are still not done as the requirement is to find the top five states by their
    occurrence in the collection; we still have just the states and their occurrences,
    so the final step is to sort the documents by the `value` field, which is the
    number of times the state's name occurs in descending order, and limit the result
    to five documents.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成，因为要找到集合中出现次数最多的五个州；我们只有州和它们的出现次数，所以最后一步是按照`value`字段对文档进行排序，这个字段是州名出现的次数，按降序排列，并将结果限制为五个文档。
- en: See also
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Refer to [Chapter 8](ch08.html "Chapter 8. Integration with Hadoop"), *Integration
    with Hadoop* for different recipes on executing Map Reduce jobs in MongoDB using
    the Hadoop connector. This allows us to write the `Map` and `Reduce` functions
    in languages such as Java, Python, and so on.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 参考[第8章](ch08.html "第8章。与Hadoop集成")，“与Hadoop集成”中有关在MongoDB中使用Hadoop连接器执行Map Reduce作业的不同方法。这使我们能够使用Java、Python等语言编写`Map`和`Reduce`函数。
