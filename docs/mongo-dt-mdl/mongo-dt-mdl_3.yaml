- en: Chapter 3. Querying Documents
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。查询文档
- en: In a NoSQL database, such as MongoDB, planning queries is a very important task,
    and depending on the query you want to perform, your document can vary greatly.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在NoSQL数据库中，比如MongoDB，规划查询是一项非常重要的任务，根据您要执行的查询，您的文档可能会有很大的变化。
- en: As you saw in [Chapter 2](ch02.html "Chapter 2. Data Modeling with MongoDB"),
    *Data Modeling with MongoDB*, the decision to refer or include documents in a
    collection is, in a large part, the result of our planning. It is essential to
    determine whether we will give a preference to reading or writing in a collection.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html“第2章。使用MongoDB进行数据建模”)中，*使用MongoDB进行数据建模*，决定在集合中引用或包含文档，在很大程度上是我们规划的结果。确定我们是否偏向于在集合中进行读取或写入是至关重要的。
- en: Here, we will see how planning queries can help us create documents in a more
    efficient and effective way, and we will also consider more sensible questions
    such as atomicity and transactions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看到如何规划查询可以帮助我们更有效地创建文档，我们还将考虑更明智的问题，比如原子性和事务。
- en: 'This chapter will focus on the following subjects:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点关注以下主题：
- en: Read operations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取操作
- en: Write operations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写操作
- en: Write concerns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入关注点
- en: Bulk writing documents
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批量写入文档
- en: Understanding the read operations
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解读取操作
- en: Read is the most common and fundamental operation in a database. It's very hard
    to imagine a database that is used only to write information, where this information
    is never read. By the way, I have never heard of such an approach.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中，读取是最常见和基本的操作。很难想象一个仅用于写入信息的数据库，这些信息从不被读取。顺便说一句，我从未听说过这种方法。
- en: 'In MongoDB, we can execute queries through the `find` interface. The `find`
    interface can accept queries as criteria and projections as parameters. This will
    result in a cursor. Cursors have methods that can be used as modifiers of the
    executed query, such as `limit`, `map`, `skip`, and `sort`. For example, take
    a look at the following query:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中，我们可以通过`find`接口执行查询。`find`接口可以接受查询作为条件和投影作为参数。这将产生一个游标。游标有可以用作执行查询的修饰符的方法，比如`limit`、`map`、`skip`和`sort`。例如，看一下以下查询：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This would return the following document:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下文档：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can use the `find` interface to execute a query in MongoDB. The `find` interface
    will select the documents in a collection and return a cursor for the selected
    documents.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`find`接口在MongoDB中执行查询。`find`接口将选择集合中的文档，并返回所选文档的游标。
- en: Compared with the SQL language, the `find` interface should be seen as a `select`
    statement. And, similar to a `select` statement where we can determinate clauses
    with expressions and predicates, the `find` interface allows us to use criteria
    and projections as parameters.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与SQL语言相比，`find`接口应该被视为`select`语句。类似于`select`语句，我们可以使用表达式和谓词确定子句，`find`接口允许我们使用条件和投影作为参数。
- en: 'As mentioned before, we will use JSON documents in these `find` interface parameters.
    We can use the `find` interface in the following way:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将在这些`find`接口参数中使用JSON文档。我们可以以以下方式使用`find`接口：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中：
- en: '`criteria` is a JSON document that will specify the criteria for the selection
    of documents inside a collection by using some operators'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`criteria`是一个JSON文档，将使用一些运算符指定集合中文档的选择条件'
- en: '`projection` is a JSON document that will specify which document''s fields
    in a collection will be returned as the query result'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`projection`是一个JSON文档，将指定集合中将作为查询结果返回的文档字段'
- en: Both are optional parameters, and we will go into more detail regarding these
    later.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个都是可选参数，我们稍后将更详细地讨论这些。
- en: 'Let''s execute the following example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下示例：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中：
- en: '`{"username": "johnclay"}` is the criteria'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{"username": "johnclay"}`是条件'
- en: '`{_id: 1, username: 1, details: 1}` is the projection'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{_id: 1, username: 1, details: 1}`是投影'
- en: 'This query will result in this document:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询将产生这个文档：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Selecting all documents
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择所有文档
- en: As mentioned in the previous section, in the `find` interface, both the criteria
    and projection parameters are optional. To use the `find` interface without any
    parameters means selecting all the documents in a collection.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在`find`接口中，条件和投影参数都是可选的。在没有任何参数的情况下使用`find`接口意味着选择集合中的所有文档。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the query result is a cursor with all the selected documents.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，查询结果是一个包含所有所选文档的游标。
- en: 'So, a query in the `products` collection executes in this way:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`products`集合中的查询以这种方式执行：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It will return:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Selecting documents using criteria
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用条件选择文档
- en: Despite the convenience, selecting all the documents in a collection can turn
    out to be a bad idea due to a given collection's length. If we take as an example
    a collection with hundreds, thousands, or millions of records, it is essential
    to create a criterion in order to select only the documents we want.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管方便，但选择集合中的所有文档可能会因为集合的长度而变得不切实际。举个例子，如果一个集合中有数百、数千或数百万条记录，就必须创建一个标准，以便只选择我们想要的文档。
- en: However, nothing prevents the query result from being huge. In this case, depending
    on the chosen drive that is executing the query, we must iterate the returned
    cursor.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有什么可以阻止查询结果变得非常庞大。在这种情况下，根据执行查询的所选驱动器，我们必须迭代返回的游标。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that in the mongo shell, the default value of returned records is 20.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在mongo shell中，返回记录的默认值为20。
- en: 'Let''s check the following example query. We want to select the documents where
    the attribute name is `Product 1`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查以下示例查询。我们想选择属性名称为`Product 1`的文档：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will give us as a result:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们一个结果：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding query selects the documents through the equality `{name: "Product
    1"}`. It''s also possible to use operators on the criteria interface.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '上述查询通过相等性`{name: "Product 1"}`选择文档。还可以在条件接口上使用运算符。'
- en: 'The following example demonstrates how it''s possible to select all documents
    where the price is greater than 10:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何选择所有价格大于 10 的文档：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This produces as a result:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生如下结果：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When we execute a query using the operator `$gt`, only documents that have an
    information price greater than 10 will be returned as a result in the cursor.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `$gt` 运算符执行查询时，只有价格信息大于 10 的文档将作为游标结果返回。
- en: In addition, there are other operators such as comparison, logical, element,
    evaluation, geographical, and arrays.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有其他运算符，如比较、逻辑、元素、评估、地理和数组运算符。
- en: 'Let''s take, for example, the documents from the `products` collection, shown
    as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们从 `products` 集合中选择的文档如下所示：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Comparison operators
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较运算符
- en: 'MongoDB provides us with a way to define equality between values. With comparison
    operators, we can compare BSON type values. Let''s look at these operators:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 为我们提供了一种定义值之间相等关系的方式。通过比较运算符，我们可以比较 BSON 类型的值。让我们看看这些运算符：
- en: 'The `$gte` operator is responsible for searching values that are equal or greater
    than the value specified in the query. If we execute the query `db.products.find({price:
    {$gte: 20}})`, it will return:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$gte` 运算符负责搜索等于或大于查询中指定值的值。如果我们执行查询 `db.products.find({price: {$gte: 20}})`，它将返回：'
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With the `$lt` operator, it''s possible to search for values that are inferior
    to the requested value in the query. The query `db.products.find({price: {$lt:
    20}})` will return:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用 `$lt` 运算符，可以搜索小于查询中请求的值的值。查询 `db.products.find({price: {$lt: 20}})` 将返回：'
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `$lte` operator searches for values that are less than or equal to the
    requested value in the query. If we execute the query `db.products.find({price:
    {$lte: 20}})`, it will return:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$lte` 运算符搜索小于或等于查询中请求的值的值。如果我们执行查询 `db.products.find({price: {$lte: 20}})`，它将返回：'
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `$in` operator is able to search any document where the value of a field
    equals a value that is specified in the requested array in the query. The execution
    of the query `db.products.find({price:{$in: [5, 10, 15]}})` will return:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$in` 运算符能够搜索任何字段值等于查询中请求的数组中指定的值的文档。执行查询 `db.products.find({price:{$in: [5,
    10, 15]}})` 将返回：'
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `$nin` operator will match values that are not included in the specified
    array. The execution of the `db.products.find({price:{$nin: [10, 20]}})` query
    will produce:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$nin` 运算符将匹配不包含在指定数组中的值。执行 `db.products.find({price:{$nin: [10, 20]}})` 查询将产生：'
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `$ne` operator will match any values that are not equal to the specified
    value in the query. The execution of the `db.products.find({name: {$ne: "Product
    1"}})` query will produce:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ne` 运算符将匹配任何不等于查询中指定值的值。执行 `db.products.find({name: {$ne: "Product 1"}})`
    查询将产生：'
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Logical operators
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'Logical operators are how we define the logic between values in MongoDB. These
    are derived from Boolean algebra, and the truth value of a Boolean value can be
    either `true` or `false`. Let''s look at the logical operators in MongoDB:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符是我们在 MongoDB 中定义值之间逻辑关系的方式。这些源自布尔代数，布尔值的真值可以是 `true` 或 `false`。让我们看看 MongoDB
    中的逻辑运算符：
- en: 'The `$and` operator will make a logical *AND* operation in an expressions array,
    and will return the values that match all the specified criteria. The execution
    of the `db.products.find({$and: [{price: {$lt: 30}}, {name: "Product 2"}]})` query
    will produce:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$and` 运算符将在表达式数组中执行逻辑 *AND* 操作，并返回匹配所有指定条件的值。执行 `db.products.find({$and: [{price:
    {$lt: 30}}, {name: "Product 2"}]})` 查询将产生：'
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `$or` operator will make a logical *OR* operation in an expressions array,
    and will return all the values that match either of the specified criteria. The
    execution of the `db.products.find({$or: [{price: {$gt: 50}}, {name: "Product
    3"}]})` query will produce:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$or` 运算符将在表达式数组中执行逻辑 *OR* 操作，并返回匹配任一指定条件的所有值。执行 `db.products.find({$or: [{price:
    {$gt: 50}}, {name: "Product 3"}]})` 查询将产生：'
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `$not` operator inverts the query effect and returns the values that do
    not match the specified operator expression. It is used to negate any operation.
    The execution of the `db.products.find({price: {$not: {$gt: 10}}})` query will
    produce:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$not` 运算符反转查询效果，并返回不匹配指定运算符表达式的值。它用于否定任何操作。执行 `db.products.find({price: {$not:
    {$gt: 10}}})` 查询将产生：'
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `$nor` operator will make a logical *NOR* operation in an expressions array,
    and will return all the values that fail to match all the specified expressions
    in the array. The execution of the `db.products.find({$nor:[{price:{$gt: 35}},
    {price:{$lte: 20}}]})` query will produce:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$nor` 运算符将在表达式数组中执行逻辑 *NOR* 操作，并返回所有未能匹配数组中所有指定表达式的值。执行 `db.products.find({$nor:[{price:{$gt:
    35}}, {price:{$lte: 20}}]})` 查询将产生：'
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Element operators
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元素运算符
- en: To query a collection about our documents fields, we can use element operators.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询集合关于我们文档字段的信息，我们可以使用元素运算符。
- en: 'The `$exists` operator will return all documents that have the specified field
    in the query. The execution of `db.products.find({sku: {$exists: true}})` will
    not return any document, because none of them have the field `sku`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`$exists` 运算符将返回查询中具有指定字段的所有文档。执行 `db.products.find({sku: {$exists: true}})`
    将不会返回任何文档，因为它们都没有 `sku` 字段。'
- en: Evaluation operators
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估运算符
- en: 'Evaluation operators are how we perform an assessment of an expression in MongoDB.
    We must take care with this kind of operator, especially if there is no index
    for the field we are using on the criteria. Let''s consider the evaluation operator:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 评估运算符是我们在 MongoDB 中对表达式进行评估的方式。我们必须小心使用这种类型的运算符，特别是如果我们正在使用的字段没有索引。让我们考虑评估运算符：
- en: 'The `$regex` operator will return all values that match a regular expression.
    The execution of `db.products.find({name: {$regex: /2/}})` will return:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$regex` 运算符将返回所有匹配正则表达式的值。执行 `db.products.find({name: {$regex: /2/}})` 将返回：'
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Array operators
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组运算符
- en: 'When we are working with arrays on a query, we should use array operators.
    Let''s consider the array operator:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在查询中使用数组时，应该使用数组运算符。让我们考虑数组运算符：
- en: The `$elemMatch` operator will return all documents where the specified array
    field values have at least one element that match the query criteria conditions.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$elemMatch`操作符将返回所有指定数组字段值至少有一个与查询条件匹配的元素的文档。'
- en: 'The `db.products.find({review: {$elemMatch: {stars: {$gt: 5}, customer: {email:
    "customer@customer.com"}}}})` query will look at all the collection documents
    where the `review` field has documents, the `stars` field value is greater than
    `5`, and `customer email` is `customer@customer.com`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.products.find({review: {$elemMatch: {stars: {$gt: 5}, customer: {email:
    "customer@customer.com"}}}})`查询将查看所有集合文档，其中`review`字段有文档，`stars`字段值大于`5`，并且`customer
    email`是`customer@customer.com`：'
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Besides the presented operators, we have: `$mod`, `$text`, `$where`, `$all`,
    `$geoIntersects`, `$geoWithin`, `$nearSphere`, `$near`, `$size`, and `$comment`.
    You can find more information regarding this in the MongoDB manual reference at
    [http://docs.mongodb.org/manual/reference/operator/query/](http://docs.mongodb.org/manual/reference/operator/query/).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 除了已呈现的操作符外，我们还有：`$mod`，`$text`，`$where`，`$all`，`$geoIntersects`，`$geoWithin`，`$nearSphere`，`$near`，`$size`和`$comment`。您可以在MongoDB手册参考中找到更多关于这方面的信息[http://docs.mongodb.org/manual/reference/operator/query/](http://docs.mongodb.org/manual/reference/operator/query/)。
- en: Projections
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 投影
- en: Until now, we have executed queries where the presented result is the document
    as it is persisted in MongoDB. But, in order to optimize the network overhead
    between MongoDB and its clients, we should use projections.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们执行的查询中呈现的结果是文档在MongoDB中持久化的样子。但是，为了优化MongoDB与其客户端之间的网络开销，我们应该使用投影。
- en: As you saw at the beginning of the chapter, the `find` interface allows us to
    use two parameters. The second parameter is projections.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在本章开头看到的，`find`接口允许我们使用两个参数。第二个参数是投影。
- en: 'By using the same sample collection we used in the previous session, an example
    of a query with projection would be:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在上一节中使用的相同示例集合，具有投影的查询示例将是：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This query produces:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询产生：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The projection is a JSON document with all the fields we would like to present
    or hide, followed by `0` or `1`, depending on what we want.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 投影是一个JSON文档，其中包含我们想要呈现或隐藏的所有字段，后面跟着`0`或`1`，取决于我们的需求。
- en: When a field is followed by a `0`, then this field will not be shown in the
    resulting document. On the other hand, if the field is followed by a `1`, then
    this means that it will be shown in the resulting document.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个字段后面跟着`0`，那么这个字段将不会显示在结果文档中。另一方面，如果字段后面跟着`1`，那么这意味着它将显示在结果文档中。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By default, the `_id` field has the value `1`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`_id`字段的值为`1`。
- en: 'The `db.products.find({price: {$not: {$gt: 10}}}, {_id: 0, name: 1, "supplier.name":
    1})` query will show the following document:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.products.find({price: {$not: {$gt: 10}}}, {_id: 0, name: 1, "supplier.name":
    1})`查询将显示以下文档：'
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In fields that have an array as a value, we can use operators such as `$elemMatch`,
    `$split`, `$slice`, and `$`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有数组值的字段中，我们可以使用`$elemMatch`，`$split`，`$slice`和`$`等操作符。
- en: 'The `db.products.find({price: {$gt: 20}}, {review: {$elemMatch: {stars: 5}}})`
    query will produce:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.products.find({price: {$gt: 20}}, {review: {$elemMatch: {stars: 5}}})`
    查询将产生：'
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Introducing the write operations
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍写操作
- en: 'In MongoDB, we have three kinds of write operations: insert, update, and remove.
    To run these operations, MongoDB provides three interfaces: `db.document.insert`,
    `db.document.update`, and `db.document.remove`. The write operations in MongoDB
    are targeted to a specific collection and are atomic on the level of a single
    document.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中，我们有三种写操作：插入、更新和删除。为了运行这些操作，MongoDB提供了三个接口：`db.document.insert`，`db.document.update`和`db.document.remove`。MongoDB中的写操作针对特定集合，并且在单个文档级别上是原子的。
- en: The write operations are as important as the read operations when we are modeling
    documents in MongoDB. The atomicity in a level of a single document can determine
    whether we embed documents or not. We will go into this in a little more detail
    in [Chapter 7](ch07.html "Chapter 7. Scaling"), *Scaling*, but the activity of
    choosing a shard key will be decisive in whether we write an operation's performance
    because, depending on the key choice, we will write in one or many shards.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中，当我们对文档进行建模时，写操作和读操作一样重要。单个文档级别的原子性可以决定我们是否嵌入文档。我们将在[第7章](ch07.html
    "第7章。扩展")*扩展*中更详细地讨论这个问题，但选择分片键的活动将决定我们是否写入操作的性能，因为根据键的选择，我们将在一个或多个分片上进行写入。
- en: Also, another determining factor in a writing operations' performance is related
    to the MongoDB physical model. There are many recommendations given by 10gen but
    let's focus on those that have the greatest impact on our development. Due to
    MongoDB's update model, which is based on random I/O operations, it is recommended
    that you use solid state discs, or SSD. The solid state disk has superior performance
    compared to spinning disks, in terms of random I/O operations. Even though spinning
    disks are cheaper, and the cost to scale an infrastructure based on this kind
    of hardware is not that expensive either, the use of SSDs or increasing the RAM
    is still more effective. Studies on this subject show us that SSDs outperform
    spinning disks by 100 times for random I/O operations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，写操作性能的另一个决定因素与MongoDB物理模型有关。10gen提出了许多建议，但让我们专注于对我们的开发产生最大影响的建议。由于MongoDB的更新模型是基于随机I/O操作的，建议您使用固态硬盘或SSD。与旋转硬盘相比，固态硬盘在随机I/O操作方面具有更高的性能。尽管旋转硬盘更便宜，基于这种硬件的基础设施扩展成本也不是很昂贵，但使用SSD或增加RAM仍然更有效。关于这个主题的研究表明，SSD在随机I/O操作方面比旋转硬盘性能提高了100倍。
- en: Another important thing to understand about write operations is how the documents
    are actually written on disk by MongoDB. MongoDB uses a journaling mechanism to
    write operations, and this mechanism uses a journal to write the change operation
    before we write it in the data files. This is very useful, especially when we
    have a dirty shutdown. MongoDB will use the journal files to recover the database
    state to a consistent state when the `mongod` process is restarted.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 关于写操作的另一个重要事项是了解MongoDB如何实际将文档写入磁盘。MongoDB使用日志记录机制来写入操作，该机制在写入数据文件之前使用日志来写入更改操作。这在发生脏关闭时非常有用。当`mongod`进程重新启动时，MongoDB将使用日志文件将数据库状态恢复到一致状态。
- en: As stated in [Chapter 2](ch02.html "Chapter 2. Data Modeling with MongoDB"),
    *Data Modeling with MongoDB*, the BSON specification allows us to have a document
    with the maximum size of 16 MB. Since its 2.6 version, MongoDB uses a space allocation
    strategy for a record, or document, named "power of two sized allocation." As
    its name suggests, MongoDB will allocate to each document a size in bytes that
    is its size to the power of two (for example, 32, 64, 128, 256, 512, …), considering
    that the minimum size of a document is 32 bytes. This strategy allocates more
    space than the document really needs, giving it more space to grow.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第2章](ch02.html "第2章。使用MongoDB进行数据建模")中所述，“使用MongoDB进行数据建模”，BSON规范允许我们拥有最大大小为16MB的文档。自其2.6版本以来，MongoDB使用了一种名为“二次幂大小分配”的记录或文档的空间分配策略。正如其名称所示，MongoDB将为每个文档分配一个字节大小，即其大小的二次幂（例如，32、64、128、256、512，...），考虑到文档的最小大小为32字节。该策略分配的空间比文档实际需要的空间更多，从而为其提供更多的增长空间。
- en: Inserts
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入
- en: 'The `insert` interface is one of the possible ways of creating a new document
    in MongoDB. The `insert` interface has the following syntax:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert`接口是在MongoDB中创建新文档的可能方式之一。`insert`接口具有以下语法：'
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里：
- en: '`document or array of documents` is either a document or an array with one
    or many documents that should be created in the targeted collection.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`文档或文档数组`是一个文档或一个包含一个或多个文档的数组，应该在目标集合中创建。'
- en: '`writeConcern` is a document expressing the write concern.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`writeConcern`是表示写入关注的文档。'
- en: '`ordered` should be a Boolean value, which if true will carry out an ordered
    process on the documents of the array, and if there is an error in a document,
    MongoDB will stop processing it. Otherwise, if the value is false, it will carry
    out an unordered process and it will not stop if an error occurs. By default,
    the value is `true`.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ordered`应该是一个布尔值，如果为true，将在数组的文档上执行有序过程，如果文档中有错误，MongoDB将停止处理它。否则，如果值为false，将执行无序过程，如果发生错误，将不会停止。默认情况下，值为`true`。'
- en: 'In the following example, we can see how an `insert` operation can be used:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们可以看到如何使用`insert`操作：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As we did not specify a value for the `_id` field, it will be automatically
    generated with a unique `ObjectId` value. The document created by this `insert`
    operation is:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有为`_id`字段指定值，它将自动生成具有唯一`ObjectId`值的值。此`insert`操作创建的文档是：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you observed in the first paragraph of this section, the `insert` interface
    is not the only way to create new documents in MongoDB. By using the `upsert`
    option on updates, we could also create new documents. Let's go into more detail
    regarding this now.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在本节的第一段中观察到的，`insert`接口不是在MongoDB中创建新文档的唯一方式。通过在更新上使用`upsert`选项，我们也可以创建新文档。现在让我们更详细地了解一下这个。
- en: Updates
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新
- en: The `update` interface is used to modify previous existing documents in MongoDB,
    or even to create new ones. To select which document we would like to change,
    we will use a criterion. An update can modify the field values of a document or
    an entire document.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`接口用于修改MongoDB中先前存在的文档，甚至创建新文文档。为了选择要更改的文档，我们将使用条件。更新可以修改文档的字段值或整个文档。'
- en: An update operation will modify only one document at a time. If the criterion
    matches more than one document, then it is necessary to pass a document with a
    `multi` parameter with the `true` value to the update interface. If the criteria
    matches no document and the `upsert` parameter is `true`, a new document will
    be created, or else it will update the matching document.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 更新操作一次只会修改一个文档。如果条件匹配多个文档，则需要通过`multi`参数为`true`的文档传递给update接口。如果条件不匹配任何文档，并且`upsert`参数为`true`，则将创建一个新文档，否则将更新匹配的文档。
- en: 'The `update` interface is represented as:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`接口表示为：'
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里：
- en: '`query` is the criteria'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query`是条件'
- en: '`update` is the document containing the modification to be applied'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update`是包含要应用的修改的文档'
- en: '`upsert` is a Boolean value that, if true, creates a new document if the criteria
    does not match any document in the collection'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upsert`是一个布尔值，如果为true，则在集合中没有匹配任何文档的情况下创建一个新文档'
- en: '`multi` is a Boolean value that, if true, updates every document that meets
    the criteria'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multi`是一个布尔值，如果为true，则更新满足条件的每个文档'
- en: '`writeConcern` is a document expressing the write concern'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`writeConcern`是表示写入关注的文档'
- en: 'Using the document created in the previous session, a sample update would be:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上一节中创建的文档，示例更新将是：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The modified document is:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的文档是：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `$set` operator allows us to update only the `email` field of the matched
    documents.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`$set`运算符允许我们仅更新匹配文档的`email`字段。'
- en: 'Otherwise, you may have this update:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，您可能会有此更新：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In this case, the modified document would be:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，修改后的文档将是：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'That is, without the `$set` operator, we modify the old document with the one
    passed as a parameter on the update. Besides the `$set` operator, we also have
    other important update operators:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，没有`$set`运算符，我们使用传递给更新的参数修改旧文档。除了`$set`运算符之外，我们还有其他重要的更新运算符：
- en: '`$inc` increments the value of a field with the specified value:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$inc`增加具有指定值的字段的值：'
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This update will increment the field `details.age` by 1 in the matched documents.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此更新将在匹配文档中将字段`details.age`增加1。
- en: '`$rename` will rename the specified field:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$rename`将重命名指定的字段：'
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This update will rename the field `username` to `login` in the matched documents.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此更新将在匹配的文档中将字段`username`重命名为`login`。
- en: '`$unset` will remove the field from the matched document:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$unset`将从匹配的文档中删除字段：'
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This update will remove the `login` field from the matched documents.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此更新将从匹配的文档中删除`login`字段。
- en: As the write operations are atomic at the level of a single document, we can
    afford to be careless with the use of the preceding operators. All of them can
    be safely used.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于写操作在单个文档级别是原子的，我们可以在使用前面的操作符时放心大胆。所有这些操作符都可以安全使用。
- en: Write concerns
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写关注点
- en: Many of the discussions surrounding non-relational databases are related to
    the ACID concept. We, as database professionals, software engineers, architects,
    and developers, are fairly accustomed to the relational universe, and we spend
    a lot of time developing without caring about ACID matters.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕非关系型数据库的许多讨论与ACID概念有关。作为数据库专业人员、软件工程师、架构师和开发人员，我们对关系型宇宙非常熟悉，并且花费了大量时间开发而不关心ACID问题。
- en: Nevertheless, we should understand by now why we really have to take this matter
    into consideration, and how these simple four letters are essential in the non-relational
    world. In this section, we will discuss the letter **D**, which means durability,
    in MongoDB.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们现在应该明白为什么我们真的必须考虑这个问题，以及这些简单的四个字母在非关系型世界中是如此重要。在本节中，我们将讨论**D**这个字母，在MongoDB中意味着持久性。
- en: Durability in database systems is a property that tells us whether a write operation
    was successful, whether the transaction was committed, and whether the data was
    written on non-volatile memory in a durable medium, such as a hard disk.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库系统中的持久性是一个属性，告诉我们写入操作是否成功，事务是否已提交，数据是否已写入非易失性存储器中，例如硬盘。
- en: Unlike relational database systems, the response to a write operation in NoSQL
    databases is determined by the client. Once again, we have the possibility to
    make a choice on our data modeling, addressing the specific needs of a client.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与关系型数据库系统不同，NoSQL数据库中对写操作的响应由客户端确定。再次，我们有可能在数据建模上做出选择，满足客户的特定需求。
- en: In MongoDB, the response of a successful write operation can have many levels
    of guarantee. This is what we call a write concern. The levels vary from weak
    to strong, and the client determines the strength of guarantee. It is possible
    for us to have, in the same collection, both a client that needs a strong write
    concern and another that needs a weak one.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中，成功写入操作的响应可以有多个级别的保证。这就是我们所说的写入关注点。这些级别从弱到强不等，客户端确定保证的强度。在同一个集合中，我们可以有一个需要强写入关注点的客户端，另一个需要弱写入关注点的客户端。
- en: 'The write concern levels that MongoDB offers us are:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB提供给我们的写入关注点级别是：
- en: Unacknowledged
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未确认
- en: Acknowledged
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认
- en: Journaled
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已记录
- en: Replica acknowledged
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 副本已确认
- en: Unacknowledged
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未确认
- en: 'As its name suggests, with an unacknowledged write concern, the client will
    not attempt to respond to a write operation. If this is possible, only network
    errors will be captured. The following diagram shows that drivers will not wait
    that MongoDB acknowledge the receipt of write operations:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，使用未确认的写入关注点，客户端将不会尝试响应写入操作。如果可能的话，只会捕获网络错误。以下图表显示驱动程序将不等待MongoDB确认接收写入操作：
- en: '![Unacknowledged](img/B04075_03_01.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: ！[未确认]（img / B04075_03_01.jpg）
- en: 'In the following example, we have an `insert` operation in the `customers`
    collection with an unacknowledged write concern:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们在`customers`集合中进行了一个未确认的写入操作：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Acknowledged
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确认
- en: With this write concern, the client will have an acknowledgement of the write
    operation, and see that it was written on the in-memory view of MongoDB. In this
    mode, the client can catch, among other things, network errors and duplicate keys.
    Since the 2.6 version of MongoDB, this is the default write concern.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此写入关注点，客户端将收到写入操作的确认，并看到它已在MongoDB的内存视图上写入。在这种模式下，客户端可以捕获网络错误和重复键等问题。自MongoDB
    2.6版本以来，这是默认的写入关注点。
- en: 'As you saw earlier, we can''t guarantee that a write on the in-memory view
    of MongoDB will be persisted on the disk. In the event of a failure of MongoDB,
    the data in the in-memory view will be lost. The following diagram shows that
    drivers wait MongoDB acknowledge the receipt of write operations and applied the
    change to the in-memory view of data:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您之前看到的，我们无法保证MongoDB的内存视图上的写入将持久保存在磁盘上。如果MongoDB发生故障，内存视图中的数据将丢失。以下图表显示驱动程序等待MongoDB确认接收写入操作，并将更改应用于数据的内存视图：
- en: '![Acknowledged](img/B04075_03_02.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: ！[已确认]（img / B04075_03_02.jpg）
- en: 'In the following example, we have an `insert` operation in the `customers`
    collection with an acknowledged write concern:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们在`customers`集合中进行了一个已确认的写入操作：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Journaled
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 已记录
- en: With a journaled write concern, the client will receive confirmation that the
    write operation was committed in the journal. Thus, the client will have a guarantee
    that the data will be persisted on the disk, even if something happens to MongoDB.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用已记录的写入关注点，客户端将收到确认写入操作已在日志中提交的确认。因此，客户端将保证数据将持久保存在磁盘上，即使发生了MongoDB的故障。
- en: 'To reduce the latency when we use a journaled write concern, MongoDB will reduce
    the frequency in which it commits operations to the journal from the default value
    of 100 milliseconds to 30 milliseconds. The following diagram shows that drivers
    will wait MongoDB acknowledge the receipt of write operations only after committing
    the data to the journal:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少使用已记录的写入关注点时的延迟，MongoDB将将操作提交到日志的频率从默认值100毫秒降低到30毫秒。以下图表显示驱动程序将等待MongoDB确认接收写入操作，只有在将数据提交到日志后才会等待：
- en: '![Journaled](img/B04075_03_03.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: ！[已记录]（img / B04075_03_03.jpg）
- en: 'In the following example, we have an `insert` in the `customers` collection
    with a journaled write concern:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们在`customers`集合中使用了一个日志写关注的`insert`：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Replica acknowledged
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 副本已确认
- en: When we are working with replica sets, it is important to be sure that a write
    operation was successful not only in the primary node, but also that it was propagated
    to members of the replica set. For this purpose, we use a replica acknowledged
    write concern.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用副本集时，重要的是要确保写操作不仅在主节点上成功，而且还传播到副本集的成员。为此，我们使用了一个副本已确认的写关注。
- en: 'By changing the default write concern to replica acknowledged, we can determine
    the number of members of the replica set from which we want the write operation
    confirmation. The following diagram shows that drivers will wait that MongoDB
    acknowledge the receipt of write operations on a specified number of the replica
    set members:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将默认写关注更改为副本已确认，我们可以确定我们希望从副本集的成员中获得写操作确认的数量。下图显示了驱动程序将等待MongoDB确认在指定数量的副本集成员上接收写操作：
- en: '![Replica acknowledged](img/B04075_03_04.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![副本已确认](img/B04075_03_04.jpg)'
- en: 'In the following example, we will wait until the write operation propagates
    to the primary and at least two secondary nodes:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将等待写操作传播到主节点和至少两个辅助节点：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We should include a timeout property in milliseconds to avoid that a write operation
    remains blocked in a case of a node failure.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在毫秒级别包含一个超时属性，以避免写操作在节点故障的情况下仍然被阻塞。
- en: 'In the following example, we will wait until the write operation propagates
    to the primary and at least two secondary nodes, with a timeout of three seconds.
    If one of the two secondary nodes from which we are expecting a response fails,
    then the method times out after three seconds:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将等待写操作传播到主节点和至少两个辅助节点，并设置了三秒的超时。如果我们期望响应的两个辅助节点中的一个失败，那么该方法将在三秒后超时：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Bulk writing documents
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 批量编写文档
- en: Sometimes it is quite useful to insert, update, or delete more than one record
    of your collection. MongoDB provides us with the capability to perform bulk write
    operations. A bulk operation works in a single collection, and can be either ordered
    or unordered.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一次插入、更新或删除集合中的多条记录是非常有用的。MongoDB为我们提供了执行批量写操作的能力。批量操作在单个集合中工作，可以是有序的或无序的。
- en: As with the `insert` method, the behavior of an ordered bulk operation is to
    process records serially, and if an error occurs, MongoDB will return without
    processing any of the remaining operations.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 与`insert`方法一样，有序批量操作的行为是按顺序处理记录，如果发生错误，MongoDB将返回而不处理任何剩余的操作。
- en: The behavior of an unordered operation is to process in parallel, so if an error
    occurs, MongoDB will still process the remaining operations.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 无序操作的行为是并行处理，因此如果发生错误，MongoDB仍将处理剩余的操作。
- en: We also can determine the level of acknowledgement required for bulk write operations.
    Since its 2.6 version, MongoDB has introduced new bulk methods with which we can
    insert, update, or delete documents. However, we can make a bulk insert only by
    passing an array of documents on the `insert` method.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以确定批量写操作所需的确认级别。自其2.6版本以来，MongoDB引入了新的批量方法，我们可以使用这些方法插入、更新或删除文档。但是，我们只能通过在`insert`方法上传递文档数组来进行批量插入。
- en: 'In the following example, we make a bulk insert using the `insert` method:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们使用`insert`方法进行批量插入：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the following example, we make an unordered bulk insert using the new bulk
    methods:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们使用新的批量方法进行无序批量插入：
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We should use all the power tools MongoDB provides us with, but not without
    paying all our possible attention. MongoDB has a limit of executing a maximum
    of 1,000 bulk operations at a time. So, if this limit is exceeded, MongoDB will
    divide the operations into groups of a maximum of 1,000 bulk operations.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该利用MongoDB提供给我们的所有强大工具，但不要忽视任何可能的注意事项。MongoDB一次最多执行1,000个批量操作的限制。因此，如果超过此限制，MongoDB将把操作分成最多1,000个批量操作的组。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you were hopefully able to better understand the read and write
    operations in MongoDB. Moreover, now, you should also understand why it is important
    that you already know the queries you need to execute even before the document
    modeling process. Finally, you learned how to use the MongoDB properties, such
    as atomicity, at the document level and saw how it can help us to produce better
    queries.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您希望能够更好地理解MongoDB中的读写操作。此外，现在，您还应该明白为什么在文档建模过程之前就已经知道需要执行的查询是很重要的。最后，您学会了如何使用MongoDB的属性，比如原子性，在文档级别上，并看到它如何帮助我们生成更好的查询。
- en: In the next chapter, you will see how a special data structure known as index
    can improve the execution of our queries.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将看到一种称为索引的特殊数据结构如何改进我们查询的执行。
