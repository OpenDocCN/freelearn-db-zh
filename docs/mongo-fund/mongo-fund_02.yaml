- en: 2\. Documents and Data Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 文档和数据类型
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces you to MongoDB documents, their structure, and data
    types. For those who are new to the JSON model, this chapter will also serve as
    a short introduction to JSON. You will identify the basic concepts and data types
    of JSON documents and compare the document-based storage of MongoDB with the tabular
    storage of relational databases. You will learn how to represent complex data
    structures in MongoDB using embedded objects and arrays. By the end of this chapter,
    you will understand the need for precautionary limits and restrictions on MongoDB documents.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了MongoDB文档、它们的结构和数据类型。对于那些对JSON模型不熟悉的人来说，本章也将作为JSON的简要介绍。您将识别JSON文档的基本概念和数据类型，并将MongoDB的基于文档的存储与关系数据库的表格存储进行比较。您将学习如何在MongoDB中使用嵌入对象和数组表示复杂的数据结构。通过本章的学习，您将了解对MongoDB文档的预防性限制和限制的需求。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we learned how MongoDB, as a NoSQL database, differs
    from traditional relational databases. We covered the basic features of MongoDB,
    including its architecture, its different versions, and MongoDB Atlas.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了作为NoSQL数据库的MongoDB与传统关系数据库的不同之处。我们涵盖了MongoDB的基本特性，包括其架构、不同版本和MongoDB
    Atlas。
- en: MongoDB is designed for modern-world applications. We live in a world where
    requirements change rapidly. We want to build lightweight and flexible applications
    that can quickly adapt to these new requirements and ship them to production as
    quickly as possible. We want our databases to become agile so that they can adapt
    to the ever-changing needs of our applications, reduce downtime, scale out easily,
    and perform efficiently. MongoDB is a perfect fit for all such needs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是为现代应用程序设计的。我们生活在一个需求迅速变化的世界。我们希望构建轻量灵活的应用程序，能够快速适应这些新需求，并尽快将其部署到生产环境中。我们希望我们的数据库变得敏捷，以便能够适应应用程序不断变化的需求，减少停机时间，轻松扩展，并且性能高效。MongoDB完全符合所有这些需求。
- en: One of the major factors that make MongoDB an agile database is its document-based
    data model. Documents are widely accepted as a flexible way of transporting information.
    You might have come across many applications that exchange data in the form of
    **JavaScript Object Notation** (**JSON**) documents. MongoDB stores data in Binary
    JSON (BSON) format and represents it in human readable JSON. This means that when
    we use MongoDB, we see the data in JSON format. This chapter begins with an overview
    of the JSON and BSON formats, followed by details of MongoDB documents and data
    types.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使MongoDB成为一种敏捷数据库的主要因素之一是其基于文档的数据模型。文档被广泛接受为传输信息的灵活方式。您可能已经遇到许多以JSON文档形式交换数据的应用程序。MongoDB以二进制JSON（BSON）格式存储数据，并以人类可读的JSON表示数据。这意味着当我们使用MongoDB时，我们看到的数据是以JSON格式呈现的。本章以JSON和BSON格式的概述开始，然后介绍MongoDB文档和数据类型的详细信息。
- en: Introduction to JSON
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON介绍
- en: JSON is a full-text, lightweight format for data representation and transportation.
    JavaScript's simple representation of objects gave birth to JSON. Douglas Crockford,
    who was one of the developers of the JavaScript language, came up with the proposal
    for the JSON specification that defines the grammar and data types for the JSON syntax.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是一种用于数据表示和传输的全文本、轻量级格式。JavaScript对对象的简单表示形式催生了JSON。道格拉斯·克罗克福德（Douglas Crockford）是JavaScript语言的开发人员之一，他提出了JSON规范的建议，定义了JSON语法的语法和数据类型。
- en: The JSON specification became a standard in 2013\. If you have been developing
    applications for a while, you might have seen the transition of applications from
    XML to JSON. JSON offers a human-readable, plain-text way of representing data.
    In comparison to XML, where information is wrapped inside tags, and lots of tags
    make it look bulky, JSON offers a compact and natural format where you can easily
    focus on the information.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: JSON规范于2013年成为标准。如果您已经开发了一段时间的应用程序，您可能已经看到应用程序从XML转换为JSON的过渡。JSON提供了一种人类可读的纯文本表示数据的方式。与XML相比，其中信息被包裹在标签内，而且大量标签使其看起来笨重，JSON提供了一种紧凑和自然的格式，您可以轻松地专注于信息。
- en: To read or write information in JSON or XML format, the programming languages
    use their respective parsers. As XML documents are bound by schema definitions
    and tag library definitions, parsers need to do a lot of work to read and validate
    **XML Schema Definition** (**XSD**) and **Tag Library Descriptors** (**TLDs**).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以JSON或XML格式读取或写入信息，编程语言使用它们各自的解析器。由于XML文档受模式定义和标签库定义的约束，解析器需要做大量工作来读取和验证XML模式定义（XSD）和标签库描述符（TLD）。
- en: On the other hand, JSON does not have any schema definition, and JSON parsers
    only need to deal with opening and closing brackets and colons. Different programming
    languages have different ways of representing language constructs, such as objects,
    lists, arrays, variables, and more. When two systems, written in two different
    programming languages, want to exchange data, they need to have a mutually agreed
    standard for representing information. JSON provides that standard with its lightweight
    format. The objects, collections, and variables of any programming language can
    naturally fit into the JSON structure. Most programming languages have parsers
    that can translate their own objects to and from JSON documents.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，JSON没有任何模式定义，JSON解析器只需要处理开放和关闭括号以及冒号。不同的编程语言有不同的表示语言构造的方式，例如对象、列表、数组、变量等。当两个用不同编程语言编写的系统想要交换数据时，它们需要有一个共同约定的标准来表示信息。JSON以其轻量级格式提供了这样的标准。任何编程语言的对象、集合和变量都可以自然地适应JSON结构。大多数编程语言都有解析器，可以将它们自己的对象转换为JSON文档，反之亦然。
- en: Note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: JSON does not impose JavaScript language internals on other languages. JSON
    is the syntax for language-independent data representation. The grammar that defines
    the JSON format was derived from JavaScript's syntax. However, to use JSON, programmers
    do not need to know JavaScript internals
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JSON不会将JavaScript语言内部规定强加给其他语言。JSON是语言无关数据表示的语法。定义JSON格式的语法是从JavaScript的语法派生出来的。然而，为了使用JSON，程序员不需要了解JavaScript的内部。
- en: JSON Syntax
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON语法
- en: JSON documents or objects are a plain-text set of zero or more key-value pairs.
    The key-value pairs form an object, and if the value is a collection of zero or
    more values, they form an array. JSON has a very simple structure where, by only
    using a set of curly braces (`{}`), square brackets (`[]`), colons (`:`), and
    commas(`,`), you can represent any complex piece of information in a compact form.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: JSON文档或对象是一组零个或多个键值对的纯文本。键值对形成一个对象，如果值是零个或多个值的集合，它们形成一个数组。JSON具有非常简单的结构，只需使用一组大括号`{}`、方括号`[]`、冒号`:`和逗号`,`，就可以以紧凑的形式表示任何复杂的信息。
- en: 'In a JSON object, key-value pairs are enclosed within curly braces: `{}`. Within
    an object, the key is always a string. However, the value can be any of JSON''s
    specified types. The JSON grammar specification does not define any order for
    JSON fields and can be represented as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSON对象中，键值对被包含在大括号`{}`中。在对象内，键始终是一个字符串。然而，值可以是JSON指定的任何类型。JSON语法规范没有为JSON字段定义任何顺序，可以表示如下：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding document represents a valid JSON object that has a single key-value
    pair. Moving on to JSON arrays, an array is a set of zero or more values that
    are enclosed within square brackets, `[]`, and separated by commas. While most
    programming languages have support for ordered arrays, JSON''s specification does
    not specify the order for array elements. Let''s take a look at an example array
    that has three fields separated by commas:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的文件代表一个有效的JSON对象，其中有一个键值对。接下来是JSON数组，数组是一组零个或多个值，这些值被包含在方括号`[]`中，并用逗号分隔。虽然大多数编程语言支持有序数组，但JSON的规范并未指定数组元素的顺序。让我们看一个例子，其中有三个字段，用逗号分隔：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we have looked at JSON syntax, let''s consider a sample JSON document
    that contains the basic information of a company. The example demonstrates how
    naturally a piece of information can be presented in document format, making it
    easily readable:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过了JSON的语法，让我们考虑一个包含公司基本信息的示例JSON文档。这个例子展示了信息如何以文档格式自然地呈现，使其易于阅读：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'From the preceding document, we can see the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的文件中，我们可以看到以下内容：
- en: Company name and address, both being string fields
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公司名称和地址，都是字符串字段
- en: Foundation year, number of employees, and revenue as numeric fields
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成立年份、员工人数和收入作为数字字段
- en: The company's Twitter username as null or no information
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公司的Twitter用户名为空或没有信息
- en: JSON Data Types
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON数据类型
- en: 'Unlike many programming languages, JSON supports a limited and basic set of
    data types, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多编程语言不同，JSON支持一组有限和基本的数据类型，如下：
- en: '**String**: Refers to plain text'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串**：指纯文本'
- en: '**Number**: Consists of all numeric fields'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字**：包括所有数字字段'
- en: '`True` or `False`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`True`或`False`'
- en: '**Object**: Other embedded JSON objects'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象**：其他嵌入的JSON对象'
- en: '**Array**: Collection of fields'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数组**：字段的集合'
- en: '**Null**: Special value to denote fields without any value'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Null**：特殊值，表示没有任何值的字段'
- en: One of the major reasons for the wide acceptance of JSON is its language-independent
    format. Different languages have different data types. Some languages support
    **statically typed variables**, while some support **dynamically typed variables**.
    If JSON had many data types, it would be more in line with a number of languages—though,
    not all.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: JSON被广泛接受的一个主要原因是它的独立于语言的格式。不同的语言有不同的数据类型。一些语言支持**静态类型变量**，而一些支持**动态类型变量**。如果JSON有许多数据类型，它将更符合许多语言，尽管不是所有语言。
- en: JSON is a data exchange format. When an application transmits a piece of information
    over the wire, the information gets serialized into plain strings. The receiving
    application then deserializes the information into its objects so that it becomes
    available to use. The presence of basic data types provided by JSON reduces complexity
    during this process.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是一种数据交换格式。当应用程序通过网络传输一条信息时，该信息被序列化为纯字符串。接收应用程序然后将信息反序列化为其对象，以便可以使用。JSON提供的基本数据类型的存在减少了这个过程中的复杂性。
- en: Thus, JSON keeps it simple and minimal in terms of data types. JSON parsers
    specific to programming languages can easily relate basic data types to the most
    specific types the language provides.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，JSON在数据类型方面保持简单和最小化。特定于编程语言的JSON解析器可以将基本数据类型轻松地关联到语言提供的最具体的类型。
- en: JSON and Numbers
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON和数字
- en: As per the JSON specification, a number is just a sequence of digits. It does
    not differentiate between numbers such as `integer`, `float`, or `long`. Additionally,
    it restricts the range limits of numbers. This leads to greater flexibility when
    data is transferred or represented.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 根据JSON规范，数字只是一系列数字。它不区分诸如`整数`、`浮点数`或`长整数`之类的数字。此外，它限制了数字的范围限制。这导致在数据传输或表示时具有更大的灵活性。
- en: However, there are some challenges involved. Most programming languages represent
    numbers in the form of `integer`, `float`, or `long`. When a piece of information
    is presented in JSON, the parsers cannot anticipate the exact format or range
    of a numeric field in the entire document. To avoid number format corruption or
    the loss of precision of numeric fields, the two parties exchanging data should
    agree and follow a certain contract in advance.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也存在一些挑战。大多数编程语言以`整数`、`浮点数`或`长整数`的形式表示数字。当一条信息以JSON格式呈现时，解析器无法预期整个文档中数值字段的确切格式或范围。为了避免数字格式损坏或数值字段精度丢失，交换数据的双方应事先达成一定的协议并遵循。
- en: 'For instance, say you are reading a movie record set in the form of JSON documents.
    When you look at the first record, you find the `audience_rating` field is an
    `integer`. However, when you reach the next record, you realize it is a `float`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您正在阅读以JSON文档形式呈现的电影记录集。当您查看第一条记录时，您发现`audience_rating`字段是一个`整数`。然而，当您到达下一条记录时，您意识到它是一个`浮点数`：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will look at how this issue can be overcome in an upcoming section, *BSON*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在即将到来的*BSON*部分中看看如何克服这个问题。
- en: JSON and Dates
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON和日期
- en: 'As you may have noticed, JSON documents do not support the `Date` data type,
    and all dates are represented as plain strings. Let''s look at an example of a
    few JSON documents, each of which has a valid date representation:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，JSON文档不支持`Date`数据类型，所有日期都表示为普通字符串。让我们看一个例子，其中有几个JSON文档，每个文档都有一个有效的日期表示：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Although all the documents represent the same date, they are written in a different
    format. Different systems, based on their local standards, use different formats
    to write the same date and time instances.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有文档表示相同的日期，但它们以不同的格式编写。根据其本地标准，不同的系统使用不同的格式来编写相同的日期和时间实例。
- en: Like the examples of JSON numbers, the parties exchanging the information need
    to standardize the `Date` format during the transfers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与JSON数字的示例一样，交换信息的各方需要在传输过程中标准化`Date`格式。
- en: Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that the JSON specification defines syntax and grammar for data representation.
    However, how you read the data depends on the interpreters of the languages and
    their data exchange contracts.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，JSON规范定义了数据表示的语法和语法。然而，您如何读取数据取决于语言的解释器和它们的数据交换协议。
- en: 'Exercise 2.01: Creating Your Own JSON Document'
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.01：创建您自己的JSON文档
- en: Now that you have learned the basics of JSON syntax, it is time to put this
    knowledge into practice. Suppose your organization wants to build a dataset of
    movies and series, and they want to use MongoDB to store the records. As a proof
    of concept, they ask you to choose a random movie and represent it in JSON format.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了JSON语法的基础知识，是时候将这些知识付诸实践了。假设您的组织想要构建一个电影和系列节目的数据集，并且他们想要使用MongoDB来存储记录。作为概念验证，他们要求您选择一部随机电影，并以JSON格式表示它。
- en: 'In this exercise, you will write your first basic JSON document from scratch
    and verify whether it is a grammatically valid document. For this exercise, you
    will consider a sample movie, `Beauty and the Beast`, and refer to the `Movie
    ID`, `Movie Title`, `Release Year`, `Language`, `IMDb Rating` `Genre`, `Director`,
    and `Runtime` fields, which contain the following information:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将从头开始编写您的第一个基本JSON文档，并验证它是否是一个语法上有效的文档。对于这个练习，您将考虑一部样本电影，`美女与野兽`，并参考`电影ID`、`电影标题`、`发行年份`、`语言`、`IMDb评分`、`类型`、`导演`和`时长`字段，其中包含以下信息：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To successfully create a JSON document for the preceding listed fields, first
    differentiate each field into key-value pairs. Execute the following steps to
    achieve the desired result:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功地为上述列出的字段创建一个JSON文档，首先将每个字段区分为键值对。执行以下步骤以实现所需的结果：
- en: Open a JSON validator—for example, [https://jsonlint.com/](https://jsonlint.com/).
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个JSON验证器，例如[https://jsonlint.com/](https://jsonlint.com/)。
- en: 'Type the preceding information in JSON format, which looks as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将上述信息以JSON格式输入，如下所示：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Remember, a JSON document always starts with `{` and ends with `}`. Each element
    is separated by a colon (`:`) and the key-value pairs are separated by a comma
    (`,`).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，JSON文档总是以`{`开头，以`}`结尾。每个元素由冒号(`:`)分隔，键值对由逗号(`,`)分隔。
- en: 'Click on `Validate JSON` to validate the code. The following screenshot displays
    the expected output and validity of the JSON document:![Figure 2.1: The JSON document
    and its validity check'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击`验证JSON`以验证代码。以下屏幕截图显示了JSON文档的预期输出和有效性：![图2.1：JSON文档及其有效性检查
- en: '](img/B15507_02_01.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_01.jpg)'
- en: 'Figure 2.1: The JSON document and its validity check'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：JSON文档及其有效性检查
- en: In this exercise, you modeled a movie record into a document format and created
    a grammatically valid JSON object. To practice it more, you can consider any general
    item, such as a product you recently bought or a book you read, and model it as
    a valid JSON document. In the next section, we will look at a brief overview of
    MongoDB's BSON.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将把一部电影记录建模成文档格式，并创建一个语法上有效的JSON对象。要更多地练习它，您可以考虑任何一般项目，比如您最近购买的产品或您阅读的一本书，并将其建模为一个有效的JSON文档。在下一节中，我们将简要概述MongoDB的BSON。
- en: BSON
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BSON
- en: When you work with MongoDB using database clients such as mongo shell, MongoDB
    Compass, or the Collections Browser in Mongo Atlas, you always see the documents
    in human readable JSON format. However, internally, MongoDB documents are stored
    in a binary format called BSON. BSON documents are not human-readable, and you
    will never have to deal with them directly. Before we explore MongoDB documents
    in detail, let's have a quick overview of the BSON features that benefit the MongoDB
    document structure.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用数据库客户端（如mongo shell、MongoDB Compass或Mongo Atlas中的Collections Browser）与MongoDB一起工作时，您总是以人类可读的JSON格式看到文档。然而，在内部，MongoDB文档以一种称为BSON的二进制格式存储。BSON文档不是人类可读的，您永远不需要直接处理它们。在我们详细探讨MongoDB文档之前，让我们快速概述一下BSON的特性，这些特性有益于MongoDB文档结构。
- en: Like JSON, BSON was introduced in 2009 by MongoDB. Although it was invented
    by MongoDB, many other systems also use it as a format for data storage or transportation.
    BSON specifications are primarily based on JSON as they inherit all the good features
    of JSON, such as the syntax and flexibility. It also provides a few additional
    features, which are specifically designed for improving storage efficiency, ease
    of traversal, and a few data type enhancements to avoid the type conflicts that
    we saw in the *Introduction to JSON* section.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与JSON一样，BSON是由MongoDB在2009年引入的。尽管它是由MongoDB发明的，但许多其他系统也将其用作数据存储或传输的格式。BSON规范主要基于JSON，因为它继承了JSON的所有优点，如语法和灵活性。它还提供了一些额外的功能，专门设计用于提高存储效率，便于遍历，并避免类型冲突的一些数据类型增强，这些冲突是我们在*JSON简介*部分中看到的。
- en: 'As we have already covered the JSON features in detail, let''s focus on the
    enhancements that BSON provides:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经详细介绍了JSON的特性，让我们专注于BSON提供的增强功能：
- en: BSON documents are designed to be more efficient than JSON as they occupy less
    space and provide faster traversal.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BSON文档的设计旨在比JSON更高效，因为它们占用更少的空间并提供更快的遍历速度。
- en: With each document, BSON stores some **meta-information**, such as the length
    of the fields or the length of the sub-documents. The meta-information makes the
    document parsing, as well as traversing, faster.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个文档，BSON存储一些**元信息**，例如字段的长度或子文档的长度。元信息使文档解析和遍历更快。
- en: BSON documents have **ordered arrays**. Each element in an array is prefixed
    by its index position and can be accessed using its index number.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BSON文档具有**有序数组**。数组中的每个元素都以其索引位置为前缀，并可以使用其索引号进行访问。
- en: BSON provides many **additional data types**, such as dates, integers, doubles,
    byte arrays, and more. We will cover BSON data types later, in the next section.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BSON提供了许多**额外的数据类型**，如日期、整数、双精度、字节数组等。我们将在下一节中详细介绍BSON数据类型。
- en: Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Because of the binary format, BSON documents are compact in nature. However,
    some smaller documents end up occupying more space compared to JSON documents
    with the same information. This is because of the meta-information added to each
    document. However, for large documents, BSON is more space efficient.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于二进制格式，BSON文档在性质上是紧凑的。但是，一些较小的文档最终占用的空间比具有相同信息的JSON文档更多。这是因为每个文档都添加了元信息。但是，对于大型文档，BSON更节省空间。
- en: Now that we have completed a detailed introduction to JSON and BSON enhancements,
    let's now learn about MongoDB documents.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了对JSON和BSON增强功能的详细介绍，让我们现在学习一下MongoDB文档。
- en: MongoDB Documents
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB文档
- en: A MongoDB database is composed of collections and documents. A database can
    have one or more collections, and each collection can store one or more related
    BSON documents. In comparison to RDBMS, collections are analogous to tables and
    documents are analogous to rows within a table. However, documents are much more
    flexible compared with the rows in a table.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB数据库由集合和文档组成。一个数据库可以有一个或多个集合，每个集合可以存储一个或多个相关的BSON文档。与关系型数据库相比，集合类似于表，文档类似于表中的行。但是，与表中的行相比，文档更加灵活。
- en: RDBMSes consist of a tabular data model that comprises rows and columns. However,
    your applications may need to support more complex data structures, such as a
    nested object or a collection of objects. Tabular databases restrict the storage
    of such complex data structures. In such cases, you will have to split your data
    into multiple tables and change the application's object structures accordingly.
    On the other hand, the document-based data model of MongoDB allows your application
    to store and retrieve more complex object structures due to the flexible JSON-like
    format of the documents.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库由行和列组成的表格数据模型。但是，您的应用程序可能需要支持更复杂的数据结构，例如嵌套对象或对象集合。表格数据库限制了这种复杂数据结构的存储。在这种情况下，您将不得不将数据拆分成多个表，并相应地更改应用程序的对象结构。另一方面，MongoDB的基于文档的数据模型允许您的应用程序存储和检索更复杂的对象结构，因为文档具有灵活的类似JSON的格式。
- en: 'The following list details some of the major features of MongoDB''s document-based
    data model:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表详细介绍了MongoDB基于文档的数据模型的一些主要特性：
- en: The documents provide a flexible and natural way of representing data. The data
    can be stored as is, without having to transform it into a database structure.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档提供了一种灵活和自然的表示数据的方式。数据可以按原样存储，而无需将其转换为数据库结构。
- en: The objects, nested objects, and arrays that are within a document are easily
    relatable to your programming language's object structure.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档中的对象、嵌套对象和数组与您编程语言的对象结构容易相关联。
- en: With the ability of a flexible schema, the documents are agile in practice.
    They continuously integrate with application changes and new features without
    any major schema changes or downtimes.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有灵活模式的能力使文档在实践中更加灵活。它们可以持续集成应用程序的变化和新功能，而无需进行任何重大的模式更改或停机。
- en: Documents are self-contained pieces of data. They avoid the need to read multiple
    relational tables and table-joins to understand a complete unit of information.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档是自包含的数据片段。它们避免了阅读多个关系表和表连接以理解完整信息单元的需要。
- en: The documents are extensible. You can use documents to store the entire object
    structure, use it as a map or a dictionary, as a key-value pair for quick lookup,
    or have a flat structure that resembles a relational table.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档是可扩展的。您可以使用文档来存储整个对象结构，将其用作映射或字典，作为快速查找的键值对，或者具有类似关系表的扁平结构。
- en: Documents and Flexibility
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档和灵活性
- en: 'As stated earlier, MongoDB documents are a flexible way of storing data. Consider
    the following example. Imagine you are developing a movie service where you need
    to create a movie database. A movie record in a simple MongoDB document will look
    like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所述，MongoDB文档是一种灵活的存储数据的方式。考虑以下示例。想象一下，您正在开发一个电影服务，需要创建一个电影数据库。一个简单的MongoDB文档中的电影记录将如下所示：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'However, storing only the title is not enough. You need more fields. Now, let''s
    consider a few more basic fields. With a list of movies in the MongoDB database,
    the documents will look like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅存储标题是不够的。您需要更多的字段。现在，让我们考虑一些更基本的字段。在MongoDB数据库中有一系列电影，文档将如下所示：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Say you are using an RDBMS table instead. On an RDBMS platform, you need to
    define your schema at the beginning, and to do that, first, you must think about
    the columns and data types. You might then come up with a `CREATE TABLE` query
    as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在使用RDBMS表。在RDBMS平台上，您需要在开始时定义您的模式，为此，首先您必须考虑列和数据类型。然后，您可能会提出一个`CREATE TABLE`查询，如下所示：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This query is a clear indication that relational tables are bound by a definition
    called the `id` field and `user_ratings` can never be a string.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询清楚地表明，关系表受到一个叫做`id`字段的定义的限制，而`user_ratings`永远不能是一个字符串。
- en: 'With a few records inserted, the table will appear as in *Figure 2.2*. This
    table is as good as a MongoDB document:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 插入了一些记录后，表将显示为*图2.2*。这个表和一个MongoDB文档一样好：
- en: '![Figure 2.2: The movies table'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2：电影表'
- en: '](img/B15507_02_02.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_02.jpg)'
- en: 'Figure 2.2: The movies table'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：电影表
- en: 'Now, say you want to include the IMDb ratings for each of the movies listed
    in the table, and going forward, all the movies will have `imdb_ratings` included
    in the table. For an existing list of movies, `imdb_ratings` can be set to `null`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设您想要在表中列出的每部电影中包括IMDb评分，并且今后，所有电影都将在表中包括`imdb_ratings`。对于现有的电影列表，`imdb_ratings`可以设置为`null`：
- en: 'To meet this requirement, you will include an `ALTER TABLE` query in your syntax:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这个要求，您将在您的语法中包含一个`ALTER TABLE`查询：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The query is correct, but there can be instances where table alterations may
    block the table for some time, especially for large datasets. When a table is
    blocked, other read and write operations will have to wait until the table is
    altered, which may lead to downtime. Now, let's see how we can tackle the same
    situation in MongoDB.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 查询是正确的，但是在某些情况下，表的更改可能会阻塞表一段时间，特别是对于大型数据集。当表被阻塞时，其他读写操作将不得不等待表被更改，这可能导致停机。现在，让我们看看如何在MongoDB中解决同样的情况。
- en: MongoDB supports a flexible schema, and there is no specific schema definition.
    Without altering anything on the database or the collection, you can simply insert
    a new movie with the additional field. The collection will behave exactly like
    the modified table of the movies, where the latest insertions will have `imdb_ratings`
    and the previous ones will return a `null` value. In MongoDB documents, a non-existent
    field is always considered `null`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB支持灵活的模式，并且没有特定的模式定义。在不改变数据库或集合上的任何内容的情况下，您可以简单地插入一个带有额外字段的新电影。集合的行为将与修改后的电影表完全相同，最新插入的将具有`imdb_ratings`，而之前的将返回`null`值。在MongoDB文档中，不存在的字段始终被视为`null`。
- en: 'Now, the whole collection will look similar to the following screenshot. You
    will notice that the last movie has a new field, `imdb_ratings`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，整个集合将看起来类似于以下的屏幕截图。您会注意到最后一个电影有一个新字段，`imdb_ratings`：
- en: '![Figure 2.3: Result for imdb_ratings for the movies collection'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3：电影集合的imdb_ratings结果'
- en: '](img/B15507_02_03.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_03.jpg)'
- en: 'Figure 2.3: Result for imdb_ratings for the movies collection'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：电影集合的imdb_ratings结果
- en: The preceding examples clearly indicate that documents are extremely flexible
    in comparison to tabular databases. Documents can incorporate changes on the go
    without any downtime.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子清楚地表明，与表格数据库相比，文档非常灵活。文档可以在不停机的情况下进行更改。
- en: MongoDB Data Types
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB数据类型
- en: You have learned how MongoDB stores JSON-like documents. You have also seen
    various documents and read the information stored within them and seen how flexible
    these documents are to store different types of data structures, irrespective
    of the complexity of your data.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学会了MongoDB如何存储类似JSON的文档。您还看到了各种文档，并读取了其中存储的信息，并看到了这些文档在存储不同类型的数据结构时有多灵活，无论您的数据有多复杂。
- en: In this section, you will learn about the various data types supported by MongoDB's
    BSON documents. Using the right data types in your documents is very important
    as correct data types help you use the database features more effectively, avoid
    data corruption, and improve data usability. MongoDB supports all the data types
    from JSON and BSON. Let's look at each in detail, with examples.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解MongoDB的BSON文档支持的各种数据类型。在文档中使用正确的数据类型非常重要，因为正确的数据类型可以帮助您更有效地使用数据库功能，避免数据损坏，并提高数据的可用性。MongoDB支持JSON和BSON中的所有数据类型。让我们详细看看每种类型，以及示例。
- en: Strings
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: A string is a basic data type used to represent text-based fields in a document.
    It is a plain sequence of characters. In MongoDB, the string fields are UTF-8
    encoded, and thus they support most international characters. The MongoDB drivers
    for various programming languages convert the string fields to UTF-8 while reading
    or writing data from a collection.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是用来表示文本字段的基本数据类型。它是一系列普通字符。在MongoDB中，字符串字段是UTF-8编码的，因此它们支持大多数国际字符。各种编程语言的MongoDB驱动程序在从集合中读取或写入数据时将字符串字段转换为UTF-8。
- en: 'A string with plain-text characters appears as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含纯文本字符的字符串如下所示：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A string with random characters and whitespaces will appear as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含随机字符和空格的字符串将显示如下：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In JSON, a value that is wrapped in double quotes is considered a string. Consider
    the following example in which a valid number and date are wrapped in double quotes,
    both forming a string:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSON中，用双引号括起来的值被视为字符串。考虑以下示例，其中一个有效的数字和日期被双引号括起来，都形成一个字符串：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: An interesting fact about MongoDB string fields is that they support search
    capabilities with regular expressions. This means you can search for documents
    by providing the full value of a text field or by providing only part of the string
    value using regular expressions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有关MongoDB字符串字段的一个有趣事实是，它们支持使用正则表达式进行搜索。这意味着您可以通过提供文本字段的完整值或仅提供部分字符串值来使用正则表达式搜索文档。
- en: Numbers
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字
- en: 'A number is JSON''s basic data type. A JSON document does not specify whether
    a number is an integer, a float, or *long*:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 数字是JSON的基本数据类型。 JSON文档不指定数字是整数，浮点数还是*长*：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, MongoDB supports the following types of numbers:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，MongoDB支持以下类型的数字：
- en: '`double`: 64-bit floating point'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`：64位浮点'
- en: '`int`: 32-bit signed integer'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`：32位有符号整数'
- en: '`long`: 64-bit unsigned integer'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long`：64位无符号整数'
- en: '`decimal`: 128-bit floating point – which is IEE 754-compliant'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decimal`：128位浮点 - 符合IEE 754标准'
- en: When you are working with a programming language, you don't have to worry about
    these data types. You can simply program using the language's native data types.
    The MongoDB drivers for respective languages take care of encoding the language-specific
    numbers to one of the previously listed data types.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用编程语言时，您不必担心这些数据类型。您可以简单地使用语言的本机数据类型进行编程。各种语言的MongoDB驱动程序负责将语言特定的数字编码为先前列出的数据类型之一。
- en: 'If you are working on the mongo shell, you get three wrappers to handle: `integer`,
    `long`, and `decimal`. The Mongo shell is based on JavaScript, and thus all the
    documents are represented in JSON format. By default, it treats any number as
    a 64-bit floating point. However, if you want to explicitly use the other types,
    you can use the following wrappers.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在mongo shell上工作，您将获得三个包装器来处理：`integer`，`long`和`decimal`。 Mongo shell基于JavaScript，因此所有文档都以JSON格式表示。默认情况下，它将任何数字视为64位浮点数。但是，如果要明确使用其他类型，可以使用以下包装器。
- en: '`NumberInt`: The `NumberInt` constructor can be used if you want the number
    to be saved as a 32-bit integer and not as a 64-bit float:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`NumberInt`：如果要将数字保存为32位整数而不是64位浮点数，则可以使用`NumberInt`构造函数：'
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding snippet, the first number, `plainNum`, is initialized with
    a sequence of digits without mentioning any explicit data type. Therefore, by
    default, it will be treated as a *64-bit floating-point number* (also known as
    a **double**).
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在上面的片段中，第一个数字`plainNum`是使用未提及任何显式数据类型的数字序列初始化的。因此，默认情况下，它将被视为*64位浮点数*（也称为**double**）。
- en: '`explicitInt`, however, is initialized with an integer-type constructor and
    a string representation of a number, and so MongoDB reads the number in an argument
    as a *32-bit integer*.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是，`explicitInt`是使用整数类型构造函数和数字的字符串表示初始化的，因此MongoDB将参数中的数字读取为*32位整数*。
- en: However, in the `explicitInt_double` initialization, the number provided in
    the constructor argument doesn't have double quotes. Therefore, it will be treated
    as a *64-bit float*—that is, a **double**—and used to form a *32-bit integer*.
    But as the provided number fits in the integer range, no change is seen.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是，在`explicitInt_double`初始化中，构造函数参数中提供的数字没有双引号。因此，它将被视为*64位浮点数* - 也就是**double**
    - 并用于形成*32位整数*。但是，由于提供的数字适合整数范围，因此不会看到任何更改。
- en: 'When you print the preceding numbers, they look as follows:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您打印上述数字时，它们看起来如下：
- en: '![Figure 2.4: Output for the plainNum, explicitInt, and explicitInt_double'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：plainNum，explicitInt和explicitInt_double的输出
- en: '](img/B15507_02_04.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_04.jpg)'
- en: 'Figure 2.4: Output for the plainNum, explicitInt, and explicitInt_double'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：plainNum，explicitInt和explicitInt_double的输出
- en: '`NumberLong`: `NumberLong` wrappers are similar to `NumberInt`. The only difference
    is that they are stored as 64-bit integers. Let''s try it on the shell:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`NumberLong`：`NumberLong`包装器类似于`NumberInt`。唯一的区别是它们存储为64位整数。让我们在shell上尝试一下：'
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s print the documents in the shell:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在shell中打印文档：
- en: '![Figure 2.5: MongoDB shell output'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5：MongoDB shell输出'
- en: '](img/B15507_02_05.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_05.jpg)'
- en: 'Figure 2.5: MongoDB shell output'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：MongoDB shell输出
- en: '`NumberDecimal`: This wrapper stores the given number as a 128-bit IEEE 754
    decimal format. The `NumberDecimal` constructor accepts both a string and a double
    representation of the number:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`NumberDecimal`：此包装器将给定数字存储为128位IEEE 754十进制格式。`NumberDecimal`构造函数接受数字的字符串和双精度表示：'
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We are passing a string representation of a decimal number to `explicitDecimal`.
    However, `explicitDecimal_double` is created using a `double`. When we print the
    results, they appear slightly differently:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个十进制数的字符串表示传递给`explicitDecimal`。但是，`explicitDecimal_double`是使用`double`创建的。当我们打印结果时，它们看起来略有不同：
- en: '![Figure 2.6: Output for explicitDecimal and explicitDecimal_double'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6：explicitDecimal和explicitDecimal_double的输出'
- en: '](img/B15507_02_06.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_06.jpg)'
- en: 'Figure 2.6: Output for explicitDecimal and explicitDecimal_double'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：explicitDecimal和explicitDecimal_double的输出
- en: The second number has been appended with trailing zeros. This is because of
    the internal parsing of the numbers. When we pass a double value to `NumberDecimal`,
    the argument is parsed to BSON's double, which is then converted to a 128-bit
    decimal with a precision of 15 digits.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个数字已附加尾随零。这是由于数字的内部解析。当我们将双精度值传递给`NumberDecimal`时，参数被解析为BSON的双精度，然后转换为具有15位数字精度的128位小数。
- en: 'During this conversion, the decimal numbers are rounded off and may lose precision.
    Let''s look at the following example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在此转换过程中，十进制数将四舍五入并可能失去精度。让我们看下面的例子：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s print the numbers and inspect the output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打印数字并检查输出：
- en: '![Figure 2.7: Output for dec and decDbl'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：dec和decDbl的输出
- en: '](img/B15507_02_07.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_07.jpg)'
- en: 'Figure 2.7: Output for dec and decDbl'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：dec和decDbl的输出
- en: It is evident that when a double is passed to `NumberDecimal`, there is a chance
    of a loss of precision. Therefore, it is important to always use string-based
    constructors when using `NumberDecimal`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，当双精度值传递给`NumberDecimal`时，存在失去精度的可能。因此，在使用`NumberDecimal`时始终使用基于字符串的构造函数非常重要。
- en: Booleans
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'The Boolean data type is used to represent whether something is true or false.
    Therefore, the value of a valid Boolean field is either `true` or `false`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔数据类型用于表示某事是真还是假。因此，有效布尔字段的值要么是`true`，要么是`false`：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The values do not have double quotes. If you wrap them in double quotes, they
    will be treated as strings.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 值没有双引号。如果您用双引号括起来，它们将被视为字符串。
- en: Objects
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象
- en: The object fields are used to represent nested or embedded documents—that is,
    a field whose value is another valid JSON document.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字段用于表示嵌套或嵌入文档，即其值是另一个有效的JSON文档。
- en: 'Let''s take a look at the following example from the airbnb dataset:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下来自airbnb数据集的以下示例：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The value of the host field is another valid JSON. MongoDB uses a dot notation
    (`.`) to access the embedded objects. To access an embedded document, we will
    create a variable of the listing on the mongo shell:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 主机字段的值是另一个有效的JSON。MongoDB使用点表示法（`.`）来访问嵌入对象。要访问嵌入文档，我们将在mongo shell上创建一个列表的变量：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To print only the host details, use the dot notation (`.`) to get the embedded
    object, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅打印主机详细信息，请使用点表示法（`.`）获取嵌入对象，如下所示：
- en: '![Figure 2.8: Output for the embedded object'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.8：嵌入对象的输出'
- en: '](img/B15507_02_08.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_08.jpg)'
- en: 'Figure 2.8: Output for the embedded object'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：嵌入对象的输出
- en: 'Using a similar notation, you can also access a specific field of the embedded
    document as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似的表示法，您还可以访问嵌入文档的特定字段，如下所示：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Embedded documents can have further documents within them. Having embedded documents
    makes a MongoDB document a piece of self-contained information. To record the
    same information in an RDBMS database, you will have to create the listing and
    the host as two separate tables with a foreign key reference in between, and join
    the data from both tables to get a piece of information.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入文档可以包含其中的更多文档。具有嵌入文档使MongoDB文档成为一个自包含的信息片段。要在RDBMS数据库中记录相同的信息，您将不得不创建列表和主机作为两个单独的表，并在两者之间创建一个外键引用，并从两个表中获取信息。
- en: Along with embedded documents, MongoDB also supports links between the documents
    of two different collections, which resembles having foreign key references.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了嵌入文档之外，MongoDB还支持两个不同集合的文档之间的链接，这类似于具有外键引用。
- en: 'Exercise 2.02: Creating Nested Objects'
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.02：创建嵌套对象
- en: Your organization is happy with the movie representation so far. Now they have
    come up with a requirement to include the IMDb ratings and the number of votes
    that derived the rating. They also want to incorporate Tomatometer ratings, which
    include the user ratings and critics ratings along with fresh and rotten scores.
    Your task is to modify the document to update the `imdb` field to include the
    number of votes and add a new field called `tomatoes`, which contains the Rotten
    Tomato ratings.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您的组织对电影表示感到满意。现在他们提出了一个要求，要包括IMDb评分和导致评分的投票数。他们还希望包含番茄表评分，其中包括用户评分和评论家评分以及新鲜和烂的分数。您的任务是修改文档，更新`imdb`字段以包括投票数，并添加一个名为`tomatoes`的新字段，其中包含烂番茄评分。
- en: 'Recall the JSON document of a sample movie record that you created in *Exercise
    2.01*, *Creating Your Own JSON Document*:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下您在*练习2.01*中创建的样本电影记录的JSON文档，*创建您自己的JSON文档*：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following steps will help modify the IMDb ratings:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助修改IMDb评分：
- en: 'The existing `imdb_rating` field indicates the IMDb rating score, so add an
    additional field to represent the vote count. However, both fields are closely
    related to each other and will always be used together. Therefore, group them
    together in a single document:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现有的`imdb_rating`字段表示IMDb评分，因此添加一个额外的字段来表示投票数。然而，这两个字段彼此密切相关，并且将始终一起使用。因此，将它们组合在一个单独的文档中：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding document with two fields represents the complete IMDb rating.
    Replace the current `imdb_rating` field with the one you just created:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的文档具有两个字段，表示完整的IMDb评分。用您刚创建的字段替换当前的`imdb_rating`字段：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This `imdb` field with its value of an embedded object represents the IMDb ratings.
    Now, add the Tomatometer ratings.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个带有嵌入对象值的`imdb`字段表示IMDb评分。现在，添加番茄表评分。
- en: 'As stated previously, the Tomatometer rating includes viewer ratings and critics
    ratings, along with the fresh score and the rotten score. Like the IMDb ratings,
    both `Viewer Ratings` and `Critics Ratings` will have a `rating` field and a `votes`
    field. Write these two documents separately:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，番茄表评分包括观众评分和评论家评分，以及新鲜分数和烂分数。与IMDb评分一样，`观众评分`和`评论家评分`都将有一个`评分`字段和一个`投票`字段。分别编写这两个文档：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As both ratings are related, group them together in a single document:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于两个评分相关，将它们组合在一个单独的文档中：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the `fresh` and `rotten` scores as per the description:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据描述添加`fresh`和`rotten`分数：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following output represents the Tomatometer ratings with the new `tomatoes`
    field in our movie record:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出表示了我们电影记录中新的`tomatoes`字段的番茄表评分：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, validate your document with any online JSON validator (in our case,
    [https://jsonlint.com/](https://jsonlint.com/)). Click on `Validate JSON` to validate
    the code:![Figure 2.9: Validation of the JSON document'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用任何在线JSON验证器（在我们的案例中，[https://jsonlint.com/](https://jsonlint.com/)）验证您的文档。单击“验证JSON”以验证代码：![图2.9：验证JSON文档
- en: '](img/B15507_02_09.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_09.jpg)'
- en: 'Figure 2.9: Validation of the JSON document'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：验证JSON文档
- en: Your movie record is now updated with detailed IMBb ratings and the new `tomatoes`
    rating. In this exercise, you practiced creating two nested documents to represent
    IMDb ratings and Tomatometer ratings. Now that we have covered nested or embedded
    objects, let's learn about arrays.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您的电影记录现在已更新为详细的IMBb评分和新的`tomatoes`评分。在这个练习中，您练习了创建两个嵌套文档来表示IMDb评分和番茄表评分。现在我们已经涵盖了嵌套或嵌入对象，让我们了解一下数组。
- en: Arrays
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: 'A field with an **array** type has a collection of zero or more values. In
    MongoDB, there is no limit to how many elements an array can contain or how many
    arrays a document can have. However, the overall document size should not exceed
    16 MB. Consider the following example array containing four numbers:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 具有**数组**类型的字段具有零个或多个值的集合。在MongoDB中，数组可以包含的元素数量或文档可以拥有的数组数量没有限制。但是，整个文档大小不应超过16
    MB。考虑以下包含四个数字的示例数组：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Each element in an array can be accessed using its index position. While accessing
    an element on a specific index position, the index number is enclosed in square
    brackets. Let''s print the third element in the array:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用其索引位置访问数组中的每个元素。在访问特定索引位置上的元素时，索引号用方括号括起来。让我们打印数组中的第三个元素：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Indexes are always zero-based. The index position `3` denotes the fourth element
    in the array.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 索引始终从零开始。索引位置`3`表示数组中的第四个元素。
- en: 'Using the index position, you can also add new elements to an existing array,
    as in the following example:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用索引位置，您还可以向现有数组添加新元素，如下例所示：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Upon printing the array, you will see that the fifth element has been added
    correctly, which contains the index position, `4`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 打印数组后，您将看到第五个元素已正确添加，其中包含索引位置`4`：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Just like objects having embedded objects, arrays can also have embedded arrays.
    The following syntax adds an embedded array into the sixth element:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 就像对象具有嵌入对象一样，数组也可以具有嵌入数组。以下语法将嵌入数组添加到第六个元素中：
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you print the array, you will see the embedded array as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果打印数组，您将看到嵌入数组如下所示：
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, you can use the square notation, `[]`, to access the elements of a specific
    index in the embedded array, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用方括号`[]`来访问嵌入数组中特定索引的元素，如下所示：
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The array can contain any MongoDB valid data type fields. This can be seen
    in the following snippet:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以包含任何MongoDB有效的数据类型字段。这可以在以下代码片段中看到：
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Exercise 2.03: Using Array Fields'
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.03：使用数组字段
- en: 'In order to add comment details for each movie, your organization wants you
    to include full text of the comment along with user details such as name, email,
    and date. Your task is to prepare two dummy comments and add them to the existing
    movie record. In *Exercise 2.02*, *Creating Nested Objects*, you developed a movie
    record in a document format, which looks as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为每部电影添加评论详细信息，您的组织希望您包括评论的全文以及用户详细信息，如姓名、电子邮件和日期。您的任务是准备两条虚拟评论并将它们添加到现有的电影记录中。在*练习2.02*中，*创建嵌套对象*，您以文档格式开发了一条电影记录，如下所示：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Build upon this document to add additional information by executing the following steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下步骤构建此文档以添加附加信息：
- en: 'Create two comments and list the details:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两条评论并列出详细信息：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Split the two comments into separate documents as follows:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个注释拆分为单独的文档，如下所示：
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There are two comments in two separate documents, and you can easily fit them
    in the movie record as `comment_1` and `comment_2`. However, as the number of
    comments will increase, it will be difficult to count their number. To overcome
    this, we will use an array, which implicitly assigns an index position to each element.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 有两条评论在两个单独的文档中，您可以轻松地将它们放入电影记录中作为`comment_1`和`comment_2`。但是，随着评论数量的增加，将很难计算它们的数量。为了克服这一点，我们将使用一个数组，它隐式地为每个元素分配索引位置。
- en: 'Add both comments to an array as follows:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两条评论添加到数组中，如下所示：
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'An array gives you the opportunity to add as many comments as you want. Also,
    because of the implicit indexes, you are free to access any comment via its dedicated
    index position. Once you add this array in the movie record, the output will appear
    as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 数组为您提供了添加尽可能多的评论的机会。此外，由于隐式索引，您可以自由地通过其专用索引位置访问任何评论。一旦将此数组添加到电影记录中，输出将如下所示：
- en: '[PRE42]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, validate the JSON document with an online validator (for example, [https://jsonlint.com/](https://jsonlint.com/)).
    Click `Validate JSON` to validate the code:![Figure 2.10: Validation of the JSON
    document'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用在线验证器（例如，[https://jsonlint.com/](https://jsonlint.com/)）验证JSON文档。单击“验证JSON”以验证代码：![图2.10：验证JSON文档
- en: '](img/B15507_02_10.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_10.jpg)'
- en: 'Figure 2.10: Validation of the JSON document'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10：验证JSON文档
- en: We can see that our movie record now has user comments. In this exercise, we
    have modified our movie record to practice creating array fields. Now it is time
    to move on to the next data type, `null`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的电影记录现在有用户评论。在这个练习中，我们修改了我们的电影记录以练习创建数组字段。现在是时候转到下一个数据类型，`null`。
- en: 'Null'
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'Null'
- en: 'Null is a special data type in a document and denotes a field that does not
    contain a value. The `null` field can have only `null` as the value. You will
    print the object in the following example, which will result in the `null` value:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Null是文档中的一种特殊数据类型，表示不包含值的字段。`null`字段只能有`null`作为值。在下面的示例中，您将打印对象，这将导致`null`值：
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Build upon the array we created in the *Arrays* section:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在*数组*部分创建的数组上进行构建：
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, create a new variable and initialize it to `null` by inserting the variable
    in the next index position:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个新变量并将其初始化为`null`，通过将变量插入到下一个索引位置：
- en: '[PRE45]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, print this array to see the `null` field:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打印此数组以查看`null`字段：
- en: '[PRE46]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ObjectId
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ObjectId
- en: Every document in a collection must have an `_id` that contains a unique value.
    This field acts as a *primary key* to these documents. The primary keys are used
    to uniquely identify the documents, and they are always indexed. The value of
    the `_id` field must be unique in a collection. When you work with any dataset,
    each dataset represents a different context, and based on the context, you can
    identify whether your data has a primary key. For example, if you are dealing
    with the users' data, the users' email addresses will always be unique and can
    be considered the most appropriate `_id` field. However, for some datasets that
    do not have a unique key, you can simply omit the `_id` field.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 集合中的每个文档都必须有一个包含唯一值的“_id”。这个字段充当这些文档的*主键*。主键用于唯一标识文档，并且它们总是被索引的。“_id”字段的值在集合中必须是唯一的。当您使用任何数据集时，每个数据集代表不同的上下文，并且根据上下文，您可以确定您的数据是否有主键。例如，如果您处理用户数据，用户的电子邮件地址将始终是唯一的，并且可以被视为最合适的“_id”字段。然而，对于一些没有唯一键的数据集，您可以简单地省略“_id”字段。
- en: If you insert a document without an `_id` field, the MongoDB driver will autogenerate
    a unique ID and add it to the document. So, when you retrieve the inserted document,
    you will find `_id` is generated with a unique value of random text. When the
    `_id` field is automatically added by the driver, the value is generated using `ObjectId`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您插入一个没有“_id”字段的文档，MongoDB驱动程序将自动生成一个唯一ID并将其添加到文档中。因此，当您检索插入的文档时，您会发现“_id”是用随机文本的唯一值生成的。当驱动程序自动添加“_id”字段时，该值是使用`ObjectId`生成的。
- en: 'The `ObjectId` value is designed to generate lightweight code that is unique
    across different machines. It generates a unique value of 12 bytes, where the
    first 4 bytes represent the timestamp, bytes 5 to 9 represent a random value,
    and the last 3 bytes are an incremental counter. Create and print an `ObjectId`
    value as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObjectId`值旨在生成跨不同机器唯一的轻量级代码。它生成一个唯一值的12个字节，其中前4个字节表示时间戳，第5到9个字节表示随机值，最后3个字节是递增计数器。创建并打印`ObjectId`值如下：'
- en: '[PRE47]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Print `uniqueID` on the next line:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行打印`uniqueID`：
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: MongoDB supports a technique called sharding, where a dataset is distributed
    and stored on different machines. When a collection is sharded, its documents
    are physically located on different machines. Even so, `ObjectId` can ensure that
    the values will be unique in the collection across different machines. If the
    collection is sorted using the `ObjectId` field, the order will be based on the
    document creation time. However, the timestamp in `ObjectId` is based on the number
    of seconds to epoch time. Hence, documents inserted within the same second may
    appear in a random order. The `getTimestamp()` method on `ObjectId` tells us the
    document insertion time.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB支持一种称为分片的技术，其中数据集被分布并存储在不同的机器上。当一个集合被分片时，它的文档被物理地位于不同的机器上。即使如此，“ObjectId”也可以确保在不同机器上的集合中的值是唯一的。如果使用“ObjectId”字段对集合进行排序，顺序将基于文档创建时间。然而，“ObjectId”中的时间戳是基于秒数到纪元时间。因此，在同一秒内插入的文档可能以随机顺序出现。“ObjectId”上的`getTimestamp()`方法告诉我们文档插入时间。
- en: Dates
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期
- en: The JSON specifications do not support date types. All the dates in JSON documents
    are represented as plain strings. The string representations of dates are difficult
    to parse, compare, and manipulate. MongoDB's BSON format, however, supports **Date**
    types explicitly.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: JSON规范不支持日期类型。JSON文档中的所有日期都表示为纯字符串。日期的字符串表示形式很难解析、比较和操作。然而，MongoDB的BSON格式明确支持**日期**类型。
- en: The MongoDB dates are stored in the form of milliseconds since the Unix epoch,
    which is January 1, 1970\. To store the millisecond's representation of a date,
    MongoDB uses a 64-bit integer (`long`). Because of this, the date fields have
    a range of around +/-290 million years since the Unix epoch. One thing to note
    is that all dates are stored in *UTC*, and there is no *time zone* associated
    with them.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB日期以自Unix纪元以来的毫秒形式存储，即1970年1月1日。为了存储日期的毫秒表示，MongoDB使用64位整数（`long`）。由于这个原因，日期字段的范围大约为自Unix纪元以来的+-290百万年。需要注意的一点是所有日期都以*UTC*存储，并且没有与它们相关联的*时区*。
- en: 'While working on the mongo shell, you can create `Date` instances using `Date()`,
    `new Date()`, or `new ISODate()`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在mongo shell上工作时，您可以使用`Date()`、`new Date()`或`new ISODate()`创建`Date`实例。
- en: Note
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Dates created with a new `Date()` constructor or a new `ISODate()` constructor
    are always in UTC, and ones created with `Date()` will be in the local time zone.
    An example of this is given next.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的`Date()`构造函数或新的`ISODate()`构造函数创建的日期始终是UTC时间，而使用`Date()`创建的日期将是本地时区的时间。下面给出一个例子。
- en: '[PRE49]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: When a `Date()` type is used to construct a date, it uses JavaScript's date
    representation, which is in the form of plain strings. These dates represent the
    date and time based on your current time zone. However, being in string formats,
    they are not useful for comparison or manipulation.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`Date()`类型来构造日期时，它使用JavaScript的日期表示，这是以纯字符串形式的。这些日期表示基于您当前的时区的日期和时间。然而，作为字符串格式，它们对于比较或操作是没有用的。
- en: 'If you add the `new` keyword to the `Date` constructor, you get the BSON date
    that is wrapped in `ISODate()` as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`new`关键字添加到`Date`构造函数中，您将得到包装在`ISODate()`中的BSON日期，如下所示：
- en: '[PRE50]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can also use the `ISODate()` constructor directly to create `date` objects
    as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以直接使用`ISODate()`构造函数创建`date`对象，如下所示：
- en: '[PRE51]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: These dates can be manipulated, compared, and searched.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这些日期可以被操作、比较和搜索。
- en: Note
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As per the MongoDB documentation, not all drivers support 64-bit date encodings.
    However, all the drivers support encoding dates having the year ranging from 0
    to 9999.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 根据MongoDB文档，不是所有的驱动程序都支持64位日期编码。然而，所有的驱动程序都支持编码年份范围从0到9999的日期。
- en: Timestamps
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间戳
- en: The timestamp is a 64-bit representation of date and time. Out of the 64 bits,
    the first 32 bits store the number of seconds since the Unix epoch time, which
    is January 1, 1970\. The other 32 bits indicate an incrementing counter. The timestamp
    type is exclusively used by MongoDB for internal operations.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 时间戳是日期和时间的64位表示。在这64位中，前32位存储自Unix纪元时间以来的秒数，即1970年1月1日。另外32位表示一个递增的计数器。时间戳类型是MongoDB专门用于内部操作的。
- en: Binary Data
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二进制数据
- en: 'Binary data, also called `BinData`, is a BSON data type for storing data that
    exists in a binary format. This data type gives you the ability to store almost
    anything in the database, including files such as text, videos, music, and more.
    `BinData` can be mapped with a binary array in your programming language as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数据，也称为`BinData`，是一种用于存储以二进制格式存在的数据的BSON数据类型。这种数据类型使您能够在数据库中存储几乎任何东西，包括文本、视频、音乐等文件。`BinData`可以与编程语言中的二进制数组进行映射，如下所示：
- en: '![Figure 2.11: Binary array'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.11：二进制数组'
- en: '](img/B15507_02_11.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_11.jpg)'
- en: 'Figure 2.11: Binary array'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11：二进制数组
- en: 'The first argument to `BinData` is a binary subtype to indicate the type of
    information stored. The zero value stands for plain binary data and can be used
    with text or media files. The second argument to `BinData` is a *base64*-encoded
    text file. You can use the binary data field in a document as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinData`的第一个参数是一个二进制子类型，用于指示存储的信息类型。零值代表普通二进制数据，可以与文本或媒体文件一起使用。`BinData`的第二个参数是*base64*编码的文本文件。您可以在文档中使用二进制数据字段，如下所示：'
- en: '[PRE52]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We will cover MongoDB's document size limit in the upcoming section.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的部分介绍MongoDB的文档大小限制。
- en: Limits and Restrictions on Documents
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档的限制和限制
- en: So far, we have discussed the importance and benefits of using documents. Documents
    play a major role in building efficient applications, and they improve overall
    data usability. We know how documents offer a flexible way to represent data in
    its most natural form. They are often self-contained and can hold a complete unit
    of information. The self-containment comes from nested objects and arrays.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了使用文档的重要性和好处。文档在构建高效应用程序中起着重要作用，并且它们提高了整体数据的可用性。我们知道文档以最自然的形式提供了一种灵活的表示数据的方式。它们通常是自包含的，可以容纳完整的信息单元。自包含性来自嵌套对象和数组。
- en: 'To use any database effectively, it is important to have the correct data structure.
    The incorrect data structures you build today may result in lots of pain in the
    future. In the long term, as your application''s usage grows, the amount of data
    also grows, and the problems that seemed very small initially become more evident.
    Then comes the obvious question: how do you know whether your data structure is
    correct?'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要有效地使用任何数据库，正确的数据结构是很重要的。您今天构建的不正确的数据结构可能会在未来带来很多痛苦。从长远来看，随着应用程序的使用量增加，数据量也会增加，最初似乎很小的问题变得更加明显。然后显而易见的问题就来了：您如何知道您的数据结构是否正确？
- en: Your application will tell you the answer. If, to access a certain piece of
    information, your application must execute multiple queries to the database and
    combine all the results to get the final information, then it will slow down the
    overall throughput. Contrastingly, if a single query on the database returns too
    much information in a single result, your application will have to scan through
    the entire result set and grab the intended piece of information. This will cause
    higher memory consumption, stale objects, and finally, slower performance.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序会告诉您答案。如果要访问某个信息，您的应用程序必须执行多个查询到数据库，并组合所有结果以获取最终信息，那么它将减慢整体吞吐量。相反，如果数据库上的单个查询返回了太多信息，您的应用程序将不得不扫描整个结果集并获取所需的信息。这将导致更高的内存消耗，过时的对象，最终导致性能下降。
- en: Thus, MongoDB has put some limits and restrictions on documents. One thing to
    note is that the restrictions are not because of database limitations or shortcomings.
    The restrictions are added so that the overall database platform can perform efficiently.
    We have already covered the flexibility that MongoDB documents offer; now it is
    important to know the restrictions.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，MongoDB对文档进行了一些限制和限制。需要注意的一点是，这些限制并不是因为数据库的限制或缺陷。这些限制是为了使整体数据库平台能够高效运行。我们已经介绍了MongoDB文档提供的灵活性；现在重要的是要了解这些限制。
- en: Document Size Limit
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档大小限制
- en: A document with too much information is bad in many ways. For this reason, MongoDB
    puts a limit of 16 MB on the size of every document in the collection. The limit
    of 16 MB is enough to store the right information. A collection can have as many
    documents as you want. There is no limitation on the size of a collection. Even
    if a collection exceeds the space of the underlying system, you can use vertical
    or horizontal scaling to increase the capacity of the collection.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 包含过多信息的文档在许多方面都是不好的。因此，MongoDB对集合中每个文档的大小限制为16 MB。16 MB的限制足以存储正确的信息。一个集合可以有任意多的文档。集合的大小没有限制。即使集合超出了底层系统的空间，您也可以使用垂直或水平扩展来增加集合的容量。
- en: The flexibility and self-containment of documents may tempt developers to put
    in too much information and create bulky documents. Oversized documents are usually
    an indication of bad design. Most of the time, your applications do not need all
    the information. A good database design considers the needs of the application.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 文档的灵活性和自包含性可能会诱使开发人员放入过多的信息并创建臃肿的文档。超大型文档通常是糟糕设计的表现。大多数情况下，您的应用程序并不需要所有的信息。良好的数据库设计考虑了应用程序的需求。
- en: Imagine your application is an interface providing sales information from various
    stores, where users can search and find sold items by the item type or by the
    store location. Most of the time, it is your application that will be hitting
    the database and that too with a similar set of queries. Therefore, your application's
    needs play a major role in database design, especially when the user base grows,
    and your application starts getting thousands and millions of requests in a short
    period of time. All you want is faster queries, less processing, and less resource
    consumption.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的应用程序是一个提供来自各种商店的销售信息的界面，用户可以按商品类型或商店位置搜索和找到已售出的商品。大部分时间，是你的应用程序会频繁访问数据库，并且使用类似的查询。因此，你的应用程序的需求在数据库设计中起着重要作用，特别是当用户基数增长，你的应用程序开始在短时间内获得成千上万的请求。你所希望的是更快的查询，更少的处理和更少的资源消耗。
- en: 'Oversized documents are also expensive in terms of resource usage. When the
    documents are read from the system, they are held in memory and then transferred
    over the wire. Wire transfers are always slower. Then, your driver will map the
    received information to your programming language''s objects. Larger documents
    will result in too many bulky objects. Consider a sample document from a dummy
    sales record, as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 超大的文档在资源使用方面也很昂贵。当文档从系统中读取时，它们会被保存在内存中，然后通过网络传输。网络传输总是比较慢的。然后，你的驱动程序会将接收到的信息映射到你编程语言的对象中。更大的文档会导致太多的庞大对象。考虑一个来自虚拟销售记录的样本文档，如下所示：
- en: '[PRE53]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Although this document is just fine, there are some constraints. The `items`
    field is an array of the `items` object. If an order has too many `items`, the
    size of the array will increase, which will result in an increase in the size
    of the overall document. If your application allows multiple items per order and
    you have thousands of unique items in store, this document will easily become
    oversized. The best way to deal with such complex documents is to split the collection
    into two and have document links embedded within.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个文档很好，但也有一些限制。`items`字段是`items`对象的数组。如果一个订单有太多的`items`，数组的大小会增加，这将导致整个文档的大小增加。如果你的应用程序允许每个订单有多个项目，并且你的商店有成千上万个独特的项目，这个文档很容易变得过大。处理这种复杂文档的最佳方法是将集合拆分为两个，并在其中嵌入文档链接。
- en: Nesting Depth Limit
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套深度限制
- en: A MongoDB BSON document supports nesting up to 100 levels, which is more than
    enough. Nested documents are a great way to provide readable data. They provide
    complete information in one go and avoid multiple queries to gather a piece of information.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB BSON文档支持嵌套达到100级，这已经足够了。嵌套文档是提供可读数据的好方法。它们一次性提供完整的信息，避免多次查询来收集一部分信息。
- en: However, as the nesting level increases, performance and memory consumption
    issues arise. For example, consider a driver that is parsing the document to an
    object structure. During the scan, whenever a new sub-document is found, the scanner
    recursively enters the nested objects while maintaining a stack of already read
    information. This causes high memory utilization and slow performance.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着嵌套级别的增加，性能和内存消耗问题会出现。例如，考虑一个将文档解析为对象结构的驱动程序。在扫描过程中，每当发现一个新的子文档时，扫描器会递归进入嵌套对象，同时保持一个已读信息的堆栈。这会导致内存利用率高和性能慢。
- en: By setting the nesting limit of 100 levels, MongoDB avoids such issues. However,
    if you can't avoid such deep nesting, you can consider splitting the collections
    into two, or more, and have document references.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置100级的嵌套限制，MongoDB避免了这些问题。然而，如果无法避免这种深层嵌套，可以考虑将集合拆分为两个或更多，并引用文档。
- en: Field Name Rules
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段名称规则
- en: 'MongoDB has a few rules about document field names, which are listed as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB有一些关于文档字段名称的规则，列举如下：
- en: The field name cannot contain a **null** character.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字段名称不能包含**空**字符。
- en: Only the fields in an array or an embedded document can have a name starting
    with the dollar sign (`$`). For the top-level fields, the name cannot start with
    a dollar (`$`) sign.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有数组或嵌入文档中的字段才能以美元符号（`$`）开头。对于顶级字段，名称不能以美元（`$`）符号开头。
- en: Documents with duplicate field names are not supported. According to the MongoDB
    documentation, when a document with duplicate field names is inserted, no error
    will be thrown, but the document won't be inserted. Even the drivers will drop
    the documents silently. On the mongo shell, however, if such a document is inserted,
    it gets inserted correctly. However, the resulting document will have only the
    second field. That means the second occurrence of the field overwrites the value
    of the first.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不支持具有重复字段名称的文档。根据MongoDB文档，当插入具有重复字段名称的文档时，不会抛出错误，但文档也不会被插入。甚至驱动程序会悄悄地丢弃这些文档。然而，在mongo
    shell中，如果插入这样的文档，它会被正确插入。然而，结果文档只会有第二个字段。这意味着第二次出现的字段会覆盖第一个字段的值。
- en: Note
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: MongoDB (as of version 4.2.8) does not recommend field names starting with a
    dollar (`$`) sign or a dot (`.`). The MongoDB query language may not work correctly
    with such fields. Additionally, the drivers do not support them.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB（截至版本4.2.8）不建议字段名称以美元（`$`）符号或点（`.`）开头。MongoDB查询语言可能无法正确处理这些字段。此外，驱动程序也不支持它们。
- en: 'Exercise 2.04: Loading Data into an Atlas Cluster'
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.04：将数据加载到Atlas集群中
- en: 'Now that you have learned about documents and their structures, you can implement
    your learning on a business use case and observe MongoDB documents. In *Chapter
    1*, *Introduction to MongoDB*, you created a MongoDB Atlas account and initiated
    a cluster on the cloud. You will load sample datasets into this cluster. MongoDB
    Atlas provides sample datasets that can be loaded into the cluster by executing
    a few simple steps. These sample databases are large, real-life datasets that
    are made available for practice. The sample dataset in MongoDB Atlas has the following
    databases, where each database has multiple collections:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了文档及其结构，可以在业务用例上实施您的学习，并观察MongoDB文档。在*第1章*，*MongoDB简介*中，您创建了一个MongoDB
    Atlas账户，并在云上初始化了一个集群。您将在这个集群中加载示例数据集。MongoDB Atlas提供了可以通过执行几个简单步骤加载到集群中的示例数据集。这些示例数据库是大型的、真实的数据集，供练习使用。MongoDB
    Atlas中的示例数据集包括以下数据库，每个数据库都有多个集合：
- en: '`sample_mflix`'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sample_mflix`'
- en: '`sample_airbnb`'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sample_airbnb`'
- en: '`sample_geospatial`'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sample_geospatial`'
- en: '`sample_supplies`'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sample_supplies`'
- en: '`sample_training`'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sample_training`'
- en: '`sample_weatherdata`'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sample_weatherdata`'
- en: Of all these datasets, it will be the `sample_mflix` dataset that you deal with
    throughout this book. This is a huge database with over 23,000 movies and series
    records along with their ratings, comments, and other details. Before you learn
    about the database, import the database into our cluster and familiarize ourselves
    with its structure and components.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些数据集中，您将在本书中处理`sample_mflix`数据集。这是一个庞大的数据库，包括超过23,000部电影和系列记录，以及它们的评分、评论和其他详细信息。在了解数据库之前，将数据库导入到我们的集群中，并熟悉其结构和组件。
- en: 'The following are the steps to be executed in order to achieve the desired
    result:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是要执行的步骤，以实现所需的结果：
- en: 'Visit [https://cloud.mongodb.com/](https://cloud.mongodb.com/) and click to
    log in to your account:![Figure 2.12: Atlas login page'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://cloud.mongodb.com/](https://cloud.mongodb.com/)，并点击登录到您的账户：![图2.12：Atlas登录页面
- en: '](img/B15507_02_12.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_12.jpg)'
- en: 'Figure 2.12: Atlas login page'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12：Atlas登录页面
- en: 'Since you already have a cluster created on the cloud, upon login, the following
    screen displaying the cluster details will appear:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您已经在云上创建了一个集群，登录后将显示以下显示集群详细信息的屏幕：
- en: '![Figure 2.13: Cluster view'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.13：集群视图'
- en: '](img/B15507_02_13.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_13.jpg)'
- en: 'Figure 2.13: Cluster view'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13：集群视图
- en: 'Click on the (`…`) option available next to `COLLECTIONS`. A drop-down list
    displaying the following options will appear. Click `Load Sample Dataset`:![Figure
    2.14: The Load Sample Dataset option'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`COLLECTIONS`旁边的（`…`）选项。将出现一个下拉列表，显示以下选项。点击“加载示例数据集”：![图2.14：加载示例数据集选项
- en: '](img/B15507_02_14.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_14.jpg)'
- en: 'Figure 2.14: The Load Sample Dataset option'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14：加载示例数据集选项
- en: 'This opens a confirmation dialog that shows the total size of a sample dataset
    that will be loaded into your cluster:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个确认对话框，显示将加载到您的集群中的示例数据集的总大小：
- en: '![Figure 2.15: Load Sample Dataset confirmation'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.15：加载示例数据集确认'
- en: '](img/B15507_02_15.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_15.jpg)'
- en: 'Figure 2.15: Load Sample Dataset confirmation'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15：加载示例数据集确认
- en: 'Click `Load Sample Dataset`. You will see a message saying `Loading your sample
    dataset...` on the screen:![Figure 2.16: Loading your sample dataset… window'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“加载示例数据集”。您将在屏幕上看到一条消息，显示“正在加载您的示例数据集…”：![图2.16：加载您的示例数据集…窗口
- en: '](img/B15507_02_16.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_16.jpg)'
- en: 'Figure 2.16: Loading your sample dataset… window'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16：加载您的示例数据集…窗口
- en: It may take a few minutes to load the data and redeploy the cluster instances.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 加载数据并重新部署集群实例可能需要几分钟时间。
- en: 'Once the dataset has successfully loaded, you will see a success message saying
    `Sample dataset successfully loaded`:![Figure 2.17: Sample dataset successfully
    loaded'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据集成功加载后，您将看到一个成功消息，显示“示例数据集成功加载”：![图2.17：示例数据集成功加载
- en: '](img/B15507_02_17.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_17.jpg)'
- en: 'Figure 2.17: Sample dataset successfully loaded'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17：示例数据集成功加载
- en: As the dataset is loaded, you can also see charts showing information about
    the number of read and write operations performed on the dataset, the total connections,
    and the total size of the dataset.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集加载完成后，您还可以看到图表，显示有关数据集上执行的读取和写入操作数量、总连接数以及数据集的总大小的信息。
- en: 'Now, click `COLLECTIONS`. On the next screen, you will see the following list
    of available databases:![Figure 2.18: List of sample databases'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击“COLLECTIONS”。在下一个屏幕上，您将看到以下可用数据库的列表：![图2.18：示例数据库列表
- en: '](img/B15507_02_18.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_18.jpg)'
- en: 'Figure 2.18: List of sample databases'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18：示例数据库列表
- en: Click the down arrow next to `sample_mflix`.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`sample_mflix`旁边的向下箭头。
- en: Select the `movies` collection.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`movies`集合。
- en: 'Your result for the first 20 documents will be displayed as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 您的前20个文档的结果将显示如下：
- en: '![Figure 2.19: Movies collection on the cluster'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.19：集群上的电影集合'
- en: '](img/B15507_02_19.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_19.jpg)'
- en: 'Figure 2.19: Movies collection on the cluster'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19：集群上的电影集合
- en: In this exercise, we were able to load the `sample_mflix` database into our
    cluster. Let's now perform a simple activity that will help us put our understanding
    of everything we've learned in this chapter to practice.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们成功将`sample_mflix`数据库加载到了我们的集群中。现在，让我们进行一个简单的活动，帮助我们将本章学到的所有内容付诸实践。
- en: 'Activity 2.01: Modeling a Tweet into a JSON Document'
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动2.01：将推文建模为JSON文档
- en: Now that you understand JSON documents, the data types supported by MongoDB,
    and the document-based storage model, it's time to practice modeling a real-life
    entity into a valid JSON document format.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了JSON文档、MongoDB支持的数据类型以及基于文档的存储模型，是时候练习将现实生活中的实体建模为有效的JSON文档格式了。
- en: 'Your task is to prepare a valid JSON document to represent the data of a tweet.
    For this, use the dummy tweet shown in *Figure 2.20* From this tweet, identify
    all the various pieces of information that you can find, decide the field names
    and data types they can be represented with, prepare a JSON document with all
    the fields, and validate your document:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 您的任务是准备一个有效的JSON文档来表示推文的数据。为此，请使用*图2.20*中显示的虚拟推文，从这条推文中识别出所有各种信息，确定字段名称和它们可以表示的数据类型，准备一个包含所有字段的JSON文档，并验证您的文档：
- en: '![Figure 2.20: Sample tweet'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.20：示例推文'
- en: '](img/B15507_02_20.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_02_20.jpg)'
- en: 'Figure 2.20: Sample tweet'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20：示例推文
- en: 'The following steps will help you achieve the desired result:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您实现期望的结果：
- en: List all the objects that you see in the tweet, such as user ID, name, profile
    picture, tweet text, tags, and mentions.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出您在推文中看到的所有对象，例如用户ID、名称、个人资料图片、推文文本、标签和提及。
- en: Identify the set of closely related fields that can be grouped together. These
    groups of fields can be placed as embedded objects or arrays.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别可以分组在一起的一组相关字段。这些字段组可以作为嵌入对象或数组放置。
- en: Once you have created the JSON document, validate it using any JSON validator
    available online (for example, [https://jsonlint.com/](https://jsonlint.com/)).
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建JSON文档后，使用在线可用的任何JSON验证器对其进行验证（例如，[https://jsonlint.com/](https://jsonlint.com/)）。
- en: 'The following code represents the final JSON document with only a few fields revealed:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码表示最终的JSON文档，只显示了一些字段：
- en: '[PRE54]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15507_Solution_Final_SZ_ePub.xhtml#_idTextAnchor463).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以通过[此链接](B15507_Solution_Final_SZ_ePub.xhtml#_idTextAnchor463)找到。
- en: Summary
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered a detailed structure of MongoDB documents and
    document-based models, which is important before we dive into more advanced concepts
    in the upcoming chapters. We began our discussion with the transportation and
    storage of information in the form of JSON-like documents that provide a flexible
    and language-independent format. We studied an overview of JSON documents, the
    document structure, and basic data types, followed by BSON document specifications
    and differentiating between BSON and JSON on various parameters.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经涵盖了MongoDB文档和基于文档的模型的详细结构，在我们深入研究即将到来的更高级概念之前，这是很重要的。我们从以JSON样式的文档形式传输和存储信息开始讨论，这提供了一种灵活的、与语言无关的格式。我们研究了JSON文档的概述、文档结构和基本数据类型，接着是BSON文档规范，以及在各种参数上区分BSON和JSON。
- en: We then covered MongoDB documents, considering their flexibility, self-containment,
    relatability, and agility, as well as various data types provided by BSON. Finally,
    we made a note of MongoDB's limitations and restrictions for documents and learned
    why the limitations are imposed and why they are important.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们涵盖了MongoDB文档，考虑到它们的灵活性、自包含性、关联性和灵活性，以及BSON提供的各种数据类型。最后，我们注意到了MongoDB文档的限制和限制，并学习了为什么会施加这些限制以及它们为什么重要。
- en: In the next chapter, we will use the mongo shell and Mongo Compass to connect
    to an actual MongoDB server and manage user authentication and authorization.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用mongo shell和Mongo Compass连接到实际的MongoDB服务器，并管理用户身份验证和授权。
