- en: 5\. Inserting, Updating, and Deleting Documents
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 插入、更新和删除文档
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces you to the core operations in MongoDB, namely inserting,
    updating, and deleting documents in a collection. You will learn how to insert
    a single document or a batch of multiple documents into a MongoDB collection.
    You will add or autogenerate an `_id` field, replace existing documents, and update
    specific fields in the documents of an existing collection. Finally, you will
    learn how you can delete all or delete specific documents in a collection.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了MongoDB中的核心操作，即在集合中插入、更新和删除文档。您将学习如何将单个文档或一批多个文档插入到MongoDB集合中。您将添加或自动生成一个`_id`字段，替换现有文档，并更新现有集合中文档的特定字段。最后，您将学习如何删除集合中的所有文档或特定文档。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In previous chapters, we covered various database commands and queries. We learned
    to prepare query conditions and use them to find or count the matching documents.
    We also learned to use various conditional operators, logical operators, and regular
    expressions on fields, nested fields, and arrays. In addition to these, we learned
    how to format, skip, limit, and sort the documents in the result set.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们涵盖了各种数据库命令和查询。我们学会了准备查询条件并使用它们来查找或计算匹配的文档。我们还学会了在字段、嵌套字段和数组上使用各种条件运算符、逻辑运算符和正则表达式。除此之外，我们还学会了如何格式化、跳过、限制和对结果集中的文档进行排序。
- en: 'Now that you know how to correctly find and represent the required documents
    from a collection, the next step is to learn how to modify the documents in the
    collection. When working on any database management system, you will be required
    to modify the underlying data. Consider this: you are managing our movies dataset
    and are often required to add new movies to the collection as they release. You
    will also be required to permanently remove some movies or remove incorrectly
    inserted movies from the database. Over a period of time, some movies may receive
    new awards, reviews, and ratings. In such cases, you will need to modify the details
    of existing movies.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道如何正确地从集合中找到并表示所需的文档，下一步是学习如何修改集合中的文档。在任何数据库管理系统上工作时，您都将需要修改底层数据。想象一下：您正在管理我们的电影数据集，并经常需要在电影上映时向集合中添加新电影。您还需要永久删除一些电影或从数据库中删除错误插入的电影。随着时间的推移，一些电影可能会获得新的奖项、评论和评分。在这种情况下，您将需要修改现有电影的详细信息。
- en: In this chapter, you will learn how to create, delete, and update documents
    in a collection. We will start by creating new collections, adding one or more
    documents to a collection, and consider the importance of the unique primary key.
    We will then cover deleting all or deleting specific documents from a collection,
    as well as various delete functions provided by MongoDB and their characteristics.
    Next, you will learn how to replace existing documents from a collection and understand
    how MongoDB keeps the primary key unchanged. You will also see how to use the
    replace operation to perform an update or insert, which is also called upsert.
    Finally, you will learn to modify documents. MongoDB provides various update functions
    and a wide range of update operators that can be used in specific requirements.
    We will cover all of these functions in depth and practice with the operators.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何在集合中创建、删除和更新文档。我们将首先创建新的集合，向集合中添加一个或多个文档，并考虑唯一主键的重要性。然后，我们将介绍如何从集合中删除所有或删除特定文档，以及MongoDB提供的各种删除函数及其特性。接下来，您将学习如何替换集合中的现有文档，并了解MongoDB如何保持主键不变。您还将了解如何使用替换操作执行更新或插入，也称为upsert。最后，您将学习如何修改文档。MongoDB提供了各种更新函数和广泛的更新运算符，可用于特定需求。我们将深入研究所有这些函数，并练习使用这些运算符。
- en: Inserting Documents
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入文档
- en: 'In this section, you will learn to insert new documents into a MongoDB collection.
    MongoDB collections provide a function named `insert()`, which is used to create
    a new document in a collection. The function is executed on the collection and
    takes the document to be inserted as an argument. The syntax of this function
    is shown in the next command:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何向MongoDB集合中插入新文档。MongoDB集合提供了一个名为`insert()`的函数，用于在集合中创建新文档。该函数在集合上执行，并将要插入的文档作为参数。该函数的语法如下命令所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To see this in an example, open the mongo Shell, connect to the database cluster,
    and create a new database by using the `use CH05` command. You can give a different
    name to the database as per your preference. The database mentioned in this command
    will be created if it is not present earlier. In the following operation, we are
    inserting a movie with a `title` field and an `_id`, and the output is printed
    on the next line:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要在示例中查看此内容，请打开mongo Shell，连接到数据库集群，并使用`use CH05`命令创建一个新数据库。您可以根据自己的喜好给数据库取一个不同的名字。如果之前不存在该数据库，则该命令中提到的数据库将被创建。在以下操作中，我们正在插入一个带有`title`字段和`_id`的电影，并且输出将打印在下一行上：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this chapter, we will be inserting, updating, and deleting a lot of documents
    in collections, and we do not want to corrupt the existing `sample_mflix` dataset.
    For this reason, we are creating a different database and using it throughout
    the chapter. Exercises and activities are focused on real-world scenarios and
    will therefore use the `sample_mflix` dataset.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在集合中插入、更新和删除大量文档，并且我们不希望损坏现有的`sample_mflix`数据集。因此，我们正在创建一个不同的数据库，并在整个章节中使用它。练习和活动侧重于真实场景，并因此将使用`sample_mflix`数据集。
- en: 'This mongo shell snippet shows the execution of the `insert` command and the
    result on the next line. The result (`WriteResult`) shows that one record was
    successfully inserted. First perform a `find()` query and confirm whether the
    record was created as we wanted:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个mongo shell片段显示了`insert`命令的执行和下一行的结果。结果（`WriteResult`）显示成功插入了一条记录。首先执行一个`find()`查询，确认记录是否按我们的要求创建：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding query and its output verify the correct insertion of our document.
    However, notice that the collection of `new_movies` was never present, nor did
    we create it. Where did the document go?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的查询及其输出验证了我们文档的正确插入。但是，请注意，`new_movies`集合从未存在，也没有我们创建它。文档去哪了呢？
- en: 'To find that, you execute the `show collections` command on the shell. This
    command prints the names of all collections in the current database:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到它，您在shell上执行`show collections`命令。此命令打印当前数据库中所有集合的名称：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding snippet shows a new collection of `new_movies` is added to the
    database. This proves that, when a document `insert` command is executed, MongoDB
    will also create the given collection, if it does not exist already.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段显示了一个名为`new_movies`的新集合被添加到数据库中。这证明了当执行`insert`命令时，如果该集合不存在，MongoDB也会创建给定的集合。
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When a new document is inserted, MongoDB does not validate the name of the collection.
    A typo in the collection name will result in the document being added to a completely
    new collection. Also, by default, MongoDB does not have any schema associated
    with a collection. Because of this, by giving an incorrect collection name, you
    may accidentally end up adding your document to any other existing collection,
    and MongoDB will not complain. This is why you should always be careful about
    the collection names in your `insert` commands.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当插入新文档时，MongoDB不会验证集合的名称。集合名称中的拼写错误将导致文档被添加到一个全新的集合中。此外，默认情况下，MongoDB没有与集合关联的任何模式。因此，通过给出不正确的集合名称，您可能会意外地将您的文档添加到任何其他现有集合中，而MongoDB不会抱怨。这就是为什么您应该始终小心您的`insert`命令中的集合名称。
- en: Inserting Multiple Documents
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入多个文档
- en: 'When multiple documents need to be inserted into a collection, you can call
    the `insert()` function that you saw in the previous section multiple times, as
    shown here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要将多个文档插入到集合中时，可以多次调用在前一节中看到的`insert()`函数，如下所示：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'MongoDB collections also provide the `insertMany()` function, which is a function
    specifically meant for inserting multiple documents into a collection. As shown
    in the syntax that follows, this function takes one argument of an array containing
    one or more documents to be inserted:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB集合还提供了`insertMany()`函数，这是一个专门用于向集合中插入多个文档的函数。如下面的语法所示，此函数接受一个包含一个或多个要插入的文档的数组作为参数：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To use this function, create an array of all the documents to be inserted and
    then pass this array to the function. The array of the same four movies will look
    like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此函数，创建要插入的所有文档的数组，然后将此数组传递给函数。相同的四部电影的数组将如下所示：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, you insert these four new movies into the collection:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将这四部新电影插入到集合中：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding command uses `insertMany()` and passes an array of four movies
    to it. You can see the result in the following figure:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令使用了`insertMany()`并将一个包含四部电影的数组传递给它。您可以在下图中看到结果：
- en: '![Figure 5.1: Using insertMany() to pass an array of four movies'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1：使用insertMany()传递一个包含四部电影的数组'
- en: '](img/B15507_05_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_01.jpg)'
- en: 'Figure 5.1: Using insertMany() to pass an array of four movies'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：使用insertMany()传递一个包含四部电影的数组
- en: The result in the preceding operation contains two things. The first field is
    `acknowledged` with the value of `true`. This confirms the write operation was
    successfully performed. The second field of the result lists down all the `IDs`
    of the inserted documents. To insert multiple documents, it is preferable to use
    the `insertMany()` function, because insertion happens as a single operation.
    On the other hand, the insertion of each document separately will be executed
    as a number of different database commands and will make the process slower.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面操作的结果包含两个内容。第一个字段是`acknowledged`，其值为`true`。这确认了写操作已成功执行。结果的第二个字段列出了所有插入文档的`IDs`。要插入多个文档，最好使用`insertMany()`函数，因为插入作为单个操作进行。另一方面，单独插入每个文档将作为多个不同的数据库命令执行，并且会使过程变慢。
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can insert as many documents as you want using the function `insertMany()`.
    However, the batch size should not exceed 100,000\. On a mongo shell, if you try
    to insert more than 100,000 documents in a single batch, the query will fail.
    If you do the same thing using a programming language, the MongoDB driver will
    internally split a single operation into multiple batches of permissible sizes
    and perform the batch insert.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`insertMany()`函数插入尽可能多的文档。但是，批处理大小不应超过100,000。在mongo shell上，如果尝试在单个批处理中插入超过100,000个文档，查询将失败。如果使用编程语言做同样的事情，MongoDB驱动程序将在内部将单个操作拆分为多个允许大小的批次，并执行批量插入。
- en: Inserting Duplicate Keys
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入重复的键
- en: In any database system, a primary key is always unique in the table. Similarly,
    in MongoDB collections, the value expressed by the `_id` field is a primary key,
    and so it must be unique. If you try to insert a document whose key is already
    present in the collection, you will get a *Duplicate Key Error*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何数据库系统中，主键在表中始终是唯一的。同样，在MongoDB集合中，由`_id`字段表示的值是主键，因此必须是唯一的。如果尝试插入已经存在于集合中的键的文档，将会收到*重复键错误*。
- en: 'In the previous examples, we have already inserted a movie whose `_id` is `2`.
    Now we will try to duplicate the primary key in another `insert` operation:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们已经插入了一个`_id`为`2`的电影。现在我们将尝试在另一个`insert`操作中复制主键：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This `insert` operation inserts a dummy movie into the collection and explicitly
    mentions the `_id` field as `2`. When the command is executed, we get a duplicate
    key error with a detailed message, as can be seen in the following figure:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此`insert`操作将一个虚拟电影插入到集合中，并明确将`_id`字段指定为`2`。当执行该命令时，我们会收到一个详细的重复键错误消息，如下图所示：
- en: '![Figure 5.2: Error message for the duplicate _id field'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2：重复的_id字段的���误消息'
- en: '](img/B15507_05_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_02.jpg)'
- en: 'Figure 5.2: Error message for the duplicate _id field'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：重复的_id字段的错误消息
- en: 'Similarly, the operation of a bulk insert fails when one or more of the documents
    in the given array has a duplicate `_id`. For example, consider the following
    snippet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当给定数组中的一个或多个文档具有重复的`_id`时，批量插入操作将失败。例如，考虑以下代码片段：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, using the `insertMany()` operation, you will insert four different movies
    into your collection. However, the third movie has an `_id` of `2`, and we know
    that another movie with the same `_id` already exists. This leads to an error,
    as can be seen in the following figure:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用`insertMany()`操作，您将向集合中插入四部不同的电影。然而，第三部电影的`_id`为`2`，我们知道已经存在另一部具有相同`_id`的电影。这导致错误，如下图所示：
- en: '![Figure 5.3: Error message for the duplicate _id field'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3：重复_id字段的错误消息'
- en: '](img/B15507_05_03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_03.jpg)'
- en: 'Figure 5.3: Error message for the duplicate _id field'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：重复_id字段的错误消息
- en: 'When you execute the command, it fails with a detailed error message. The error
    message clearly indicates that the value of `2` is duplicated in the `_id` field.
    However, the value of `nInserted` indicates that two documents have been inserted
    successfully. To confirm this, you will query the database and observe the output:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行该命令时，它将失败并显示详细的错误消息。错误消息清楚地指出`_id`字段中的值`2`是重复的。然而，`nInserted`的值表明已成功插入了两个文档。为了确认这一点，您将查询数据库并观察输出：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: From the `find()` command and its output, shown in the previous snippet, we
    can conclude that the command failed while inserting the third document. However,
    the documents inserted before the third one will remain in the database.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的`find()`命令及其输出中，我们可以得出结论，该命令在插入第三个文档时失败。然而，在第三个文档之前插入的文档将保留在数据库中。
- en: Inserting without _id
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有_id的插入
- en: So far, we have learned the basics of creating new documents in a collection.
    In all the examples we showed up till now, we explicitly added a primary key (`_id`
    field). However, in *Chapter 2*, *Documents and Data Types*, we learned that while
    creating a new document, MongoDB verifies the presence and uniqueness of a given
    primary key and, if the primary key is not already present, the database autogenerates
    it and adds it into the document.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了在集合中创建新文档的基础知识。在我们到目前为止展示的所有示例中，我们都明确添加了主键（`_id`字段）。然而，在*第2章*，*文档和数据类型*中，我们学到，在创建新文档时，MongoDB会验证给定主键的存在和唯一性，如果主键尚不存在，数据库会自动生成它并将其添加到文档中。
- en: 'The following is a snippet from the mongo shell where an `insert` command is
    executed. The `insert` command is trying to push a new movie into the collection,
    but the document does not have an `_id` field. The result on the very next line
    shows that the document is successfully created inside the collection:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是mongo shell中执行`insert`命令的代码片段。`insert`命令试图将新电影推送到集合中，但文档没有`_id`字段。下一行的结果显示，文档已成功创建在集合中：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, you query the newly inserted document and see if it has the `_id` field.
    To do so, query the collection using the value of the `title` field:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您查询新插入的文档，并查看它是否具有`_id`字段。为此，使用`title`字段的值查询集合：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the previous snippet, the result shows that the document exists in the collection
    and an autogenerated `_id` field is added to the document. As we learned in *Chapter
    2*, *Documents and Data Types*, the autogenerated primary is derived from the
    `ObjectId` constructor and it is globally unique. The same is true for bulk inserts.
    For instance, consider the following snippet:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，结果显示文档存在于集合中，并且自动生成的`_id`字段已添加到文档中。正如我们在*第2章*，*文档和数据类型*中学到的，自动生成的主键来自`ObjectId`构造函数，它是全局唯一的。对于批量插入也是如此。例如，考虑以下代码片段：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, the `insertMany()` command is pushing four movies into the collection.
    Out of the four new documents, the third document does not have a primary key;
    however, the rest of the documents have respective primary keys. The result of
    this can be seen as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`insertMany()`命令将四部电影推送到集合中。在这四个新文档中，第三个文档没有主键；然而，其余的文档都有各自的主键。其结果如下所示：
- en: '![Figure 5.4: Inserting a movie without _id'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.4：插入没有_id的电影'
- en: '](img/B15507_05_04.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_04.jpg)'
- en: 'Figure 5.4: Inserting a movie without _id'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：插入没有_id的电影
- en: The output of the query indicates the query was successful, and the `insertedIds`
    field shows that all documents except the third were inserted with the given keys
    and the third document has got an autogenerated primary key.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 查询的输出表明查询成功，并且`insertedIds`字段显示除第三个文档外，所有文档都已使用给定的键插入，第三个文档获得了自动生成的主键。
- en: While working on datasets, our documents will have unique fields that can be
    used as primary keys. Primary keys are the ones that can uniquely identify a record.
    MongoDB's autogenerated keys are useful in terms of uniqueness, but they are meaningless
    in terms of the data the respective document represents. Also, these autogenerated
    keys are lengthy and thus tedious to type in or remember. Therefore, we should
    always try to use the primary keys that already exist in the datasets. For example,
    in a user's dataset, the `email_address` field is the best example of a primary
    key. However, in the case of movies, there is no field that can be unique. So,
    for the purpose of movies, we can use autogenerated primary keys.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数据集时，我们的文档将具有可用作主键的唯一字段。主键是可以唯一标识记录的字段。MongoDB自动生成的键在唯一性方面很有用，但在表示相应文档的数据方面是无意义的。此外，这些自动生成的键很长，因此输入或记住它们很麻烦。因此，我们应该始终尝试使用数据集中已经存在的主键。例如，在用户数据集中，`email_address`字段是主键的最佳示例。然而，在电影的情况下，没有可以是唯一的字段。因此，对于电影，我们可以使用自动生成的主键。
- en: In this section, we covered how to create a single as well as multiple documents
    in a collection. During this, we learned that in MongoDB an `insert` command also
    creates the underlying collection if it does not exist. We also learned that the
    primary keys need to be unique in a collection, and if a new document does not
    have a primary key, MongoDB autogenerates and adds it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了如何在集合中创建单个文档和多个文档。在此过程中，我们了解到在MongoDB中，`insert`命令还会在不存在时创建底层集合。我们还了解到主键在集合中需要是唯一的，如果新文档没有主键，MongoDB会自动生成并添加它。
- en: Deleting Documents
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除文档
- en: In this section, we will see how to remove the documents from a collection.
    To delete one or more documents from a collection, we have to use one of the various
    delete functions provided by MongoDB. Each of these functions has different behaviors
    and purposes. To delete documents from a collection, we have to use one of the
    delete functions and provide a query condition to specify which documents should
    be deleted. Let's take a look at this in detail.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何从集合中删除文档。要从集合中删除一个或多个文档，我们必须使用MongoDB提供的各种删除函数之一。每个函数都有不同的行为和目的。要从集合中删除文档，我们必须使用其中一个删除函数，并提供一个查询条件来指定应删除哪些文档。让我们详细看一下。
- en: Deleting Using deleteOne()
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用deleteOne()删除
- en: As the name suggests, the function `deleteOne()` is used to delete a single
    document from a collection. It accepts a document representing a query condition.
    Upon successful execution, it returns a document containing the total number of
    documents deleted (represented by the field `deletedCount`) and whether the operation
    was confirmed (given by the field `acknowledged`). However, as the method deletes
    only one document, the value of `deletedCount` is always one. If the given query
    condition matches more than one document in the collection, only the first document
    will be deleted.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，`deleteOne()`函数用于从集合中删除单个文档。它接受一个表示查询条件的文档。成功执行后，它返回一个包含删除的文档总数（由字段`deletedCount`表示）以及操作是否被确认（由字段`acknowledged`给出）的文档。然而，由于该方法只删除一个文档，`deletedCount`的值始终为1。如果给定的查询条件在集合中匹配多个文档，只有第一个文档将被删除。
- en: 'To see this, write a delete command using `deleteOne()` and see the results:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这一点，请使用`deleteOne()`编写一个删除命令并查看结果：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code snippet, you executed the `deleteOne()` command and passed
    a query condition of `{_id : 2}`. This means that you want to delete a document
    for which the value of `_id` is `2`. The output on the next line indicates that
    the deletion was successful.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码片段中，您执行了`deleteOne()`命令，并传递了一个查询条件`{_id: 2}`。这意味着您要删除`_id`值为`2`的文档。下一行的输出表明删除成功删除了。'
- en: 'Exercise 5.01: Deleting One of Many Matched Documents'
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.01：删除多个匹配的文档中的一个
- en: 'In this exercise, you will use a query that matches more than one document
    and verify that only the first document is deleted when you do this. Perform the
    following steps to complete this exercise:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用一个匹配多个文档的查询，并验证当您这样做时只有第一个文档被删除。执行以下步骤完成这个练习：
- en: 'Use a regular expression in a query to match all movies where the `title` field
    starts with the word `movie`, as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在查询中使用正则表达式，匹配所有`title`字段以单词`movie`开头的电影，如下所示：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following snippet from the mongo shell shows that when you use the preceding
    query condition in a `find()` query, you get four movies:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: mongo shell中的以下片段显示，当您在`find()`查询中使用前面的查询条件时，您会得到四部电影：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Use the same query condition with `deleteOne()` to match all movies with titles
    starting with the word `movie`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的查询条件和`deleteOne()`来匹配所有标题以单词`movie`开头的电影：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The output in the second line here confirms that only one document is deleted successfully.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第二行输出确认只有一个文档成功删除。
- en: 'To find out which document is deleted, execute the same `find()` query on your collection:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要找出哪个文档被删除了，请在您的集合上执行相同的`find()`查询：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding snippet confirms that, although all four documents matched the
    query condition, only the first document is deleted.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段证实，尽管所有四个文档都匹配了查询条件，但只有第一个文档被删除了。
- en: Deleting Multiple Documents Using deleteMany()
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用deleteMany()删除多个文档
- en: To delete multiple documents that match the given criteria, you can execute
    the `deleteOne()` function multiple times. However, in that case, each document
    will be deleted in a separate database command, which can slow down the performance.
    MongoDB collections provide the function `deleteMany()` to delete multiple documents
    in a single command.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了删除符合给定条件的多个文档，您可以多次执行`deleteOne()`函数。然而，在这种情况下，每个文档将在单独的数据库命令中被删除，这可能会降低性能。MongoDB集合提供了`deleteMany()`函数，可以在单个命令中删除多个文档。
- en: 'The `deleteMany()` function must be provided with a query condition, and all
    the documents that match the given query will be removed:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleteMany()`函数必须提供一个查询条件，所有匹配给定查询的文档将被删除：'
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `deleteMany()` command in the previous snippet uses the same regular expression
    used in the previous examples. The output in the next line indicates that all
    three movies whose titles start with the word "movie" are deleted.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个片段中的`deleteMany()`命令使用了前面示例中使用的相同的正则表达式。下一行的输出表明，所有标题以单词"movie"开头的三部电影都被删除了。
- en: The behavior of both of the delete functions, in terms of matching the documents
    to given query expressions, is similar to finding documents, as we saw in the
    previous chapter. Passing an empty query document is equivalent to not passing
    any filter, and thus, all the documents are matched.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在匹配给定查询表达式的文档方面，这两个删除函数的行为与我们在上一章中看到的查找文档的行为类似。传递一个空的查询文档等同于不传递任何过滤器，因此所有文档都被匹配。
- en: 'In the following example, both of the commands have been given an empty query document:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，这两个命令都被给予了一个空的查询文档：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `deleteOne()` function will delete the document that is found first. However,
    the `deleteMany()` function will delete all the documents in the collection. In
    the same manner, the following queries perform a **null** check on a non-existent
    field. In MongoDB, a non-existent field is considered to be **null** and so the
    given condition will match all of the documents in the collection:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleteOne()`函数将删除找到的第一个文档。但是，`deleteMany()`函数将删除集合中的所有文档。同样，以下查询对不存在的字段执行**null**检查。在MongoDB中，不存在的字段被视为**null**，因此给定条件将匹配集合中的所有文档：'
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike finding documents, delete operations are `write` operations, and they
    permanently change the state of the collection. Therefore, while writing query
    conditions, which include null checks, you should always ensure that there is
    no typo in the field name. An incorrect field name may lead to the removal of
    all documents from the collection.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与查找文档不同，删除操作是`write`操作，并且会永久改变集合的状态。因此，在编写查询条件时，包括空值检查，您应该始终确保字段名称没有拼写错误。不正确的字段名称可能导致从集合中删除所有文档。
- en: Deleting Using findOneAndDelete()
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用findOneAndDelete()进行删除
- en: 'Apart from the two delete methods we saw previously, there is another function
    named `findOneAndDelete()`, which, as the name indicates, finds and deletes one
    document from the collection. Although it behaves similarly to the `deleteOne()`
    function, it provides a few more options:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们之前看到的两种删除方法之外，还有另一个名为`findOneAndDelete()`的函数，正如其名称所示，它从集合中查找并删除一个文档。虽然它的行为类似于`deleteOne()`函数，但它提供了一些更多的选项：
- en: It finds one document and deletes it.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它找到一个文档并将其删除。
- en: If more than one document is found, only the first one will be deleted.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到多个文档，只有第一个会被删除。
- en: Once deleted, it returns the deleted document as a response.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦删除，它会将被删除的文档作为响应返回。
- en: In the case of multiple document matches, the `sort` option can be used to influence
    which document gets deleted.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个文档匹配的情况下，可以使用`sort`选项来影响哪个文档被删除。
- en: Projection can be used to include or exclude fields from the document in response.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投影可以用来在响应中包含或排除文档中的字段。
- en: 'Here, use `findOneAndDelete()` to delete a record and get the deleted document
    as a response:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用`findOneAndDelete()`来删除一条记录，并将删除的文档作为响应获取：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding snippet, the delete command finds a document by its `_id`.
    The response in the next line shows that the deleted document is returned in the
    response. This is a very useful feature. Firstly, because it clearly indicates
    which record was matched and deleted. Secondly, it allows you to further process
    the deleted record. In some cases, you may want to store the record in an archive
    collection, or you may want to inform some other system about this deletion. If
    the query matches multiple documents, only the first document gets deleted. However,
    you can use an option to sort the matched documents and control which document
    gets deleted, as can be seen in the following snippet:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，删除命令通过其`_id`找到一个文档。下一行的响应显示了被删除的文档。这是一个非常有用的功能。首先，因为它清楚地指示了匹配和删除的记录。其次，它允许您进一步处理已删除的记录。在某些情况下，您可能希望将记录存储在归档集合中，或者您可能希望通知其他系统进行此删除。如果查询匹配多个文档，只有第一个文档会被删除。但是，您可以使用选项对匹配的文档进行排序并控制哪个文档被删除，如下面的片段所示：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Using the preceding `insert` command, you have inserted five new documents
    into your collection. In the following snippet, you use the `findOneAndDelete()`
    command, which uses a regular expression to find those titles in the collection
    that start with the word `movie`. The query will match four documents; however,
    you will sort the `_id` field in descending order so that the document with the
    `_id` of 14 gets deleted:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上面的`insert`命令，您已经将五个新文档插入到您的集合中。在下面的片段中，您使用`findOneAndDelete()`命令，该命令使用正则表达式在集合中查找以单词`movie`开头的标题。查询将匹配四个文档；但是，您将按照降序排序`_id`字段，以便删除`_id`为14的文档：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This operation demonstrates how a sort option can influence which documents
    get deleted. Without providing the sort option, the document with an `_id` of
    11 will be deleted.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作演示了排序选项如何影响被删除的文档。如果不提供排序选项，将会删除`_id`为11的文档。
- en: 'As we have seen, this delete function always returns the deleted document in
    the response. We can also use the projection option to control the fields that
    are included or excluded in the document in response:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，这个删除函数总是在响应中返回被删除的文档。我们还可以使用投影选项来控制响应中包含或排除的字段：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this delete command, we are using the option of projection to include only
    the `title` field in the response. The output on the next line confirms the successful
    deletion and the document in response shows only the `title` field.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个删除命令中，我们使用了投影选项，只在响应中包含`title`字段。下一行的输出确认了成功的删除，并且响应中的文档只显示了`title`字段。
- en: 'Exercise 5.02: Deleting a Low-Rated Movie'
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.02：删除评分低的电影
- en: The movie archives team in your organization is the team that ensures that most
    highly rated movies are present in the database. In order to improve the user
    experience, they want to frequently perform quality checks on the database and
    remove the movies with the lowest ratings. To measure quality, they want to consider
    IMDb ratings and the total number of votes because a higher number of votes means
    a more reliable rating.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您组织中的电影档案团队负责确保数据库中存在大多数评分最高的电影。为了改善用户体验，他们希望经常对数据库进行质量检查，并删除评分最低的电影。为了衡量质量，他们希望考虑IMDb评分和总投票数，因为投票数越高意味着评分更可靠。
- en: 'Based on this, they asked you to remove a movie with a high number of IMDb
    votes, a low average rating, and the least awards won from the list of low-rated
    movies. Your task for this exercise is to connect to the `sample_mflix` cluster
    and execute a delete command so that a movie with least awards won, an IMDb rating
    of less than 2, and more than 50,000 votes gets deleted. Then, record the `title`
    and `_id` of the deleted movie. The following steps will help you complete this
    exercise:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，他们要求您从低评分电影列表中删除一部IMDb投票数较高、平均评分较低且获奖最少的电影。您在本练习中的任务是连接到`sample_mflix`集群并执行删除命令，以便删除获奖最少、IMDb评分低于2且投票超过50,000的电影。然后，记录已删除电影的`title`和`_id`。以下步骤将帮助您完成此练习：
- en: 'As you have to delete one movie, you can use either the `deleteOne()` or `findOneAndDelete()`
    function and prepare a query filter using the IMDb rating and votes. However,
    to ensure that the movie with the least awards gets deleted, you need to sort
    the films in ascending order of awards won and let the first movie in the resulting
    list be deleted. This means you will need to use `findOneAndDelete()`. First,
    open any text editor and start writing the query. Begin by writing the query filter.
    The first condition is to find movies with less than a two-point rating in IMDb:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于您需要删除一部电影，您可以使用`deleteOne()`或`findOneAndDelete()`函数，并使用IMDb评分和投票准备查询过滤器。但是，为了确保删除获奖最少的电影，您需要按获奖次数升序对电影进行排序，并让结果列表中的第一部电影被删除。这意味着您需要使用`findOneAndDelete()`。首先，打开任何文本编辑器并开始编写查询。首先编写查询过滤器。第一个条件是查找IMDb评分低于两分的电影：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The IMDb rating is a nested field; therefore, you will use the dot notation
    to access the field and then write the condition using the `$lt` operator.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: IMDb评分是一个嵌套字段；因此，您将使用点表示法访问该字段，然后使用`$lt`运算符编写条件。
- en: 'Next, the second condition says the total number of IMDb votes should be more
    than 50,000\. Add this condition to your query:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，第二个条件表示IMDb投票的总数应超过50,000。将此条件添加到您的查询中：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The second condition is expressed using the `$gt` operator.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个条件使用`$gt`运算符表示。
- en: 'Now, write a `findOneAndDelete()` function and add the preceding query into
    it:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写一个`findOneAndDelete()`函数，并将前面的查询添加到其中：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding command will find movies with less than 2-star ratings and more
    than 50,000 votes and delete the first one. However, you also want to ensure that
    the movie with the least awards gets deleted.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将查找评分低于2星且投票超过50,000的电影，并删除第一个。但是，您还希望确保删除获奖最少的电影。
- en: 'To delete the movie with the least awards won, add a `sort` option:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要删除获奖最少的电影，请添加一个`sort`选项：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This command sorts the filtered movies in ascending order of awards won.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将按获奖次数升序对筛选后的电影进行排序。
- en: 'Now, add a projection option to return only the `_id` and `title` field of
    the deleted movie:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个投影选项，仅返回已删除电影的`_id`和`title`字段：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding command has a projection option wherein the `title` field is explicitly
    included. This means that all the other fields will be excluded, while `_id` is
    included by default.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令具有一个投影选项，其中明确包含了`title`字段。这意味着所有其他字段将被排除，而`_id`默认包含。
- en: 'Finally, open the mongo shell and connect to the Atlas cluster. Use the `sample_mflix`
    database and execute the preceding command. You should see the following output:![Figure
    5.5: Deleting the low-rated movie'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开mongo shell并连接到Atlas集群。使用`sample_mflix`数据库并执行前面的命令。您应该看到以下输出：![图5.5：删除低评分电影
- en: '](img/B15507_05_05.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_05.jpg)'
- en: 'Figure 5.5: Deleting the low-rated movie'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：删除低评分电影
- en: As seen in the preceding output, the command was executed successfully. The
    document returned in the response correctly includes the `_id` and `title` of
    the deleted movie.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的输出所示，命令已成功执行。响应中返回的文档正确包括已删除电影的`_id`和`title`。
- en: In this exercise, you used one of the delete functions to correctly delete a
    specific record from the real-world collection of movies.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您使用了一个删除函数，正确地从电影的真实集合中删除了一个特定的记录。
- en: Replacing Documents
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换文档
- en: In this section, you will learn how you can completely replace the documents
    in a collection.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何完全替换集合中的文档。
- en: Sometimes you may want to replace an incorrectly inserted document in a collection.
    Or consider that, often, the data stored in documents is changed over time. Or,
    perhaps, to support your product's new requirements, you may want to alter the
    way your documents are structured or change the fields in your documents. In all
    such cases, you will need to replace the documents.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望替换集合中错误插入的文档。或者考虑到，通常，文档中存储的数据会随时间而改变。或者，为了支持产品的新要求，您可能希望更改文档的结构或更改文档中的字段。在所有这些情况下，您都需要替换文档。
- en: 'In the previous section, we used a new database of `CH05` which we will continue
    using in this section. In the same database, create a collection named `users`
    and insert a few users into it, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们使用了一个名为`CH05`的新数据库，我们将在本节中继续使用。在同一个数据库中，创建一个名为`users`的集合，并插入一些用户，如下所示：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can see that the command is successful, and four users are added. Before
    going any further, quickly use the `find()` command to ensure no other documents
    are present in the collection except for the newly inserted ones:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到命令执行成功，并添加了四个用户。在继续之前，快速使用`find()`命令确保集合中除了新插入的文档之外没有其他文档：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the documents in the preceding snippet, each user has a unique ID, name,
    and email address. Now, suppose the user `Margaery Tyrell` gets married to `Joffrey
    Baratheon`, and she wishes to change her surname to her husband's. To accomplish
    this, you will have to change her name as well as her email.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面片段的文档中，每个用户都有一个唯一的ID、姓名和电子邮件地址。现在，假设用户`Margaery Tyrell`与`Joffrey Baratheon`结婚，并且她希望将姓氏改为丈夫的姓氏。为了实现这一点，您需要更改她的姓名以及她的电子邮件。
- en: 'As per the requirement, the new record for `Margaery Tyrell` should look like
    this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 根据要求，`Margaery Tyrell`的新记录应如下所示：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To replace a single document in a collection, MongoDB provides the method `replaceOne()`,
    which accepts a query filter and a replacement document. The function finds the
    document that matches the criteria and replaces it with the provided document.
    The following example demonstrates this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换集合中的单个文档，MongoDB提供了`replaceOne()`方法，该方法接受查询过滤器和替换文档。该函数找到与条件匹配的文档，并用提供的文档替换它。以下示例演示了这一点：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, the first argument is the query filter to identify the document to be
    replaced, and the second argument is the new document. The output clearly indicates
    that the given query matched one document and one document was updated. The query
    filter need not always be the `_id` field. It can be any query that filters using
    any field or combination of multiple fields and operators. For example, the following
    replace command will have the same effect as the previous one, as long as there
    is only one user with the name of `Margaery Tyrell`. If there is more than one
    document that matches the query, then only the first one will be replaced:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个参数是查询过滤器，用于识别要替换的文档，第二个参数是新文档。输出清楚地表明给定的查询匹配了一个文档，并且更新了一个文档。查询过滤器不一定总是`_id`字段。它可以是使用任何字段或多个字段和运算符进行过滤的任何查询。例如，以下替换命令将产生与前一个相同的效果，只要只有一个名为`Margaery
    Tyrell`的用户。如果有多个文档与查询匹配，则只有第一个文档将被替换：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: _id Fields Are Immutable
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: _id字段是不可变的
- en: 'In the previous example, you will have noticed that there was no `_id` field
    in the replacement document. In that case, do you think MongoDB must have added
    and autogenerated a primary key field? Query the document and find out:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，您会注意到替换文档中没有`_id`字段。在这种情况下，您认为MongoDB一定会添加并自动生成一个主键字段吗？查询文档并找出：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding output indicates that the `_id` of the original document is retained
    in the new document.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出表明原始文档的`_id`在新文档中保留了下来。
- en: This is because `_id` fields are immutable in MongoDB. Immutable fields are
    like normal fields; however, once assigned with a value, their value cannot be
    changed again. The `_id` field serves as a unique identifier of a document and
    so should not be changed as long as the document exists.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为MongoDB中的`_id`字段是不可变的。不可变字段就像普通字段一样；但是，一旦赋予了一个值，它们的值就不能再次更改。`_id`字段用作文档的唯一标识符，因此只要文档存在，就不应更改它。
- en: It is similar to the user accounts you create on the various online portals,
    where your username is your unique identifier. You can change your password, or
    any other information in your profile, however, most portals won't allow you to
    change your username. Even if they allow you to modify your username, the old
    username cannot be assigned to anyone because there might be someone who still
    knows you by your old username.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于您在各种在线门户网站上创建的用户帐户，其中您的用户名是您的唯一标识符。您可以更改密码，或者在您的个人资料中更改任何其他信息，但是大多数门户网站不允许您更改用户名。即使他们允许您修改用户名，旧用户名也不能分配给任何人，因为可能还有人知道您的旧用户名。
- en: 'This was the theory of why the `_id` fields in MongoDB are immutable. However,
    try modifying the field and observe what happens:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么MongoDB中的`_id`字段是不可变的理论。然而，尝试修改该字段并观察会发生什么：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, the replace command finds a document named `Margaery Baratheon`. In the
    replacement document, it also provides a new value for the `_id` field:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，替换命令找到了一个名为`Margaery Baratheon`的文档。在替换文档中，它还为`_id`字段提供了一个新值：
- en: '![Figure 5.6: Error when _id is being modified'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.6：修改_id时出错'
- en: '](img/B15507_05_06.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_06.jpg)'
- en: 'Figure 5.6: Error when _id is being modified'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6：修改_id时出错
- en: In this example, you executed a replace command, as shown in the preceding snippet,
    where the replacement document now has an explicit `_id` field. The command failed
    with a very detailed error message. The preceding snapshot highlights the most
    important part of the error message, which indicates that the field is immutable.
    Hence, the update was rolled back, and no change happened to the record.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您执行了一个替换命令，如前面片段所示，替换文档现在有一个显式的`_id`字段。命令失败，并显示了一个非常详细的错误消息。前面的快照突出了错误消息的最重要部分，表明该字段是不可变的。因此，更新被回滚，记录没有发生任何变化。
- en: Upsert Using Replace
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用替换进行Upsert
- en: In the previous sections, we learned that we can find an existing document in
    a collection and replace it with a new document. However, there will be times
    you want to replace an existing document with a new one and, if the document does
    not already exist, insert the new document. This operation is called an update
    (if found) or insert (if not found), which is further shortened to upsert. Upsert
    is a feature provided by many databases and MongoDB supports it as well.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学到了可以在集合中找到现有文档并用新文档替换它。然而，有时您希望用新文档替换现有文档，并且如果文档尚不存在，则插入新文档。这个操作称为更新（如果找到）或插入（如果找不到），进一步缩短为upsert。Upsert是许多数据库提供的功能，MongoDB也支持它。
- en: Why Use Upsert?
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么使用Upsert？
- en: For the simple scenarios that we have seen above, upsert sounds a bit unnecessary—especially
    when the same operation can be performed easily using two different commands.
    For example, we can first execute a replace command and check the results. The
    value of the matched count will tell whether the document is found in the collection.
    If the document is not found, we can then execute an `insert` command.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们上面看到的简单场景，upsert听起来有点不必要，尤其是当可以使用两个不同的命令轻松执行相同的操作时。例如，我们可以先执行一个替换命令并检查结果。匹配计数的值将告诉我们文档是否在集合中找到。如果没有找到文档，我们可以执行一个`insert`命令。
- en: However, in real-world scenarios, you will mostly be doing these operations
    in large numbers. Consider that your system receives daily updates from a user
    server, where the server sends you all the documents that were modified during
    the day. These daily updates might include records of the new users signed up
    with the server as well as changes to the existing users' profiles. On a large-scale
    system, performing a two-step update or insert operation for each of the records
    will be very time-consuming and error prone. However, having a dedicated command,
    you can simply prepare and execute an upsert command for each of the records you
    receive and let MongoDB do the update or insert.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在现实场景中，您大多数情况下会执行大量的这些操作。考虑到您的系统每天从用户服务器接收到更新，服务器会发送当天修改的所有文档。这些每日更新可能包括新用户在服务器上注册的记录，以及对现有用户配置文件的更改。在大规模系统上，为每条记录执行两步更新或插入操作将非常耗时且容易出错。然而，有了专门的命令，您可以简单地准备并执行每条记录的upsert命令，让MongoDB执行更新或插入。
- en: 'Consider the following records in the `users` collection:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`users`集合中的以下记录：
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'At the end of an episode, King Joffrey has been killed. As a result, `Margaery`
    wants to switch back to her old surname, and `Tommen Baratheon` becomes the new
    king. The update you receive from the user server contains the updated record
    for `Margaery` and the new record for `Tommen`, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在一集的结尾，乔佛里国王被杀害。因此，`Margaery`想要恢复她的旧姓，而`Tommen Baratheon`成为新国王。您从用户服务器接收到的更新包含了`Margaery`的更新记录和`Tommen`的新记录，如下所示：
- en: '[PRE39]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the following commands, you pass an additional argument of `{upsert: true}`,
    which makes these commands upsert commands:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '在以下命令中，您传递了一个额外的参数`{upsert: true}`，这使这些命令成为upsert命令：'
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When you execute the commands one after the other on a mongo shell, you see
    the following output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在mongo shell上依次执行这些命令时，您会看到以下输出：
- en: '![Figure 5.7: Output for the upsert operation'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.7：upsert操作的输出'
- en: '](img/B15507_05_07.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_07.jpg)'
- en: 'Figure 5.7: Output for the upsert operation'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7：upsert操作的输出
- en: The result of the first upsert indicates that there was a match found, and the
    document has been updated. However, the second one denotes the match was not found,
    and a new document was upserted with an autogenerated primary key.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个upsert的结果表明找到了匹配项，并且文档已被更新。然而，第二个表明未找到匹配项，并且使用自动生成的主键进行了新文档的upsert。
- en: Replacing Using findOneAndReplace()
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用findOneAndReplace()进行替换
- en: 'We have seen the `replaceOne()` function, which, after successful execution,
    returns the counts of matched and updated documents. MongoDB provides another
    operation, `findOneAndReplace()`, to perform the same operations. However, it
    provides more options. Its main features are as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`replaceOne()`函数，成功执行后返回匹配和更新的文档计数。MongoDB提供了另一个操作`findOneAndReplace()`来执行相同的操作。但是，它提供了更多选项。其主要特点如下：
- en: As the name indicates, it finds one document and replaces it.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顾名思义，它找到一个文档并替换它。
- en: If more than one document is found matching the query, the first one will be replaced.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到多个与查询匹配的文档，第一个将被替换。
- en: A sort option can be used to influence which document gets replaced if more
    than one document is matched.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用排序选项来影响匹配多个文档时哪个文档被替换。
- en: By default, it returns the original document.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，它返回原始文档。
- en: 'If the option of `{returnNewDocument: true}` is set, the newly added document
    will be returned.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果设置了`{returnNewDocument: true}`选项，新添加的文档将被返回。'
- en: Field projection can be used to include only specific fields in the document
    returned in response.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段投影可用于在响应中只包含特定字段的文档。
- en: 'To see the `findOneAndReplace()` function in action, add five documents to
    a movie collection:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`findOneAndReplace()`函数的操作，请向电影集合添加五个文档：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, say that these five movies, all having the same `title`, were released
    and inserted in different calendar years. When these records were originally inserted,
    the field for the year of release wasn''t added. As a result, to find the latest
    movie with this `title`, you need to use the incremental `_id` field, where the
    movie with the largest `_id` value is the latest one. To make future find queries
    simpler, you have been instructed to find the document of the latest movie with
    this `title` and add a flag of `latest: true` to that document. So, when someone
    tries to find that movie, they can pass this additional filter to get the latest
    one in the response, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，假设这五部电影都具有相同的`title`，并且在不同的日历年份发布和插入。当这些记录最初插入时，发布年份的字段尚未添加。因此，要找到具有此`title`的最新电影，您需要使用递增的`_id`字段，其中具有最大`_id`值的电影是最新的。为了使未来的查找查询更简单，您已被指示找到具有此`title`的最新电影的文档，并向该文档添加`latest:
    true`标志。因此，当有人尝试查找该电影时，他们可以传递此附加过滤器以获取响应中的最新电影，如下所示：'
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the previous snippet, you found the document for a movie by its `title`
    and replaced it with another document that contains an additional field—that is,
    `latest : true`. Apart from that, the command used the option of `sort` so that
    the record with the largest value `_id` appears on top. The command also uses
    a projection option to include only the `title` field in the response. The output
    is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '在上面的片段中，您通过`title`找到了一部电影的文档，并用包含额外字段`latest: true`的另一个文档替换了它。除此��外，该命令使用了`sort`选项，以便具有最大值`_id`的记录出现在顶部。该命令还使用了投影选项，只在响应中包含`title`字段。输出如下：'
- en: '![Figure 5.8: Output for the findOneAndReplace command'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.8：findOneAndReplace命令的输出'
- en: '](img/B15507_05_08.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_08.jpg)'
- en: 'Figure 5.8: Output for the findOneAndReplace command'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8：findOneAndReplace命令的输出
- en: 'The preceding snapshot confirms that the operation is successful, and the `title`
    of the old document is included in the response. Alternatively, if you are required
    to get the updated document in the response, you can make use of the `returnNewDocument`
    flag in the command. Setting this flag to true will return the replaced document
    from the collection, as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 上述快照确认了操作成功，并且旧文档的`title`包含在响应中。或者，如果需要在响应中获取更新后的文档，可以使用命令中的`returnNewDocument`标志。将此标志设置为true将从集合中返回替换后的文档，如下所示：
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This replace command works similarly to the previous one, but the only difference
    is that it is using an additional option of `returnNewDocument`, which is set
    to `true`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个替换命令与之前的命令类似，唯一的区别是它使用了一个额外的`returnNewDocument`选项，该选项设置为`true`。
- en: '![Figure 5.9: Output after setting returnNewDocument to true'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.9：设置returnNewDocument为true后的输出'
- en: '](img/B15507_05_09.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_09.jpg)'
- en: 'Figure 5.9: Output after setting returnNewDocument to true'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9：设置returnNewDocument为true后的输出
- en: 'This output shows that having the `returnNewDocument` flag set to `true` returns
    the new document. Now, quickly query the database and see whether the replace
    command did actually work:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出显示，将`returnNewDocument`标志设置为`true`会返回新文档。现在，快速查询数据库，看看替换命令是否真的起作用：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The preceding output shows the latest record now has the desired flag.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出显示，最新的记录现在具有所需的标志。
- en: Replace versus Delete and Re-Insert
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换与删除和重新插入
- en: As we have seen in the previous sections, there are dedicated functions to find
    and replace documents in a collection. It is possible to replace a document using
    a combination of delete and insert, where you delete an existing document and
    insert a new one. This two-step operation of the delete and `insert` combination
    gives you the same results; let's see how.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的部分中所看到的，有专门的函数来查找和替换集合中的文档。可以使用删除和插入的组合来替换文档，其中您删除一个现有文档并插入一个新文档。删除和`insert`组合的这两步操作会给您相同的结果；让我们看看如何操作。
- en: To perform the two-step, replace operation using delete and `insert`, use the
    same example that you saw in the `findOneAndReplace()` section.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用删除和`insert`进行两步替换操作，请使用在`findOneAndReplace()`部分中看到的相同示例。
- en: 'First, delete all the previously inserted or modified documents from the collection:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从集合中删除所有先前插入或修改的文档：
- en: '[PRE45]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, insert the five documents again:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次插入这五个文档：
- en: '[PRE46]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, find the document of the latest movie titled `Macbeth` and add the flag
    `"latest" : true` to it:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，找到标题为`Macbeth`的最新电影的文档，并为其添加标志`"latest" : true`：'
- en: '[PRE47]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This snippet shows two different commands. The first is a `findOneAndDelete()`
    command that finds a movie by its `title` and also uses the sort option so that
    only the movie with largest `_id` gets deleted. The result of the deletion operation,
    which is the deleted document, is stored in a variable of `deletedDocument`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段显示了两个不同的命令。第一个是`findOneAndDelete()`命令，它通过`title`找到一部电影，并使用排序选项，以便只删除具有最大`_id`的电影。删除操作的结果，即已删除的文档，存储在`deletedDocument`的变量中。
- en: 'The next command in the preceding snippet is an insert operation that re-inserts
    the same movie along with the flag `latest : true`. While doing so, it uses the
    `_id` value from the deleted document, so that the new record is inserted with
    the same primary key:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '上述片段中的下一个命令是一个插入操作，它重新插入了相同的电影，并使用了`latest : true`标志。在这样做的同时，它使用了已删除文档的`_id`值，以便新记录使用相同的主键进行插入：'
- en: '![Figure 5.10: Output for delete first and then insert'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.10：删除后插入的输出'
- en: '](img/B15507_05_10.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_10.jpg)'
- en: 'Figure 5.10: Output for delete first and then insert'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10：删除后插入的输出
- en: 'The preceding output indicates that you have executed both commands sequentially,
    and the response shows that one document was inserted successfully, which can
    be verified using the `find` operation:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出表明您已经按顺序执行了两个命令，响应显示成功插入了一个文档，可以使用`find`操作进行验证：
- en: '[PRE48]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The result of a `find` operation on the collection confirms that the two-step
    replacement operation worked perfectly.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对集合进行`find`操作的结果确认了两步替换操作完美地起作用。
- en: Although the results are exactly the same, the two-step operation is more error
    prone. The two-step operation executes two totally different commands, one after
    the other. In the first command, your MongoDB client or your programming language's
    driver sends the `delete` command to the server. The server then validates and
    processes the command to remove the document. Then the deleted document is sent
    back to the client over the network. The client or driver then parses the returned
    result into the language-specific object. In our case, we are executing commands
    from a mongo shell, and so the results are parsed into the JSON format and stored
    in the variable `deleteDocument`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管结果完全相同，两步操作更容易出错。两步操作执行两个完全不同的命令，一个接着一个。在第一个命令中，您的MongoDB客户端或编程语言的驱动程序将`delete`命令发送到服务器。然后服务器验证和处理命令以删除文档。然后已删除的文档通过网络发送回客户端。客户端或驱动程序然后将返回的结果解析为特定于语言的对象。在我们的情况下，我们正在从mongo
    shell执行命令，因此结果被解析为JSON格式并存储在变量`deleteDocument`中。
- en: Next, your MongoDB client or the driver sends another command to insert the
    new document. The new document, which is in JSON format in our case, gets transformed
    into BSON and sent over the wire to the server. For the MongoDB server, this `insert`
    command is like any other fresh `insert` commands. The server performs the initial
    validation of the document, checks whether the `_id` field is present, and also
    validates the uniqueness of the value in the collection. If the document is found
    to be valid, the insert will happen.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您的MongoDB客户端或驱动程序发送另一个命令来插入新文档。新文档，在我们的情况下是JSON格式，被转换为BSON并通过网络发送到服务器。对于MongoDB服务器，这个`insert`命令就像任何其他新的`insert`命令一样。服务器对文档进行初始验证，检查`_id`字段是否存在，并验证集合中值的唯一性。如果文档被发现有效，插入将会发生。
- en: 'Now that you are familiar with the details of the two-step replace operation,
    consider the following potential shortfalls of using it over dedicated replace
    functions:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了两步替换操作的细节，请考虑在使用它时可能存在的以下潜在缺陷：
- en: First of all, in the delete and insert method, the data is transferred over
    the wire multiple times. This involves the drivers or clients to parse the data
    in multiple stages. This will slow down the overall performance.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在删除和插入方法中，数据会多次通过网络传输。这需要驱动程序或客户端在多个阶段解析数据。这将减慢整体性能。
- en: When multiple clients are constantly reading and writing to your collections,
    concurrency issues may arise. As an example, say you have successfully deleted
    a record and before you insert the new record, some other client accidentally
    inserts a different record with the same `_id`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当多个客户端不断读取和写入您的集合时，可能会出现并发问题。例如，假设您已成功删除了一条记录，在插入新记录之前，某个其他客户端意外地插入了一个具有相同`_id`的不同记录。
- en: Your database client or driver may lose its connection to the database in the
    middle of two operations. For example, the delete operation was successful but
    insertion could not happen. To avoid such issues, you will have to run your commands
    in a transaction so that the failure of one operation can revert the previously
    successful operations in the same transaction.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的数据库客户端或驱动程序可能在两个操作之间失去与数据库的连接。例如，删除操作成功，但插入无法进行。为了避免这种问题，您将不得不在事务中运行您的命令，以便一个操作的失败可以撤销同一事务中先前成功的操作。
- en: The dedicated replace functions, on the other hand, are effectively atomic and
    are therefore safe to use in concurrent environments. An atomic operation is the
    smallest unit of operation that cannot be divided further. For this reason, when
    an atomic operation is performed, it is executed in one go as a single unit. Thus,
    dedicated replace functions are safer as compared to the delete and insert combination.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，专用替换函数实际上是原子的，因此在并发环境中使用是安全的。原子操作是不能进一步分割的最小操作单位。因此，当执行原子操作时，它将作为单个单元一次性执行。因此，与删除和插入组合相比，专用替换函数更安全。
- en: The dedicated functions first find a document to be replaced and lock it. The
    lock is then released only after the operation is finished. Because of this, no
    other client or process is able to modify that particular document while it is
    locked. Also, the replace operation replaces only the rest of the fields in the
    documents, keeping `_id` untouched. There is no chance that other processes will
    be able to push a different document with the same `_id` value.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 专用函数首先找到要替换的文档并锁定它。锁定只有在操作完成后才会释放。因此，在锁定文档时，没有其他客户端或进程能够修改该特定文档。此外，替换操作仅替换文档中其余的字段，保持`_id`不变。其他进程不可能能够推送具有相同`_id`值的不同文档。
- en: Thus, it is always preferable to use the specialty functions provided by MongoDB.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好始终使用MongoDB提供的专用函数。
- en: Modify Fields
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改字段
- en: In the previous sections, we learned that we could replace any document in a
    MongoDB collection once it has been inserted. During the replace operation, a
    document in the database will be replaced with a completely new document while
    keeping the same primary key. The replacement operations are quite useful when
    it comes to rectifying errors and to incorporating data changes or updates. However,
    in most cases, updates will affect only one or a few fields of a document. Think
    about any movie record from the `sample_mflix` dataset, where most of its fields
    (such as the title, cast, directors, duration, and so on) may never change. However,
    over a period of time, the movie may receive new comments, new reviews, and ratings.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，我们学到了一旦插入，就可以替换MongoDB集合中的任何文档。在替换操作期间，数据库中的文档将被完全新的文档替换，同时保留相同的主键。替换操作在纠正错误和合并数据更改或更新时非常有用。然而，在大多数情况下，更新只会影响文档的一个或几个字段。想象一下`sample_mflix`数据集中的任何电影记录，其中大多数字段（如标题、演员、导演、时长等）可能永远不会改变。然而，随着时间的推移，电影可能会收到新的评论、新的评价和评分。
- en: The find and replace operation is very useful when all or most fields of a document
    are modified. But, using it to update only particular fields in the documents
    will not be easy. To do so, the replacement document you provide will need to
    have all the unchanged fields with their existing values and the changed fields
    with their new values. For a smaller document, this doesn't sound like a problem,
    but for large documents, like our movie records, the command will be bulky and
    error prone. We will see this with an example of a command that we will not execute
    on the database.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 查找和替换操作在所有或大多数文档字段被修改时非常有用。但是，使用它来更新文档中的特定字段将不容易。为此，您提供的替换文档将需要具有所有未更改字段及其现有值以及更改字段及其新值。对于较小的文档，这听起来不像是问题，但对于大型文档，比如我们的电影记录，命令将变得臃肿且容易出错。我们将通过一个我们不会在数据库上执行的命令的示例来看到这一点。
- en: 'Say a record of a movie was added to the database, but the value of the field
    `year` is incorrect. The following is an example of how the command will look
    if the replace operation is used to correct the value. In the first statement,
    we find the movie document and assign it to a variable. Next is the actual replace
    command where the replacement document with all of its fields needs to be provided.
    We use the variable `movie` that we assigned in the first line and refer to all
    of its unchanged fields. The last field in the replacement document is the field
    of `year` with the new value:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 假设数据库中添加了一部电影的记录，但字段`year`的值不正确。以下是使用替换操作来更正该值的命令的示例。在第一条语句中，我们找到电影文档并将其分配给一个变量。接下来是实际的替换命令，其中需要提供具有所有字段的替换文档。我们使用在第一行中分配的变量`movie`，并引用其所有未更改的字段。替换文档中的最后一个字段是`year`字段，其具有新值：
- en: '[PRE49]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The problem with the command is that it is too bulky, especially since we only
    want to update a single field. It re-enters all the fields, even if they are not
    changed, and there is a good possibility of a typo being introduced when we are
    re-assigning the unchanged field values. Moreover, this is a two-step operation
    and introduces concurrency problems that are hard to debug.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的问题在于它太庞大了，特别是因为我们只想要更新一个字段。它重新输入了所有字段，即使它们没有改变，而且在重新分配未更改的字段值时很可能会引入拼写错误。此外，这是一个两步操作，引入了难以调试的并发问题。
- en: To understand the concurrency problem, imagine that the find operation in the
    first statement is successful, and the next statement is a replace command that
    refers to all the unchanged fields from the existing documents; but before the
    second statement is executed, the actual document in the database was modified
    by some other client or thread. Once your statement is executed, the updates added
    by the other client will be lost forever.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解并发问题，想象一下第一条语句中的查找操作成功，下一条语句是一个替换命令，引用了现有文档中所有未更改的字段；但在第二条语句执行之前，数据库中的实际文档被其他客户端或线程修改了。一旦您的语句执行，其他客户端添加的更新将永远丢失。
- en: This is why the replace operation should only be used when all or most of the
    fields are being modified. To modify one or only a few fields of a document, MongoDB
    provides the `update` command. Let's explore this in the next section.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么替换操作应该仅在修改所有或大部分字段时使用。要修改文档的一个或只有几个字段，MongoDB提供了`update`命令。让我们在下一节中探讨这个问题。
- en: Updating a Document with updateOne()
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`updateOne()`更新文档
- en: 'To update the fields of a single document in a collection, we can use the function
    `updateOne()`. This function, which is provided by MongoDB collections, accepts
    a query condition to find the record to be updated, and a document that specifies
    the field-level update expressions. The third argument to the function is to provide
    miscellaneous options and is optional. The syntax of this function looks like
    this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新集合中单个文档的字段，我们可以使用`updateOne()`函数。这个函数由MongoDB集合提供，接受一个查询条件来找到要更新的记录，以及一个指定字段级更新表达式的文档。函数的第三个参数是提供杂项选项的，是可选的。这个函数的语法如下：
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Like the replace commands, `updateOne()` cannot be used to update the `_id`
    field of a document because it is immutable. Once the update is performed, it
    returns a detailed result in the form of a document, which indicates how many
    records were matched and how many records were updated.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 与替换命令一样，`updateOne()`不能用于更新文档的`_id`字段，因为它是不可变的。更新执行后，它以文档的形式返回详细结果，指示匹配了多少条记录以及更新了多少条记录。
- en: 'Before using this function, first delete all the previously inserted and modified
    records from the collection:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用此功能之前，首先从集合中删除所有先前插入和修改的记录：
- en: '[PRE51]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, use the following `insert` command to add four new records to the collection:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下`insert`命令向集合添加四条新记录：
- en: '[PRE52]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Write and execute your first update command to change the field `year` for
    the movie `Macbeth`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 编写并执行第一个更新命令以更改电影`Macbeth`的`year`字段：
- en: '[PRE53]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the preceding command, the first argument to the `updateOne()` function is
    the query condition, wherein you specify that the name of the movie should be
    `Macbeth`. The second argument is a document that specifies a new field of `year`
    and its value. Here, we are using a new operator, `$set`, to assign values to
    the fields provided in a document. In the upcoming sections, we will learn more
    about the `$set` operator and also a few other operators that are supported by
    all the update functions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述命令中，`updateOne()`函数的第一个参数是查询条件，其中您指定电影的名称应为`Macbeth`。第二个参数是一个指定`year`字段及其值的文档。在这里，我们使用了一个新的运算符`$set`，来为文档中提供的字段赋值。在接下来的章节中，我们将学习更多关于`$set`运算符以及所有更新函数支持的其他运算符。
- en: 'When the command is executed on a mongo shell, the output looks like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当在mongo shell上执行该命令时，输出如下：
- en: '[PRE54]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output is a document that denotes the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个表示以下内容的文档：
- en: '`"acknowledged" : true` indicates that the update was performed and confirmed.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"acknowledged" : true` 表示更新已执行并已确认。'
- en: '`"matchedCount" : 1` shows the number of documents found and chosen for the
    update (1 in this case.)'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"matchedCount" : 1` 显示找到并选择进行更新的文档数量（在这种情况下为1）。'
- en: '`"modifiedCount" : 1` refers to the number of documents modified (1 in this
    case.)'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"modifiedCount" : 1` 指的是修改的文档数量（在这种情况下为1）。'
- en: 'The following query and the output that follows confirm that the update command
    was executed correctly:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询和随后的输出确认了更新命令的正确执行：
- en: '[PRE55]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the preceding record, the field `year` is correctly set to `2015`, which
    was previously `2014`. If we execute the same command again, no update will be
    performed as the value is already `2015`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述记录中，字段`year`正确设置为`2015`，之前是`2014`。如果我们再次执行相同的命令，由于值已经是`2015`，不会执行更新：
- en: '[PRE56]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '*Figure 5.12* shows the output of executing the same update command again.
    The resulting document indicates that there was one document that was matched
    as eligible for the update; however, no document was updated.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.12*显示了再次执行相同更新命令的输出。结果文档表明有一个文档符合更新的条件，但是没有文档被更新。'
- en: Modifying More Than One Field
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改多个字段
- en: 'The `$set` operator that we used to update a field of a document can also be
    used to modify multiple fields of a document. As seen in the previous examples,
    `$set` is provided with a document that contains the update expression. Similarly,
    to modify more than one field, the update expression can contain more than one
    field and value pair. For example, consider this snippet:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来更新文档字段的`$set`运算符也可以用来修改文档的多个字段。如前面的例子所示，`$set`后面跟着包含更新表达式的文档。同样，要修改多个字段，更新表达式可以包含多个字段和值对。例如，考虑以下代码片段：
- en: '[PRE57]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the preceding operation, the update expression `{"type": "movie", "num_mflix_comments":
    1}}` specifies two fields and their values. Out of these, the `num_mflix_comment`
    field does not exist in the respective movie. Execute the command on our movie
    collection and see the output:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的操作中，更新表达式`{"type": "movie", "num_mflix_comments": 1}}`指定了两个字段及其值。其中，`num_mflix_comment`字段在相应的电影中不存在。在我们的电影集合上执行该命令并查看输出：'
- en: '[PRE58]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The preceding figure shows that the operation was successful, and one record
    is modified as expected. Now, query the document and see if the fields are modified correctly:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示该操作成功，并且一个记录按预期被修改。现在查询文档并查看字段是否被正确修改：
- en: '[PRE59]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The document from the collection indicates that the movie type has been modified
    correctly, and a new field named `num_mflix_comments` has been added with the
    given value. Thus, you have seen that `$set` can be used to update multiple fields
    in the same command, and if a field is new, it will be added to the document with
    the specified value.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 集合中的文档表明电影类型已经正确修改，并且添加了一个名为`num_mflix_comments`的新字段，其给定值。因此，您已经看到`$set`可以用于在同一命令中更新多个字段，如果字段是新的，它将被添加到文档中并指定值。
- en: 'Before we move on to the next section, it is important to know that, in an
    update operation, updating the same field multiple times is valid, irrespective
    of the field''s value. As seen in the previous output, the `year` field of the
    movie `Macbeth` is set to 2015\. Modify the same field multiple times in the same
    command:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一节之前，重要的是要知道，在更新操作中，多次更新相同字段是有效的，无论字段的值如何。如前面的输出所示，电影`Macbeth`的`year`字段设置为2015。在同一命令中多次修改相同字段：
- en: '[PRE60]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The preceding update command, which uses the `$set` operator, sets the year
    multiple times. The first two expressions set the field to its current value;
    however, the last two expressions have different values. Execute the command and
    observe the behavior:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的更新命令使用了`$set`运算符，多次设置了年份。前两个表达式将字段设置为其当前值；然而，最后两个表达式具有不同的值。执行该命令并观察行为：
- en: '[PRE61]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'As expected, the operation is valid, and one document is modified. Query the
    document from the collection and see the value of the `year` field:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，该操作是有效的，并且一个文档被修改。查询集合中的文档并查看`year`字段的值：
- en: '[PRE62]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the preceding output, we prove that, when the same field is provided multiple
    times, the update happens from left to right. First, the `year` field (which was
    already 2015) is set to 2015 twice; then with the third expression, the year is
    set to 2016; and lastly, with the rightmost expression, it is set to 2017.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们证明了当同一字段多次提供时，更新是从左到右进行的。首先，`year`字段（已经是2015）被设置为2015两次；然后，通过第三个表达式，年份被设置为2016；最后，通过最右边的表达式，它被设置为2017。
- en: In any valid scenario, you will hardly ever update a field twice in an update
    operation. However, even if you do so, perhaps accidentally, you now know the
    behavior, and this will help you in debugging.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何有效的情况下，您几乎不会在更新操作中两次更新字段。但是，即使您这样做，也许是意外的，现在您已经了解了行为，这将帮助您进行调试。
- en: Multiple Documents Matching a Condition
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匹配条件的多个文档
- en: 'As the name of the `updateOne()` function indicates, it always updates only
    one document in the collection. If the given query condition matches more than
    one document, only the first document will be modified:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 正如`updateOne()`函数的名称所示，它总是只更新集合中的一个文档。如果给定的查询条件匹配多个文档，只有第一个文档将被修改：
- en: '[PRE63]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The preceding operation finds documents where `type` is `movie` and sets the
    value of `flag` as `modified`. Remember, we have a total of three documents of
    type `movie` in our movie collection. When the command is executed on our collection,
    the result will look like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的操作找到`type`为`movie`的文档，并将`flag`的值设置为`modified`。请记住，我们的电影集合中共有三个`movie`类型的文档。当该命令在我们的集合上执行时，结果将如下所示：
- en: '[PRE64]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The result of the execution indicates that one document was matched and chosen
    for the update, and one document was actually modified. Thus, it proves that even
    if there is more than one document that matches the given query condition, only
    one document is chosen and updated.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 执行结果表明有一个文档匹配并被选择进行更新，实际上有一个文档被修改。因此，这证明即使有多个文档匹配给定的查询条件，也只选择并更新一个文档。
- en: Upsert with updateOne()
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用updateOne()进行upsert
- en: 'In the previous section, we learned in detail about the upsert operation. When
    upsert-based updates are executed, the document will be updated if it is found;
    however, if the document is not found, a new document is created inside the collection.
    Similar to the replace operations, `updateOne()` also supports upserts with an
    additional flag in the command. Consider the following snippet:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们详细了解了upsert操作。当执行基于upsert的更新时，如果找到文档，将对其进行更新；但是，如果未找到文档，则在集合中创建一个新文档。与替换操作类似，`updateOne()`还支持在命令中使用附加标志进行upsert。考虑以下代码片段：
- en: '[PRE65]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The preceding operation executes an update command on the movie `Sicario`,
    which does not exist in our collection. When the command is executed without any
    `upsert` flag, no update is performed:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的操作在电影`Sicario`上执行了更新命令，该电影在我们的集合中不存在。当没有任何`upsert`标志的情况下执行该命令时，不会进行更新：
- en: '[PRE66]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output indicates that no document was matched, and no document was updated.
    Now, we will execute the same command with an `upsert` flag:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明没有匹配的文档，也没有更新的文档。现在，我们将使用`upsert`标志执行相同的命令：
- en: '[PRE67]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The preceding operation uses a third argument, which contains a document with
    the `upsert` flag set to `true`, which is false by default. The output can be
    seen here:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的操作使用了第三个参数，其中包含一个将`upsert`标志设置为`true`的文档，默认为false。输出如下所示：
- en: '![Figure 5.11: Update a non-existing movie with the upsert flag'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.11：使用upsert标志更新不存在的电影'
- en: '](img/B15507_05_11.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_11.jpg)'
- en: 'Figure 5.11: Update a non-existing movie with the upsert flag'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11：使用upsert标志更新不存在的电影
- en: 'So, the output of executing the command is slightly different this time. It
    indicates that no document was matched, and no document was updated. However,
    `"upsertedId" : ObjectId("5e…")` indicates that one document was inserted with
    an autogenerated primary key.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，执行命令的输出这次略有不同。它指示没有匹配的文档，也没有更新的文档。然而，`"upsertedId" : ObjectId("5e…")`表明插入了一个带有自动生成的主键的文档。'
- en: 'The following query finds the document using the autogenerated primary key.
    When you execute this query on your shell, you will have to use the `ObjectId`
    that was generated in the previous command:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询使用自动生成的主键找到文档。当您在shell上执行此查询时，您将需要使用在上一个命令中生成的`ObjectId`：
- en: '[PRE68]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: When we query the collection with the newly created primary key value, we get
    the newly inserted record.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用新创建的主键值查询集合时，我们得到了新插入的记录。
- en: One thing to notice here is that the new document has two fields, out of which
    the field `year` was part of the update expression; however, `title` was part
    of the query condition. When MongoDB creates a new document as part of an `upsert`
    operation, it combines fields from the update expressions as well as query conditions.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，新文档有两个字段，其中字段`year`是更新表达式的一部分；然而，`title`是查询条件的一部分。当MongoDB创建新文档作为`upsert`操作的一部分时，它会合并更新表达式和查询条件中的字段。
- en: Updating a Document with findOneAndUpdate()
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用findOneAndUpdate()更新文档
- en: 'We have seen the function `updateOne()`, which modifies one document from a
    collection. MongoDB also provides the `findOneAndUpdate()` function, which is
    capable of doing everything that `updateOne()` does with a few additional features,
    which we''ll explore now. The syntax of this function is the same as `updateOne()`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`updateOne()`函数，它修改了集合中的一个文档。MongoDB还提供了`findOneAndUpdate()`函数，它能够做到`updateOne()`所做的一切，并且还有一些额外的功能，我们现在将探讨。这个函数的语法与`updateOne()`相同：
- en: '[PRE69]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`findOneAndUpdate()` needs at least two arguments where the first one is a
    query condition to find the document to be modified and the second one is the
    update expression. By default, it returns the old document in the response. In
    some scenarios, getting back the old document is really useful, especially when
    it needs to be archived somewhere. However, by passing a flag as an argument,
    the behavior of the function can be changed to return the new document in the
    response. Consider the following example.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`findOneAndUpdate()`至少需要两个参数，第一个是用于找到要修改的文档的查询条件，第二个是更新表达式。默认情况下，它在响应中返回旧文档。在某些情况下，获取旧文档真的很有用，特别是当需要将其存档时。然而，通过传递一个标志作为参数，函数的行为可以更改为在响应中返回新文档。考虑以下示例。'
- en: 'The record for the movie `Macbeth` in our collection has only one comment,
    given by the field `num_mflix_comments`. Modify the count of these comments using
    the update command as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们集合中电影`Macbeth`的记录只有一个评论，由字段`num_mflix_comments`给出。使用以下更新命令修改这些评论的计数：
- en: '[PRE70]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The preceding command finds a movie by its `title` and sets `num_mflix_comments`
    to the value of 10\. We can see that it looks pretty similar to the `updateOne()`
    commands, and the effects on the collection will be exactly the same. However,
    the only difference we will see here is the response, as can be seen in the following
    figure:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令通过`title`找到电影，并将`num_mflix_comments`设置为10的值。我们可以看到它看起来与`updateOne()`命令非常相似，对集合的影响也完全相同。然而，我们在这里看到的唯一区别是响应，如下图所示：
- en: '![Figure 5.12: Update using fineOneAndUpdate()'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.12：使用fineOneAndUpdate()进行更新'
- en: '](img/B15507_05_12.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_12.jpg)'
- en: 'Figure 5.12: Update using fineOneAndUpdate()'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12：使用fineOneAndUpdate()进行更新
- en: 'The output shows that the `findOneAndUpdate()` function did not return the
    query stats, such as how many records were matched and how many records were modified.
    Instead, it returns the document in its old state. Now query and verify whether
    the update was successful:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示`findOneAndUpdate()`函数没有返回查询统计信息，比如匹配了多少记录，修改了多少记录。相反，它返回了文档的旧状态。现在查询并验证更新是否成功：
- en: '[PRE71]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The query and its output here confirm that the number of comments is modified
    to its new value.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的查询及其输出确认了评论数量已经修改为新值。
- en: Returning a New Document in Response
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回响应中的新文档
- en: 'So far, we have used the function with two arguments where the first is the
    query condition and the second is the update expression. However, the function
    also supports an optional third argument, which is used to provide miscellaneous
    options to the commands. Out of these options, the `returnNewDocument` can be
    used to control which document should be returned in the response. By default,
    the value of this flag is set to false, which is why we get the old document without
    passing the options. However, setting this flag to true, we get back the modified
    or new document in the response. For example, consider the following snippet:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用了两个参数的函数，第一个是查询条件，第二个是更新表达式。然而，该函数还支持一个可选的第三个参数，用于向命令提供杂项选项。在这些选项中，`returnNewDocument`可以用于控制响应中应返回哪个文档。默认情况下，此标志的值设置为false，因此我们在不传递选项的情况下得到了旧文档。然而，将此标志设置为true，我们将在响应中得到修改后的或新文档。例如，考虑以下代码片段：
- en: '[PRE72]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The preceding operation sets the comments count to 15 and also passes the flag
    of `returnNewDocument` set to true. The output can be seen as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 上述操作将评论计数设置为15，并将`returnNewDocument`标志设置为true。输出如下所示：
- en: '![Figure 5.13: findOneAndUpdate() with the returnNewDocument flag'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.13：带有returnNewDocument标志的findOneAndUpdate()'
- en: '](img/B15507_05_13.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_13.jpg)'
- en: 'Figure 5.13: findOneAndUpdate() with the returnNewDocument flag'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13：带有returnNewDocument标志的findOneAndUpdate()
- en: The output shows that by setting the flag `returnNewDocument` to `true`, the
    response shows the modified document, which also confirms that the count of comments
    has been modified correctly.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，通过将标志`returnNewDocument`设置为`true`，响应显示了修改后的文档，这也确认了评论数量已经正确修改。
- en: 'With the optional third argument to the function, we can also provide an expression
    to limit the number of fields returned in the documents (also called a projection
    expression). The projection expression can be used for both cases—that is, returning
    an old or new document as a response:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 通过函数的可选第三个参数，我们还可以提供一个表达式来限制文档中返回的字段数量（也称为投影表达式）。投影表达式可以用于返回旧文档或新文档作为响应的情况：
- en: '[PRE73]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The preceding update command finds the movie by `title` and sets the count
    of comments to 20\. As the third argument, it passes two options to the command.
    The first option is the projection expression, which includes only `num_mflix_comments`
    in the response and excludes the `_id` explicitly. By using the second operation,
    the function will return the modified document. The output can be seen here:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 上述更新命令通过`title`找到电影，并将评论数设置为20。作为第三个参数，它将两个选项传递给命令。第一个选项是投影表达式，它只在响应中包含`num_mflix_comments`，并明确排除了`_id`。通过使用第二个操作，函数将返回修改后的文档。输出可以在这里看到：
- en: '![Figure 5.14: findOneAndUpdate() with projection'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.14：带有投影的findOneAndUpdate()'
- en: '](img/B15507_05_14.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_14.jpg)'
- en: 'Figure 5.14: findOneAndUpdate() with projection'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14：带有投影的findOneAndUpdate()
- en: We can see that the projection expression has excluded the `_id` and included
    only the `num_mflix_comments` field, as expected.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，投影表达式已排除了`_id`，并且只包含了`num_mflix_comments`字段，正如预期的那样。
- en: Sorting to Find a Document
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排序以查找文档
- en: So far, we have covered two update functions, and both are capable of updating
    a single document at a time. If more than one document is matched by the given
    query condition, the first document will be chosen for modification. This behavior
    is common between both functions. However, the `findOneAndUpdate()` function provides
    an additional option to sort the matching documents in a specific order. Using
    the sort option, you can influence which document is selected for the modification.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了两个更新函数，它们都能够一次更新一个文档。如果给定的查询条件���配了多个文档，那么将选择第一个文档进行修改。这种行为在两个函数之间是共同的。但是，`findOneAndUpdate()`函数提供了一个额外的选项，可以按特定顺序对匹配的文档进行排序。使用排序选项，您可以影响选择哪个文档进行修改。
- en: The sort option is specified as a field under the optional third argument of
    the `findOneAndUpdate()` function. The value of the sort field must be a document
    containing valid sort expressions. We will now see an example of using the sort
    option in an update command.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 排序选项被指定为`findOneAndUpdate()`函数的可选第三个参数下的一个字段。排序字段的值必须是包含有效排序表达式的文档。现在我们将看到一个在更新命令中使用排序选项的示例。
- en: '*Figure 5.15* shows that our collection has four records, which are of the
    movie type. Each one has a sequential `_id` field where the record inserted latest
    has the largest value in the sequence:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.15*显示了我们的集合有四条记录，都是电影类型。每个记录都有一个顺序的`_id`字段，最后插入的记录在序列中具有最大的值：'
- en: '![Figure 5.15: A collection having four records'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.15：一个包含四条记录的集合'
- en: '](img/B15507_05_15.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_15.jpg)'
- en: 'Figure 5.15: A collection having four records'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.15：一个包含四条记录的集合
- en: 'Write a command that will use the same filter of `{"type" : "movie"}` and put
    the flag `"latest" : true` to the last inserted record:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '编写一个命令，将使用`{"type" : "movie"}`的相同过滤器，并将标志`"latest" : true`放到最后插入的记录中：'
- en: '[PRE74]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The update command in the preceding snippet sets the `latest` flag to true.
    The query condition finds a document with a `type` of `movie`. The options argument
    sets a flag to return the modified document in the response and also specifies
    a sort expression to sort documents by descending order of the primary key:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 上述片段中的更新命令将`latest`标志设置为true。查询条件找到了一个`type`为`movie`的文档。选项参数设置一个标志，以在响应中返回修改后的文档，并且还指定了一个排序表达式，以按照主键的降序对文档进行排序：
- en: '![Figure 5.16: Update one record by sorting matched documents'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.16：通过排序匹配的文档更新一条记录'
- en: '](img/B15507_05_16.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_16.jpg)'
- en: 'Figure 5.16: Update one record by sorting matched documents'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.16：通过排序匹配的文档更新一条记录
- en: 'The response to the update command, as shown in *Figure 5.16*, indicates that
    the record with `_id : 4` has the latest flag. This is due to the specified sort
    option, which ordered the matching records so that the largest IDs will appear
    first. The function picked up the first record and modified it.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '更新命令的响应，如*图5.16*所示，指示具有`_id : 4`的记录具有最新标志。这是由于指定的排序选项，它对匹配的记录进行排序，以便最大的ID将首先出现。函数选择了第一条记录并对其进行了修改。'
- en: 'Exercise 5.03: Updating the IMDb and Tomatometer Rating'
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.03：更新IMDb和Tomatometer评分
- en: Your movie database has records of a large number of worldwide movies along
    with their details. Your product owners want you to keep the database updated
    with the most recent changes. People still love to watch some of the timeless
    classic movies and rate them or post their reviews, so the ratings of some of
    the popular movies, which were released a few decades ago, keep changing on a
    daily basis. Your organization has decided to incorporate rating updates for all
    movies irrespective of their release date. As a proof of concept, they have chosen
    *The Godfather*, one of the all-time great movies, and asked you to update it
    with the latest IMDb and Tomatometer ratings. If your product team is happy with
    the update, they will sign off on receiving regular updates from these platforms.
    Your task is to write and execute an update operation to update these ratings.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 您的电影数据库记录了大量全球电影及其详细信息。您的产品所有者希望您保持数据库与最新变化的更新。人们仍然喜欢观看一些永恒的经典电影并对其进行评分或发表评论，因此一些几十年前发布的流行电影的评分每天都在变化。您的组织已决定无论电影的发布日期如何，都要纳入所有电影的评分更新。作为概念验证，他们选择了《教父》，这部有史以来最伟大的电影之一，并要求您使用最新的IMDb和Tomatometer评分对其进行更新。如果您的产品团队对此更新满意，他们将同意从这些平台接收定期更新。您的任务是编写并执行更新操作以更新这些评分。
- en: 'These are the latest IMDb and Tomatometer viewer ratings of the movie:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这是电影的最新IMDb和Tomatometer观众评分：
- en: '**IMDb rating**'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**IMDb评分**'
- en: 'Rating: 9.2 and Votes: 1,565,120'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 评分：9.2，投票数：1,565,120
- en: '**Tomatometer viewer rating**'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 番茄表观众评分
- en: 'Rating: 4.76, number of reviews: 733, 777, meter 98'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 评分：4.76，评论数量：733，777，米特98
- en: 'Take a look at the database to find the current values of these ratings:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 查看数据库以找到这些评分的当前值：
- en: '[PRE75]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This query finds and prints the IMDb and Tomatometer viewer rating of the movie
    `The Godfather`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询查找并打印电影`教父`的IMDb和番茄表观众评分：
- en: '![Figure 5.17: Ratings of the movie The Godfather'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.17：电影教父的评分'
- en: '](img/B15507_05_17.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_17.jpg)'
- en: 'Figure 5.17: Ratings of the movie The Godfather'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.17：电影教父的评分
- en: The output shows the current ratings from the `sample_mflix` database.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了`sample_mflix`数据库中当前的评分。
- en: 'Open any text editor and write a `findOneAndUpdate()` command along with a
    query parameter:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开任何文本编辑器，并编写一个带有查询参数的`findOneAndUpdate()`命令：
- en: '[PRE76]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, use the `$set` operator to set the IMDb fields. As the IMDb rating is
    still the same, you will only update the field `votes` field. To refer to the
    nested field of `votes`, use the dot notation:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`$set`运算符设置IMDb字段。由于IMDb评分仍然相同，因此只需更新`votes`字段。要引用`votes`的嵌套字段，使用点表示法：
- en: '[PRE77]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Next, add another update expression for Tomatometer ratings. For the Tomatometer
    viewer rating, you only need to update the fields of `rating` and `numReviews`.
    As these are two separate fields, add two separate update expressions to the `$set`
    operator. As these fields are nested within a nested object, use dot notation
    two times:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为番茄表观众评分添加另一个更新表达式。对于番茄表观众评分，您只需要更新`rating`和`numReviews`字段。由于这是两个单独的字段，因此将两个单独的更新表达式添加到`$set`运算符中。由于这些字段嵌套在嵌套对象中，因此使用点表示法两次：
- en: '[PRE78]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now that your update query is complete, add the flag to return the modified
    document in response along with projection on specific fields:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您的更新查询已经完成，添加标志以返回响应中修改后的文档以及特定字段的投影：
- en: '[PRE79]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Open the mongo shell and connect to the Atlas `sample_mflix` database. Copy
    the previous command and execute it:![Figure 5.18: Updated ratings'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开mongo shell并连接到Atlas`sample_mflix`数据库。复制上一个命令并执行它：![图5.18：更新评分
- en: '](img/B15507_05_18.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_18.jpg)'
- en: 'Figure 5.18: Updated ratings'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.18：更新后的评分
- en: The previous output shows that the respective fields have been updated correctly.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示相应的字段已经被正确更新。
- en: In this exercise, you have practiced using `findOneAndUpdate()` and `$set` to
    update the values of nested fields. Next, we will learn to update multiple documents
    using `updateMany()`.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您已经练习了使用`findOneAndUpdate()`和`$set`来更新嵌套字段的值。接下来，我们将学习使用`updateMany()`来更新多个文档。
- en: Updating Multiple Documents with updateMany()
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用updateMany()更新多个文档
- en: 'In the previous sections, we learned to find one document and modify or update
    its fields. Many times though, you will want to perform the same update operation
    on multiple documents in a collection. MongoDB provides the `updateMany()` function,
    which updates multiple documents at a time. Similar to `updateOne()`, the `updateMany()`
    function takes two mandatory arguments. The first argument is the query condition,
    and the second is the update expression. The third argument, which is optional,
    is used to provide miscellaneous options. Upon execution, this function updates
    all the documents that match the given query condition. The syntax of the function
    looks like this:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何找到一个文档并修改或更新其字段。然而，很多时候，您可能希望对集合中的多个文档执行相同的更新操作。MongoDB提供了`updateMany()`函数，可以一次更新多个文档。与`updateOne()`类似，`updateMany()`函数需要两个必需的参数。第一个参数是查询条件，第二个是更新表达式。第三个参数是可选的，用于提供杂项选项。执行后，此函数将更新所有匹配给定查询条件的文档。函数的语法如下：
- en: '[PRE80]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We will write and execute an update operation on our movie collection. Consider
    that our movie collection has four movies that were released in 2015\. Add a field
    named `languages` to these movies, as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的电影集合上编写并执行更新操作。假设我们的电影集合有四部于2015年发布的电影。为这些电影添加一个名为`languages`的字段，如下所示：
- en: '[PRE81]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This update operation uses two arguments. The first is to find all the movies
    that were released in 2015\. The second argument is an update expression, which
    uses the `$set` operator, to add a new field named `languages`. The value of the
    `languages` field is an array containing English as the only language. The output
    can be seen here:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 此更新操作使用两个参数。第一个是查找所有在2015年发布的电影。第二个参数是一个更新表达式，它使用`$set`运算符添加一个名为`languages`的新字段。`languages`字段的值是一个包含英语作为唯一语言的数组。输出如下：
- en: '[PRE82]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The output indicates that the operation was successful, and, like the `updateOne()`
    function, a similar document is returned in the response. The response indicates
    that the query condition matched a total of four documents, and all were modified.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明操作成功，并且与`updateOne()`函数一样，响应中返回了类似的文档。响应表明查询条件匹配了总共四个文档，并且所有文档都已被修改。
- en: 'In this section, we learned about modifying fields of one or more documents
    in MongoDB collections. We have covered three update functions, out of which `updateOne()`
    and `findOneAndUpdate()` are used to update one document in a collection while
    `updateMany()` is used to update multiple documents in a collection. The following
    are a few important points about the update operations and are applicable to all
    three functions:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何修改MongoDB集合中一个或多个文档的字段。我们已经介绍了三个更新函数，其中`updateOne()`和`findOneAndUpdate()`用于更新集合中的一个文档，而`updateMany()`用于更新集合中的多个文档。以下是关于更新操作的一些重要点，适用于所有三个函数：
- en: None of the update functions allows you to change the `_id` field.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有任何更新函数允许更改`_id`字段。
- en: The order of the fields in a document is always maintained, except when the
    update includes renaming a field. However, the `_id` field will always appear
    first. (We will cover renaming fields in the next section).
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档中字段的顺序始终保持不变，除非更新包括重命名字段。但是，`_id`字段将始终首先出现。（我们将在下一节中介绍重命名字段）。
- en: Update operations are atomic on a single document. A document cannot be modified
    until another process has finished updating it.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新操作在单个文档上是原子的。在另一个进程完成更新之前，文档不能被修改。
- en: 'All of the update functions support upsert. To execute an upsert command, `upsert
    : true` needs to be passed as an option.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '所有的更新函数都支持upsert。要执行upsert命令，需要将`upsert : true`作为选项传递。'
- en: In the next section, we will cover various update operators and their usages.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将详细介绍各种更新运算符及其用法。
- en: Update Operators
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新运算符
- en: 'In order to facilitate different types of update commands, MongoDB provides
    various update operators or update modifiers such as set, multiply, increment,
    and more. In the previous sections, we used the operator `$set`, which is one
    of the update operators provided by MongoDB. In this section, we will learn some
    of the most commonly used operators and examples. Before we go through the operators,
    we will discuss their syntax. The following code snippet shows the basic syntax
    of an update expression that uses an update operator:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便不同类型的更新命令，MongoDB提供了各种更新运算符或更新修饰符，如set、multiply、increment等。在前面的部分中，我们使用了操作符`$set`，这是MongoDB提供的更新运算符之一。在本节中，我们将学习一些最常用的运算符和示例。在我们讨论运算符之前，我们将讨论它们的语法。以下代码片段显示了使用更新运算符的更新表达式的基本语法：
- en: '[PRE83]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: As per the preceding syntax, an operator can be assigned a document containing
    one or more pairs of field and value. The operator is then applied to each field
    using the respective value. An update expression like the previous one is useful
    when all the given fields need to be updated with the same operator. You may also
    want to update different fields of a document using different operators. For such
    cases, an update expression can contain multiple update operators, each separated
    by a comma.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的语法，可以将运算符分配给包含一个或多个字段和值对的文档。然后，运算符将应用于每个字段，使用相应的值。像前面的更新表达式对于所有给定字段需要使用相同的运算符时是有用的。您可能还希望使用不同的运算符更新文档的不同字段。对于这种情况，更新表达式可以包含多个更新运算符，每个运算符之间用逗号分隔。
- en: '[PRE84]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The preceding snippet shows the syntax for using multiple operators in the same
    update expression. In an update operation, each of these operators will be executed
    in sequence.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段显示了在同一更新表达式中使用多个运算符的语法。在更新操作中，这些运算符中的每一个都将按顺序执行。
- en: Let's go through each of the update operators in detail now.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们详细了解每个更新运算符。
- en: Set ($set)
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置（$set）
- en: As we have already seen, the `$set` operator is used to set the values of fields
    in a document. It is the most commonly used operator, as it can be easily used
    to set values of any type of field or add new fields in a document. The operator
    takes a document that contains pairs of field names and their new values. If the
    given field is not already present, it will be created.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，`$set`运算符用于设置文档中字段的值。它是最常用的运算符，因为它可以轻松地用于设置任何类型的字段的值或在文档中添加新字段。该运算符接受一个包含字段名和它们的新值对的文档。如果给定的字段尚不存在，它将被创建。
- en: Increment ($inc)
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增量（$inc）
- en: The increment operator `($inc`) is used to increment the value of a numeric
    field by a specific number. The operator accepts a document containing pairs of
    a field name and a number. Given a positive number, the value of the field will
    be incremented and if a negative number is provided, the value will be decremented.
    It is obvious but worth mentioning that the `$inc` operator can only be used with
    numeric fields; if attempted for non-numeric fields, the operation fails with
    an error.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 增量运算符`($inc`)用于将数值字段的值增加特定数字。该运算符接受包含字段名和数字对的文档。给定正数，字段的值将增加；如果提供负数，值将减少。显而易见但值得一提的是，`$inc`运算符只能用于数值字段；如果尝试用于非数值字段，操作将失败并出现错误。
- en: 'Currently, in our collection, the document for a `Macbeth` movie looks as shown
    here:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在我们的集合中，`Macbeth`电影的文档如下所示：
- en: '[PRE85]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now, write an update using the `$inc` operator on two fields, out of which
    one exists in the document and the other does not:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`$inc`运算符对两个字段进行更新，其中一个存在于文档中，另一个不存在：
- en: '[PRE86]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The preceding update operation finds a movie by its `title`, increments the
    `num_mflix_comments` field by 3 and a non-existent field called `rating` by `1.5`.
    It also sets `returnNewDocument` to `true`, so that the updated record will be
    returned in the response. You can see the output in the following screenshot:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的更新操作通过`title`找到一部电影，将`num_mflix_comments`字段增加3，将一个不存在的名为`rating`的字段增加`1.5`。它还将`returnNewDocument`设置为`true`，以便在响应中返回更新后的记录。您可以在以下截图中看到输出：
- en: '![Figure 5.19: Incrementing the number of comments and the rating score'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.19：增加评论数量和评分'
- en: '](img/B15507_05_19.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_19.jpg)'
- en: 'Figure 5.19: Incrementing the number of comments and the rating score'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.19：增加评论数量和评分
- en: 'So, the update command was successful. The field of `num_mflix_comments` is
    correctly incremented by 3 and `rating` (which was a nonexistent field) is now
    added to the document with a specified value. We will see an example of decrementing
    the field values:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，更新命令成功。`num_mflix_comments`字段正确增加了3，`rating`（原本不存在的字段）现在已添加到文档中，并具有指定的值。我们将看到减少字段值的示例：
- en: '[PRE87]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The preceding command uses the `$inc` operator on two fields and provides negative numbers:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令在两个字段上使用了`$inc`运算符，并提供了负数：
- en: '![Figure 5.20: Decrementing the number of comments and rating score'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.20：减少评论数量和评分'
- en: '](img/B15507_05_20.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_20.jpg)'
- en: 'Figure 5.20: Decrementing the number of comments and rating score'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.20：减少评论数量和评分
- en: As seen in *Figure 5.20*, the negative increments lead to the response. The
    `rating`, which was 1.5, is now reduced by 0.2 and `num_mflix_comments` is reduced
    to 21.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图5.20*所示，负增量导致响应。`rating`，原为1.5，现在减少了0.2，`num_mflix_comments`减少到21。
- en: Multiply ($mul)
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 乘法（$mul）
- en: 'The multiplication `($mul`) operator is used to multiply the value of a numeric
    field by the given number. The operator accepts a document containing pairs of
    field names and numbers and can only be used on numeric fields. For example, consider
    the following snippet:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法`($mul`)操作符用于将数字字段的值乘以给定的数字。该操作符接受包含字段名称和数字对的文档，并且只能用于数字字段。例如，考虑以下代码片段：
- en: '[PRE88]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The preceding update operation finds a movie by its `title`, uses `$mul` to
    multiply the value of the field of `rating` by 2, and adds an option to return
    the modified document in the response. You can see this as follows:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的更新操作通过`title`找到电影，使用`$mul`将`rating`字段的值乘以2，并添加一个选项在响应中返回修改后的文档。结果如下所示：
- en: '![Figure 5.21: Doubling the rating score'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.21：将评分翻倍'
- en: '](img/B15507_05_21.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_21.jpg)'
- en: 'Figure 5.21: Doubling the rating score'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.21：将评分翻倍
- en: 'The output shows the value of the field `rating` is multiplied by 2\. When
    using a non-existent field with `$mul`, we should always remember that no matter
    what multiplier we provide, the field will be created and always set to zero.
    This is because, with a multiplication operation, the value of a nonexistent numeric
    field is assumed to be zero. Thus, using any multiplier on zero results in zero:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示字段`rating`的值乘以2。在使用`$mul`时，应始终记住，无论我们提供什么乘数，该字段都将被创建并始终设置为零。这是因为，在乘法操作中，假定不存在的数字字段的值为零。因此，在零上使用任何乘数都会得到零：
- en: '[PRE89]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'This update operation multiplies a nonexistent field `box_office_collection`
    by a given value:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 此更新操作将不存在的字段`box_office_collection`乘以给定值：
- en: '![Figure 5.22: Multiplying the value of a non-existing field'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.22：将不存在的字段的值乘以2'
- en: '](img/B15507_05_22.jpg)'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_22.jpg)'
- en: 'Figure 5.22: Multiplying the value of a non-existing field'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.22：将不存在的字段的值乘以2
- en: The output in *Figure 5.22* proves that irrespective of the provided value,
    the nonexistent field of `box_office_collection` has been added with a value of zero.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.22*中的输出证明，不管提供的值如何，`box_office_collection`的不存在字段都已添加了值为零。'
- en: Rename ($rename)
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重命名（$rename）
- en: As suggested by the name, the `$rename` operator is used to rename fields. The
    operator accepts a document containing pairs of field names and their new names.
    If the field is not already present in the document, the operator ignores it and
    does nothing. The provided field and its new name must be different. If they're
    the same, the operation fails with an error. If a document already contains a
    field with the provided new name, the existing field will be removed.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，`$rename`操作符用于重命名字段。该操作符接受包含字段名称和它们的新名称对的文档。如果字段尚未存在于文档中，则操作符会忽略它并不执行任何操作。提供的字段及其新名称必须不同。如果它们相同，则操作将因错误而失败。如果文档已包含具有提供的新名称的字段，则现有字段将被移除。
- en: 'To try various scenarios of the `$rename` operator, first, insert a field named
    `imdb_rating` for `Macbeth`. The following update operation sets the new field
    and the output shows that the field is correctly added:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试`$rename`操作符的各种场景，首先为`Macbeth`插入名为`imdb_rating`的字段。以下更新操作设置了新字段，输出显示字段已正确添加：
- en: '[PRE90]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now, rename the field `num_mflix_comments` to `comments` and rename the field
    `imdb_rating` to `rating`, as follows:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将字段`num_mflix_comments`重命名为`comments`，并将字段`imdb_rating`重命名为`rating`，如下所示：
- en: '[PRE91]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The update operation uses the `$rename` operator and passes a document containing
    two pairs of field names and new names. Note that the second field name and new
    name combination is trying to rename the field of `imdb_rating` to `rating`; however,
    the record already has a field with the name of `rating`. The output can be seen
    as follows:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 更新操作使用`$rename`操作符，并传递包含两对字段名称和新名称的文档。请注意，第二个字段名称和新名称组合试图将`imdb_rating`字段重命名为`rating`；然而，记录已经具有名称为`rating`的字段。输出如下所示：
- en: '![Figure 5.23: Renaming fields'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.23：重命名字段'
- en: '](img/B15507_05_23.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_23.jpg)'
- en: 'Figure 5.23: Renaming fields'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.23：重命名字段
- en: 'The output shows that the rename operation was successful. As stated above,
    the original field of `rating` is removed and the `imdb_rating` field is now renamed
    to `rating`. Using this operator, a field can also be moved to and from nested
    documents. To do so, you have to use a dot notation, like this:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示重命名操作成功。如上所述，原始字段`rating`已被移除，`imdb_rating`字段现在已重命名为`rating`。使用此操作符，字段也可以移至嵌套文档和从嵌套文档中移出。要这样做，必须使用点表示法，如下所示：
- en: '[PRE92]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Here, the update operation is renaming the `rating` field. However, the new
    name contains a dot notation:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，更新操作正在重命名`rating`字段。但是，新名称包含点表示法：
- en: '![Figure 5.24: Renaming nested fields'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.24：重命名嵌套字段'
- en: '](img/B15507_05_24.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_24.jpg)'
- en: 'Figure 5.24: Renaming nested fields'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.24：重命名嵌套字段
- en: Because of the dot notation, the field `rating` has been moved under the nested
    document `imdb`. Similarly, a field can be moved from a nested document to the
    root or to any other nested document.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 由于点表示法，字段`rating`已移至嵌套文档`imdb`下。同样，字段可以从嵌套文档移至根文档或任何其他嵌套文档中。
- en: Current Date ($currentDate)
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当前日期（$currentDate）
- en: 'The operator `$currentDate` is used to set the value of a given field as the
    current date or timestamp. If the field is not present already, it will be created
    with the current date or timestamp value. Providing a field name with a value
    of `true` will insert the current date as a `Date`. Alternatively, a `$type` operator
    can be used to explicitly specify the value as a `date` or `timestamp`:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符`$currentDate`用于将给定字段的值设置为当前日期或时间戳。如果该字段尚不存在，则将使用当前日期或时间戳值创建它。将字段名称与`true`值一起提供将当前日期插入为`Date`。或者，可以使用`$type`操作符显式指定值为`date`或`timestamp`：
- en: '[PRE93]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The preceding `findOneAndUpdate` operation sets three fields using the `$currentDate`
    operator. The field `created_date` has a value of true, which defaults to a `Date`
    type. The other two fields use a dot notation and explicit `$type` declaration.
    The output can be seen in the following figure:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`findOneAndUpdate`操作使用`$currentDate`运算符设置了三个字段。字段`created_date`的值为true，默认为`Date`类型。另外两个字段使用了点表示法和显式的`$type`声明。输出可以在下图中看到：
- en: '![Figure 5.25: Setting the current date and timestamp'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.25：设置当前日期和时间戳'
- en: '](img/B15507_05_25.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_25.jpg)'
- en: 'Figure 5.25: Setting the current date and timestamp'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.25：设置当前日期和时间戳
- en: We can see that the field `created_date` has a value of the `Date` type. A new
    field, `last_updated`, has been added and has a nested document. Under the nested
    document, another field has been initialized as a `Date` type and the other as `Timestamp`.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`created_date`字段的值是`Date`类型。添加了一个新字段`last_updated`，并且有一个嵌套文档。在嵌套文档下，另一个字段被初始化为`Date`类型，另一个字段被初始化为`Timestamp`类型。
- en: Removing Fields ($unset)
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除字段（$unset）
- en: 'The `$unset` operator removes given fields from a document. The operator accepts
    a document containing pairs of field names and values and removes all the given
    fields from the matched document. As the provided fields are being removed, their
    specified values have no impact. For instance, consider the following snippet:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '`$unset`运算符从文档中移除给定的字段。该运算符接受一个包含字段名和值的文档，并从匹配的文档中移除所有给定的字段。由于提供的字段正在被移除，它们指定的值没有影响。例如，考虑以下代码片段：'
- en: '[PRE94]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Execute an update operation using the `$unset` operator to remove unwanted
    fields:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`$unset`运算符执行更新操作以移除不需要的字段：
- en: '[PRE95]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The preceding update operation removes four fields from the document. As stated
    previously, it doesn''t matter whether and what value is provided to the field
    while it is being removed. Here, you are trying to remove multiple fields and
    providing them with different values, and you will observe that their values have
    no impact. The first field, `created_date`, is provided with a value of an empty
    string. The next two fields have some dummy values, and the field `imdb` has a
    null value. The last field, `flag`, is also provided with an empty string. Out
    of these five fields, `imdb` and `last_updated` are nested fields. You will now
    execute the operation and observe the output, as follows:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的更新操作从文档中移除了四个字段。如前所述，无论提供给字段什么值，以及是否提供给字段什么值，都没有影响。在这里，您正在尝试移除多个字段并为它们提供不同的值，您将观察到它们的值没有影响。第一个字段`created_date`提供了一个空字符串的值。接下来的两个字段有一些虚拟值，字段`imdb`有一个空值。最后一个字段`flag`也提供了一个空字符串的值。在这五个字段中，`imdb`和`last_updated`是嵌套字段。现在执行操作并观察输出，如下所示：
- en: '![Figure 5.26: Removing multiple fields'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.26：移除多个字段'
- en: '](img/B15507_05_26.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_26.jpg)'
- en: 'Figure 5.26: Removing multiple fields'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.26：移除多个字段
- en: The output indicates that all five fields are correctly removed from the document.
    The operation and the response prove that the values specified for the fields
    have no impact on field removal. Also, specifying a field with a value of a nested
    object removes the respective object and contained fields.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明，所有五个字段都已从文档中正确移除。操作和响应证明了为字段指定的值对字段移除没有影响。此外，指定一个值为嵌套对象的字段会移除相应的对象和包含的字段。
- en: Setting When Inserted ($setOnInsert)
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入时设置（$setOnInsert）
- en: 'The operator `$setOnInsert` is similar to `$set`; however, it only sets the
    given fields when an insert happens during an `upsert` operation. It has no impact
    when the `upsert` operation results in the update of existing documents. To understand
    this better, consider the following snippet:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`$setOnInsert`运算符类似于`$set`，但是它只在`upsert`操作期间插入时设置给定的字段。当`upsert`操作导致更新现有文档时，它没有影响。为了更好地理解这一点，请考虑以下代码片段：'
- en: '[PRE96]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Here, the upsert operation finds and updates the *Macbeth* movie record. It
    renames a field with a new name and also uses `$setOnInsert` on the field `created_time`,
    which is initialized to the current **Date**. As the movie is already present
    in the collection, this operation will result in an update:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，upsert操作找到并更新了*Macbeth*电影记录。它将一个字段重命名为一个新名称，并且还在字段`created_time`上使用了`$setOnInsert`，该字段被初始化为当前的**Date**。由于电影已经存在于集合中，这个操作将导致更新：
- en: '![Figure 5.27: Using $setOnInsert with upsert on an existing document'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.27：在现有文档上使用$setOnInsert进行upsert'
- en: '](img/B15507_05_27.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_27.jpg)'
- en: 'Figure 5.27: Using $setOnInsert with upsert on an existing document'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.27：在现有文档上使用$setOnInsert进行upsert
- en: 'The output shows that `$setOnInsert` did not change the document, however,
    the field `comment` is now renamed to `num_mflix_comments`. Also, the field `created_time`
    is not added because the upsert operation was used to update an existing document.
    Now try an example of an insert using the upsert operation:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示`$setOnInsert`没有改变文档，但是字段`comment`现在被重命名为`num_mflix_comments`。另外，字段`created_time`没有被添加，因为upsert操作被用来更新现有文档。现在尝试使用upsert操作来插入一个示例：
- en: '[PRE97]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The only difference between this snippet and the previous one is that this
    operation finds a movie named `Spy`, which is not present in our collection. Because
    of the upsert, the operation will result in adding a document to the collection.
    The output can be seen in the following figure:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与前面的代码唯一的区别是，这个操作找到了一个名为`Spy`的电影，而这个电影在我们的集合中不存在。由于upsert的存在，这个操作将导致向集合中添加一个文档。输出可以在下图中看到：
- en: '![Figure 5.28: Using $setOnInsert with upsert on a new document'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.28：在新文档上使用$setOnInsert进行upsert'
- en: '](img/B15507_05_28.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_28.jpg)'
- en: 'Figure 5.28: Using $setOnInsert with upsert on a new document'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.28：在新文档上使用$setOnInsert进行upsert
- en: As we can see, a new movie record has been created along with the field `created_time`.
    With the preceding example and the output, we have seen that the `$setOnInsert`
    operator sets a field only when a record is inserted as part of an upsert operation.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，一个新的电影记录已经创建，并且带有`created_time`字段。通过前面的示例和输出，我们已经看到`$setOnInsert`操作符仅在作为upsert操作的一部分插入记录时设置字段。
- en: 'Activity 5.01: Updating Comments for Movies'
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动5.01：更新电影评论
- en: 'Some of the users of your database have complained that their comments on a
    movie are not found on the website. Your customer support team did some investigating
    and found that there is a total of three comments incorrectly posted on a movie
    that actually belong to some other movie. The IDs of the incorrect comments are
    as follows:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 您数据库的一些用户抱怨说他们在网站上找不到对电影的评论。您的客服团队进行了一些调查，发现实际上有三条评论错误地发布在一部电影上，而这些评论实际上属于另一部电影。错误评论的ID如下：
- en: '[PRE98]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The following `find` query returns those three comments:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 以下“find”查询返回这三条评论：
- en: '[PRE99]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Execute the preceding query on the MongoDB Atlas `sample_mflix` database and
    the output should look as follows:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB Atlas的`sample_mflix`数据库上执行上述查询，输出应如下所示：
- en: '![Figure 5.29: Incorrect comments'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.29：不正确的评论'
- en: '](img/B15507_05_29.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_05_29.jpg)'
- en: 'Figure 5.29: Incorrect comments'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.29：不正确的评论
- en: All three comments above are posted against a 2009 movie, `Sherlock Holmes`
    (`ObjectId("573a13bcf29313caabd57db6")`), however, they belong to a 2014 movie,
    `50 First Dates` (`ObjectId("573a13abf29313caabd25582")`).
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 上述三条评论都是针对一部2009年的电影“神探夏洛克”（`ObjectId("573a13bcf29313caabd57db6")`）发布的，但实际上它们属于一部2014年的电影“初恋50次约”（`ObjectId("573a13abf29313caabd25582")`）。
- en: 'Your task for this activity is to correct `movie_id` in all three comments
    as well as to update the `num_mflix_comments` fields of these movies, respectively.
    The following steps will help you complete this activity:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 您在此活动中的任务是纠正所有三条评论中的`movie_id`，并分别更新这些电影的`num_mflix_comments`字段。以下步骤将帮助您完成此活动：
- en: Update the `movie_id` field in all three documents.
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新所有三个文档中的`movie_id`字段。
- en: Find the movie `Sherlock Holmes` by its ID and reduce the number of comments
    by 3.
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到电影“神探夏洛克”的ID，并将评论数量减少3条。
- en: Execute the command you used in *step 2* on the mongo shell and confirm the results.
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在mongo shell上执行您在*步骤2*中使用的命令，并确认结果。
- en: Find the movie `50 First Dates` and increase the number of comments by 3.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到电影“初恋50次”，并将评论数量增加3条。
- en: Execute the command you used in *step 3* on the mongo shell and confirm the results.
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在mongo shell上执行您在*步骤3*中使用的命令，并确认结果。
- en: Note
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15507_Solution_Final_SZ_ePub.xhtml#_idTextAnchor469).
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以通过[此链接](B15507_Solution_Final_SZ_ePub.xhtml#_idTextAnchor469)找到。
- en: Summary
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter with the creation of documents in a collection. We saw
    that, during an insert operation, MongoDB creates the underlying collection if
    it does not exist, and autogenerates an `_id` field if the document does not have
    one already. We then covered various functions provided by MongoDB to delete and
    replace one or more documents in a collection, as well as the concept of upsert,
    its benefits, its support in MongoDB, and how an upsert operation differs from
    delete and insert. Then we learned how to add, update, rename, or remove fields
    in MongoDB documents using various functions and operators.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从在集合中创建文档开始了本章。我们看到，在插入操作期间，如果文档不存在，MongoDB会创建底层集合，并且如果文档还没有`_id`字段，则会自动生成一个。然后，我们介绍了MongoDB提供的各种函数，用于删除和替换集合中的一个或多个文档，以及upsert的概念、其好处、在MongoDB中的支持，以及upsert操作与删除和插入的区别。然后我们学习了如何使用各种函数和操作符在MongoDB文档中添加、更新、重命名或删除字段。
- en: In the next chapter, we will execute some complex update commands using the
    aggregation pipeline support that was added in MongoDB 4.2, and learn how to modify
    the elements in an array field.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用MongoDB 4.2中添加的聚合管道支持执行一些复杂的更新命令，并学习如何修改数组字段中的元素。
