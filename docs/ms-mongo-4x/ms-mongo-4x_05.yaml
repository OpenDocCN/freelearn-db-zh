- en: MongoDB CRUD Operations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB CRUD操作
- en: In this chapter, we will learn how to use the mongo shell for database administration
    operations. Starting with simple **create,** **read,** **update, and delete**
    (**CRUD**) operations, we will master scripting from the shell. We will also learn
    how to write MapReduce scripts from the shell and contrast them to the aggregation
    framework, into which we will dive deeper in [Chapter 6](e74806c0-d233-4157-a354-31ab937b85b5.xhtml),
    *Aggregation*. Finally, we will explore authentication and authorization using
    the MongoDB community and its paid counterpart, the Enterprise Edition.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用mongo shell进行数据库管理操作。从简单的**创建**、**读取**、**更新**和**删除**（CRUD）操作开始，我们将掌握从shell进行脚本编写。我们还将学习如何从shell编写MapReduce脚本，并将其与聚合框架进行对比，我们将在[第6章](e74806c0-d233-4157-a354-31ab937b85b5.xhtml)中深入探讨聚合。最后，我们将探讨使用MongoDB社区及其付费版本企业版进行身份验证和授权。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: CRUD using the shell
  id: totrans-3
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用shell进行CRUD
- en: Administration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理
- en: Aggregation framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合框架
- en: Securing the shell
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护shell
- en: Authentication with MongoDB
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MongoDB进行身份验证
- en: CRUD using the shell
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用shell进行CRUD
- en: 'The mongo shell is equivalent to the administration console used by relational
    databases. Connecting to the mongo shell is as easy as typing the following code:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: mongo shell相当于关系数据库使用的管理控制台。连接到mongo shell就像输入以下代码一样简单：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Type this on the command line for standalone servers or replica sets. Inside
    the shell, you can view available databases simply by typing the following code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于独立服务器或副本集，请在命令行上键入此代码。在shell中，您可以通过输入以下代码简单查看可用的数据库：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, you can connect to a database by typing the following code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以通过输入以下代码连接到数据库：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The mongo shell can be used to query and update data into our databases. Inserting
    this document in the `books` collection can be done as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: mongo shell可用于查询和更新我们的数据库中的数据。可以通过以下方式将此文档插入到`books`集合中：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can then find documents from a collection named `books` by typing the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过输入以下内容从名为`books`的集合中查找文档：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The result we get back from MongoDB informs us that the write succeeded and
    inserted one new document in the database.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从MongoDB得到的结果告诉我们写入成功，并在数据库中插入了一个新文档。
- en: 'Deleting this document has a similar syntax and results in the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 删除这个文档有类似的语法，并导致以下代码的结果：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can try to update this same document as shown in the following code block:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试按照以下代码块中所示更新相同的文档：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we notice a couple of things:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们注意到了一些事情：
- en: The JSON-like formatted field in the `update` command is our query for searching
    for documents to update
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update`命令中的类似JSON格式的字段是我们搜索要更新的文档的查询'
- en: The `WriteResult` object notifies us that the query matched one document and
    modified one document
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WriteResult`对象通知我们查询匹配了一个文档并修改了一个文档'
- en: Most importantly, the contents of this document were entirely replaced by the
    contents of the second JSON-like formatted field but we have lost information
    on `title` and `isbn`
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最重要的是，该文档的内容完全被第二个类似JSON格式的字段的内容替换，但我们丢失了`title`和`isbn`的信息
- en: 'By default, the `update` command in MongoDB will replace the contents of our
    document with the document we specify in the second argument. If we want to update
    the document and add new fields to it, we need to use the `$set` operator, as
    follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，MongoDB中的`update`命令将使用我们在第二个参数中指定的文档替换我们文档的内容。如果我们想要更新文档并向其添加新字段，我们需要使用`$set`运算符，如下所示：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, our document matches what we would expect:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的文档与我们的预期相匹配：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, deleting a document can be done in several ways, the most simple way
    is through its unique `ObjectId`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，删除文档可以通过多种方式完成，最简单的方式是通过其唯一的`ObjectId`：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can see here that when there are no results, the mongo shell will not return
    anything other than the shell prompt itself: `>`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里看到，当没有结果时，mongo shell除了shell提示本身之外不会返回任何内容：`>`。
- en: Scripting for the mongo shell
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为mongo shell编写脚本
- en: Administering the database using built-in commands is helpful, but it's not
    the main reason for using the shell. The true power of the mongo shell comes from
    the fact that it is a JavaScript shell.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内置命令管理数据库是有帮助的，但这并不是使用shell的主要原因。mongo shell的真正强大之处在于它是一个JavaScript shell。
- en: 'We can declare and assign variables in the shell as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在shell中声明和分配变量，如下所示：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the previous example, we declared a new `title` variable as `MongoDB in a
    nutshell` and used the variable to insert a new document into our `books` collection,
    as shown in the following code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们声明了一个名为`title`的新变量，值为`MongoDB in a nutshell`，并使用该变量将一个新文档插入到我们的`books`集合中，如下面的代码所示。
- en: 'As it''s a JavaScript shell, we can use it for functions and scripts that generate
    complex results from our database:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是一个JavaScript shell，我们可以使用它来生成复杂结果的函数和脚本：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With this one-liner, we are creating a new function named `queryBooksByIsbn` that
    takes a single argument, which is the `isbn` value. With the data that we have
    in our collection, we can use our new function and fetch books by `isbn`, as shown
    in the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个一行代码，我们创建了一个名为`queryBooksByIsbn`的新函数，它接受一个参数，即`isbn`值。有了我们在集合中的数据，我们可以使用我们的新函数并按`isbn`获取书籍，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Using the shell, we can write and test these scripts. Once we are satisfied,
    we can store them in the `.js` file and invoke them directly from the command
    line:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用shell，我们可以编写和测试这些脚本。一旦我们满意，我们可以将它们存储在`.js`文件中，并直接从命令行调用它们：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here are some useful notes about the default behavior of these scripts:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于这些脚本的默认行为的一些有用注释：
- en: Write operations will use a default write concern of `1`, which is global for
    MongoDB as of the current version. As write concern of `1` will request an acknowledgement
    that the write operation has propagated to the standalone `mongod` server or the
    primary server in a replica set.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写操作将使用默认的写关注`1`，这是MongoDB当前版本的全局默认值。写关注`1`将请求确认写操作已传播到独立的`mongod`服务器或副本集中的主服务器。
- en: To get results from operations from a script back to standard output, we must
    use either JavaScript's built-in `print()` function or the mongo-specific `printjson()`
    function, which prints out results formatted in JSON.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将脚本中的操作结果返回到标准输出，我们必须使用JavaScript的内置`print()`函数或mongo特定的`printjson()`函数，它以JSON格式打印出结果。
- en: The differences between scripting for the mongo shell and using it directly
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本编写mongo shell和直接使用之间的区别
- en: 'When writing scripts for the mongo shell, we cannot use the shell helpers.
    MongoDB''s commands, such as `use <database_name>`, `show collections`, and other
    helpers are built into the shell and so are not available from the JavaScript
    context where our scripts will get executed. Fortunately, there are equivalents
    to them that are available from the JavaScript execution context, as shown in
    the following table:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在为mongo shell编写脚本时，我们不能使用shell助手。MongoDB的命令，如`use <database_name>`，`show collections`和其他助手内置在shell中，因此无法从JavaScript上下文中使用，而我们的脚本将在其中执行。幸运的是，有它们的等价物可以从JavaScript执行上下文中使用，如下表所示：
- en: '| **Shell helpers** | **JavaScript equivalents** |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **Shell helpers** | **JavaScript equivalents** |'
- en: '| `show dbs, show databases` | `db.adminCommand(''listDatabases'')` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `show dbs, show databases` | `db.adminCommand(''listDatabases'')` |'
- en: '| `use <database_name>` | `db = db.getSiblingDB(''<database_name>'')` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `use <database_name>` | `db = db.getSiblingDB(''<database_name>'')` |'
- en: '| `show collections` | `db.getCollectionNames()` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `show collections` | `db.getCollectionNames()` |'
- en: '| `show users` | `db.getUsers()` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `show users` | `db.getUsers()` |'
- en: '| `show roles` | `db.getRoles({showBuiltinRoles: true})` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `show roles` | `db.getRoles({showBuiltinRoles: true})` |'
- en: '| `show log <logname>` | `db.adminCommand({ ''getLog'' : ''<logname>'' })`
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `show log <logname>` | `db.adminCommand({ ''getLog'' : ''<logname>'' })`
    |'
- en: '| `show logs` | `db.adminCommand({ ''getLog'' : ''*'' })` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `show logs` | `db.adminCommand({ ''getLog'' : ''*'' })` |'
- en: '| `it` | `cursor = db.collection.find()` `if ( cursor.hasNext() ){`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '| `it` | `cursor = db.collection.find()` `if ( cursor.hasNext() ){`'
- en: '` cursor.next();`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '` cursor.next();`'
- en: '`}` |'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`}` |'
- en: In the previous table, `it` is the iteration cursor that the mongo shell returns
    when we query and get back too many results to show in one batch.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在上表中，`it`是迭代光标，当我们查询并返回太多结果以显示在一个批处理中时，mongo shell返回的。
- en: Using the mongo shell, we can script almost anything that we would from a client,
    meaning that we have a really powerful tool for prototyping and getting quick
    insights into our data.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用mongo shell，我们可以编写几乎任何我们从客户端编写的脚本，这意味着我们有一个非常强大的原型工具，可以快速了解我们的数据。
- en: Batch inserts using the shell
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用shell进行批量插入
- en: 'When using the shell, there will be many times we want to insert a large number
    of documents programmatically. The most straightforward implementation since we
    have a JavaScript shell, is to iterate through a loop, generating each document
    along the way, and performing a write operation in every iteration in the loop,
    as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用shell时，我们经常需要以编程方式插入大量文档。由于我们有一个JavaScript shell，最直接的实现方式是通过循环迭代，逐步生成每个文档，并在每次循环迭代中执行写操作，如下所示：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this simple example, we create an `authorMongoFactory()` method for an author
    who writes `1000` books on MongoDB with a slightly different name for each one:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，我们为一个作者创建了一个`authorMongoFactory()`方法，他写了`1000`本关于MongoDB的书，每本书的名字略有不同：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will result in `1000` writes being issued to the database. While it is
    simple from a development point of view, this method will put a strain on the
    database.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致向数据库发出`1000`次写入。虽然从开发的角度来看很简单，但这种方法会给数据库带来压力。
- en: 'Instead, using a `bulk` write, we can issue a single database `insert` command
    with the `1000` documents that we have prepared beforehand, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，使用`bulk`写入，我们可以使用事先准备好的`1000`个文档发出单个数据库`insert`命令，如下所示：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The end result is the same as before, with the `1000` documents being inserted
    with the following structure in our `books` collection:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果与之前相同，在我们的`books`集合中插入了`1000`个文档，结构如下：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The difference from the user's perspective lies in the speed of execution and
    reduced strain on the database.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度来看，区别在于执行速度和对数据库的减轻压力。
- en: In the preceding example, we used `initializeUnorderedBulkOp()` for the `bulk`
    operation builder setup. The reason we did this is because we don't care about
    the order of insertions being the same as the order in which we add them to our
    `bulk` variable with the `bulk.insert()` command.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了`initializeUnorderedBulkOp()`来设置`bulk`操作构建器。我们这样做的原因是因为我们不关心插入的顺序与我们使用`bulk.insert()`命令将它们添加到我们的`bulk`变量的顺序相同。
- en: This makes sense when we can make sure that all operations are unrelated to
    each other or idempotent.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们可以确保所有操作彼此无关或幂等时，这是有意义的。
- en: 'If we care about having the same order of insertions, we can use `initializeOrderedBulkOp()`;
    by changing the second line of our function, we get the following code snippet:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们关心插入的顺序相同，我们可以使用`initializeOrderedBulkOp()`；通过更改函数的第二行，我们得到以下代码片段：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Batch operations using the mongo shell
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用mongo shell进行批量操作
- en: In the case of inserts, we can generally expect that the order of operations
    doesn't matter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入的情况下，我们通常可以期望操作的顺序并不重要。
- en: '`bulk`, however, can be used with many more operations than just inserts. In
    the following example, we have a single book with `isbn : 101` and the `name` of `Mastering
    MongoDB` in a `bookOrders` collection with the number of available copies to purchase
    in the `available` field, with the `99` books available for purchase:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`bulk`可以用于比插入更多的操作。在下面的例子中，我们在`bookOrders`集合中有一本书，`isbn：101`，`name`为`Mastering
    MongoDB`，在`available`字段中有可购买的可用副本数量，有`99`本可供购买：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With the following series of operations in a single `bulk` operation, we are
    adding one book to the inventory and then ordering `100` books, for a final total
    of zero copies available:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一系列操作在单个`bulk`操作中，我们将向库存中添加一本书，然后订购`100`本书，最终总共可用的副本为零：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With the code, we will get the following output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代码，我们将得到以下输出：
- en: '![](img/be7ce6c2-d39a-4090-953c-aa8830588774.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be7ce6c2-d39a-4090-953c-aa8830588774.png)'
- en: Using `initializeOrderedBulkOp()`, we can make sure that we are adding one book
    before ordering `100` so that we are never out of stock. On the contrary, if we
    were using `initializeUnorderedBulkOp()`, we won't have such a guarantee and we
    might end up with the 100-book order coming in before the addition of the new
    book, resulting in an application error as we don't have that many books to fulfill
    the order.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`initializeOrderedBulkOp()`，我们可以确保在订购`100`本书之前添加一本书，以便我们永远不会缺货。相反，如果我们使用`initializeUnorderedBulkOp()`，我们就无法得到这样的保证，我们可能会在添加新书之前收到100本书的订单，导致应用程序错误，因为我们没有那么多书来满足订单。
- en: 'When executing through an ordered list of operations, MongoDB will split the
    operations into batches of `1000` and group these by operation. For example, if
    we have `1002` inserts, `998` updates, `1004` deletes, and finally, `5` inserts,
    we will end up with the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行有序操作列表时，MongoDB将操作分成`1000`个批次，并按操作分组。例如，如果我们有`1002`个插入，`998`个更新，`1004`个删除，最后`5`个插入，我们最终会得到以下结果：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The previous code can be explained as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可以解释如下：
- en: '![](img/9bce1eca-424e-447a-a0df-5c866a63024f.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9bce1eca-424e-447a-a0df-5c866a63024f.png)'
- en: This doesn't affect the series of operations, but it implicitly means that our
    operations will leave the database in batches of `1000`. This behavior is not
    guaranteed to stay in future versions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会影响操作系列，但隐含意味着我们的操作将以`1000`的批次离开数据库。这种行为不能保证在将来的版本中保持不变。
- en: If we want to inspect the execution of a `bulk.execute()` command, we can issue
    `bulk.getOperations()` right after we type `execute()`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要检查`bulk.execute()`命令的执行，我们可以在输入`execute()`后立即发出`bulk.getOperations()`。
- en: Since version 3.2, MongoDB has offered an alternative command for bulk writes,
    `bulkWrite()`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 自3.2版本以来，MongoDB提供了批量写入的替代命令`bulkWrite()`。
- en: '`bulkWrite` arguments are the series of operations we want to execute. `WriteConcern` (the
    default is again `1`), and if the series of write operations should get applied
    in the order that they appear in the array (they will be ordered by default):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`bulkWrite`参数是我们要执行的操作系列。`WriteConcern`（默认值再次为`1`），以及写操作系列是否应按照它们在数组中出现的顺序应用（默认情况下将按顺序排列）：'
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following operations are the same ones supported by `bulk`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下操作与`bulk`支持的操作相同：
- en: '`insertOne`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insertOne`'
- en: '`updateOne`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateOne`'
- en: '`updateMany`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateMany`'
- en: '`deleteOne`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deleteOne`'
- en: '`deleteMany`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deleteMany`'
- en: '`replaceOne`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replaceOne`'
- en: '`updateOne`, `deleteOne`, and `replaceOne` have matching filters; if they match
    more than one document, they will only operate on the first one. It''s important
    to design these queries so that they don''t match more than one document, otherwise,
    the behavior will be undefined.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateOne`，`deleteOne`和`replaceOne`具有匹配的过滤器；如果它们匹配多个文档，它们只会对第一个文档进行操作。重要的是要设计这些查询，以便它们不匹配多个文档，否则行为将是未定义的。'
- en: Administration
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理
- en: Using MongoDB should, for the most part, be as transparent as possible to the
    developer. Since there are no schemas, there is no need for migrations, and generally,
    developers find themselves spending less time on administrative tasks in the database
    world.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，使用MongoDB应该对开发人员尽可能透明。由于没有模式，因此不需要迁移，通常情况下，开发人员发现自己在数据库世界中花费的时间较少。
- en: That said, there are several tasks that an experienced MongoDB developer or
    architect can perform to keep up the speed and performance of MongoDB.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，有几个任务是经验丰富的MongoDB开发人员或架构师可以执行以保持MongoDB的速度和性能。
- en: 'Administration is generally performed in three different levels, ranging from
    more generic to more specific: **process**, **collection**, and **index**.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 管理通常在三个不同的级别上执行，从更通用到更具体：**进程**，**集合**和**索引**。
- en: At the process level, there is the `shutDown` command to shut down the MongoDB
    server.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在进程级别上，有`shutDown`命令来关闭MongoDB服务器。
- en: 'At the database level, we have the following commands:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库级别上，我们有以下命令：
- en: '`dropDatabase`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dropDatabase`'
- en: '`listCollections`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`listCollections`'
- en: '`copyDB` or `clone` to clone a remote database locally'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copyDB`或`clone`以在本地克隆远程数据库'
- en: '`repairDatabase` for when our database is not in a consistent state due to
    an unclean shutdown'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repairDatabase`：当我们的数据库由于不干净的关闭而处于不一致状态时'
- en: 'In comparison, at the collection level, the following commands are used:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在集合级别上，使用以下命令：
- en: '`drop`: To drop a collection'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drop`：删除集合'
- en: '`create`: To create a collection'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create`：创建集合'
- en: '`renameCollection`: To rename a collection'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`renameCollection`：重命名集合'
- en: '`cloneCollection`: To clone a remote collection to our local DB'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cloneCollection`：将远程集合克隆到我们的本地数据库'
- en: '`cloneCollectionAsCapped`: To clone a collection into a new capped collection'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cloneCollectionAsCapped`：将集合克隆到新的封顶集合'
- en: '`convertToCapped`: To convert a collection to a capped one'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`convertToCapped`：将集合转换为封顶集合'
- en: 'At the index level, we can use the following commands:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在索引级别上，我们可以使用以下命令：
- en: '`createIndexes`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createIndexes`'
- en: '`listIndexes`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`listIndexes`'
- en: '`dropIndexes`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dropIndexes`'
- en: '`reIndex`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reIndex`'
- en: We will also go through a few other commands that are more important from an
    administration standpoint.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍一些更重要的管理命令。
- en: fsync
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fsync
- en: MongoDB normally writes all operations to the disk every 60 seconds. fsync will
    force data to persist to the disk immediately and synchronously.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB通常每60秒将所有操作写入磁盘。fsync将强制数据立即和同步地持久保存到磁盘。
- en: If we want to take a backup of our databases, we need to apply a lock as well.
    Locking will block all writes and some reads while fsync is operating.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想备份数据库，我们还需要应用锁。在fsync操作时，锁定将阻止所有写入和一些读取。
- en: In almost all cases, it's better to use journaling and refer to our techniques
    for backup and restore, which will be covered in [Chapter 8](687220c0-264a-4edb-9e04-c10b0c180766.xhtml)*,*
    *Monitoring, Backup, and Security*, for maximum availability and performance.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有情况下，最好使用日志记录，并参考我们的备份和恢复技术，这将在[第8章](687220c0-264a-4edb-9e04-c10b0c180766.xhtml)*，*
    *监控、备份和安全*中进行介绍，以获得最大的可用性和性能。
- en: compact
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: compact
- en: MongoDB documents take up a specified amount of space on a disk. If we perform
    an update that increases the size of a document, this may end up being moved out
    of sequence to the end of the storage block, creating a hole in storage, resulting
    in increased execution times for this update, and possibly missing it from running
    queries. The compact operation will defragment space and result in less space
    being used.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB文档在磁盘上占据指定的空间。如果我们执行一个更新，增加了文档的大小，这可能会导致它被移出存储块的顺序，在存储中创建一个空洞，导致此更新的执行时间增加，并可能导致它在运行查询时被忽略。紧缩操作将对空间进行碎片整理，并减少使用的空间。
- en: 'We can update a document by adding an extra 10 bytes, showing how it will be
    moved to the end of the storage block, and creating an empty space in the physical
    storage:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加额外的10个字节来更新一个文档，展示它将如何被移动到存储块的末尾，并在物理存储中创建一个空间：
- en: '![](img/8e60c62b-f925-4231-9ff6-6e43f60683df.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e60c62b-f925-4231-9ff6-6e43f60683df.png)'
- en: '`compact` can also take a `paddingFactor` argument as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`compact`也可以接受`paddingFactor`参数，如下所示：'
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`paddingFactor` is the preallocated space in each document that ranges from
    `1.0` (that is, no padding, which is the default value) to `4.0` for calculating
    the padding of `300` bytes for each `100` bytes of document space that is needed
    when we initially insert it.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`paddingFactor`是每个文档中预分配的空间，范围从`1.0`（即没有填充，这是默认值）到`4.0`，用于计算每个文档空间的`100`字节所需的`300`字节填充。'
- en: Adding padding can help alleviate the problem of updates moving documents around,
    at the expense of more disk space being needed for each document when created.
    By padding each document, we are allocating more space for it that will prevent
    it from being moved to the end of the storage block if our updated document can
    still fit in the preallocated storage space.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 添加填充可以帮助缓解更新移动文档的问题，但需要更多的磁盘空间来创建每个文档。通过为每个文档添加填充，我们为其分配了更多的空间，这将防止它被移动到预分配的存储空间的末尾，如果我们更新的文档仍然可以适应预分配的存储空间。
- en: currentOp and killOp
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: currentOp和killOp
- en: '`db.currentOp()` will show us the currently-running operation in the database
    and will attempt to kill it. We need to run the `use admin` command before running
    `killOp()`. Needless to say, using `killOp()` against internal MongoDB operations
    is not recommended or advised, as the database may end up in an undefined state.
    The `killOp()` command can be used as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.currentOp()`将显示数据库中当前正在运行的操作，并尝试终止它。在运行`killOp()`之前，我们需要运行`use admin`命令。毋庸置疑，不建议或建议使用`killOp()`来终止内部MongoDB操作，因为数据库可能会处于未定义的状态。`killOp()`命令可以如下使用：'
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: collMod
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: collMod
- en: '`collMod` is used to pass flags to a collection by modifying the underlying
    database''s behavior.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`collMod`用于通过修改底层数据库的行为来向集合传递标志。'
- en: Since version 3.2, the most interesting set of flags that we can pass to a collection
    is document validation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本3.2以来，我们可以传递给集合的最有趣的一组标志是文档验证。
- en: Document validation can specify a set of rules to be applied to new updates
    and inserts into a collection. This means that current documents will be checked
    if they get modified.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 文档验证可以指定一组规则，应用于对集合的新更新和插入。这意味着如果修改了当前文档，将会对当前文档进行检查。
- en: We can only apply validations to documents that are already valid if we set
    `validationLevel` to `moderate`. By specifying `validationAction`, we can log
    documents that are invalid by setting it to `warn` or prevent updates from happening
    altogether by setting it to `error`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`validationLevel`设置为`moderate`，我们只能对已经有效的文档应用验证。通过指定`validationAction`，我们可以通过将其设置为`warn`来记录无效的文档，或者通过将其设置为`error`来完全阻止更新。
- en: 'For example, with the previous example of `bookOrders` we can set `validator`
    on the `isbn` and `name` fields being present for every insert or update, as demonstrated
    in the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于之前的`bookOrders`示例，我们可以在每次插入或更新时设置`isbn`和`name`字段的`validator`，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, we get back the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们得到了以下代码：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, if we try to insert a new document with only the `isbn` field being present,
    we get an error:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们尝试插入一个只有`isbn`字段的新文档，我们会收到一个错误：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We get an error because our validation has failed. Managing validation from
    the shell is really useful as we can write scripts to manage it, and also make
    sure that everything is in place.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到错误是因为我们的验证失败了。从shell中管理验证非常有用，因为我们可以编写脚本来管理它，并确保一切就位。
- en: touch
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: touch
- en: 'The `touch` command will load data and/or index data from storage to memory.
    This is typically useful if our script will subsequently use this data, speeding
    up the execution:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`touch`命令将从存储中加载数据和/或索引数据到内存中。如果我们的脚本随后将使用这些数据，这通常是有用的，可以加快执行速度：'
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This command should be used with caution in production systems, as loading data
    and indexes into memory will displace existing data from it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产系统中应谨慎使用此命令，因为将数据和索引加载到内存中将会将现有数据从中移除。
- en: MapReduce in the mongo shell
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在mongo shell中的MapReduce
- en: One of the most interesting features that has been underappreciated and not
    widely supported throughout MongoDB history, is the ability to write MapReduce
    natively using the shell.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个MongoDB历史中，一个被低估并且没有得到广泛支持的最有趣的功能之一，是能够在shell中原生地编写MapReduce。
- en: MapReduce is a data processing method for getting aggregation results from large
    sets of data. The main advantage of this is that it is inherently parallelizable
    as evidence by frameworks such as Hadoop.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: MapReduce是一种从大量数据中获取聚合结果的数据处理方法。其主要优势在于它本质上是可并行化的，这可以通过Hadoop等框架来证明。
- en: MapReduce is really useful when used to implement a data pipeline. Multiple
    MapReduce commands can be chained to produce different results. An example of
    this is aggregating data by using different reporting periods (such as hour, day,
    week, month, and year) where we use the output of each more granular reporting
    period to produce a less granular report.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当用于实现数据管道时，MapReduce非常有用。多个MapReduce命令可以链接在一起产生不同的结果。一个例子是通过使用不同的报告周期（如小时、天、周、月和年）对数据进行聚合，我们使用每个更精细的报告周期的输出来生成一个不太精细的报告。
- en: 'A simple example of MapReduce in our examples given that our input books collection
    is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，MapReduce的一个简单示例是，假设我们的输入书籍集合如下：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Our map and reduce functions are defined as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的map和reduce函数定义如下：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this `mapper`, we simply output a key of `id` of each document with a value
    of `1`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`mapper`中，我们只是输出每个文档的`id`键和值`1`：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In `reducer`, we sum across all values (where each one has a value of `1`):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在`reducer`中，我们对所有值求和（每个值都是`1`）：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Our final output will be a document with no ID, since we didn't output any value
    for ID, and a value of six, since there are six documents in the input dataset.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终输出将是一个没有ID的文档，因为我们没有输出任何ID的值，以及一个值为六的文档，因为输入数据集中有六个文档。
- en: Using MapReduce, MongoDB will apply a map to each input document, emitting key-value
    pairs at the end of the map phase. Then each reducer will get key-value pairs
    with the same key as input, processing all multiple values. The reducer's output
    will be a single key-value pair for each key.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MapReduce，MongoDB将对每个输入文档应用映射，在映射阶段结束时发出键值对。然后，每个reducer将获得具有与输入相同键的键值对，处理所有多个值。reducer的输出将是每个键的单个键值对。
- en: Optionally, we can use a `finalize` function to further process the results
    of `mapper` and `reducer`. MapReduce functions use JavaScript and run within the
    `mongod` process. MapReduce can output inline as a single document, subject to
    the 16 MB document size limit, or as multiple documents in an output collection.
    Input and output collections can be sharded.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，我们可以使用“finalize”函数进一步处理“mapper”和“reducer”的结果。MapReduce函数使用JavaScript并在“mongod”进程中运行。MapReduce可以作为单个文档内联输出，受到16MB文档大小限制的限制，或者作为输出集合中的多个文档输出。输入和输出集合可以进行分片。
- en: MapReduce concurrency
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MapReduce并发
- en: 'MapReduce operations will place several short-lived locks that should not affect
    operations. However, at the end of the `reduce` phase, if we output the data to
    an existing collection, then output actions such as `merge`, `reduce`, and `replace`
    will take an exclusive global write lock for the whole server, blocking all other
    writes to the `db` instance. If we want to avoid this, then we should invoke `mapReduce`
    in the following way:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: MapReduce操作将放置几个短暂的锁，不应影响操作。然而，在`reduce`阶段结束时，如果我们将数据输出到现有集合，则`merge`、`reduce`和`replace`等输出操作将为整个服务器获取独占全局写锁，阻止对`db`实例的所有其他写入。如果我们想避免这种情况，那么我们应该以以下方式调用`mapReduce`：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We can apply `nonAtomic` only to `merge` or `reduce` actions. `replace` will
    just replace the contents of documents in `bookOrders`, which will not take much
    time anyway.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能将“nonAtomic”应用于“merge”或“reduce”操作。`replace`将只是替换`bookOrders`中文档的内容，这也不会花费太多时间。
- en: With the `merge` action, the new result is merged with the existing result if
    the output collection already exists. If an existing document has the same key
    as the new result, then it will overwrite the existing document.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`merge`操作，如果输出集合已经存在，新结果将与现有结果合并。如果现有文档具有与新结果相同的键，则它将覆盖现有文档。
- en: With the `reduce` action, the new result is processed together with the existing
    result if the output collection already exists. If an existing document has the
    same key as the new result, it will apply the `reduce` function to both the new
    and the existing documents, and will overwrite the existing document with the
    result.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`reduce`操作，如果输出集合已经存在，新结果将与现有结果一起处理。如果现有文档具有与新结果相同的键，则它将对新文档和现有文档应用`reduce`函数，并用结果覆盖现有文档。
- en: Although MapReduce has been present since the early versions of MongoDB, it
    hasn't evolved as much as the rest of the database, resulting in its usage being
    less than that of specialized MapReduce frameworks such as Hadoop, which we will
    learn more about in [Chapter 11](da971527-0a0e-43cd-933e-5979379e75b4.xhtml),
    *Harnessing Big Data with MongoDB*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管MapReduce自MongoDB的早期版本以来就存在，但它的发展不如数据库的其他部分，导致其使用量不及专门的MapReduce框架（如Hadoop）多，我们将在[第11章](da971527-0a0e-43cd-933e-5979379e75b4.xhtml)中更多地了解有关*利用MongoDB进行大数据处理*。
- en: Incremental MapReduce
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增量MapReduce
- en: Incremental MapReduce is a pattern where we use MapReduce to aggregate to previously
    calculated values. An example of this could be counting non-distinct users in
    a collection for different reporting periods (that is, by hour, day, or month)
    without the need to recalculate the result every hour.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 增量MapReduce是一种模式，我们使用MapReduce来聚合先前计算的值。一个例子是对不同的报告周期（即按小时、天或月）中的集合进行计数非不同用户，而无需每小时重新计算结果。
- en: 'To set up our data for incremental MapReduce, we need to do the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置我们的数据进行增量MapReduce，我们需要做以下工作：
- en: Output our reduce data to a different collection
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的减少数据输出到不同的集合
- en: At the end of every hour, query only for the data that got into the collection
    in the last hour
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个小时结束时，只查询进入集合的数据
- en: With the output of our reduce data, merge our results with the calculated results
    from the previous hour
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们减少的数据输出，将我们的结果与上一个小时的计算结果合并
- en: 'Continuing with the previous example, let''s assume that we have a `published`
    field in each of the documents with our input dataset, as shown in the following
    code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 继续上一个例子，假设我们的输入数据集中每个文档都有一个`published`字段，如下所示：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Using our previous example of counting books, we will get the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前计算书籍数量的例子，我们将得到以下代码：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now we get a third book in our `mongo_book` collection with a document, as
    follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在我们的“mongo_book”集合中得到了第三本书，内容如下：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: What happened in the preceding code is that by querying for documents in July,
    2017, we only got the new document out of the query and then used its value to
    reduce the value with the already-calculated value of `2` in our `books_count`
    document, adding `1` to the final sum of `3` documents.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中发生的是，通过查询2017年7月的文档，我们只得到了查询中的新文档，然后使用它的值将值与我们的`books_count`文档中已经计算的值`2`进行减少，将`1`添加到最终的`3`文档的总和中。
- en: 'This example, as contrived as it is, shows a powerful attribute of MapReduce:
    the ability to re-reduce results to incrementally calculate aggregations over
    time.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子虽然有些牵强，但展示了MapReduce的一个强大特性：能够重新减少结果以逐渐计算聚合。
- en: Troubleshooting MapReduce
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除MapReduce
- en: Over the years, one of the major shortcomings of MapReduce frameworks has been
    the inherent difficulty in troubleshooting, as opposed to simpler non-distributed
    patterns. Most of the time, the most effective tool is debugging using `log` statements
    to verify that output values match our expected values. In the mongo shell, which
    is a JavaScript shell, it is as simple as providing the output using the `console.log()`
    function.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，MapReduce框架的主要缺点之一是与简单的非分布式模式相比，故障排除的固有困难。大多数时候，最有效的工具是使用`log`语句进行调试，以验证输出值是否与我们预期的值匹配。在mongo
    shell中，这是一个JavaScript shell，只需使用`console.log（）`函数提供输出即可。
- en: Diving deeper into MapReduce in MongoDB, we can debug both in the map and the
    reduce phase by overloading the output values.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解MongoDB中的MapReduce，我们可以通过重载输出值来调试映射和减少阶段。
- en: 'By debugging the `mapper` phase, we can overload the `emit()` function to test
    what the output key values will be, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调试“mapper”阶段，我们可以重载“emit（）”函数来测试输出键值将是什么，如下所示：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can then call it manually on a single document to verify that we get back
    the key-value pair that we expect:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以手动调用它来验证我们得到了预期的键值对：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `reducer` function is somewhat more complicated. A MapReduce `reducer`
    function must meet the following criteria:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: “reducer”函数有点复杂。MapReduce“reducer”函数必须满足以下标准：
- en: It must be idempotent
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须是幂等的
- en: It must be commutative
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须是可交换的
- en: The order of values coming from the `mapper` function should not matter for
    the reducer's result
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自“mapper”函数的值的顺序对于减少器的结果并不重要
- en: The `reducer` function must return the same type of result as the `mapper` function
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “reducer”函数必须返回与“mapper”函数相同类型的结果
- en: 'We will dissect each of these following requirements to understand what they
    really mean:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分解以下每个要求，以了解它们真正的含义：
- en: '**It must be idempotent**: MapReduce, by design, may call the `reducer` function
    multiple times for the same key with multiple values from the `mapper` phase.
    It also doesn''t need to reduce single instances of a key as it''s just added
    to the set. The final value should be the same no matter the order of execution.
    This can be verified by writing our own `verifier` function and forcing `reducer`
    to re-reduce, or by executing `reducer` many times as shown in the following code
    snippet:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它必须是幂等的**：MapReduce的设计可能会多次调用“reducer”函数，对于来自“mapper”阶段的相同键的多个值。它也不需要减少键的单个实例，因为它只是添加到集合中。无论执行顺序如何，最终值应该是相同的。这可以通过编写我们自己的“verifier”函数并强制“reducer”重新减少，或者像下面的代码片段中所示执行多次“reducer”来验证：'
- en: '[PRE39]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**It must be commutative**: As multiple invocations of the `reducer` function
    may happen for the same `key`, if it has multiple values, the following code should
    hold:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它必须是可交换的**：由于对于相同的“键”，可能会多次调用“reducer”函数，如果它有多个值，以下代码应该成立：'
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**The order of values coming from the mapper function should not matter for
    the reducer''s result**: We can test that the order of values from `mapper` doesn''t
    change the output for `reducer`, by passing in documents to `mapper` in a different
    order and verifying that we get the same results out:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**来自mapper函数的值的顺序对于reducer的结果并不重要**：我们可以测试`mapper`的值的顺序是否改变了`reducer`的输出，通过以不同的顺序将文档传递给`mapper`并验证我们得到了相同的结果：'
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**The reduce function must return the same type of result as the mapper function**:
    Hand-in-hand with the first requirement, the type of object that the `reduce`
    function returns should be the same as the output of the `mapper` function.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少函数必须返回与映射函数相同类型的结果**：与第一个要求紧密相关，`reduce`函数返回的对象类型应与`mapper`函数的输出相同。'
- en: Aggregation framework
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合框架
- en: Since version 2.2, MongoDB has provided a better way to work with aggregation,
    one that has been supported, adopted, and enhanced regularly ever since. The aggregation
    framework is modeled after data processing pipelines.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 自2.2版本以来，MongoDB提供了一种更好的处理聚合的方式，这种方式一直得到支持、采用和定期增强。聚合框架是模仿数据处理管道的。
- en: 'In data processing pipelines, there are three main operations: filters that
    operate like queries, filtering documents, and document transformations that transform
    documents to get them ready for the next stage.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据处理管道中，有三个主要操作：像查询一样操作的过滤器，过滤文档，以及文档转换，以准备好进行下一阶段的转换。
- en: SQL to aggregation
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL到聚合
- en: 'An aggregation pipeline can replace and augment querying operations in the
    shell. A common pattern for development is as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合管道可以在shell中替换和增强查询操作。开发的常见模式如下：
- en: To verify that we have the correct data structures and get quick results using
    a series of queries in the shell
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证我们是否有正确的数据结构，并使用一系列shell中的查询快速获得结果
- en: To prototype pipeline results using the aggregation framework
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用聚合框架原型管道结果
- en: To refine and refactor if/when needed, either by ETL processes to get data into
    a dedicated data warehouse, or by more extensive usage of the application layer
    to get the insights that we need
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需要进行细化和重构，可以通过ETL过程将数据放入专用数据仓库，也可以通过更广泛地使用应用程序层来获得所需的见解
- en: 'In the following table, we can see how SQL commands map to the aggregation
    framework operators:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下表中，我们可以看到SQL命令如何映射到聚合框架操作符：
- en: '| **SQL** | **Aggregation framework** |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: SQL | 聚合框架 |
- en: '| `WHERE`/`HAVING` | `$match` |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: WHERE / HAVING | $match |
- en: '| `GROUP BY` | `$group` |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: 分组 | $group |
- en: '| `SELECT` | `$project` |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: 选择 | $project |
- en: '| `ORDER BY` | `$sort` |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: ORDER BY | $sort |
- en: '| `LIMIT` | `$limit` |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: LIMIT | $limit |
- en: '| `sum()`/`count()` | `$sum` |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: sum() / count() | $sum |
- en: '| `join` | `$lookup` |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: 连接 | $lookup |
- en: Aggregation versus MapReduce
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合与MapReduce
- en: 'In MongoDB, we can essentially get data out of our database by using three
    methods: querying, the aggregation framework, and MapReduce. All three of them
    can be chained to each other and many times it is useful to do so; however, it''s
    important to understand when we should use aggregation and when MapReduce may
    be a better alternative.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中，我们可以通过三种方法从数据库中获取数据：查询、聚合框架和MapReduce。这三种方法都可以相互链接，很多时候这样做是有用的；然而，重要的是要理解何时应该使用聚合，何时MapReduce可能是更好的选择。
- en: We can use both aggregation and MapReduce with sharded databases.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在分片数据库中同时使用聚合和MapReduce。
- en: Aggregation is based on the concept of a pipeline. As such, it's important to
    be able to model our data from the input to the final output, in a series of transformations
    and processing that can get us there. It's also mostly useful when our intermediate
    results can be used on their own, or feed parallel pipelines. Our operations are
    limited by the operators that we have available from MongoDB, so it's important
    to make sure that we can calculate all the results we need by using the available
    commands.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合基于管道的概念。因此，能够对我们的数据进行建模，从输入到最终输出，在一系列的转换和处理中，可以让我们达到目标，这一点非常重要。当我们的中间结果可以单独使用或者供并行管道使用时，它也是非常有用的。我们的操作受到来自MongoDB的可用操作符的限制，因此确保我们可以使用可用的命令计算出所有需要的结果非常重要。
- en: MapReduce, on the other hand, can be used to construct pipelines by chaining
    the output of one MapReduce job to the input of the next one via an intermediate
    collection, but this is not its primary purpose.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，MapReduce可以通过将一个MapReduce作业的输出链接到下一个作业的输入，通过一个中间集合来构建管道，但这不是它的主要目的。
- en: MapReduce's most common use case is to periodically calculate aggregations for
    large datasets. Having MongoDB's querying in place, we can incrementally calculate
    these aggregations without the need to scan through the whole input table every
    time. In addition, its power comes from its flexibility as we can define mappers
    and reducers in JavaScript with the full flexibility of the language when calculating
    intermediate results. Not having the operators that the aggregation framework
    provides us with, we have to implement them on our own.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: MapReduce最常见的用例是定期计算大型数据集的聚合。有了MongoDB的查询，我们可以增量计算这些聚合，而无需每次都扫描整个输入表。此外，它的强大之处在于其灵活性，我们可以使用JavaScript定义映射器和减速器，完全灵活地计算中间结果。由于没有聚合框架提供的操作符，我们必须自己实现它们。
- en: In many cases, the answer is not either/or. We can (and should) use the aggregation
    framework to construct our ETL pipeline and resort to MapReduce for the parts
    that are not yet supported sufficiently by it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，答案不是二选一。我们可以（也应该）使用聚合框架来构建ETL管道，并在尚未得到足够支持的部分使用MapReduce。
- en: A complete use case with aggregation and MapReduce is provided in [Chapter 6](e74806c0-d233-4157-a354-31ab937b85b5.xhtml),
    *Aggregation*.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在《第6章》《聚合》中提供了一个完整的聚合和MapReduce用例。
- en: Securing the shell
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护shell
- en: MongoDB is a database developed with the ease of development in mind. As such,
    security at the database level was not baked in from the beginning and it was
    up to the developers and administrators to secure the MongoDB host from accessing outside
    the application server.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是一个以开发便利性为目标开发的数据库。因此，数据库级别的安全性并不是从一开始就内置的，而是由开发人员和管理员来保护MongoDB主机不被外部应用服务器访问。
- en: Unfortunately, this means that as far as back as 2015, there were 39,890 databases
    found open to the internet, with no security access configured. Many of them were
    production databases, one belonging to a French telecom operator and containing
    more than eight million records from its customers.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这意味着早在2015年，就发现有39,890个数据库对外开放，没有配置安全访问。其中许多是生产数据库，其中一个属于法国电信运营商，包含了超过800万条客户记录。
- en: Nowadays, there is no excuse for leaving any MongoDB server with the default
    authentication off settings at any stage of development, from local server deployment
    to production.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，没有任何借口可以让任何MongoDB服务器在任何开发阶段都保持默认的关闭认证设置。
- en: Authentication and authorization
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证和授权
- en: Authentication and authorization are closely connected and sometimes confused.
    Authentication is about verifying the identity of a user to the database. An example
    of authentication is **Secure Sockets Layer** (**SSL**), where the web server
    verifies its identity—that it is who it claims to be—to the user.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 认证和授权密切相关，有时会引起混淆。认证是验证用户对数据库的身份。认证的一个例子是安全套接字层（SSL），在这里，Web服务器验证其身份——即它向用户所声称的身份。
- en: Authorization is about determining what actions a user can take on a resource.
    In the next sections, we will discuss authentication and authorization with these
    definitions in mind.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 授权是确定用户对资源可以执行哪些操作。在接下来的章节中，我们将根据这些定义讨论认证和授权。
- en: Authorization with MongoDB
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB的授权
- en: 'MongoDB''s most basic authorization relies on the username/password method.
    By default, MongoDB will not start with authorization enabled. To enable it, we
    need to start our server with the `--auth` parameter:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB最基本的授权依赖于用户名/密码方法。默认情况下，MongoDB不会启用授权。要启用它，我们需要使用`--auth`参数启动服务器。
- en: '[PRE42]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To set up authorization, we need to start our server without authorization
    to set up a user. Setting up an admin user is simple:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置授权，我们需要在没有授权的情况下启动服务器以设置用户。设置管理员用户很简单：
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here, `<adminUser>` is the name of the user we want to create, `<password>`
    is the password, and `<adminRole>` can be any of the following values ordered
    from the most powerful to the least powerful, as shown in the following list:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<adminUser>`是我们要创建的用户的名称，`<password>`是密码，`<adminRole>`可以是以下列表中从最强大到最弱的任何一个值：
- en: '`root`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`root`'
- en: '`dbAdminAnyDatabase`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dbAdminAnyDatabase`'
- en: '`userAdminAnyDatabase`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userAdminAnyDatabase`'
- en: '``readWriteAnyDatabase``'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readWriteAnyDatabase`'
- en: '`readAnyDatabase`'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readAnyDatabase`'
- en: '`dbOwner`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dbOwner`'
- en: '`dbAdmin`'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dbAdmin`'
- en: '`userAdmin`'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userAdmin`'
- en: '`readWrite`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readWrite`'
- en: '`read`'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read`'
- en: Of these roles, `root` is the superuser that allows access to everything. This
    is not recommended to be used, except for special circumstances.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些角色中，`root`是允许访问所有内容的超级用户。除了特殊情况，不建议使用这个角色。
- en: All the `AnyDatabase` roles provide access to all databases, of which `dbAdminAnyDatabase`
    combines the `userAdminAnyDatabase` and `readWriteAnyDatabase` scopes being an
    admin again in all databases.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的`AnyDatabase`角色都提供对所有数据库的访问权限，其中`dbAdminAnyDatabase`结合了`userAdminAnyDatabase`和`readWriteAnyDatabase`范围，再次成为所有数据库中的管理员。
- en: 'The rest of the roles are defined in the database that we want them to apply,
    by changing the roles subdocument of the preceding `db.createUser()`; for example,
    to create a `dbAdmin` for our `mongo_book` database, we would use the following
    code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的角色是在我们希望它们应用的数据库中定义的，通过更改前面的`db.createUser()`的角色子文档；例如，要为我们的`mongo_book`数据库创建`dbAdmin`，我们将使用以下代码：
- en: '[PRE44]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Cluster administration has even more roles, which we will cover in more depth
    in [Chapter 12](59874e20-5c76-4e7c-9d21-934fe637f3c1.xhtml), *Replication*.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 集群管理还有更多的角色，我们将在[第12章](59874e20-5c76-4e7c-9d21-934fe637f3c1.xhtml) *复制*中更深入地介绍。
- en: 'Finally, when we restart our database with the `--auth` flag set, we can use
    either the command line or the connection string (from any driver) to connect
    as `admin` and create new users with predefined or custom-defined roles:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们使用`--auth`标志重新启动我们的数据库时，我们可以使用命令行或连接字符串（来自任何驱动程序）作为`admin`连接并创建具有预定义或自定义角色的新用户：
- en: '[PRE45]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Security tips for MongoDB
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB的安全提示
- en: Common software system security precautions apply with MongoDB. We will outline
    some of them here and learn how to enable them.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的软件系统安全预防措施也适用于MongoDB。我们将在这里概述其中一些，并学习如何启用它们。
- en: Encrypting communication using TLS/SSL
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TLS/SSL加密通信
- en: Communication between the `mongod` or `mongos` server and the client mongo shell
    or applications should be encrypted. This is supported in most MongoDB distributions
    from version 3.0 onward; however, we need to take care that we download the proper
    version with SSL support.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`mongod`或`mongos`服务器与客户端mongo shell或应用程序之间的通信应该是加密的。这在大多数MongoDB发行版中从3.0版本开始就得到支持；但是，我们需要注意下载具有SSL支持的正确版本。'
- en: After this, we need to get a signed certificate from a trusted certificate authority
    or sign our own. Using self-signed certificates is fine for preproduction systems,
    but in production it will mean that MongoDB servers won't be able to verify our
    identity, leaving us susceptible to man-in-the-middle attacks; thus using a proper
    certificate is highly recommended.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要从受信任的证书颁发机构获取签名证书，或者自己签名。对于预生产系统来说，使用自签名证书是可以的，但在生产中，这将意味着MongoDB服务器无法验证我们的身份，使我们容易受到中间人攻击的影响；因此强烈建议使用正确的证书。
- en: 'To start our MongoDB server with SSL, we need the following code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用SSL启动我们的MongoDB服务器，我们需要以下代码：
- en: '[PRE46]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, `<pem>` is our `.pem` signed certificate file and `<ca>` is the `.pem`
    root certificate from the certificate authority that contains the root certificate
    chain.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<pem>`是我们的`.pem`签名证书文件，`<ca>`是证书颁发机构的`.pem`根证书，其中包含根证书链。
- en: 'These options can also be defined in our configuration file, `mongod.conf`
    or `mongos.conf`, in YAML file format, as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项也可以在我们的配置文件`mongod.conf`或`mongos.conf`中以YAML文件格式定义如下：
- en: '[PRE47]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, we specified a `PEMKeyFile`, a `CAFile`, and also that we won't allow
    the server to start with certificates that follow the `TLS1_0`, `TLS1_1` or `TLS1_2`
    versions. These are the available versions for `disabledProtocols` at this time.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定了`PEMKeyFile`，`CAFile`，并且我们不允许服务器使用`TLS1_0`，`TLS1_1`或`TLS1_2`版本的证书启动。这些是当前可用的`disabledProtocols`版本。
- en: Encrypting data
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密数据
- en: Using WiredTiger is highly recommended for encrypting data at rest, as it supports
    it natively from version 3.2.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用WiredTiger强烈建议用于对数据进行加密，因为它从3.2版本开始就原生支持。
- en: For users of the Community Edition version, this can be achieved in the storage
    selection of their choice; for example, in **Amazon Web Services** (**AWS**) using **Elastic
    Block Store** (**EBS**) encrypted storage volumes.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '对于社区版的用户，可以在他们选择的存储中实现这一点；例如，在**亚马逊网络服务**（**AWS**）中使用**弹性块存储**（**EBS**）加密存储卷。 '
- en: This feature is available only for MongoDB Enterprise Edition.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能仅适用于MongoDB企业版。
- en: Limiting network exposure
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制网络暴露
- en: 'The oldest security method to secure any server is to disallow it from accepting
    connections from unknown sources. In MongoDB, this is done in a configuration
    file with a simple line as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 保护任何服务器的最古老的安全方法是禁止它接受来自未知来源的连接。在MongoDB中，这是在配置文件中通过一行简单的代码完成的，如下所示：
- en: '[PRE48]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, `<string>` is a comma-separated list of IPs that the MongoDB server will
    accept connections from.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<string>`是MongoDB服务器将接受连接的IP的逗号分隔列表。
- en: Firewalls and VPNs
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防火墙和VPN
- en: Together with limiting network exposure on the server side, we can use firewalls
    to prevent access to our network from the outside internet. VPNs can also provide
    tunneled traffic between our servers, but regardless, they shouldn't be used as
    our sole security mechanism.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在服务器端限制网络暴露之外，我们还可以使用防火墙阻止外部互联网对我们网络的访问。VPN也可以在我们的服务器之间提供隧道流量，但无论如何，它们都不应该作为我们唯一的安全机制。
- en: Auditing
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审计
- en: No matter how secure any system is, we need to keep a close eye on the system from
    an auditing perspective to make sure that we detect possible breaches and stop
    them as soon as possible.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 无论系统有多安全，我们都需要从审计的角度密切关注系统，以确保我们及时发现可能的违规行为并尽快停止它们。
- en: This feature is available only for MongoDB Enterprise Edition.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能仅适用于MongoDB企业版。
- en: For users of the Community Edition version, we have to set up auditing manually
    by logging changes to documents and collections in the application layer, possibly
    in a different database altogether. This will be addressed in the next chapter,
    which covers advanced querying using client drivers.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对于社区版用户，我们必须通过在应用程序层记录文档和集合的更改来手动设置审计，可能在完全不同的数据库中。这将在下一章中讨论，该章节涵盖了使用客户端驱动程序进行高级查询。
- en: Using secure configuration options
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用安全配置选项
- en: 'It goes without saying that the same configuration options should be used.
    We must use one of the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，应该使用相同的配置选项。我们必须使用以下之一：
- en: MapReduce
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MapReduce
- en: The mongo shell group operation or a group operation from our client driver
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mongo shell组操作或来自客户端驱动程序的组操作
- en: '`$where` JavaScript server evaluation'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$where` JavaScript服务器评估'
- en: If we don't, we should disable server-side scripting by using the `--noscripting`
    option on the command line when we start our server.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不这样做，我们应该在启动服务器时使用命令行上的`--noscripting`选项来禁用服务器端脚本。
- en: The mongo shell group operation, as mentioned in the previous list, can be a
    tricky one as many drivers may use MongoDB's `group()` command when we issue group
    commands in the driver. However, given the limitations that `group()` has in terms
    of performance and output documents, we should rethink our design to use the aggregation
    framework or application-side aggregations.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的列表中所述，mongo shell组操作可能会有些棘手，因为许多驱动程序在发出组命令时可能会使用MongoDB的`group()`命令。然而，考虑到`group()`在性能和输出文档方面的限制，我们应该重新考虑我们的设计，使用聚合框架或应用程序端的聚合。
- en: 'The web interface also has to be disabled by not using any of the following
    commands:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 还必须通过不使用以下任何命令来禁用Web界面：
- en: '`net.http.enabled`'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net.http.enabled`'
- en: '`net.http.JSONPEnabled`'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net.http.JSONPEnabled`'
- en: '`net.http.RESTInterfaceEnabled`'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net.http.RESTInterfaceEnabled`'
- en: On the contrary, `wireObjectCheck` needs to remain enabled as it is by default,
    and ensures that all documents stored by the `mongod` instance are valid BSON.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`wireObjectCheck`需要保持默认启用，以确保`mongod`实例存储的所有文档都是有效的BSON。
- en: Authentication with MongoDB
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MongoDB进行身份验证
- en: By default, MongoDB uses SCRAM-SHA-1 as the default challenge and response authentication
    mechanism. This is an SHA-1 username/password-based mechanism for authentication.
    All drivers and the mongo shell itself have built-in methods to support it.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，MongoDB使用SCRAM-SHA-1作为默认的挑战和响应身份验证机制。这是一种基于SHA-1的用户名/密码身份验证机制。所有驱动程序和mongo
    shell本身都具有内置方法来支持它。
- en: The authentication protocol in MongoDB has changed since version 3.0\. In older
    versions, the less secure MONGODB-CR was used.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 自MongoDB 3.0版本以来，MongoDB中的身份验证协议已经发生了变化。在旧版本中，使用了不太安全的MONGODB-CR。
- en: Enterprise Edition
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业版
- en: MongoDB's Enterprise Edition is a paid subscription product offering more features
    around security and administration.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB的企业版是一种付费订阅产品，提供了更多关于安全性和管理的功能。
- en: Kerberos authentication
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kerberos身份验证
- en: MongoDB Enterprise Edition also offers Kerberos authentication. Kerberos, named
    after the character Kerberos (or Cerberus) from Greek mythology—which is the ferocious
    three-headed guard-dog of the god of the underworld, Hades—focuses on mutual authentication
    between client and server, protecting against eavesdropping and replay attacks.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB企业版还提供Kerberos身份验证。Kerberos是根据希腊神话中的角色Kerberos（或Cerberus）命名的，它是地府之神哈迪斯的凶猛的三头看门犬，专注于客户端和服务器之间的相互认证，防止窃听和重放攻击。
- en: 'Kerberos is widely used in Windows systems through integration with Microsoft''s
    Active Directory. To install Kerberos, we need to start `mongod` without Kerberos
    set up, then connect to the `$external` database (not the admin that we normally
    use for admin authorization), and create a user with a Kerberos role and permissions:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Kerberos在Windows系统中广泛使用，通过与微软的Active Directory集成。要安装Kerberos，我们需要启动未设置Kerberos的`mongod`，然后连接到`$external`数据库（而不是我们通常用于管理授权的admin），并创建具有Kerberos角色和权限的用户：
- en: '[PRE49]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding example, we authorize the `mongo_book_user@packt.net` user
    to read our `mongo_book` database, just like we would do with a user using our
    admin system.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们授权`mongo_book_user@packt.net`用户读取我们的`mongo_book`数据库，就像我们在管理系统中使用用户一样。
- en: 'After that, we need to start our server with Kerberos support by passing in
    the `authenticationMechanisms` parameter, as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要通过传递`authenticationMechanisms`参数来启动支持Kerberos的服务器，如下所示：
- en: '[PRE50]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now we can connect from our server or command line, as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从我们的服务器或命令行连接，如下所示：
- en: '[PRE51]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: LDAP authentication
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LDAP身份验证
- en: Similar to Kerberos authentication, we can also use **Lightweight Directory
    Access Protocol** (**LDAP**) in MongoDB Enterprise Edition only. The user setup
    needs to be done in the `$external` database and must match the name of the authentication
    LDAP name. The name may need to pass through a transformation and this may cause
    a mismatch between the LDAP name and the user entry in the `$external` database.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 与Kerberos身份验证类似，我们也只能在MongoDB企业版中使用轻量级目录访问协议（LDAP）。用户设置必须在`$external`数据库中完成，并且必须与身份验证LDAP名称匹配。名称可能需要经过转换，这可能会导致LDAP名称与`$external`数据库中的用户条目不匹配。
- en: Setting up LDAP authentication is beyond the scope of this book, but the important
    thing to consider is that any changes in the LDAP server may need changes in the
    MongoDB server, which won't happen automatically.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 设置LDAP身份验证超出了本书的范围，但需要考虑的重要事情是LDAP服务器的任何更改可能需要对MongoDB服务器进行更改，这不会自动发生。
- en: Summary
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we scratched the tip of the iceberg of CRUD operations. Starting
    from the mongo shell, we learned how to insert, delete, read, and modify documents.
    We also discussed the differences between one-off inserts and inserting in batches
    for performance.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只是触及了CRUD操作的冰山一角。从mongo shell开始，我们学习了如何插入、删除、读取和修改文档。我们还讨论了一次性插入和批量插入的性能差异。
- en: Following that, we discussed administration tasks and how to perform them in
    the mongo shell. MapReduce and its successor, aggregation framework, were also
    discussed in this chapter, including how they compare, how to use them, and how
    we can translate SQL queries to aggregation framework pipeline commands.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论了管理任务以及如何在mongo shell中执行它们。本章还讨论了MapReduce及其后继者聚合框架，包括它们的比较、如何使用它们以及如何将SQL查询转换为聚合框架管道命令。
- en: Finally, we discussed security and authentication with MongoDB. Securing our
    database is of paramount importance; we will learn more about this in [Chapter
    8](687220c0-264a-4edb-9e04-c10b0c180766.xhtml), *Monitoring, Backup, and Security*.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了MongoDB的安全性和认证。保护我们的数据库至关重要；我们将在第8章《监控、备份和安全》中学到更多内容。
- en: 'In the next chapter, we will dive deeper into CRUD using three of the most
    popular languages for web development: Ruby, Python, and **PHP: Hypertext Preprocessor**
    (**PHP**).'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨使用三种最流行的Web开发语言进行CRUD操作：Ruby、Python和PHP（超文本预处理器）。
