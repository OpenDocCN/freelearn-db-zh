- en: Multi-Document ACID Transactions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多文档ACID事务
- en: MongoDB introduced multi-document **atomicity**, **consistency**, **isolation**,
    and **durability** (**ACID**) transactions in version 4.0, which was released
    in July 2018\. Transactions are an integral part of relational databases. Every
    **relational database management system** (**RDBMS**) from the very early days
    relied on transactions to achieve ACID. Getting these in a non-relational database
    is a breakthrough that can fundamentally change the way developers and database
    architects design software systems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB在2018年7月发布的4.0版本中引入了多文档原子性、一致性、隔离性和持久性（ACID）事务。事务是关系数据库的一个组成部分。从早期开始，每个关系数据库管理系统（RDBMS）都依赖事务来实现ACID。在非关系型数据库中实现这些功能是一个突破，可以从根本上改变开发人员和数据库架构师设计软件系统的方式。
- en: 'In the previous chapter, we learned how to query MongoDB using Ruby, Python,
    and PHP drivers and frameworks. In this chapter, we will learn about the following
    topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用Ruby、Python和PHP的驱动程序和框架查询MongoDB。在本章中，我们将学习以下主题：
- en: Multi-document ACID transactions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多文档ACID事务
- en: Using transactions with Ruby and Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ruby和Python进行事务处理
- en: Background
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景
- en: MongoDB is a non-relational database and provides few guarantees around ACID.
    Data modeling in MongoDB is not focused around BCNF, 2NF, and 3NF normalization, but
    rather, quite the opposite direction.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是一个非关系型数据库，对ACID提供了很少的保证。MongoDB中的数据建模并不是围绕BCNF、2NF和3NF规范化，而是相反的方向。
- en: In MongoDB, many times, the best approach is to embed our data into subdocuments,
    resulting in more self-contained documents than a single row of data in an RDBMS.
    This means that a logical transaction can affect a single document many times.
    Single-document transactions are ACID-compliant in MongoDB, meaning that multi-document
    ACID transactions have not been essential for MongoDB development.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中，很多时候，最好的方法是将我们的数据嵌入子文档中，这样可以得到比在关系数据库管理系统中单行数据更自包含的文档。这意味着一个逻辑事务可以多次影响单个文档。在MongoDB中，单文档事务是符合ACID的，这意味着多文档ACID事务对于MongoDB的开发并不是必不可少的。
- en: However, there are a few reasons why getting multi-document transactions is
    a good idea. Over the years, MongoDB has grown from being a niche database to
    a multi-purpose database that is used everywhere – from startups to major Fortune
    500 companies. Across many different use cases, there are inevitably a few corner
    cases where data modeling can't, or shouldn't, fit data in subdocuments and arrays.
    Also, even when the best solution for a data architect today is to embed data,
    they can't be sure this will always be the case. This makes choosing the right
    database layer difficult.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有几个原因说明为什么实现多文档事务是一个好主意。多年来，MongoDB已经从一个小众数据库发展成为一个多用途数据库，被各种公司广泛使用，从初创公司到财富500强公司。在许多不同的用例中，不可避免地会有一些情况，数据建模无法或不应该将数据放入子文档和数组中。此外，即使对于数据架构师来说，今天最好的解决方案是嵌入数据，他们也无法确定这种情况会一直持续下去。这使得选择正确的数据库层变得困难。
- en: RDBMS data modeling has been around for over 40 years and is a well-known and
    understood data modeling process. Helping data architects work in a familiar way
    is always an added bonus.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库数据建模已经存在了40多年，是一个众所周知和理解的数据建模过程。帮助数据架构师以熟悉的方式工作总是一个额外的好处。
- en: Before multi-document transactions were introduced, the only workaround was
    implementing them in a customized way in the application layer. This was both
    time consuming and prone to error. Implementing a 2-phase commit process in the
    application layer could also be slower and lead to increased database locks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入多文档事务之前，唯一的解决方法是在应用层以定制的方式实现它们。这既耗时又容易出错。在应用层实现两阶段提交过程也可能更慢，并导致增加数据库锁。
- en: In this chapter, we will focus on using the native MongoDB transactions, as
    it is now strongly recommended by MongoDB Inc.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于使用原生的MongoDB事务，因为这是MongoDB公司强烈推荐的。
- en: ACID
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ACID
- en: ACID stands for atomicity, consistency, isolation, and durability. In the following
    sections, we will explain what each of these means for our database design and
    architecture.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ACID代表原子性、一致性、隔离性和持久性。在接下来的章节中，我们将解释这些对于我们的数据库设计和架构意味着什么。
- en: Atomicity
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子性
- en: Atomicity refers to the concept that transactions need to be atomic. Either
    it succeeds and its results are visible to every subsequent user reading them,
    or it fails and every change is rolled back to the point it was at before it started.
    Either all actions in a transaction occur, or none at all.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 原子性指的是事务需要是原子的概念。要么成功并且其结果对每个后续用户都是可见的，要么失败并且每个更改都被回滚到开始之前的状态。事务中的所有操作要么全部发生，要么全部不发生。
- en: A simple example to understand atomicity is by transferring money from account
    *A* to account *B*. Money needs to be credited from account *A* and then debited
    into account *B*. If the operation fails midway, then both accounts *A* and *B*
    need to be reverted to their state before the operation started.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子来理解原子性是将钱从账户*A*转账到账户*B*。需要从账户*A*中存入钱，然后转入账户*B*。如果操作在中途失败，那么账户*A*和*B*都需要恢复到操作开始之前的状态。
- en: In MongoDB, operations in a single document are always atomic even if the operation
    spans multiple subdocuments or arrays within the document.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中，即使操作跨多个子文档或数组，单个文档中的操作也总是原子的。
- en: Operations spanning multiple documents need to use MongoDB transactions to be
    made atomic.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 跨多个文档的操作需要使用MongoDB事务来实现原子性。
- en: Consistency
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一致性
- en: Consistency refers to the database always being in a consistent state. Every
    database operation may complete successfully, fail, or abort; however, in the
    end, our database must be in a state where its data is consistent.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性指的是数据库始终处于一致的状态。每个数据库操作可能成功完成、失败或中止；然而，最终，我们的数据库必须处于一个数据一致的状态。
- en: Database constraints must be respected at all times. Any future transaction
    must also be able to view data updated by past transactions. The consistency model
    most commonly used in practice for distributed data systems is eventual consistency.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库约束必须始终得到尊重。任何未来的事务也必须能够查看过去事务更新的数据。在实践中，分布式数据系统中最常用的一致性模型是最终一致性。
- en: Eventual consistency guarantees that once we stop updating our data, all future
    reads will eventually read the latest committed write value. In distributed systems,
    this is the only acceptable model in terms of performance, as data needs to be
    replicated over the network across different servers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最终一致性保证一旦我们停止更新数据，所有未来的读取将最终读取最新提交的写入值。在分布式系统中，这是性能方面唯一可接受的模型，因为数据需要在不同服务器之间的网络上复制。
- en: In contrast, the least popular model of strong consistency guarantees that every
    future read will always read the write value that was committed last. This implies
    that every update is propagated and committed to every server before the next
    read comes in, which will cause a huge strain on performance for these systems.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，最不受欢迎的强一致性模型保证每次未来读取都将始终读取上次提交的写入值。这意味着每次更新都会在下一次读取之前传播并提交到每个服务器，这将对这些系统的性能造成巨大压力。
- en: MongoDB falls somewhere in between eventual and strict consistency. In fact,
    MongoDB adopts a causal consistency model. With causal consistency, any transaction
    execution sequence is the same as if all causally-related read/write ops were
    executed in an order that reflects their causality.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB介于最终一致性和严格一致性之间。事实上，MongoDB采用因果一致性模型。在因果一致性中，任何事务执行顺序都与如果所有因果相关的读/写操作按照反映它们因果关系的顺序执行的顺序相同。
- en: What this means in practice is that concurrent operations may be seen in different
    orders, and reads correspond to the latest value written with regard to the writes
    that they are causally dependent on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这意味着并发操作可能以不同的顺序被看到，读取对应于最新写入的值，与它们因果依赖的写入相关。
- en: Eventually, it's a trade-off between how many concurrent operations can happen
    at once and the consistency of data being read by the application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这是一个权衡，即同时发生多少并发操作和应用程序读取的数据一致性。
- en: Isolation
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隔离
- en: Isolation refers to the visibility of transaction operations to other operations
    happening in parallel.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离指的是事务操作对其他并行操作的可见性。
- en: 'An example of why isolation levels are essential is described in the following
    scenario:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离级别至关重要的一个例子描述如下情景：
- en: Transaction *A* updates user 1's account balance from 50 to 100, but does not
    commit the transaction.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务*A*将用户1的账户余额从50更新为100，但不提交事务。
- en: Transaction *B* reads user 1's account balance as 100.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务*B*将用户1的账户余额读取为100。
- en: Transaction *A* is rolled back, reverting user 1's account balance to 50.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务*A*被回滚，将用户1的账户余额恢复为50。
- en: Transaction *B* thinks that user 1 has 100 pounds, whereas they only have 50.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务*B*认为用户1有100英镑，而实际上只有50英镑。
- en: Transaction *B* updates user 2's value, by adding 100 pounds. User 2 receives
    100 pounds out of thin air from user 1, since user 1 only has 50 pounds in their
    account. Our imaginary bank is in trouble.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务*B*更新用户2的值，增加100英镑。用户2从用户1那里凭空得到100英镑，因为用户1的账户中只有50英镑。我们的想象中的银行陷入了麻烦。
- en: 'Isolation typically has four levels, with the most to the least strict, as
    follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离通常有四个级别，从最严格到最不严格，如下所示：
- en: Serializable
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可串行化
- en: Repeatable read
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复读取
- en: Read committed
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读已提交
- en: Read uncommitted
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读未提交
- en: 'The problems we can run into from the least to the most serious, and depending
    on the isolation level, are as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能遇到的问题，从最不严重到最严重，取决于隔离级别，如下所示：
- en: Phantom reads
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幻读
- en: Non-repeatable reads
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可重复读取
- en: Dirty reads
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脏读
- en: Lost updates
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丢失更新
- en: Losing data about an operational update is the worst thing that can happen in
    any database, because this would render our database unusable and make it a store
    of data that cannot be trusted. That's why, in every isolation level, even read
    uncommitted isolation will not lose data.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何数据库中，丢失有关操作更新的数据是最糟糕的事情，因为这将使我们的数据库无法使用，并使其成为一个不可信任的数据存储。这就是为什么在每个隔离级别中，即使是读取未提交的隔离，也不会丢失数据。
- en: However, the other three issues may also arise. We will briefly explain what
    these are in the following sections.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，其他三个问题也可能出现。我们将在以下部分简要解释这些问题是什么。
- en: Phantom reads
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 幻读
- en: 'A phantom read occurs when, during the course of a transaction, another transaction
    modifies its result set by adding or deleting rows that belong to its result set.
    An example of this would be the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 幻读发生在事务过程中，另一个事务通过添加或删除属于其结果集的行来修改其结果集。一个例子是：
- en: Transaction *A* queries for all users. 1,000 users are returned but the transaction
    does not commit.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务*A*查询所有用户。返回1,000个用户，但事务没有提交。
- en: Transaction *B* adds another user; 1,001 users are now in our database.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务*B*添加另一个用户；现在我们的数据库中有1,001个用户。
- en: Transaction *A* queries for all users for a second time. 1,001 users are now
    returned. Transaction *A* now commits.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务*A*第二次查询所有用户。现在返回1,001个用户。事务*A*现在提交。
- en: Under a strict serializable isolation level, transaction *B* should be blocked
    from adding the new user until transaction *A* commits its transaction. This can,
    of course, cause huge contention in the database and contention in the database
    and lead to performance degradation, as every update operation needs to wait for
    reads to commit their transactions. This is why, typically, serializable is rarely
    used in practice.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格的可串行化隔离级别下，事务*B*应该被阻止添加新用户，直到事务*A*提交其事务。当然，这可能会在数据库中引起巨大的争用，并导致性能下降，因为每个更新操作都需要等待读取提交其事务。这就是为什么通常在实践中很少使用可串行化。
- en: Non-repeatable reads
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可重复读取
- en: A non-repeatable read occurs when, during a transaction, a row is retrieved
    twice and the row's values are different with every read operation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当在事务期间检索一行两次并且行的值在每次读取操作时都不同时，就会发生不可重复读取。
- en: 'Following the previous money transfer example, we can illustrate a non-repeatable
    read in a similar way:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 根据先前的资金转移示例，我们可以类似地说明不可重复读取：
- en: Transaction *B* reads user 1's account balance as 50.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务*B*读取用户1的账户余额为50。
- en: Transaction *A* updates user 1's account balance from 50 to 100, and commits
    the transaction.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务*A*将用户1的账户余额从50更新为100，并提交事务。
- en: Transaction *B* reads user 1's account balance again and gets the new value,
    100, and then commits the transaction.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务*B*再次读取用户1的账户余额，并获得新值100，然后提交事务。
- en: The problem here is that transaction *B* has got a different value in the course
    of its transaction because it was affected by transaction *A*'s update. This is
    a problem because transaction *B* is getting different values within its own transaction.
    However, in practice, it solves the issue of transferring money between users
    when they don't exist.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于事务*B*在其事务过程中得到了不同的值，因为它受到了事务*A*的更新的影响。这是一个问题，因为事务*B*在其自己的事务中得到了不同的值。然而，在实践中，它解决了在用户不存在时在用户之间转移资金的问题。
- en: This is why a read committed isolation level, which does not prevent non-repeatable
    reads but does prevent dirty reads, is the most commonly-used isolation level
    in practice.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么读取提交的隔离级别在实践中是最常用的隔离级别，它不会阻止不可重复读取，但会阻止脏读。
- en: Dirty reads
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脏读
- en: The previous example, where we made money out of thin air and ended up transferring
    100 pounds out of an account that only had 50 pounds in balance, is a classic
    example of dirty reads.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的例子中，我们通过虚拟货币赚了钱，最终从只有50英镑余额的账户中转出了100英镑，这是脏读的典型例子。
- en: A read uncommitted isolation level does not protect us from dirty reads and
    that is why it is rarely used in production level systems.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 读取未提交的隔离级别不能保护我们免受脏读的影响，这就是为什么它在生产级系统中很少使用的原因。
- en: 'The following is the isolation levels versus potential issues:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是隔离级别与潜在问题的对比：
- en: '| **Isolation level** | **Lost updates** | **Dirty reads** | **Non-repeatable
    reads** | **Phantoms** |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **隔离级别** | **丢失更新** | **脏读** | **不可重复读** | **幻读** |'
- en: '| Read uncommitted | Don''t occur | May occur | May occur | May occur |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 读取未提交 | 不会发生 | 可能发生 | 可能发生 | 可能发生 |'
- en: '| Read committed | Don''t occur | Don''t occur | May occur | May occur |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 读取提交 | 不会发生 | 不会发生 | 可能发生 | 可能发生 |'
- en: '| Repeatable read | Don''t occur | Don''t occur | Don''t occur | May occur
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 可重复读取 | 不会发生 | 不会发生 | 不会发生 | 可能发生 |'
- en: '| Serializable | Don''t occur | Don''t occur | Don''t occur | Don''t occur
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 可串行化 | 不会发生 | 不会发生 | 不会发生 | 不会发生 |'
- en: PostgreSQL uses a default (and configurable) isolation level of read committed.
    As MongoDB is not inherently an RDBMS, using transactions for every operation
    makes the situation is more complicated.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL使用默认（和可配置的）读取提交的隔离级别。由于MongoDB本质上不是关系数据库管理系统，对每个操作使用事务会使情况变得更加复杂。
- en: The equivalent isolation level in these terms is read uncommitted. This may
    look scary based on the examples previously given, but on the other hand, in MongoDB,
    there is (again, in general) no concept of transactions or rolling them back.
    Read uncommitted refers to the fact that changes will be made visible before they
    are made durable. More details on the made durable part are provided in the following
    section on durability.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些术语中，等价的隔离级别是读取未提交。根据先前给出的例子，这可能看起来很可怕，但另一方面，在MongoDB中，（再次强调，一般情况下）没有事务的概念或回滚事务。读取未提交指的是在使其持久化之前将更改可见。有关持久化部分的更多详细信息将在持久性的以下部分中提供。
- en: Durability
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 耐久性
- en: Durability in relational database systems refers to the property that every
    transaction that has successfully committed will survive in the face of failure.
    This usually refers to writing the contents of the committed transaction in persistent
    storage (such as a hard disk or SDD). RDBMSes are always following the durability
    concept by writing every committed transaction to a transaction log or **write-ahead
    log** (**WAL**). MongoDB, using the WiredTiger storage engine, is committing writes
    using WAL to its persistent storage-based journal every 60 msec and is, for all
    practical purposes, durable. As durability is important, every database system
    prefers relaxing other aspects of ACID first, and durability usually gets relaxed
    last.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系数据库系统中，持久性是指每个成功提交的事务将在面对故障时幸存的属性。这通常指的是将已提交事务的内容写入持久存储（如硬盘或SDD）。关系数据库管理系统总是通过将每个已提交的事务写入事务日志或**预写式日志**（**WAL**）来遵循持久性概念。MongoDB使用WiredTiger存储引擎，每60毫秒将写入使用WAL提交到其基于持久存储的日志，并且在所有实际目的上是持久的。由于持久性很重要，每个数据库系统都更喜欢首先放松ACID的其他方面，而持久性通常是最后放松的。
- en: When do we need ACID in MongoDB ?
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们何时需要在MongoDB中使用ACID？
- en: Existing atomicity guarantees, for single-document operations, that MongoDB can
    meet the integrity needs for most real-world applications. However, there are
    some use cases that have traditionally benefited from ACID transactions; modeling
    them in MongoDB could be significantly more difficult than using the well-known
    ACID paradigm.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的原子性保证，对于单文档操作，MongoDB可以满足大多数现实世界应用程序的完整性需求。然而，一些传统上受益于ACID事务的用例在MongoDB中建模可能比使用众所周知的ACID范式要困难得多。
- en: Unsurprisingly, many of these cases come from the financial industry. Dealing
    with money and stringent regulation frameworks means that each and every operation
    needs to be stored, sometimes in strict execution order, logged, verified, and
    be able to be audited if requested. Building a digital bank requires interaction
    between multiple accounts that could be represented as documents in MongoDB.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，许多这些情况来自金融行业。处理资金和严格的监管框架意味着每个操作都需要被存储，有时需要严格的执行顺序，记录，验证，并且在需要时可以进行审计。构建数字银行需要在MongoDB中将多个账户之间的交互表示为文档。
- en: Managing high volumes of financial transactions, either by users or algorithms
    executing high-frequency trading, also requires verifying each and every single
    one of them. These transactions may span multiple documents, as they would again
    refer to multiple accounts.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 管理用户或执行高频交易的算法产生的大量财务交易，还需要验证每一笔交易。这些交易可能涉及多个文档，因为它们可能再次涉及多个帐户。
- en: The general pattern for using multi-document ACID transactions is when we can
    have an unbounded number of entities, sometimes to the millions. In this case,
    modeling entities in subdocuments and arrays cannot work, as the document would
    eventually outgrow the built-in 16 MB document size limit present in MongoDB.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多文档ACID事务的一般模式是当我们可以拥有无限数量的实体时，有时可能达到数百万。在这种情况下，对实体进行子文档和数组建模是行不通的，因为文档最终会超出MongoDB中内置的16
    MB文档大小限制。
- en: Building a digital bank using MongoDB
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MongoDB构建数字银行
- en: The most common use cases for multi-document ACID transactions come from the
    financial sector. In this section, we will model a digital bank using transactions
    and go through progressively more complicated examples of how we can use transactions
    for our benefit.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 多文档ACID事务的最常见用例来自金融领域。在本节中，我们将使用事务模拟数字银行，并逐渐介绍如何利用事务来获益的更复杂的示例。
- en: 'The basic functionality that a bank must provide is accounts and transferring
    monetary amounts between them. Before transactions were introduced, MongoDB developers
    had two options. The first option – the MongoDB way of doing it – is to embed
    data in a document, either as a subdocument or as an array of values. In the case
    of accounts, this could result in a data structure like the following code block:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 银行必须提供的基本功能是帐户和在它们之间转移货币金额。在引入事务之前，MongoDB开发人员有两个选择。第一种选择是MongoDB的处理方式，即将数据嵌入文档中，可以是子文档或值数组。对于帐户，这可能会导致以下代码块中的数据结构：
- en: '[PRE0]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, even in this simple format, it will quickly outgrow the fixed 16 MB
    document limit in MongoDB. The advantage of this approach is that since we have
    to deal with a single document, all operations will be atomic, resulting in strong
    consistency guarantees when we transfer money from one account to another.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使在这种简单的格式中，它也会很快超出MongoDB中固定的16 MB文档限制。这种方法的优势在于，由于我们必须处理单个文档，所有操作都将是原子的，从而在我们将资金从一个帐户转移到另一个帐户时产生强一致性保证。
- en: The only viable alternative, except for using a relational database, is to implement
    guarantees in the application level that will simulate a transaction with the
    appropriate code in place to undo parts, or the whole, of a transaction in case
    of an error. This can work, but will result in a longer time to market and is
    more prone to error.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用关系数据库之外，唯一可行的替代方案是在应用程序级别实现保证，以模拟具有适当代码的事务，以便在出现错误时撤消部分或全部事务。这种方法可以奏效，但会导致更长的上市时间，并且更容易出现错误。
- en: 'MongoDB''s multi-document ACID transactions approach is similar to how we would
    work with transactions in a relational database. Taking the most simple example
    from MongoDB Inc.''s white paper, *MongoDB Multi-Document ACID Transactions,*
    published in June, 2018, the generic transaction in MongoDB will look like the
    following code block:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB的多文档ACID事务方法类似于我们在关系数据库中处理事务的方式。从MongoDB Inc.于2018年6月发布的《MongoDB多文档ACID事务》白皮书中，最简单的例子是，MongoDB中的通用事务将如下代码块所示：
- en: '[PRE1]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, the same transaction in MySQL will be as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在MySQL中进行相同的事务将如下所示：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That said, in modern web application frameworks, most of the time transactions
    are hidden in the **object-relational mapping** (**ORM**) layer and not immediately
    visible to the application developer. The framework ensures that web requests
    are wrapped in transactions to the underlying database layer. This is not yet
    the case for ODM frameworks, but you would expect that this could now change.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，在现代Web应用程序框架中，大多数情况下，事务都隐藏在对象关系映射（ORM）层中，对应用程序开发人员不可见。框架确保Web请求被包装在传递到底层数据库层的事务中。这在ODM框架中还没有实现，但可以预期这种情况可能会发生改变。
- en: Setting up our data
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的数据
- en: 'We are going to use a sample `init_data.json` file with two accounts. Alex
    has 100 of the hypnotons imaginary currency, whereas Mary has 50 of them:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个包含两个帐户的示例`init_data.json`文件。Alex有100个hypnotons虚拟货币，而Mary有50个：
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Using the following Python code, we can insert these values into our database
    as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下Python代码，我们可以将这些值插入到我们的数据库中：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This results in our `mongo_bank` database having the following documents in
    our `accounts` collection:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致我们的`mongo_bank`数据库在我们的`accounts`集合中具有以下文档：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Transferring between accounts – part 1
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 帐户之间的转移-第1部分
- en: 'As a MongoDB developer, the most familiar approach to model a transaction is
    to implement basic checks in the code. With our sample account documents, you
    may be tempted to implement an account transfer as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 作为MongoDB开发人员，模拟事务的最常见方法是在代码中实现基本检查。对于我们的示例帐户文档，您可能会尝试实现帐户转移如下：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Calling this method in Python will transfer 300 hypnotons from account 1 to
    account 2:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中调用此方法将从帐户1转移300个hypnotons到帐户2：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will result in the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下结果：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The problem here isn't the checks on `updated_source_balance` and `updated_target_balance`.
    Both of these values reflect the new values of `-200` and `350`, respectively.
    The problem isn't the `abort_transaction()` operation either. Instead, the problem
    is that we are not using the session.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题不在于`updated_source_balance`和`updated_target_balance`的检查。这两个值都反映了分别为`-200`和`350`的新值。问题也不在于`abort_transaction()`操作。相反，问题在于我们没有使用会话。
- en: The single most important thing to learn about transactions in MongoDB is that
    we need to use the session object to wrap operations in a transaction; but, all
    the while, we can still perform operations outside the transaction scope within
    a transaction code block.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中学习有关事务的最重要的一点是，我们需要使用会话对象来包装事务中的操作；但与此同时，在事务代码块内部仍然可以执行事务范围之外的操作。
- en: 'What happened here is that we initiated a transaction session, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的是，我们启动了一个事务会话，如下所示：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And then completely ignored it by doing all of our updates in a non-transactional
    way. Then we invoked `abort_transaction`, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后完全忽略了这一点，通过非事务方式进行所有更新。然后我们调用了`abort_transaction`，如下所示：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The transaction to be aborted was essentially void and didn't have anything
    to roll back.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要中止的事务本质上是无效的，没有任何需要回滚的内容。
- en: Transferring between accounts – part 2
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 账户之间的转账-第2部分
- en: 'The correct way to implement a transaction is to use the session object in
    each and every operation that we want to either commit or roll back at the end
    of it, as you can see from the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 实现事务的正确方法是在每个我们想要在最后提交或回滚的操作中使用会话对象，如下所示：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The only difference now is that we are passing `session=ses` in both of our
    update statements. In order to validate whether we have enough funds to actually
    make the transfer, we wrote a helper method, `__validate_transfer`, with its arguments
    being the source and target account IDs:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在唯一的区别是我们在两个更新语句中都传递了`session=ses`。为了验证我们是否有足够的资金来实际进行转账，我们编写了一个辅助方法`__validate_transfer`，其参数是源和目标账户ID：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Unfortunately, this attempt will also *fail*. The reason is the same as before.
    When we are inside a transaction, we make changes to the database that follow
    the ACID principles. Changes inside a transaction are not visible to any queries
    outside of it, until they are committed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这次尝试也会*失败*。原因与之前相同。当我们在事务内部时，对数据库进行的更改遵循ACID原则。事务内部的更改对外部查询不可见，直到它们被提交。
- en: Transferring between accounts – part 3
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 账户之间的转账-第3部分
- en: 'The correct implementation to the transfer problem will look like the following
    code (the full code sample is attached with the code bundle):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 解决转账问题的正确实现将如下代码所示（完整的代码示例附在代码包中）：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, by passing the session object's `ses` value, we ensure that we
    can both make changes in our database using `update_one()` and also view these
    changes using `find_one()`, before doing either an `abort_transaction()` operation
    or a `commit_transaction()` operation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，通过传递会话对象的`ses`值，我们确保可以使用`update_one()`在数据库中进行更改，并且还可以使用`find_one()`查看这些更改，然后执行`abort_transaction()`操作或`commit_transaction()`操作。
- en: Transactions cannot perform **data definition language** (**DDL**) operations,
    so `drop()`, `create_collection()`, and other operations that can affect MongoDB's
    DDL will fail inside a transaction. This is why we are setting `w='majority'`
    in our `MongoClient` object, to make sure that, when we drop a collection right
    before we start our transaction, this change will be visible to the transaction.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 事务无法执行**数据定义语言**（**DDL**）操作，因此`drop()`，`create_collection()`和其他可能影响MongoDB的DDL的操作在事务内部将失败。这就是为什么我们在`MongoClient`对象中设置`w='majority'`，以确保当我们在开始事务之前删除集合时，此更改将对事务可见。
- en: Even if we explicitly take care not to create or remove collections during a
    transaction, there are operations that will implicitly do so.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们明确注意在事务期间不创建或删除集合，也有一些操作会隐式执行此操作。
- en: We need to make sure that the collection exists before we attempt to insert
    or upsert (update and insert) a document.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保在尝试插入或更新（更新和插入）文档之前集合存在。
- en: In the end, using transactions if we need to rollback, we don't need to keep
    track of the previous account balance values, as MongoDB will discard all of the
    changes that we made inside the transaction scope.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果需要回滚，使用事务时我们不需要跟踪先前的账户余额值，因为MongoDB将放弃事务范围内所做的所有更改。
- en: 'Continuing with the same example using Ruby, we have the following code for
    part 3:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用Ruby进行相同的示例，我们有第3部分的以下代码：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Alongside all of the points raised in the example in Python, we find that we
    can also customize `read_concern` and `write_concern` per transaction.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Python示例中提出的所有观点之外，我们还发现可以根据事务自定义`read_concern`和`write_concern`。
- en: 'The available `read_concern` levels for multi-document ACID transactions are
    as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 多文档ACID事务的可用`read_concern`级别如下：
- en: '`majority`: A majority of the servers in a replica set have acknowledged the
    data. For this to work as expected in transactions, they must also use `write_concern`
    to `majority`.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`majority`：复制集中大多数服务器已确认数据。为了使事务按预期工作，它们还必须使用`write_concern`为`majority`。'
- en: '`local`: Only the local server has acknowledged the data.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local`：只有本地服务器已确认数据。'
- en: '`snapshot`: The default `read_concern` levels for transactions as of MongoDB
    4.0\. If the transaction commits with `majority` as `write_concern`, all transaction
    operations will have read from a snapshot of majority committed data, otherwise
    no guarantee can be made.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`snapshot`：截至MongoDB 4.0，事务的默认`read_concern`级别。如果事务以`write_concern`为`majority`提交，所有事务操作将从大多数提交数据的快照中读取，否则无法做出保证。'
- en: Read concern for transactions is set in the transaction level or higher (session
    or, finally, client). Setting read concern in individual operations is not supported
    and is generally discouraged.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 事务的读关注点设置在事务级别或更高级别（会话或最终客户端）。不支持在单个操作中设置读关注点，并且通常不建议这样做。
- en: The available `write_concern` levels for multi-document ACID transactions are
    the same as everywhere else in MongoDB, except for `w:0` (no acknowledgement),
    which is not supported at all.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 多文档ACID事务的可用`write_concern`级别与MongoDB中的其他地方相同，除了不支持`w:0`（无确认）。
- en: E-commerce using MongoDB
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MongoDB的电子商务
- en: For our second example, we are going to use a more complex use case on a transaction
    with three different collections.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第二个示例，我们将在三个不同的集合上使用更复杂的事务用例。
- en: We are going to simulate a shopping cart and payment transaction process for
    an e-commerce application using MongoDB. Using the sample code that we'll provide
    at the end of this section, we will initially populate the database with the following
    data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用MongoDB模拟电子商务应用程序的购物车和付款交易过程。使用我们将在本节末尾提供的示例代码，我们将首先用以下数据填充数据库。
- en: 'Our first collection is the `users` collection with one document per user:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个集合是“users”集合，每个用户一个文档：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we have the `carts` collection with one document per cart, which is linked
    via the `user_id` to our users:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有一个“carts”集合，每个购物车一个文档，通过“user_id”与我们的用户相关联：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `payments` collection holds any completed payment that has gone through,
    storing the `cart_id` and the `item_id` to link to the cart that it belonged to
    and the item that has been paid:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: “payments”集合保存通过的任何已完成付款，存储“cart_id”和“item_id”以链接到它所属的购物车和已支付的商品：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, the `inventories` collection holds a count of the number of items
    (by `item_id`) that we have currently available, along with their price and a
    short description:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，“inventories”集合保存我们当前可用的物品数量（按“item_id”），以及它们的价格和简短描述：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, we are going to demonstrate using MongoDB's schema validation
    functionality. Using JSON schemata, we can define a set of validations that will
    be checked against the database level every time a document is inserted or updated.
    This is a fairly new feature as it was introduced in MongoDB 3.6\. In our case,
    we are going to use it to make sure that we always have a positive number of items
    in our inventory.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将演示使用MongoDB的模式验证功能。使用JSON模式，我们可以定义一组验证，每次插入或更新文档时都会在数据库级别进行检查。这是一个相当新的功能，因为它是在MongoDB
    3.6中引入的。在我们的情况下，我们将使用它来确保我们的库存中始终有正数的物品数量。
- en: 'The `validator` object in the MongoDB shell format is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB shell格式中的“validator”对象如下：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'JSON schemata can be used to implement many of the validations that we would
    usually have in our models in Rails or Django. We can define these keywords as
    in the following table:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: JSON模式可用于实现我们在Rails或Django中通常在模型中具有的许多验证。我们可以定义这些关键字如下表所示：
- en: '| **Keyword** | **Validates on type** | **Description** |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **关键字** | **验证类型** | **描述** |'
- en: '| `enum` | All | The enum of allowed values in a field. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: “enum” | 所有 | 字段中允许的值的枚举。
- en: '| `type` | All | The enum of allowed types in a field. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: “type” | 所有 | 字段中允许的类型的枚举。
- en: '| `minimum`/`maximum` | Numeric | The minimum and maximum values for a numeric
    field. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: “minimum”/“maximum” | 数值 | 数值字段的最小值和最大值。
- en: '| `minLength`/`maxLength` | String | The minimum and maximum length allowed
    for a string field. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: “minLength”/“maxLength” | 字符串 | 字符串字段允许的最小和最大长度。
- en: '| `pattern` | String | The regex pattern that the string field must match.
    |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: “pattern” | 字符串 | 字符串字段必须匹配的正则表达式模式。
- en: '| `required` | Objects | The document must contain all the strings defined
    in the required property array. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: “required” | 对象 | 文档必须包含在required属性数组中定义的所有字符串。
- en: '| `minItems`/`maxItems` | Arrays | The minimum and maximum length of items
    in the array. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: “minItems”/“maxItems” | 数组 | 数组中的项的最小和最大长度。
- en: '| `uniqueItems` | Arrays | If set to true, all items in the array must have
    unique values. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: “uniqueItems” | 数组 | 如果设置为true，则数组中的所有项必须具有唯一值。
- en: '| `title` | N/A | A descriptive title for the developer''s use. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '“title” | N/A | 开发人员使用的描述性标题。 '
- en: '| `description` | N/A | A description for the developer''s use. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: “description” | N/A | 开发人员使用的描述。
- en: Using JSON schema, we can offload validations from our models to the database
    layer and/or use MongoDB validations as an additional layer of security on top
    of web application validations.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JSON模式，我们可以将验证从我们的模型转移到数据库层和/或使用MongoDB验证作为Web应用程序验证的额外安全层。
- en: 'To use a JSON schema, we have to specify it at the time that we are creating
    our collection, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用JSON模式，我们必须在创建集合时指定它，如下所示：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Returning to our example, our code will simulate having an inventory of five
    bull bearings and placing two orders; one by user Alex for two bull bearings,
    followed by a second order by user Barbara for another four bull bearings.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的例子，我们的代码将模拟拥有五个滚珠轴承的库存，并下两个订单；用户Alex订购两个滚珠轴承，然后用户Barbara订购另外四个滚珠轴承。
- en: 'As expected, the second order will not go through because we don''t have enough
    ball bearings in our inventory to fulfill it. We will see this in the following
    code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，第二个订单不会通过，因为我们的库存中没有足够的滚珠来满足它。我们将在以下代码中看到这一点：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will break down the preceding example into the interesting parts, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把前面的例子分解为有趣的部分，如下所示：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `add_to_cart()` method doesn't use transactions. The reason is that because
    we are updating one document at a time, these are guaranteed to be atomic operations.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: “add_to_cart()”方法不使用事务。原因是因为我们一次只更新一个文档，这些操作是原子操作。
- en: 'Then, in the `place_order()` method, we start the session, and then subsequently,
    a transaction within this session. Similar to the previous use case, we need to
    make sure that we add the `session=ses` parameter at the end of every operation
    that we want to be executed in the transaction context:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在“place_order()”方法中，我们启动会话，然后随后在此会话中启动事务。与前一个用例类似，我们需要确保在我们想要在事务上下文中执行的每个操作的末尾添加“session=ses”参数：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this method, we are using the retry able transaction pattern. We start by
    wrapping the transaction context in a `while True` block, essentially making it
    loop forever. Then we enclose our transaction in a `try` block that will listen
    for exceptions.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们使用可重试事务模式。我们首先将事务上下文包装在“while True”块中，从本质上使其永远循环。然后我们在一个“try”块中包含我们的事务，它将监听异常。
- en: An exception of type `transient transaction`, which has the `TransientTransactionError`
    error label, will result in continued execution in the `while True` block, essentially
    retrying the transaction from the very beginning. On the other hand, a failed
    validation or any other error will reraise the exception after logging it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`transient transaction`类型的异常，具有`TransientTransactionError`错误标签，将导致在`while True`块中继续执行，从而从头开始重试事务。另一方面，验证失败或任何其他错误将在记录后重新引发异常。'
- en: The `session.commitTransaction()` and `session.abortTransaction()` operations
    will be retried once by MongoDB, no matter if we retry the transaction or not.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`session.commitTransaction()`和`session.abortTransaction()`操作将被MongoDB重试一次，无论我们是否重试事务。'
- en: We don't need to explicitly call `abortTransaction()` in this example, as MongoDB
    will abort it in the face of exceptions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不需要显式调用`abortTransaction()`，因为MongoDB会在面对异常时中止它。
- en: 'In the end, our database looks like the following code block:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的数据库看起来像下面的代码块：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The payment that we just made does not have the name field, in contrast to
    the sample payment that we inserted in our database before rolling our transactions:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚进行的付款没有名称字段，与我们在滚动事务之前插入数据库的示例付款相反：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Our inventory has the correct number of bull bearings, three (five minus the
    two that Alex ordered), as shown in the following code block:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的库存中有正确数量的滚珠轴承，三个（五减去Alex订购的两个），如下面的代码块所示：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Our carts have the correct quantities. Alex's cart (`cart_id=1`) has zero items,
    whereas Barbara's cart (`cart_id=2`) still has four, since we don't have enough
    bull bearings to fulfill her order. Our payments collection does not have an entry
    for Barbara's order and the inventory still has three bull bearings in place.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的购物车中有正确的数量。 Alex的购物车（`cart_id=1`）没有物品，而Barbara的购物车（`cart_id=2`）仍然有四个，因为我们没有足够的滚珠轴承来满足她的订单。我们的支付集合中没有Barbara订单的条目，库存中仍然有三个滚珠轴承。
- en: Our database state is consistent and saving lots of time by implementing the
    abort transaction and reconciliation data logic in our application level.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据库状态是一致的，并且通过在应用程序级别实现中止事务和对账数据逻辑来节省大量时间。
- en: 'Continuing with the same example in Ruby, we have the following code block:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ruby中继续使用相同的示例，我们有以下代码块：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Similar to the Python code sample, we are passing the `session: session` parameter
    along each operation to make sure that we are operating inside the transaction.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '与Python代码示例类似，我们在每个操作中传递`session: session`参数，以确保我们在事务内进行操作。'
- en: Here, we are not using the retry able transaction pattern. Regardless, MongoDB
    will retry committing or aborting a transaction once before throwing an exception.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们没有使用可重试的事务模式。无论如何，MongoDB都会在抛出异常之前重试提交或中止事务一次。
- en: The best practices and limitations of multi-document ACID transactions
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多文档ACID事务的最佳实践和限制
- en: 'There are currently some limitations and best practices when developing using
    MongoDB transactions in version 4.0.3:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发中使用MongoDB 4.0.3版本的事务时，目前存在一些限制和最佳实践：
- en: The transaction timeout is set to 60 seconds.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务超时设置为60秒。
- en: As a best practice, any transaction should not try to modify more than 1,000
    documents. There is no limitation in reading documents during a transaction.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为最佳实践，任何事务不应尝试修改超过1,000个文档。在事务期间读取文档没有限制。
- en: The oplog will record a single entry for a transaction, meaning that this is
    subject to the 16 MB document size limit. This is not such a big problem with
    transactions that update documents, as only the delta will be recorded in the
    oplog. It can, however, be an issue when transactions insert new documents, in
    which case the oplog will record the full contents of the new documents.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: oplog将记录事务的单个条目，这意味着这受到16MB文档大小限制的影响。对于更新文档的事务来说，这并不是一个大问题，因为oplog只会记录增量。然而，当事务插入新文档时，这可能会成为一个问题，此时oplog将记录新文档的全部内容。
- en: We should add application logic to cater for failing transactions. These could
    include using retryable writes, or executing some business logic-driven action
    when the error cannot be retried or we have exhausted our retries (usually, this
    means a custom 500 error).
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该添加应用程序逻辑来处理失败的事务。这可能包括使用可重试写入，或者在错误无法重试或我们已经耗尽重试时执行一些业务逻辑驱动的操作（通常意味着自定义500错误）。
- en: DDL operations such as modifying indexes, collections, or databases will get
    queued up behind active transactions. Transactions trying to access the namespace
    while a DDL operation is still pending will immediately abort.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诸如修改索引、集合或数据库之类的DDL操作将排队等待活动事务。在DDL操作仍在进行时尝试访问命名空间的事务将立即中止。
- en: Transactions only work in replica sets. Starting from MongoDB 4.2, transactions
    will also be available for sharded clusters.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务只在副本集中起作用。从MongoDB 4.2开始，事务也将适用于分片集群。
- en: Use sparingly; maybe the most important point to consider when developing using
    MongoDB transactions is that they are not meant as a replacement for good schema
    design. They should only be used when there is no other way to model our data
    without them.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节制使用；在开发中使用MongoDB事务时可能要考虑的最重要的一点是，它们并不是用来替代良好模式设计的。只有在没有其他方法可以对数据进行建模时才应该使用它们。
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about textbook relational database theory on ACID
    in the context of MongoDB.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了在MongoDB的上下文中关于ACID的教科书关系数据库理论。
- en: Then, we focused on multi-document ACID transactions and applied them in two
    use cases using Ruby and Python. We learned about when to use MongoDB transactions
    and when not to use them, how to use them, their best practices, and their limitations.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们专注于多文档ACID事务，并在Ruby和Python中应用它们到两个用例中。我们了解了何时使用MongoDB事务以及何时不使用它们，如何使用它们，它们的最佳实践和限制。
- en: In the next chapter, we will deal with one of the most commonly-used features
    of MongoDB – aggregation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将处理MongoDB最常用的功能之一 - 聚合。
