- en: Aggregation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合
- en: In Chapter 5, *Multi-D**o**cument ACID Transactions*, we worked through two
    use cases of the new transactions capability using code for Ruby and Python. In
    this chapter, we will dive deeper into the aggregation framework, learning how
    it can be useful. We will also look at the operators that are supported by MongoDB.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章《多文档ACID事务》中，我们使用Ruby和Python的代码解决了新事务功能的两个用例。在本章中，我们将更深入地了解聚合框架，学习它如何有用。我们还将看看MongoDB支持的操作符。
- en: To learn this information, we will use aggregations to process transaction data
    from the Ethereum blockchain. The complete source code is available at [https://github.com/PacktPublishing/Mastering-MongoDB-4.x-Second-Edition](https://github.com/PacktPublishing/Mastering-MongoDB-4.x-Second-Edition).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这些信息，我们将使用聚合来处理以太坊区块链的交易数据。完整的源代码可在[https://github.com/PacktPublishing/Mastering-MongoDB-4.x-Second-Edition](https://github.com/PacktPublishing/Mastering-MongoDB-4.x-Second-Edition)上找到。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Why aggregation?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么要使用聚合？
- en: Different aggregation operators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的聚合操作符
- en: Limitations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制
- en: Why aggregation?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要使用聚合？
- en: The aggregation framework was introduced by MongoDB in version 2.2 (which is
    version 2.1 in the development branch). It serves as an alternative to both the
    MapReduce framework and querying the database directly.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合框架是由MongoDB在2.2版本中引入的（在开发分支中是2.1版本）。它作为MapReduce框架和直接查询数据库的替代方案。
- en: Using the aggregation framework, we can perform `GROUP BY` operations in the
    server. Thus, we can project only the fields that are needed in the result set.
    Using the `$match` and `$project` operators, we can reduce the amount of data
    passed through the pipeline, resulting in faster data processing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用聚合框架，我们可以在服务器上执行`GROUP BY`操作。因此，我们可以只投影结果集中需要的字段。使用`$match`和`$project`操作符，我们可以减少通过管道传递的数据量，从而加快数据处理速度。
- en: Self-joins—that is, joining data within the same collection—can also be performed
    using the aggregation framework, as we will see in our use case.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 自连接——也就是在同一集合内连接数据——也可以使用聚合框架来执行，正如我们将在我们的用例中看到的那样。
- en: When comparing the aggregation framework to simply using the queries available
    via the shell or various other drivers, it is important to remember that there
    is a use case for both.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将聚合框架与仅使用shell或其他驱动程序提供的查询进行比较时，重要的是要记住两者都有用途。
- en: 'For selection and projection queries, it''s almost always better to use simple
    queries, as the complexity of developing, testing, and deploying an aggregation
    framework operation cannot easily outweigh the simplicity of using built-in commands.
    Finding documents with `( db.books.find({price: 50} {price: 1, name: 1}) )`, or
    without `( db.books.find({price: 50}) )` projecting only some of the fields, is
    simple and fast enough to not warrant the usage of the aggregation framework.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '对于选择和投影查询，几乎总是更好使用简单的查询，因为开发、测试和部署聚合框架操作的复杂性很难超过使用内置命令的简单性。查找具有`( db.books.find({price:
    50} {price: 1, name: 1}) )`的文档，或者没有`( db.books.find({price: 50}) )`只投影一些字段，是简单且足够快速，不需要使用聚合框架。'
- en: On the other hand, if we want to perform `GROUP BY` and self-join operations
    using MongoDB, there might be a case for using the aggregation framework. The
    most important limitation of the `group()` command in the MongoDB shell is that
    the resulting set has to fit in a document, meaning that it can't be more than
    16 MB in size. In addition, the result of any `group()` command can't have more
    than 20,000 results. Finally, `group()` doesn't work with sharded input collections,
    which means that when our data size grows we have to rewrite our queries anyway.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们想使用MongoDB执行`GROUP BY`和自连接操作，可能需要使用聚合框架。在MongoDB shell中`group()`命令的最重要限制是结果集必须适合一个文档，这意味着它的大小不能超过16MB。此外，任何`group()`命令的结果不能超过20,000个。最后，`group()`不适用于分片输入集合，这意味着当我们的数据量增加时，我们必须重新编写我们的查询。
- en: In comparison to MapReduce, the aggregation framework is more limited in functionality
    and flexibility. In the aggregation framework, we are limited by the available
    operators. On the plus side, the API for the aggregation framework is simpler
    to understand and use than MapReduce. In terms of performance, the aggregation
    framework was way faster than MapReduce in earlier versions of MongoDB, but seems
    to be on a par with the most recent versions after the improvement in performance
    by MapReduce.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与MapReduce相比，聚合框架在功能和灵活性上更有限。在聚合框架中，我们受到可用操作符的限制。但好的一面是，聚合框架的API比MapReduce更容易理解和使用。在性能方面，聚合框架在MongoDB早期版本中比MapReduce快得多，但在MapReduce性能改进后，似乎与最新版本持平。
- en: Finally, there is always the option of using the database as data storage and
    performing complex operations using the application. Sometimes this can be quick
    to develop, but should be avoided as it will most likely incur memory, networking,
    and ultimately performance costs down the road.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一种选择，就是使用数据库作为数据存储，并使用应用程序执行复杂操作。有时这可能会很快开发，但应该避免，因为最终可能会产生内存、网络和性能成本。
- en: In the next section, we will describe the available operators before using them
    in a real use case.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将在使用实际用例之前描述可用的操作符。
- en: Aggregation operators
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合操作符
- en: In this section, we will learn how to use aggregation operators. Aggregation
    operators are divided into two categories. Within each stage, we use **expression
    operators** to compare and process values. Between different stages, we use **aggregation
    stage operators** to define the data that will get passed on from one stage to
    the next, as it is considered to be in the same format.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用聚合操作符。聚合操作符分为两类。在每个阶段中，我们使用**表达式操作符**来比较和处理值。在不同阶段之间，我们使用**聚合阶段操作符**来定义将从一个阶段传递到下一个阶段的数据，因为它被认为是以相同格式呈现的。
- en: Aggregation stage operators
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合阶段操作符
- en: An aggregation pipeline is composed of different stages. These stages are declared
    in an array and executed sequentially, with the output of every stage being the
    input of the next one.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合管道由不同的阶段组成。这些阶段在数组中声明并按顺序执行，每个阶段的输出都是下一个阶段的输入。
- en: 'The `$out` stage has to be the final stage in an aggregation pipeline, outputting
    data to an output collection by replacing or adding to the existing documents:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`$out` 阶段必须是聚合管道中的最终阶段，通过替换或添加到现有文档将数据输出到输出集合：'
- en: '`$group`: This is most commonly used to group by identifier expression and
    to apply the accumulator expression. It outputs one document per distinct group.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$group`：最常用于按标识符表达式分组，并应用累加器表达式。它输出每个不同组的一个文档。'
- en: '`$project`: This is used for document transformation, and outputs one document
    per input document.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$project`：用于文档转换，每个输入文档输出一个文档。'
- en: '`$match`: This is used for filtering documents from input based on criteria.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$match`：根据条件从输入中过滤文档。'
- en: '`$lookup`: This is used for filtering documents from input. Input can be documents
    from another collection in the same database selected by an outer left join.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$lookup`：用于从输入中过滤文档。输入可以是同一数据库中另一个集合中的文档，由外部左连接选择。'
- en: '`$out`: This outputs the documents in this pipeline stage to an output collection
    by replacing or adding to the documents that already exist in the collection.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$out`：将此管道阶段的文档输出到输出集合，以替换或添加到已存在于集合中的文档。'
- en: '`$limit`: This limits the number of documents passed on to the next aggregation
    phase based on predefined criteria.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$limit`：根据预定义的条件限制传递到下一个聚合阶段的文档数量。'
- en: '`$count`: This returns a count of the number of documents at this stage of
    the pipeline.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$count`：返回管道阶段的文档数量。'
- en: '`$skip`: This skips a certain number of documents, preventing them from passing
    on to the next stage of the pipeline.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$skip`：跳过一定数量的文档，防止它们传递到管道的下一阶段。'
- en: '`$sort`: This sorts the documents based on criteria.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$sort`：根据条件对文档进行排序。'
- en: '`$redact`: As a combination of `$project` and `$match`, this will redact the
    selected fields from each document and pass them on to the next stage of the pipeline.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$redact`：作为 `$project` 和 `$match` 的组合，这将从每个文档中选择的字段进行redact，并将它们传递到管道的下一阶段。'
- en: '`$unwind`: This transforms an array of *n* elements to *n* documents, mapping
    each document to one element of the array. The documents are then passed on to
    the next stage of the pipeline.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$unwind`：这将数组中的 *n* 个元素转换为 *n* 个文档，将每个文档映射到数组的一个元素。然后将这些文档传递到管道的下一阶段。'
- en: '`$collStats`: This returns statistics regarding the view or collection.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$collStats`：返回有关视图或集合的统计信息。'
- en: '`$indexStats`: This returns statistics regarding the indexes of the collection.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$indexStats`：返回集合索引的统计信息。'
- en: '`$sample`: This randomly selects a specified number of documents from the input.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$sample`：从输入中随机选择指定数量的文档。'
- en: '`$facet`: This combines multiple aggregation pipelines within a single stage.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$facet`：在单个阶段内组合多个聚合管道。'
- en: '`$bucket`: This splits documents into buckets based on predefined selection
    criteria and bucket boundaries.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$bucket`：根据预定义的选择标准和桶边界将文档分割成桶。'
- en: '`$bucketAuto`: This splits documents into buckets based on predefined selection
    criteria and attempts to evenly distribute documents among the buckets.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$bucketAuto`：根据预定义的选择标准将文档分割成桶，并尝试在桶之间均匀分布文档。'
- en: '`$sortByCount`: This groups incoming documents based on the value of an expression
    and computes the count of documents in each bucket.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$sortByCount`：根据表达式的值对传入的文档进行分组，并计算每个桶中的文档数量。'
- en: '`$addFields`: This adds new fields to documents and outputs the same number
    of documents as input with the added fields.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$addFields`：这将向文档添加新字段，并输出与输入相同数量的文档，带有添加的字段。'
- en: '`$replaceRoot`: This replaces all existing fields of the input document (including
    the `standard _id` field) with the specified fields.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$replaceRoot`：用指定的字段替换输入文档的所有现有字段（包括 `standard _id` 字段）。'
- en: '`$geoNear`: This returns an ordered list of documents based on the proximity
    to a specified field. The output documents include a computed `distance` field.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$geoNear`：根据与指定字段的接近程度返回文档的有序列表。输出文档包括一个计算出的 `distance` 字段。'
- en: '`$graphLookup`: This recursively searches a collection and adds an array field
    with the results of the search in each output document.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$graphLookup`：递归搜索集合，并在每个输出文档中添加一个包含搜索结果的数组字段。'
- en: Expression operators
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式运算符
- en: Within every stage, we can define one or more expression operators to apply
    our intermediate calculations to. This section will focus on these expression
    operators.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个阶段中，我们可以定义一个或多个表达式运算符来应用我们的中间计算。本节将重点介绍这些表达式运算符。
- en: Expression Boolean operators
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式布尔运算符
- en: Boolean operators are used to pass a `true` or `false` value to the next stage
    of our aggregation pipeline.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔运算符用于将 `true` 或 `false` 的值传递到我们聚合管道的下一阶段。
- en: We can choose to pass the originating `integer`, `string`, or any other type
    value along as well.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以选择传递原始的 `integer`、`string` 或任何其他类型的值。
- en: We can use the `$and`, `$or`, and `$not` operators in the same way that we would
    use them in any programming language.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像在任何编程语言中一样使用 `$and`、`$or` 和 `$not` 运算符。
- en: Expression comparison operators
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式比较运算符
- en: Comparison operators can be used in conjunction with Boolean operators to construct
    the expressions that we need to evaluate as `true`/`false` for the output of our
    pipeline's stage.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符可以与布尔运算符结合使用，构建我们需要评估为 `true`/`false` 的表达式，以输出管道阶段的结果。
- en: 'The most commonly used operators are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的运算符如下：
- en: '`$eq ( equal )`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$eq ( equal )`'
- en: '`$ne ( not equal)`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ne ( not equal)`'
- en: '`$gt (greater than)`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$gt (greater than)`'
- en: '`$gte (greater than or equal)`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$gte (greater than or equal)`'
- en: '`$lt`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$lt`'
- en: '`$lte`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$lte`'
- en: All the aforementioned mentioned operators return a Boolean value of `true`
    or `false`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述运算符返回 `true` 或 `false` 的布尔值。
- en: The only operator that doesn't return a Boolean value is `$cmp`, which returns
    `0` if the two arguments are equivalent, `1` if the first value is greater than
    the second and `-1` if the second value is greater than the first.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一不返回布尔值的运算符是`$cmp`，如果两个参数相等则返回`0`，如果第一个值大于第二个值则返回`1`，如果第二个值大于第一个值则返回`-1`。
- en: Set expression and array operators
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合表达式和数组运算符
- en: As with most programming languages, set operations ignore duplicate entries
    and the order of elements, treating them as sets. The order of results is unspecified
    and duplicates will be deduplicated in the result set. Set expressions do not
    apply recursively to elements of the set, but only to the top level. This means
    that if a set contains, for example, a nested array, then this array may or may
    not contain duplicates.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数编程语言一样，集合操作会忽略重复的条目和元素的顺序，将它们视为集合。结果的顺序是未指定的，并且重复的条目将在结果集中被去重。集合表达式不会递归应用于集合的元素，而只会应用于顶层。这意味着，如果一个集合包含，例如，一个嵌套数组，那么这个数组可能包含重复项，也可能不包含。
- en: 'The available set operators are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的集合运算符如下：
- en: '`$setEquals`: This is `true` if the two sets have the same distinct elements'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$setEquals`：如果两个集合具有相同的不同元素，则为`true`'
- en: '`$setIntersection`: This returns the intersection of all input sets (that is,
    the documents that appear in all of the input sets)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$setIntersection`：返回所有输入集合的交集（即出现在所有输入集合中的文档）'
- en: '`$setUnion`: This returns the union of all input sets (that is, the documents
    that appear in at least one of all of the input sets)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$setUnion`：返回所有输入集合的并集（即出现在所有输入集合中的至少一个文档）'
- en: '`$setDifference`: This returns the documents that appear in the first input
    set but not the second'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$setDifference`：返回出现在第一个输入集合中但不在第二个输入集合中的文档'
- en: '`$setIsSubset`: This is `true` if all documents in the first set appear in
    the second one, even if the two sets are identical'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$setIsSubset`：如果第一个集合中的所有文档都出现在第二个集合中，则为`true`，即使这两个集合是相同的。'
- en: '`$anyElementTrue`: This is `true` if any of the elements in the set evaluate
    to `true`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$anyElementTrue`：如果集合中的任何元素求值为`true`，则为`true`'
- en: '`$allElementsTrue`: This is `true` if all of the elements in the set evaluate
    to `true`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$allElementsTrue`：如果集合中的所有元素求值为`true`，则为`true`'
- en: 'The available array operators are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的数组运算符如下：
- en: '`$arrayElemAt`: This returns the element at the array index position.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$arrayElemAt`：返回数组索引位置的元素。'
- en: '`$concatArrays`: This returns a concatenated array.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$concatArrays`：返回一个连接的数组。'
- en: '`$filter`: This returns a subset of the array based on specified criteria.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$filter`：根据指定的条件返回数组的子集。'
- en: '`$indexOfArray`: This returns the index of the array that fulfills the search
    criteria. If it does not, then `-1`.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$indexOfArray`：返回满足搜索条件的数组的索引。如果没有，则返回`-1`。'
- en: '`$isArray`: This returns `true` if the input is an array; otherwise, it returns `false`.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$isArray`：如果输入是数组，则返回`true`；否则返回`false`。'
- en: '`$range`: This outputs an array containing a sequence of integers according
    to user-defined inputs.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$range`：根据用户定义的输入输出包含一系列整数的数组。'
- en: '`$reverseArray`: This returns an array with the elements in reverse order.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$reverseArray`：返回元素顺序相反的数组。'
- en: '`$reduce`: This reduces the elements of an array to a single value according
    to the specified input.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$reduce`：根据指定的输入将数组的元素减少为单个值。'
- en: '`$size`: This returns the number of items in the array.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$size`：返回数组中的项目数。'
- en: '`$slice`: This returns a subset of the array.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$slice`：返回数组的子集。'
- en: '`$zip`: This returns a merged array.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$zip`：返回合并的数组。'
- en: '`$in`: This returns `true` if the specified value is in the array; otherwise,
    it returns `false`.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$in`：如果指定的值在数组中，则返回`true`；否则返回`false`。'
- en: Expression date operators
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式日期运算符
- en: 'Date operators are used to extract date information from date fields when we want
    to calculate statistics based on the day of the week/month/year using the pipeline:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 日期运算符用于从日期字段中提取日期信息，当我们想要基于一周/月/年的统计数据计算时，使用管道：
- en: '`$dayOfYear` is used to get the day of the year within a range of 1 to 366
    (for a leap year)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$dayOfYear` 用于获取一年中的日期，范围为1到366（闰年）'
- en: '`$dayOfMonth` is used to get the day of the month within a range of 1 to 31'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$dayOfMonth` 用于获取一个月中的日期，范围为1到31'
- en: '`$dayOfWeek` is used to get the day of the week within a range of 1 to 7, with
    1 being Sunday and 7 being Saturday (using English days of the week)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$dayOfWeek` 用于获取一周中的日期，范围为1到7，其中1代表星期日，7代表星期六（使用英文星期几）'
- en: '`$isoDayOfWeek` returns the weekday number in the ISO 8601 date format within
    a range of 1 to 7, with 1 being Monday and 7 being Sunday'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$isoDayOfWeek` 返回ISO 8601日期格式中的星期几编号，范围为1到7，其中1代表星期一，7代表星期日'
- en: '`$week` is the week number within a range of 0 to 53, with 0 being the partial
    week at the beginning of each year to 53 for a year with a leap week'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$week` 是0到53范围内的周数，0代表每年年初的部分周，53代表有闰周的年份'
- en: '`$isoWeek` returns the week number in the ISO 8601 date format within a range
    of 1 to 53, 1 being the first week of the year that contains a Thursday and 53
    being a leap week, if one exists in the year in question'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$isoWeek` 返回ISO 8601日期格式中的周数，范围为1到53，1代表包含星期四的年份的第一周，53代表有闰周的年份'
- en: '`$year`, `$month`, `$hour`, `$minute`, `$milliSecond` return the relevant portion
    of the date in zero-based numbering, except for `$month`, which returns a value
    ranging from 1 through 12'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$year`、`$month`、`$hour`、`$minute`、`$milliSecond` 返回日期的相关部分，从零开始编号，除了`$month`，它返回从1到12的值'
- en: '`$isoWeekYear` returns the year in ISO 8601 date format according to the date
    that the last week in ISO 8601 date format ends (for example, 2016/1/1 will still
    return 2015)'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$isoWeekYear` 根据ISO 8601日期格式返回日期的年份，该日期是ISO 8601日期格式中最后一周结束的日期（例如，2016/1/1仍然返回2015）'
- en: '`$second` returns 0 to 60 inclusive for leap seconds'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$second` 返回0到60的值，包括闰秒'
- en: '`$dateToString` converts a date input to a string'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$dateToString` 将日期输入转换为字符串'
- en: Expression string operators
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式字符串运算符
- en: 'Like date operators, string operators are used when we want to transform our
    data from one stage of the pipeline to the next one. Potential use cases include
    preprocessing text fields to extract relevant information to be used in later
    stages of a pipeline:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与日期运算符一样，字符串运算符用于在我们想要将数据从管道的一个阶段转换到下一个阶段时使用。潜在的用例包括预处理文本字段以提取相关信息，以便在管道的后续阶段中使用：
- en: '`$concat`: This is used to concatenate strings.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$concat`: 这用于连接字符串。'
- en: '`$split`: This is used to split strings based on delimiter. If the delimiter
    is not found, then the original string is returned.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$split`: 这用于根据分隔符拆分字符串。如果找不到分隔符，则返回原始字符串。'
- en: '`$strcasecmp`: This is used in case-insensitive string comparisons. It will
    return `0` if the strings are equal and `1` if the first string is great; otherwise,
    it will return `-1`.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$strcasecmp`: 这用于不区分大小写的字符串比较。如果字符串相等，则返回`0`，如果第一个字符串较大，则返回`1`；否则返回`-1`。'
- en: '`$toLower`/`$toUpper`: These are used to convert a string to all lowercase
    or all uppercase, respectively.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$toLower`/`$toUpper`: 这用于将字符串转换为全小写或全大写。'
- en: '`$indexOfBytes`: This is used to return the byte occurrence of the first occurrence
    of a substring in a string.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$indexOfBytes`: 这用于返回字符串中子字符串的第一个出现的字节位置。'
- en: '`$strLenBytes`: This is the number of bytes in the input string.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$strLenBytes`: 这是输入字符串的字节数。'
- en: '`$substrBytes`: This returns the specified bytes of the substring.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$substrBytes`: 这返回子字符串的指定字节。'
- en: 'The equivalent methods for code points (a value in Unicode, regardless of the
    underlying bytes in its representation) are as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 代码点的等效方法（Unicode中的一个值，不考虑其表示中的基础字节）如下：
- en: '`$indexOfCP`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$indexOfCP`'
- en: '`$strLenCP`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$strLenCP`'
- en: '`$substrCP`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$substrCP`'
- en: Expression arithmetic operators
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式算术运算符
- en: 'During each stage of the pipeline, we can apply one or more arithmetic operators
    to perform intermediate calculations. These operators are shown in the following
    list:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道的每个阶段，我们可以应用一个或多个算术运算符来执行中间计算。这些运算符在以下列表中显示：
- en: '`$abs`: This is the absolute value.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$abs`: 这是绝对值。'
- en: '`$add`: This can add numbers or a number to a date to get a new date.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$add`: 这可以将数字或日期加上一个数字以得到一个新的日期。'
- en: '`$ceil`/`$floor`: These are the ceiling and floor functions, respectively.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ceil`/`$floor`: 这些分别是向上取整和向下取整函数。'
- en: '`$divide`: This is used to divide by two inputs.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$divide`: 这用于由两个输入进行除法。'
- en: '`$exp`: This raises the natural number *e* to the specified exponential power.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$exp`: 这将自然数*e*提升到指定的指数幂。'
- en: '`$pow`: This raises a number to the specified exponential power.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$pow`: 这将一个数字提升到指定的指数幂。'
- en: '`$ln`/`$log`/`$log10`: These are used to calculate the natural log, the log
    on a custom base, or a log base ten, respectively.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ln`/`$log`/`$log10`: 这些用于计算自然对数、自定义底数的对数或以十为底的对数。'
- en: '`$mod`: This is the modular value.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$mod`: 这是模值。'
- en: '`$multiply`: This is used to multiply by inputs.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$multiply`: 这用于将输入相乘。'
- en: '`$sqrt`: This is the square root of the input.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$sqrt`: 这是输入的平方根。'
- en: '`$subtract`: This is the result of subtracting the second value from the first.
    If both arguments are dates, it returns the difference between them. If one argument
    is a date (this argument has to be the first argument) and the other is a number,
    it returns the resulting date.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$subtract`: 这是从第二个值中减去第一个值的结果。如果两个参数都是日期，则返回它们之间的差值。如果一个参数是日期（这个参数必须是第一个参数），另一个是数字，则返回结果日期。'
- en: '`$trunc`: This is used to truncate the result.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$trunc`: 这用于截断结果。'
- en: Aggregation accumulators
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合累加器
- en: 'Accumulators are probably the most widely used operators, as they allow us
    to sum, average, get standard deviation statistics, and perform other operations
    in each member of our group. The following is a list of the aggregation accumulators:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 累加器可能是最广泛使用的运算符，因为它们允许我们对我们组中的每个成员进行求和、平均值、获取标准偏差统计数据以及执行其他操作。以下是聚合累加器的列表：
- en: '`$sum`: This is the sum of the numerical values. It ignores non-numerical values.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$sum`: 这是数值的总和。它会忽略非数值。'
- en: '`$avg`: This is the average of the numerical values. It ignores non-numerical
    values.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$avg`: 这是数值的平均值。它会忽略非数值。'
- en: '`$first`/`$last`: This is the first and last value that passes through the
    pipeline stage. It is available in the group stage only.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$first`/`$last`: 这是通过管道阶段的第一个和最后一个值。它仅在组阶段中可用。'
- en: '`$max`/`$min`: These get the maximum and minimum value that passes through
    the pipeline stage, respectively.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$max`/`$min`: 这分别获取通过管道阶段的最大值和最小值。'
- en: '`$push`: This will add a new element at the end of an input array. It is available
    in the group stage only.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$push`: 这将一个新元素添加到输入数组的末尾。它仅在组阶段中可用。'
- en: '`$addToSet`: This will add an element (only if it does not exist) to an array,
    effectively treating it as a set. It is available in the group stage only.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$addToSet`: 这将一个元素（仅当它不存在时）添加到数组中，有效地将其视为一个集合。它仅在组阶段中可用。'
- en: '`$stdDevPop`/`$stdDevSamp`: These are used to get the population/sample standard
    deviation in the `$project` or `$match` stages.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$stdDevPop`/`$stdDevSamp`: 这些用于在`$project`或`$match`阶段获取总体/样本标准偏差。'
- en: These accumulators are available in the group or project pipeline phases except
    where otherwise noted.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些累加器在组或项目管道阶段中都可用，除非另有说明。
- en: Conditional expressions
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件表达式
- en: 'Expressions can be used to output different data to the next stage in our pipeline
    based on Boolean truth tests:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式可以根据布尔真值测试将不同的数据输出到我们管道中的下一阶段：
- en: '[PRE0]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `$cond` phrase will evaluate an expression of the format `if...then...else`,
    and depending on the result of the `if` statement, it will return the value of
    the `then` statement or `else` branches. The input can be either three named parameters
    or three expressions in an ordered list:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`$cond`短语将评估格式为`if...then...else`的表达式，并根据`if`语句的结果返回`then`语句或`else`分支的值。输入可以是三个命名参数或有序列表中的三个表达式。'
- en: '[PRE1]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `$ifNull` phrase will evaluate an expression and return the first expression
    if it is not null or the second expression if the first expression is null. Null
    can be either a missing field or a field with an undefined value:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ifNull`短语将评估一个表达式，并在其不为null时返回第一个表达式，如果第一个表达式为null，则返回第二个表达式。Null可以是一个缺失的字段或一个具有未定义值的字段：'
- en: '[PRE2]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Similar to a programming language's `switch` statement, `$switch` will execute
    a specified expression when it evaluates to `true`, and breaks out of the control
    flow.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于编程语言的`switch`语句，`$switch`将在评估为`true`时执行指定的表达式，并跳出控制流。
- en: Type conversion operators
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型转换运算符
- en: 'Introduced in MongoDB 4.0, type conversion operators allow us to convert a
    value to a specified type. The generic syntax of the command is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB 4.0中引入的类型转换运算符允许我们将值转换为指定的类型。命令的通用语法如下：
- en: '[PRE3]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this syntax, `input` and `to` (the only mandatory arguments) can be any
    valid expression. In its simplest form, we could, for example, have the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在此语法中，`input`和`to`（唯一的强制参数）可以是任何有效的表达式。在其最简单的形式中，我们可以，例如，有以下内容：
- en: '[PRE4]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This converts a string with the value `true` to the Boolean value `true`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 将值为`true`的字符串转换为布尔值`true`。
- en: The `onError` phrase can again be any valid expression, and specifies the value
    that MongoDB will return if it encounters an error during conversion, including
    unsupported type conversions. Its default behavior is to throw an error and stop
    processing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`onError`短语可以是任何有效的表达式，指定了在转换过程中MongoDB遇到错误时将返回的值，包括不支持的类型转换。其默认行为是抛出错误并停止处理。'
- en: The `onNull` phrase can also be any valid expression, and specifies the value
    that MongoDB will return if the input is null or missing. The default behavior
    is to return null.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`onNull`短语也可以是任何有效的表达式，指定了如果输入为null或缺失时MongoDB将返回的值。默认行为是返回null。'
- en: 'MongoDB also provides some helper functions for the most common `$convert`
    operations. These functions are as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB还为最常见的`$convert`操作提供了一些辅助函数。这些函数如下：
- en: '`$toBool`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$toBool`'
- en: '`$toDate`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$toDate`'
- en: '`$toDecimal`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$toDecimal`'
- en: '`$toDouble`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$toDouble`'
- en: '`$toInt`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$toInt`'
- en: '`$toLong`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$toLong`'
- en: '`$toObjectId`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$toObjectId`'
- en: '`$toString`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$toString`'
- en: 'These are even simpler to use. We could rewrite the previous example as the
    following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更简单易用。我们可以将前面的示例重写为以下形式：
- en: '[PRE5]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Other operators
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他操作符
- en: There are some operators that are not as commonly used, but which can be useful
    in use-case-specific cases. The most important of them are listed in the following
    sections.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些操作符并不常用，但在特定用例中可能很有用。其中最重要的列在以下部分中。
- en: Text search
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本搜索
- en: The `$meta` operator is used to access text search metadata.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`$meta`运算符用于访问文本搜索元数据。'
- en: Variable
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: The `$map` operator applies a sub-expression to each of the elements of an array
    and returns the array of the resulting values. It accepts named parameters.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`$map`运算符将子表达式应用于数组的每个元素，并返回结果值的数组。它接受命名参数。'
- en: The `$let` operator defines variables for use within the scope of a subexpression
    and returns the result of the subexpression. It accepts named parameters.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`$let`运算符为子表达式的范围内定义变量，并返回子表达式的结果。它接受命名参数。'
- en: Literal
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字面值
- en: The `$literal` operator will return a value without parsing. It is used for
    values that the aggregation pipeline may interpret as an expression. For example,
    you can apply a `$literal` expression to a string that starts with `$` to avoid
    parsing as a field path.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`$literal`运算符将返回一个不经解析的值。它用于聚合管道可能解释为表达式的值。例如，您可以将`$literal`表达式应用于以`$`开头的字符串，以避免解析为字段路径。'
- en: Parsing data type
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析数据类型
- en: The `$type `operator returns the `BSON` data type of the field.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`$type`运算符返回字段的`BSON`数据类型。'
- en: Limitations
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制
- en: 'The aggregation pipeline can output results in the following three distinct
    ways:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合管道可以以以下三种不同的方式输出结果：
- en: Inline as a document containing the result set
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联作为包含结果集的文档
- en: In a collection
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个集合中
- en: Returning a cursor to the result set
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回结果集的游标
- en: Inline results are subject to `BSON` maximum document size of 16 MB, meaning
    that we should use this only if our final result is of a fixed size. An example
    of this would be outputting `ObjectId` of the top five most ordered items from
    an e-commerce site.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 内联结果受`BSON`最大文档大小16 MB的限制，这意味着我们只能在最终结果是固定大小时使用它。一个例子是从电子商务网站输出前五个最常订购商品的`ObjectId`。
- en: A contrary example to this would be outputting the top 1,000 most ordered items,
    along with the product information, including the description and other fields
    of variable size.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反的例子是输出前1,000个最常订购的商品，以及产品信息，包括描述和其他大小可变的字段。
- en: Outputting results into a collection is the preferred solution if we want to
    perform further processing of the data. We can either output into a new collection
    or replace the contents of an existing collection. The aggregation output results
    will only be visible once the aggregation command succeeds; otherwise, it will
    not be visible at all.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想对数据进行进一步处理，将结果输出到集合是首选解决方案。我们可以将结果输出到新集合，或替换现有集合的内容。聚合输出结果只有在聚合命令成功后才会可见；否则，它将根本不可见。
- en: The output collection cannot be a sharded or capped collection (as of v3.4).
    If the aggregation output violates indexes (including the built-in index on the
    unique `ObjectId` per document) or document validation rules, the aggregation
    will fail.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 输出集合不能是分片的或有上限的集合（截至v3.4）。如果聚合输出违反索引（包括每个文档的唯一`ObjectId`上的内置索引）或文档验证规则，聚合将失败。
- en: Each pipeline stage can have documents exceeding the 16 MB limit as these are
    handled by MongoDB internally. Each pipeline stage, however, can only use up to
    100 MB of memory. If we expect more data in our stages, we should set `allowDiskUse:`
    to `true` to allow excess data to overflow to disk at the expense of performance.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 每个管道阶段可以有超过16MB限制的文档，因为这些由MongoDB在内部处理。然而，每个管道阶段只能使用最多100MB的内存。如果我们期望在我们的阶段中有更多的数据，我们应该将`allowDiskUse:`设置为`true`，以允许多余的数据溢出到磁盘，以换取性能。
- en: The `$graphLookup` operator does not support datasets over 100 MB and will ignore
    any setting on `allowDiskUse`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`$graphLookup`运算符不支持超过100MB的数据集，并将忽略`allowDiskUse`上的任何设置。'
- en: Aggregation use case
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合使用案例
- en: In this rather lengthy section, we will use the aggregation framework to process
    data from the Ethereum blockchain.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个相当冗长的部分中，我们将使用聚合框架来处理以太坊区块链的数据。
- en: 'Using our Python code, we have extracted data from Ethereum and loaded it into
    our MongoDB database. The relation of the blockchain to our database is shown
    in the following diagram:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的Python代码，我们已经从以太坊中提取了数据，并将其加载到我们的MongoDB数据库中。区块链与我们的数据库的关系如下图所示：
- en: '![](img/8ad5e8b5-bd05-430e-9e4f-06548aa820a9.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ad5e8b5-bd05-430e-9e4f-06548aa820a9.png)'
- en: 'Our data resides in two collections: **blocks** and **transactions**.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据驻留在两个集合中：**blocks**和**transactions**。
- en: 'A sample block document has the following fields:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 样本区块文档具有以下字段：
- en: Number of transactions
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易数量
- en: Number of contracted internal transactions
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承包内部交易的数量
- en: Block hash
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块哈希
- en: Parent block hash
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父区块哈希
- en: Mining difficulty
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挖矿难度
- en: Gas used
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的燃气
- en: Block height
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块高度
- en: 'The following code shows the output data from a block:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了区块的输出数据：
- en: '[PRE6]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A sample transaction document has the following fields:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 样本交易文档具有以下字段：
- en: Transaction hash
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易哈希
- en: The block height it belongs to
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它所属的区块高度
- en: From hash address
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从哈希地址
- en: To hash address
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到哈希地址
- en: Transaction value
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易价值
- en: Transaction fee
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易费用
- en: 'The following code shows the output data from a transaction:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了交易的输出数据：
- en: '[PRE7]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Sample data for our database is available on GitHub at: [https://github.com/PacktPublishing/Mastering-MongoDB-4.x-Second-Edition](https://github.com/PacktPublishing/Mastering-MongoDB-4.x-Second-Edition).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据库的样本数据可在GitHub上找到：[https://github.com/PacktPublishing/Mastering-MongoDB-4.x-Second-Edition](https://github.com/PacktPublishing/Mastering-MongoDB-4.x-Second-Edition)。
- en: 'As curious developers who are using this novel blockchain technology, we want
    to analyze Ethereum transactions. We are especially keen to do the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用这种新型区块链技术的好奇开发人员，我们想要分析以太坊交易。我们特别希望做到以下几点：
- en: Find the top ten addresses that transactions originate from
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到交易发起的前十个地址
- en: Find the top ten addresses that transactions end in
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到交易结束的前十个地址
- en: Find the average value per transaction, with statistics concerning the deviation
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到每笔交易的平均值，并统计偏差
- en: Find the average fee required per transaction, with statistics concerning the
    deviation
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到每笔交易所需的平均费用，并统计偏差
- en: Find the time of day that the network is more active according to the number
    or value of transactions
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到网络在一天中的哪个时间更活跃，根据交易的数量或价值
- en: Find the day of week that the network is more active according to the number
    or value of transactions
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到网络在一周中的哪一天更活跃，根据交易的数量或价值
- en: We find the top ten addresses that transactions originate from. To calculate
    this metric, we first count the number of occurrences with a `1` count for each
    one, group them by the value of the `from` field, and output them into a new field
    called `count`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到了交易发起的前十个地址。为了计算这个指标，我们首先计算每个`from`字段的值为`1`的出现次数，然后按`from`字段的值对它们进行分组，并将它们输出到一个名为`count`的新字段中。
- en: After this, we sort by the value of the `count` field in descending (`-1`) order,
    and finally, we `limit` the output to the first ten documents that pass through
    the pipeline. These documents are the top ten addresses that we are looking for.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们按照`count`字段的值按降序（`-1`）排序，最后，我们将输出限制为通过管道的前十个文档。这些文档是我们正在寻找的前十个地址。
- en: 'The following is some sample Python code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例Python代码：
- en: '[PRE8]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '[PRE9]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we find the top ten addresses that transactions end in. As we did with
    `from`, the calculation for the `to` addresses is exactly the same, only grouping
    using the `to` field instead of `from`, as shown in the following code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们找到了交易结束的前十个地址。就像我们对`from`所做的那样，对`to`地址的计算也完全相同，只是使用`to`字段而不是`from`进行分组，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '[PRE11]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s find the average value per transaction, with statistics concerning the
    standard deviation. In this example, we are using the `$avg` and `$stdDevPop`
    operators of the values of the `value` field to calculate the statistics for this
    field. Using a simple `$group` operation, we output a single document with the
    ID of our choice (here, `value`) and the `averageValues`, as shown in the following
    code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找到每笔交易的平均值，并统计标准偏差。在这个示例中，我们使用`$avg`和`$stdDevPop`操作符来计算`value`字段的统计数据。使用简单的`$group`操作，我们输出一个具有我们选择的ID（这里是`value`）和`averageValues`的单个文档，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '[PRE13]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s find the average fee required per transaction, returning statistics
    concerning the deviation. Average fees are similar to average values, replacing
    `$value` with `$txfee`, as shown in the following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找到每笔交易所需的平均费用，返回有关偏差的统计数据。平均费用类似于平均值，只是将`$value`替换为`$txfee`，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码片段的输出如下：
- en: '[PRE15]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We find the time of day that the network is more active according to the number
    or value of transactions at specific times.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到网络在特定时间更活跃的时间。
- en: 'To find out the most active hour for transactions, we use the `$hour` operator
    to extract the `hour` field from the `ISODate()` field in which we stored our
    `datetime` values and called `timestamp`, as shown in the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出交易最活跃的小时，我们使用`$hour`运算符从我们存储了`datetime`值并称为`timestamp`的`ISODate()`字段中提取`hour`字段，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE17]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following code will calculate the sum of transaction values for the most
    active hour of the day:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将计算一天中交易价值最高的小时的交易总值：
- en: '[PRE18]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE19]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s find the day of the week that the network is more active according to
    the number of transactions or value of transactions. As we did with the hour of
    the day, we use the `$dayOfWeek` operator to extract the day of the week from
    `ISODate()` objects, as shown in the following code. Days are numbered ranging
    from one for Sunday to seven for Saturday, following the US convention:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出网络活动最频繁的一天是一周中的哪一天，根据交易数量或交易价值。与一天中的小时一样，我们使用`$dayOfWeek`运算符从`ISODate()`对象中提取一周中的哪一天，如下面的代码所示。按照美国的惯例，星期天为一，星期六为七：
- en: '[PRE20]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE21]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following code will calculate the sum of transaction values for the most
    active day of the week:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将计算一周中交易价值最高的一天的交易总值：
- en: '[PRE22]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE24]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The aggregations that we calculated can be described in the following diagram:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算的聚合可以用以下图表描述：
- en: '![](img/e8fe830a-aef7-4dc6-b15a-60247711d69e.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8fe830a-aef7-4dc6-b15a-60247711d69e.png)'
- en: 'In terms of blocks, we would like to know the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在区块方面，我们想了解以下内容：
- en: Average number of transactions per block, for both the total overall transactions
    and the total contracted internal transactions.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个区块的平均交易数量，包括总体交易数量和合约内部交易的总体交易数量。
- en: Average gas used per block.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个区块的平均燃气使用量。
- en: Average gas used per transaction to a block. Is there a window of opportunity
    to submit my smart contract in a block?
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个交易到区块的平均燃气使用量。是否有机会在一个区块中提交我的智能合约？
- en: Average difficulty per block and how it deviates.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个区块的平均难度及其偏差。
- en: Average number of transactions per block, both in total and also in contracted
    internal transactions.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个区块的平均交易数量，总交易数量以及合约内部交易的平均交易数量。
- en: 'Averaging over the `number_transactions` field, we can get the number of transactions
    per block, as shown in the following code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对`number_transactions`字段进行平均，我们可以得到每个区块的交易数量，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE26]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Whereas with the following code, we can get the average number of internal
    transactions per block:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 而使用以下代码，我们可以得到每个区块的内部交易的平均数量：
- en: '[PRE27]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE28]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The average gas used per block can be acquired as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 每个区块使用的平均燃气量可以通过以下方式获得：
- en: '[PRE29]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE30]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The average difficulty per block and how it deviates can be acquired as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 每个区块的平均难度及其偏差可以通过以下方式获得：
- en: '[PRE31]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE32]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Our aggregations are described in the following schema:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聚合描述如下模式：
- en: '![](img/1b5a0878-4238-4012-bca0-c395a951a7f9.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b5a0878-4238-4012-bca0-c395a951a7f9.png)'
- en: Now that we have the basic statistics calculated, we want to up our game and
    find out more information about our transactions. Through our sophisticated machine
    learning algorithms, we have identified some of the transactions as either scams
    or **initial coin offering** (**ICO**), or maybe both.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经计算了基本统计数据，我们想要提高我们的水平，并了解有关我们的交易的更多信息。通过我们复杂的机器学习算法，我们已经确定了一些交易是欺诈或**首次代币发行**（ICO），或者两者兼而有之。
- en: 'In these documents, we have marked these attributes in an array called `tags`,
    as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些文档中，我们已经在一个名为`tags`的数组中标记了这些属性，如下所示：
- en: '[PRE33]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now we want to get the transactions from June, 2017, remove the `_id` field,
    and produce different documents according to the tags that we have identified.
    So in our example, we would output two documents in our new collection, `scam_ico_documents`,
    for separate processing.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要获取2017年6月的交易，移除`_id`字段，并根据我们已经识别的标签生成不同的文档。因此，在我们的示例中，我们将在我们的新集合`scam_ico_documents`中输出两个文档，以便进行单独处理。
- en: 'The way to do this via the aggregation framework is shown in the following
    code:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 通过聚合框架进行此操作的方式如下所示：
- en: '[PRE34]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, we have the following four distinct steps in our aggregation framework
    pipeline:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在聚合框架管道中，我们有以下四个不同的步骤：
- en: Using `$match`, we only extract documents that have a `timestamp`  field value
    of June 01, 2017.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`$match`，我们只提取具有`timestamp`字段值为2017年6月1日的文档。
- en: Using `$project`, we add a new  `report_period` field with a value of `June
    2017` and remove the `_id` field by setting its value to `0`. We keep the rest
    of the fields intact by using the value `1`, as shown in the preceding code.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`$project`，我们添加一个名为`report_period`的新字段，其值为`2017年6月`，并通过将其值设置为`0`来移除`_id`字段。我们通过使用值`1`保持其余字段不变，如前面的代码所示。
- en: Using `$unwind`, we output one new document per tag in our `$tags` array.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`$unwind`，我们在我们的`$tags`数组中为每个标签输出一个新文档。
- en: Finally, using `$out`, we output all of our documents to a new `scam_ico_documents`
    collection.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`$out`，我们将所有文档输出到一个新的`scam_ico_documents`集合中。
- en: 'Since we used the `$out` operator, we will get no results in the command line.
    If we comment out `{"$out": "scam_ico_documents"}`, we get documents that look
    like the following:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '由于我们使用了`$out`运算符，在命令行中将得不到任何结果。如果我们注释掉`{"$out": "scam_ico_documents"}`，我们将得到以下类似的文档：'
- en: '[PRE35]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The final result in our database will look like this:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们数据库中的最终结果将如下所示：
- en: '[PRE36]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now that we have documents that are clearly separated in the `scam_ico_documents`
    collection, we can perform further analysis pretty easily. An example of this
    analysis would be to append more information on some of these scammers. Luckily,
    our data scientists have come up with some additional information that we have
    extracted into a new collection `scam_details`, which looks like this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在`scam_ico_documents`集合中有了明确定义的文档，我们可以很容易地进行进一步的分析。这种分析的一个例子是在一些骗子上附加更多信息。幸运的是，我们的数据科学家已经提供了一些额外的信息，我们已经提取到一个新的集合`scam_details`中，它看起来是这样的：
- en: '[PRE37]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can now create a new aggregation pipeline job to join our `scam_ico_documents`
    with the `scam_details` collection and output these extended results in a new
    collection, called `scam_ico_documents_extended`, like this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个新的聚合管道作业，将我们的`scam_ico_documents`与`scam_details`集合连接起来，并将这些扩展结果输出到一个新的集合中，名为`scam_ico_documents_extended`，就像这样：
- en: '[PRE38]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here, we are using the following three-step aggregation pipeline:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用以下三步聚合管道：
- en: Use the `$lookup` command to join data from the `scam_details` collection and
    the `scam_address` field with data from our local collection (`scam_ico_documents`)
    based on the value from the local collection attribute `from` being equal to the
    value in the `scam_details` collection's `scam_address` field. If these are equal,
    then the pipeline adds a new field to the document called `scam_details`.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`$lookup`命令，从`scam_details`集合和`scam_address`字段中的数据与我们的本地集合（`scam_ico_documents`）中的数据进行连接，基于本地集合属性`from`的值等于`scam_details`集合的`scam_address`字段中的值。如果它们相等，那么管道将在文档中添加一个名为`scam_details`的新字段。
- en: Next, we only match the documents that have a `scam_details` field—the ones
    that matched with the lookup aggregation framework step.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们只匹配具有`scam_details`字段的文档，即与查找聚合框架步骤匹配的文档。
- en: Finally, we output these documents in a new collection called `scam_ico_documents_extended`.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将这些文档输出到一个名为`scam_ico_documents_extended`的新集合中。
- en: 'These documents will now look like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这些文档看起来是这样的：
- en: '[PRE39]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Using the aggregation framework, we have identified our data and can process
    it rapidly and efficiently.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用聚合框架，我们已经确定了我们的数据，并且可以快速高效地处理它。
- en: 'The previous steps can be summed up in the following diagram:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤可以总结如下图所示：
- en: '![](img/0ce20f81-e8bb-4501-94a4-2a855c17c203.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ce20f81-e8bb-4501-94a4-2a855c17c203.png)'
- en: Summary
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we dived deep into the aggregation framework. We discussed
    why and when we should use aggregation as opposed to simply using MapReduce or
    querying the database. We went through the vast array of options and functionalities
    for aggregation.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了聚合框架。我们讨论了为什么以及何时应该使用聚合，而不是简单地使用MapReduce或查询数据库。我们详细介绍了聚合的各种选项和功能。
- en: We discussed the aggregation stages and the various operators, such as Boolean
    operators, comparison operators, set operators, array operators, date operators,
    string operators, expression arithmetic operators, aggregation accumulators, conditional
    expressions, and variables, and the literal parsing data type operators.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了聚合阶段和各种运算符，如布尔运算符、比较运算符、集合运算符、数组运算符、日期运算符、字符串运算符、表达式算术运算符、聚合累加器、条件表达式和变量，以及文字解析数据类型运算符。
- en: Using the Ethereum use case, we went through aggregation with working code and
    learned how to approach an engineering problem to solve it.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以太坊用例，我们通过工作代码进行了聚合，并学习了如何解决工程问题。
- en: Finally, we learned about the limitation that the aggregation framework currently
    has and when to avoid it.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们了解了聚合框架目前存在的限制以及何时应避免使用它。
- en: In the next chapter, we will move on to the topic of indexing and learn how
    to design and implement performant indexes for our read and write workloads.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续讨论索引的主题，并学习如何为我们的读写工作负载设计和实现高性能索引。
