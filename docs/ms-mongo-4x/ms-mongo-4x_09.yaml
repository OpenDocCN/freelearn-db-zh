- en: Indexing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引
- en: 'This chapter will explore one of the most important properties of any database:
    indexing. Similar to book indexes, database indexes allow for quicker data retrieval.
    In the RDBMS world, indexes are widely used (and sometimes abused) to speed up
    data access. In MongoDB, indexes play an integral part in schema and query design.
    MongoDB supports a wide array of indexes that you will learn about in this chapter,
    including single field, compound, multi-key, geospatial, hashed, partial, and
    many more. In addition to reviewing the different types of indexes, we will show
    you how to build and manage indexes for single-server deployments, as well as
    complex sharded environments.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨任何数据库中最重要的属性之一：索引。与书籍索引类似，数据库索引可以加快数据检索速度。在关系型数据库管理系统中，索引被广泛使用（有时被滥用）以加快数据访问速度。在MongoDB中，索引在模式和查询设计中起着至关重要的作用。MongoDB支持各种索引类型，您将在本章中了解到，包括单字段、复合、多键、地理空间、哈希、部分等等。除了审查不同类型的索引，我们还将向您展示如何为单服务器部署以及复杂的分片环境构建和管理索引。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Index internals
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引内部
- en: Types of indexes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引类型
- en: Building and managing indexes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和管理索引
- en: Efficient usage of indexes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引的高效使用
- en: Index internals
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引内部
- en: In most cases, indexes are variations of the B-tree data structure. Invented
    by Rudolf Bayer and Ed McCreight in 1971, while they were working at Boeing research
    labs, the **B-tree** data structure allows for searches, sequential access, inserts,
    and deletes to be performed in logarithmic time. The **logarithmic time** property
    stands for both the average case performance and the worst possible performance,
    and it is a great property when applications cannot tolerate unexpected variations
    in performance behavior.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，索引是B树数据结构的变体。由Rudolf Bayer和Ed McCreight于1971年在波音研究实验室工作时发明，**B树**数据结构允许在对数时间内执行搜索、顺序访问、插入和删除。**对数时间**属性适用于平均情况性能和最坏情况性能，当应用程序无法容忍性能行为的意外变化时，这是一个很好的属性。
- en: 'To further illustrate how important the logarithmic time part is, we will show
    you the Big-O complexity chart, which is from [http://bigocheatsheet.com/](http://bigocheatsheet.com/):'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步说明对数时间的重要性，我们将向您展示Big-O复杂度图表，该图表来自[http://bigocheatsheet.com/](http://bigocheatsheet.com)：
- en: '![](img/1e0681d3-c53a-4ad0-a009-75717d94b0ee.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e0681d3-c53a-4ad0-a009-75717d94b0ee.png)'
- en: In this diagram, you can see logarithmic time performance as a flat line, parallel
    to the *x* axis of the diagram. As the number of elements increases, constant
    time (**O(n)**) algorithms perform worse, whereas quadratic time algorithms (**O(n^2)**)
    go off the chart. For an algorithm that we rely on to get our data back to us
    as quickly as possible, time performance is of the utmost importance.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，您可以看到对数时间性能作为图表的*x*轴平行的一条直线。随着元素数量的增加，常数时间（**O(n)**）算法表现更差，而二次时间算法（**O(n^2)**）则超出了图表范围。对于我们依赖的算法来尽快将数据返回给我们，时间性能至关重要。
- en: Another interesting property of a B-tree is that it is self-balancing, meaning
    that it will self-adjust to always maintain these properties. Its precursor and
    closest relative is the binary search tree, a data structure that only allows
    two children for each parent node.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: B树的另一个有趣特性是它是自平衡的，这意味着它将自动调整以始终保持这些属性。它的前身和最接近的亲戚是二叉搜索树，这是一种数据结构，每个父节点只允许两个子节点。
- en: 'Schematically, a B-tree looks like the following diagram, which can also be
    seen at [https://commons.wikimedia.org/w/index.php?curid=11701365](https://commons.wikimedia.org/w/index.php?curid=11701365):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从图表上看，B树的结构如下图所示，也可以在[https://commons.wikimedia.org/w/index.php?curid=11701365](https://commons.wikimedia.org/w/index.php?curid=11701365)上看到：
- en: '![](img/481c69b3-7abe-4924-a3d8-5682382bdf01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/481c69b3-7abe-4924-a3d8-5682382bdf01.png)'
- en: In the preceding diagram, we have a parent node with the values **7** and 16,
    pointing to three child nodes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，我们有一个父节点，其值为**7**和**16**，指向三个子节点。
- en: If we search for the value **9**, knowing that it's greater than **7** and smaller
    than **16**, we'll be directed to the middle child node that contains the value
    straight away.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们搜索值为**9**，知道它大于**7**且小于**16**，我们将直接被引导到包含该值的中间子节点。
- en: Thanks to this structure, we are approximately halving our search space with
    every step, ending in a *log n* time complexity. Compared to sequentially scanning
    through every element, halving the number of elements with each and every step
    increases our gains exponentially as the number of elements we have to search
    through increases.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种结构，我们在每一步都将搜索空间几乎减半，最终达到*log n*的时间复杂度。与顺序扫描每个元素相比，每一步将元素数量减半，使我们的收益呈指数增长，因为我们需要搜索的元素数量增加。
- en: Index types
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引类型
- en: MongoDB offers a vast array of index types for different needs. In the following
    sections, we will identify the different types, and the needs that each one of
    them fulfills.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB为不同的需求提供了各种索引类型。在接下来的章节中，我们将确定不同类型的索引以及它们各自满足的需求。
- en: Single field indexes
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单字段索引
- en: The most common and simple type of index is the single field index. An example
    of a single field and key index is the index on `ObjectId` (`_id`), which is generated
    by default in every MongoDB collection. The `ObjectId` index is also unique, preventing
    a second document from having the same `ObjectId` in a collection.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见和简单的索引类型是单字段索引。单字段和键索引的一个例子是在每个MongoDB集合中默认生成的`ObjectId`（`_id`）索引。`ObjectId`索引也是唯一的，防止另一个文档在集合中具有相同的`ObjectId`。
- en: 'An index on a single field, based on the `mongo_book` database that we used
    throughout the previous chapters, is defined like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们在前几章中使用的`mongo_book`数据库的单字段索引定义如下：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we create an index on the field name in ascending order of index creation.
    For a descending order, the same index would be created like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们按照索引创建的顺序对字段名称创建索引。对于降序，相同的索引将如下创建：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The ordering for index creation is important if we expect our queries to favor
    values on the first documents stored in our index. However, due to the extremely
    efficient time complexity that indexes have, this will not be a consideration
    for the most common use cases.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 索引创建的顺序对于我们期望查询优先考虑存储在索引中的第一个文档的值的情况很重要。然而，由于索引具有极其高效的时间复杂度，这对于最常见的用例来说并不重要。
- en: An index can be used for exact match queries or range queries on a field value.
    In the former case, the search can stop as soon as our pointer reaches the value
    after *O(log n)* time.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 索引可以用于字段值的精确匹配查询或范围查询。在前一种情况下，一旦我们的指针在*O(log n)*时间后到达值，搜索就可以停止。
- en: In range queries, due to the fact that we are storing values in order in our
    B-tree index, once we find the border value of our range query in a node of our
    B-tree, we will know that all of the values in its children will be part of our
    result set, allowing us to conclude our search.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在范围查询中，由于我们在B树索引中按顺序存储值，一旦我们在B树的节点中找到范围查询的边界值，我们将知道其所有子节点中的所有值都将成为我们结果集的一部分，从而允许我们结束我们的搜索。
- en: 'An example of this is shown as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 示例如下：
- en: '![](img/1fe86237-0faf-44c8-b1e1-603416cc5b3e.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fe86237-0faf-44c8-b1e1-603416cc5b3e.png)'
- en: Dropping indexes
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除索引
- en: 'Dropping an index is as simple as creating it. We can reference the index by
    its name or by the fields it is composed from:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 删除索引与创建索引一样简单。我们可以通过名称或由其组成的字段引用索引：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Indexing embedded fields
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引嵌入字段
- en: As a document database, MongoDB supports embedding fields and whole documents
    in nested complex hierarchies inside of the same document. Naturally, it also
    allows us to index these fields.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 作为文档数据库，MongoDB支持在同一文档的嵌套复杂层次结构中嵌入字段和整个文档。自然地，它也允许我们对这些字段进行索引。
- en: 'In our `books` collection example, we can have documents like the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`books`集合示例中，我们可以有以下类似的文档：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, the `meta_data` field is a document itself, with `page_count` and `average_customer_review` fields.
    Again, we can create an index on `page_count`, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`meta_data`字段本身是一个文档，具有`page_count`和`average_customer_review`字段。同样，我们可以按照以下方式在`page_count`上创建索引：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This can answer queries on equality and range comparisons around the `meta_data.page_count`
    field, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以回答关于`meta_data.page_count`字段的相等和范围比较的查询，如下所示：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To access embedded fields, we use dot notation, and we need to include quotes
    (`""`) around the field's name.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问嵌入字段，我们使用点表示法，并且需要在字段名称周围包含引号（`""`）。
- en: Indexing embedded documents
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引嵌入文档
- en: 'We can also index the embedded document as a whole, similar to indexing embedded
    fields:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以像索引嵌入字段一样索引整个嵌入文档：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we are indexing the whole document, expecting queries against its entirety,
    like the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在索引整个文档，期望针对其整体进行查询，如下所示：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The key difference is that when we index embedded fields, we can perform range
    queries on them using the index, whereas when we index embedded documents, we
    can only perform comparison queries using the index.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于当我们索引嵌入字段时，我们可以使用索引对它们执行范围查询，而当我们索引嵌入文档时，我们只能使用索引执行比较查询。
- en: 'The `db.books.find({"meta_data.average_customer_review": { $gte: 4.8}, "meta_data.page_count":
    { $gte: 200 } })` command will not use our `meta_data` index, whereas `db.books.find({"meta_data":
    {"page_count":256, "average_customer_review":4.8}})` will use it.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.books.find({"meta_data.average_customer_review": { $gte: 4.8}, "meta_data.page_count":
    { $gte: 200 } })`命令不会使用我们的`meta_data`索引，而`db.books.find({"meta_data": {"page_count":256,
    "average_customer_review":4.8}})`会使用它。'
- en: Background indexes
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后台索引
- en: 'Indexes can be created in the foreground, blocking all of the operations in
    the collection until they are built, or they can be created in the background,
    allowing for concurrent operations. Building an index in the background is done
    by passing in the `background: true` parameter:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '索引可以在前台创建，阻塞集合中的所有操作，直到它们建立完成，或者可以在后台创建，允许并发操作。通过传递`background: true`参数来在后台构建索引：'
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Background indexes have some limitations that we will revisit in the last section
    of this chapter, *Building and managing indexes*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 后台索引在本章的最后一节*构建和管理索引*中有一些限制，我们将在最后一节中重新讨论。
- en: Compound indexes
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合索引
- en: Compound indexes are a generalization of single-key indexes, allowing for multiple
    fields to be included in the same index. They are useful when we expect our queries
    to span multiple fields in our documents, and also for consolidating our indexes
    when we start to have too many of them in our collection.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 复合索引是单键索引的泛化，允许多个字段包含在同一个索引中。当我们期望查询跨多个字段的文档时，以及当我们开始在集合中拥有太多索引时，它们非常有用。
- en: Compound indexes can have as many as 31 fields. They cannot have a hashed index
    type.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 复合索引最多可以有31个字段。它们不能有散列索引类型。
- en: 'A compound index is declared similarly to single indexes, by defining the fields
    that we want to index and the order of indexing:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 复合索引的声明方式与单个索引类似，通过定义要索引的字段和索引的顺序来定义：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Sorting with compound indexes
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用复合索引进行排序
- en: The order of indexing is useful for sorting results. In single field indexes,
    MongoDB can traverse the index both ways, so it doesn't matter which order we
    define.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 索引的顺序对于排序结果很有用。在单字段索引中，MongoDB可以双向遍历索引，因此我们定义的顺序并不重要。
- en: 'In multi-field indexes, however, ordering can determine whether we can use
    this index to sort. In the preceding example, a query matching the sort direction
    of our index creation will use our index as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在多字段索引中，排序可以决定我们是否可以使用此索引进行排序。在前面的示例中，与我们索引创建的排序方向匹配的查询将使用我们的索引，如下所示：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It will also use a `sort` query with all of the `sort` fields reversed:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 它还将使用所有`sort`字段反转的`sort`查询：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this query, since we negated both of the fields, MongoDB can use the same
    index, traversing it from the end to the start.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个查询中，由于我们否定了两个字段，MongoDB可以使用相同的索引，从末尾到开头遍历它。
- en: 'The other two sorting orders are as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两种排序顺序如下：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: They cannot be traversed using the index, as the `sort` order that we want is
    not present in our index's B-tree data structure.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不能使用索引进行遍历，因为我们想要的`sort`顺序在我们的索引B树数据结构中不存在。
- en: Reusing compound indexes
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重用复合索引
- en: An important attribute of compound indexes is that they can be used for multiple
    queries on prefixes of the fields indexed. This is useful when we want to consolidate
    indexes that pile up in our collections over time.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 复合索引的一个重要属性是它们可以用于对索引字段的前缀进行多个查询。当我们想要在随着时间在我们的集合中堆积的索引进行合并时，这是有用的。
- en: 'Consider the compound (multi-field) index that we created previously:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们之前创建的复合（多字段）索引：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This can be used for queries on `name` or `{name, isbn}`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用于对`name`或`{name, isbn}`进行查询：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The order of the fields in our query doesn't matter; MongoDB will rearrange
    the fields to match our query.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 查询中字段的顺序并不重要；MongoDB将重新排列字段以匹配我们的查询。
- en: 'However, the order of the fields in our index does matter. A query just for
    the `isbn` field cannot use our index:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们索引中字段的顺序是重要的。仅针对`isbn`字段的查询无法使用我们的索引：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The underlying reason is that our fields' values are stored in the index as
    secondary, tertiary, and so on; each one is embedded inside of the previous ones,
    just like a **matryoshka**, the Russian nesting doll. This means that when we
    query on the first field of our multi-field index, we can use the outermost doll
    to find our pattern, whereas when we are searching for the first two fields, we
    can match the pattern on the outermost doll, and then dive into the inner one.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 根本原因是我们字段的值存储在索引中作为次要、第三等等；每个值都嵌入在前一个值中，就像俄罗斯套娃一样。这意味着当我们在多字段索引的第一个字段上进行查询时，我们可以使用最外层的套娃来找到我们的模式，而当我们搜索前两个字段时，我们可以在最外层的套娃上匹配模式，然后深入到内部的套娃中。
- en: This concept is called **prefix indexing**, and along with index intersection,
    it is the most powerful tool for index consolidation, as you will see later in
    this chapter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念被称为**前缀索引**，以及索引交集，它是索引合并的最强大工具，正如你将在本章后面看到的。
- en: Multikey indexes
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多键索引
- en: Indexing scalar (single) values was explained in the preceding sections. However,
    one of the advantages that we get from using MongoDB is the ability to easily
    store vector values in the form of arrays.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中已经解释了标量（单一）值的索引。然而，我们从使用MongoDB中获得的优势之一是能够轻松地以数组的形式存储向量值。
- en: In the relational world, storing arrays is generally frowned upon, as it violates
    the normal forms. In a document-oriented database such as MongoDB, it is frequently
    a part of our design, as we can store and query easily on complex structures of
    data.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系世界中，存储数组通常是不受欢迎的，因为它违反了正常形式。在MongoDB这样的面向文档的数据库中，它经常是我们设计的一部分，因为我们可以轻松地存储和查询数据的复杂结构。
- en: Indexing arrays of documents is achieved by using the multikey index. A multikey
    index can store both arrays of scalar values and arrays of nested documents.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用多键索引可以对文档数组进行索引。多键索引可以存储标量值数组和嵌套文档数组。
- en: 'Creating a multikey index is the same as creating a regular index:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 创建多键索引与创建常规索引相同：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Assume that we have created a document in our `books` collection, using the
    following command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经在我们的`books`集合中创建了一个文档，使用以下命令：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our new index will be a multikey index, allowing us to find documents with
    any of the tags stored in our array:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新索引将是一个多键索引，允许我们找到包含数组中任何标签的文档：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can also create compound indexes with a multikey index, but we can have,
    at the most, one array in each and every index document. Given that in MongoDB
    we don't specify the type of each field, this means that creating an index with
    two or more fields with an array value will fail at creation time, and trying
    to insert a document with two or more fields as arrays will fail at insertion
    time.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用多键索引创建复合索引，但每个索引文档中最多只能有一个数组。鉴于在MongoDB中我们不指定每个字段的类型，这意味着创建具有两个或更多字段的数组值的索引将在创建时失败，并且尝试插入具有两个或更多字段的数组的文档将在插入时失败。
- en: 'For example, a compound index on `tags`, `analytics_data` will fail to be created
    if we have the following document in our database:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的数据库中有以下文档，那么在`tags`、`analytics_data`上创建的复合索引将无法创建：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Consequently, if we first create the index on an empty collection and try to
    insert this document, the insert will fail, with the following error:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们首先在空集合上创建索引，然后尝试插入此文档，插入将失败，并显示以下错误：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Hashed indexes cannot be multikey indexes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 散列索引不能是多键索引。
- en: Another limitation that we will likely run into when trying to fine-tune our
    database is that multikey indexes cannot entirely cover a query. Covering a query
    with the index means that we can get our result data entirely from the index,
    without accessing the data in our database at all. This can result in dramatically
    increased performance, as indexes are most likely to be stored in RAM.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试微调我们的数据库时，我们可能会遇到的另一个限制是多键索引无法完全覆盖查询。使用索引覆盖查询意味着我们可以完全从索引中获取我们的结果数据，而根本不访问我们数据库中的数据。这可能会导致性能大幅提升，因为索引很可能存储在RAM中。
- en: Querying for multiple values in multikey indexes will result in a two-step process,
    from the index's perspective.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在多键索引中查询多个值将从索引的角度产生一个两步过程。
- en: 'In the first step, index will be used to retrieve the first value of the array,
    and then a sequential scan will run through the rest of the elements in the array;
    an example is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，索引将用于检索数组的第一个值，然后顺序扫描将运行数组中其余的元素；示例如下：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will first search for all entries in multikey `index` tags that have a
    `mongodb` value, and will then sequentially scan through them to find the ones
    that also have the `index`, `cheatsheet`, and `new` tags.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将首先搜索具有`mongodb`值的多键`index`标签的所有条目，然后顺序扫描它们以找到也具有`index`、`cheatsheet`和`new`标签的条目。
- en: A multikey index cannot be used as a shard key. However, if the shard key is
    a prefix index of a multikey index, it can be used. We will cover more on this
    in [Chapter 13](1c075020-a2e9-41f5-89b8-4ccd8f8d6fef.xhtml), *Sharding*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 多键索引不能用作分片键。但是，如果分片键是多键索引的前缀索引，则可以使用。我们将在[第13章](1c075020-a2e9-41f5-89b8-4ccd8f8d6fef.xhtml)
    *分片*中更多地介绍这一点。
- en: Special types of indexes
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊类型的索引
- en: Apart from the generic indexes, MongoDB supports indexes for special use cases.
    In this section, we will identify and explore how to use them.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通用索引外，MongoDB还支持特殊用例的索引。在本节中，我们将确定并探讨如何使用它们。
- en: Text indexes
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本索引
- en: Text indexes are special indexes on string value fields, used to support text
    searches. This book is based on version 3 of the text index functionality, available
    since version 3.2.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 文本索引是对字符串值字段的特殊索引，用于支持文本搜索。本书基于文本索引功能的第3版，自第3.2版起可用。
- en: 'A text index can be specified similarly to a regular index, by replacing the
    index sort order (`-1`, `1`) with the word `text`, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 文本索引可以类似于常规索引进行指定，方法是用单词`text`替换索引排序顺序（`-1`，`1），如下所示：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A collection can have one text index, at the most. This text index can support
    multiple fields, text or not. It cannot support other special types, such as multikey
    or geospatial. Text indexes cannot be used for sorting results, even if they are
    only a part of a compound index.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一个集合最多可以有一个文本索引。这个文本索引可以支持多个字段，无论是文本还是其他。它不能支持其他特殊类型，如多键或地理空间。即使它们只是复合索引的一部分，文本索引也不能用于排序结果。
- en: Since we only have one text index per collection, we need to choose the fields
    wisely. Reconstructing this text index can take quite some time, and having only
    one of them per collection makes maintenance quite tricky, as you will see toward
    the end of this chapter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个集合只有一个文本索引，因此我们需要明智地选择字段。重建此文本索引可能需要相当长的时间，并且每个集合只有一个文本索引使得维护非常棘手，正如您将在本章末尾看到的那样。
- en: 'Luckily, this index can also be a compound index:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，此索引也可以是复合索引：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A compound index with `text` fields follows the same rules of sorting and prefix
    indexing that we explained earlier in this chapter. We can use this index to query
    on `available`, or the combination of `available` and `meta_data.page_count`,
    or sort them if the sort order allows for traversing our index in any direction.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 具有`text`字段的复合索引遵循本章前面解释的排序和前缀索引规则。我们可以使用此索引来查询`available`，或`available`和`meta_data.page_count`的组合，或者如果排序顺序允许在任何方向遍历我们的索引，则对它们进行排序。
- en: 'We can also blindly index each and every field in a document that contains
    strings as `text`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以盲目地对包含字符串的每个字段进行`text`索引：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This can result in unbounded index sizes, and should be avoided; however, it
    can be useful if we have unstructured data (for example, coming straight from
    application logs wherein we don't know which fields may be useful, and we want
    to be able to query as many of them as possible).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能导致无限制的索引大小，应该避免使用；但是，如果我们有非结构化数据（例如，直接来自应用程序日志，我们不知道哪些字段可能有用，并且希望能够查询尽可能多的字段），这可能是有用的。
- en: Text indexes will apply stemming (removing common suffixes, such as plural `s`/`es`
    for English language words) and remove stop words (`a`, `an`, `the`, and so on)
    from the index.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 文本索引将应用词干处理（删除常见后缀，例如英语单词的复数`s`/`es`）并从索引中删除停用词（`a`，`an`，`the`等）。
- en: Text indexing supports more than 20 languages, including Spanish, Chinese, Urdu,
    Persian, and Arabic. Text indexes require special configurations to correctly
    index in languages other than English.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 文本索引支持20多种语言，包括西班牙语，中文，乌尔都语，波斯语和阿拉伯语。文本索引需要特殊配置才能正确地索引英语以外的语言。
- en: 'Some interesting properties of text indexes are explained as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 文本索引的一些有趣属性如下所述：
- en: '**Case-insensitivity and diacritic insensitivity**: A text index is case- and
    diacritic-insensitive. Version 3 of the text index (the one that comes with version
    3.4) supports common *C*, simple *S*, and the special *T* case folding, as described
    in **Unicode Character Database** (**UCD**) 8.0 case folding. In addition to case-insensitivity,
    version 3 of the text index supports diacritic insensitivity. This expands insensitivity
    to characters with accents in both small and capital-letter form. For example, *e*, *è*,
    *é*, *ê*, *ë*, and their capital letter counterparts, can all result into being
    equal when comparing using a text index. In the previous versions of the text
    index, these were treated as different strings.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大小写不敏感和变音符号不敏感：文本索引是大小写和变音符号不敏感的。文本索引的第3版（随第3.4版一起发布）支持常见的*C*，简单的*S*和特殊的*T*大小写折叠，如**Unicode字符数据库**（**UCD**）8.0大小写折叠中所述。除了大小写不敏感外，文本索引的第3版还支持变音符号不敏感。这将扩展对带有小写和大写字母形式的重音符号的字符的不敏感性。例如，*e*，*è*，*é*，*ê*，*ë*及其大写字母对应物，在使用文本索引进行比较时都可能相等。在文本索引的先前版本中，这些被视为不同的字符串。
- en: '**Tokenization delimiters: **Version 3 of the text index supports the tokenization
    delimiters, defined as `Dash`, `Hyphen`, `Pattern_Syntax`, `Quotation_Mark`, `Terminal_Punctuation`,
    and `White_Space`, as described in UCD 8.0 case folding.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标记化分隔符：**文本索引的第3版支持标记化分隔符，定义为`Dash`，`Hyphen`，`Pattern_Syntax`，`Quotation_Mark`，`Terminal_Punctuation`和`White_Space`，如UCD
    8.0大小写折叠中所述。'
- en: Hashed indexes
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 散列索引
- en: 'A hashed index contains `hashed` values of the indexed field:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 散列索引包含索引字段的`hashed`值：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will create a hashed index on the name of each book of our `books` collection.
    A hashed index is ideal for equality matches, but it cannot work with range queries.
    If we want to perform a range of queries on fields, we can create a regular index
    (or a compound index containing the field), and also a hashed index for equality
    matches. Hashed indexes are used internally by MongoDB for hash-based sharding,
    as we will discuss in [Chapter 13](1c075020-a2e9-41f5-89b8-4ccd8f8d6fef.xhtml),
    *Sharding*. Hashed indexes truncate floating point fields to integers. Floating
    points should be avoided for hashed fields wherever possible.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的`books`集合的每本书的名称上创建一个哈希索引。哈希索引非常适合相等匹配，但不能用于范围查询。如果我们希望对字段执行一系列查询，我们可以创建一个常规索引（或包含该字段的复合索引），并且还可以创建一个用于相等匹配的哈希索引。哈希索引在MongoDB内部用于基于哈希的分片，我们将在[第13章](1c075020-a2e9-41f5-89b8-4ccd8f8d6fef.xhtml)
    *分片*中讨论。哈希索引将浮点字段截断为整数。在可能的情况下，应尽量避免对哈希字段使用浮点数。
- en: Time to live indexes
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生存时间索引
- en: '**Time to live** (**TTL**) indexes are used to automatically delete documents
    after an expiration time. Their syntax is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**生存时间**（**TTL**）索引用于在过期时间后自动删除文档。它们的语法如下：'
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `created_at_date` field values have to be either a date or an array of dates
    (the earliest one will be used). In this example, the documents will get deleted
    one day (`86400` seconds) after `created_at_date`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`created_at_date`字段的值必须是日期或日期数组（将使用最早的日期）。在这个例子中，文档将在`created_at_date`之后的一天（`86400`秒）被删除。'
- en: If the field does not exist or the value is not a date, the document will not
    expire. In other words, a TTL index silently fails, not returning any errors when
    it does.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字段不存在或值不是日期，则文档将不会过期。换句话说，TTL索引会默默失败，不会在失败时返回任何错误。
- en: Data gets removed by a background job that runs every 60 seconds. As a result,
    there is no explicit accuracy guarantee as to how much longer documents will persist
    past their expiration dates.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 数据将通过每60秒运行一次的后台作业进行删除。因此，关于文档在其过期日期之后还会持续存在多长时间，没有明确的准确性保证。
- en: 'A TTL index is a regular single field index. It can be used for queries like
    a regular index. A TTL index cannot be a compound index, operate on a capped collection,
    or use the `_id` field. The `_id` field implicitly contains a timestamp of the
    created time for the document, but is not a `Date` field. If we want each document
    to expire at a different, custom date point, we have to set `{expireAfterSeconds:
    0}`, and set the TTL index `Date` field manually to the date on which we want
    the document to expire.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 'TTL索引是常规的单字段索引。它可以用于像常规索引一样的查询。TTL索引不能是复合索引，不能在封顶集合上操作，也不能使用`_id`字段。`_id`字段隐含地包含了文档创建时间的时间戳，但不是一个`Date`字段。如果我们希望每个文档在不同的自定义日期点过期，我们必须设置`{expireAfterSeconds:
    0}`，并手动设置TTL索引的`Date`字段为我们希望文档过期的日期。'
- en: Partial indexes
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分索引
- en: A partial index on a collection is an index that only applies to the documents
    that satisfy the `partialFilterExpression` query.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 集合上的部分索引是仅适用于满足`partialFilterExpression`查询的文档的索引。
- en: 'We''ll use our familiar `books` collection, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们熟悉的`books`集合，如下所示：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using this, we can have an index for just the books that have a price greater
    than `30`. The advantage of partial indexes is that they are more lightweight
    in creation and maintenance, and use less storage.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，我们可以为只有价格大于`30`的书籍创建一个索引。部分索引的优点是在创建和维护上更轻量，并且使用更少的存储空间。
- en: 'The `partialFilterExpression` filter supports the following operators:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`partialFilterExpression`过滤器支持以下运算符：'
- en: 'Equality expressions (that is, `field: value`, or using the `$eq` operator)'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '相等表达式（即`field: value`，或使用`$eq`运算符）'
- en: 'The `$exists: true` expression'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$exists: true`表达式'
- en: The `$gt`, `$gte`, `$lt`, and `$lte` expressions
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$gt`，`$gte`，`$lt`和`$lte`表达式'
- en: '`$type` expressions'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$type`表达式'
- en: The `$and` operator, at the top level only
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$and`运算符，仅在顶层'
- en: Partial indexes will only be used if the query can be satisfied as a whole by
    the partial index.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当查询可以完全满足部分索引时，才会使用部分索引。
- en: If our query matches or is more restrictive than the `partialFilterExpression`
    filter, then the partial index will be used. If the results may not be contained
    in the partial index, then the index will be totally ignored.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的查询匹配或比`partialFilterExpression`过滤器更严格，那么将使用部分索引。如果结果可能不包含在部分索引中，则索引将被完全忽略。
- en: '`partialFilterExpression` does not need to be a part of the sparse index fields.
    The following index is a valid sparse index:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`partialFilterExpression`不需要是稀疏索引字段的一部分。以下索引是有效的稀疏索引：'
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To use this partial index, however, we need to query for both `name` and `price` equal
    to or greater than `30`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要使用这个部分索引，我们需要查询`name`和`price`都等于或大于`30`。
- en: Prefer partial indexes to sparse indexes. Sparse indexes offer a subset of the
    functionality offered by partial indexes. Partial indexes were introduced in MongoDB
    3.2, so if you have sparse indexes from earlier versions, it may be a good idea
    to upgrade them. The `_id` field cannot be a part of a partial index. A shard
    key index cannot be a partial index. `partialFilterExpression` cannot be combined
    with the `sparse` option.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 优先选择部分索引而不是稀疏索引。稀疏索引提供了部分索引提供的功能的子集。部分索引是在MongoDB 3.2中引入的，因此如果您有早期版本的稀疏索引，升级它们可能是一个好主意。`_id`字段不能是部分索引的一部分。分片键索引不能是部分索引。`partialFilterExpression`不能与`sparse`选项结合使用。
- en: Sparse indexes
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 稀疏索引
- en: A sparse index is similar to a partial index, preceding it by several years
    (it has been available since version 1.8).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏索引类似于部分索引，但比它早几年（自1.8版本以来就可用）。
- en: 'A `sparse` index only indexes values that contain the following field:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`sparse`索引只索引包含以下字段的值：'
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It will only create an index with the documents that contain a `price` field.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它只会创建一个包含包含`price`字段的文档的索引。
- en: 'Some indexes are always sparse, due to their nature:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其性质，有些索引始终是稀疏的：
- en: '`2d`, `2dsphere` (version 2)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2d`，`2dsphere`（版本2）'
- en: '`geoHaystack`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geoHaystack`'
- en: '`text`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text`'
- en: A sparse and unique index will allow for multiple documents missing the index
    key. It will not allow for documents with the same index field values. A sparse
    and compound index with geospatial indexes (`2d`, `2dsphere`, and `geoHaystack`)
    will index the document as long as it has the `geospatial` field.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏和唯一的索引将允许多个文档缺少索引键。它不会允许具有相同索引字段值的文档。具有地理空间索引（`2d`，`2dsphere`和`geoHaystack`）的稀疏和复合索引将索引文档，只要它具有`geospatial`字段。
- en: A sparse and compound index with the `text` field will index the document as
    long as it has the `text` field. A sparse and compound index without any of the
    two preceding cases will index the document as long as it has at least one of
    the fields.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 具有`text`字段的稀疏和复合索引将索引文档，只要它具有`text`字段。没有前两种情况的稀疏和复合索引将索引文档，只要它至少有一个字段。
- en: Avoid creating new sparse indexes in the latest versions of MongoDB; use partial
    indexes instead.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB的最新版本中避免创建新的稀疏索引；改用部分索引。
- en: Unique indexes
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 唯一索引
- en: 'A unique index is similar to an RDBMS unique index, forbidding duplicate values
    for the indexed field. MongoDB creates a unique index by default on the `_id`
    field for every inserted document:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一索引类似于RDBMS唯一索引，禁止索引字段的重复值。MongoDB默认在每个插入的文档的`_id`字段上创建唯一索引：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This will create a `unique` index on a book's `name`. A unique index can also
    be a compound embedded field or an embedded document index.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在书的`name`上创建一个`unique`索引。唯一索引也可以是复合嵌入字段或嵌入文档索引。
- en: 'In a compound index, the uniqueness is enforced across the combination of values
    in all of the fields of the index; for example, the following will not violate
    the unique index:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在复合索引中，唯一性是在索引的所有字段的值的组合中强制执行的；例如，以下内容不会违反唯一索引：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is because even though the name is the same, our index is looking for the
    unique combination of `name` and `isbn`, and the two entries differ in `isbn`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为即使名称相同，我们的索引也在寻找`name`和`isbn`的唯一组合，而这两个条目在`isbn`上有所不同。
- en: Unique indexes do not work with hashed indexes. Unique indexes cannot be created
    if the collection already contains duplicate values of the indexed field. A unique
    index will not prevent the same document from having multiple values.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一索引不适用于散列索引。如果集合已包含索引字段的重复值，则无法创建唯一索引。唯一索引不会阻止同一文档具有多个值。
- en: If a document is missing the indexed field, it will be inserted. If a second
    document is missing the indexed field, it will not be inserted. This is because
    MongoDB will store the missing field value as null, only allowing one document
    to be missing in the field.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文档缺少索引字段，则将插入该字段。如果第二个文档缺少索引字段，则不会插入。这是因为MongoDB将缺少的字段值存储为null，只允许字段中缺少一个文档。
- en: Indexes that are a combination of unique and partial will only apply unique
    indexes after a partial index has been applied. This means that there may be several
    documents with duplicate values, if they are not a part of partial filtering.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一和部分组合的索引只会在应用部分索引后应用唯一索引。这意味着如果它们不是部分过滤的一部分，可能会有几个具有重复值的文档。
- en: Case-insensitive
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不区分大小写
- en: Case-sensitivity is a common problem with indexing. We may store our data in
    mixed caps and need our index to ignore case when looking for our stored data.
    Until version 3.4, this was dealt with at the application level by creating duplicate
    fields with all lowercase characters and indexing all lowercase field to simulate
    a case-insensitive index.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 大小写敏感是索引中的常见问题。我们可能会将数据存储在混合大小写中，并且需要索引在查找存储的数据时忽略大小写。直到3.4版本，这是在应用程序级别处理的，方法是创建所有小写字符的重复字段，并将所有小写字段索引以模拟不区分大小写的索引。
- en: Using the `collation` parameter, we can create case-insensitive indexes, and
    even collections that behave as case-insensitive.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`collation`参数，我们可以创建不区分大小写的索引，甚至可以创建行为不区分大小写的集合。
- en: In general, `collation` allows users to specify language-specific rules for
    string comparisons. A possible (but not the only) usage is for case-insensitive
    indexes and queries.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`collation`允许用户指定特定于语言的字符串比较规则。可能的（但不是唯一的）用法是用于不区分大小写的索引和查询。
- en: 'Using our familiar `books` collection, we can create a case-insensitive index
    on a name, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们熟悉的`books`集合，我们可以在名称上创建一个不区分大小写的索引，如下所示：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `strength` parameter is one of the collation parameters: the defining parameter
    for case-sensitivity comparisons. Strength levels follow the **International Components
    for Unicode** (**ICU**) comparison levels. The values that it accepts are as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`strength`参数是`collation`参数之一：用于区分大小写比较的定义参数。强度级别遵循**国际Unicode组件**（**ICU**）比较级别。它接受的值如下：'
- en: '| **Strength Value** | **Description** |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| **强度值** | **描述** |'
- en: '| `1a` | Primary level of comparison. Comparison based on string values, ignoring
    any other differences, such as case and diacritics. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `1a` | 比较的主要级别。基于字符串值的比较，忽略任何其他差异，如大小写和变音符。|'
- en: '| `2` | Secondary level of comparison, which is the comparison based on the
    primary level and if this is equal then compare diacritics (that is, accents).
    |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `2` | 比较的次要级别，基于主要级别的比较，如果相等，则比较变音符（即重音）。|'
- en: '| `3` (default) | Tertiary level of comparison. Same as level *2*, adding case
    and variants. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `3`（默认）|第三级比较。与级别*2*相同，添加大小写和变体。|'
- en: '| `4` | Quaternary level. Limited for specific use cases to consider the punctuation
    when levels 1-3 ignore punctuation, or for processing Japanese text. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `4` | 第四级。仅限于特定用例，考虑标点符号，当级别1-3忽略标点符号时，或用于处理日文文本。|'
- en: '| `5` | Identical level. Limited for specific use cases: a tie breaker. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `5` | 相同级别。仅限于特定用例：决定胜负者。|'
- en: 'Creating the index with `collation` is not enough to get back case-insensitive
    results. We need to specify `collation` in our query, as well:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`collation`创建索引不足以获得不区分大小写的结果。我们需要在查询中指定`collation`，如下所示：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we specify the same level of `collation` in our query as our index, then
    the index will be used. We could specify a different level of `collation`, as
    follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在查询中指定与我们的索引相同级别的`collation`，那么将使用该索引。我们可以按如下方式指定不同级别的`collation`：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, we cannot use the index, as our index has `collation` level 1, and our
    query looks for `collation` level `2`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们无法使用索引，因为我们的索引具有`collation`级别1，而我们的查询寻找`collation`级别`2`。
- en: If we don't use any `collation` in our queries, we will get results defaulting
    to level 3, that is, case-sensitive.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在查询中不使用任何`collation`，我们将得到默认级别为3的结果，即区分大小写。
- en: Indexes in collections that were created using a different `collation` from
    the default will automatically inherit this `collation` level.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与默认不同的`collation`创建的集合中的索引将自动继承此`collation`级别。
- en: 'Suppose that we create a collection with `collation` level 1, as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们创建了一个`collation`级别为1的集合，如下所示：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following index will also have collation `name: 1`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '以下索引也将具有`name: 1`的排序：'
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Default queries to this collection will be collation `strength: 1`, case-sensitive.
    If we want to override this in our queries, we need to specify a different level
    of `collation` in our queries, or ignore the `strength` part altogether. The following
    two queries will return case-insensitive, default `collation` level results in
    our `case_sensitive_books` collection:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '对该集合的默认查询将使用排序`strength: 1`，区分大小写。如果我们想在查询中覆盖这一点，我们需要在查询中指定不同级别的`collation`，或者完全忽略`strength`部分。以下两个查询将返回`case_sensitive_books`集合中不区分大小写的默认`collation`级别结果：'
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Collation is a pretty strong and relatively new concept in MongoDB, so we will
    keep exploring it throughout the different chapters.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 排序在MongoDB中是一个相当强大且相对较新的概念，因此我们将在不同章节中继续探讨它。
- en: Geospatial indexes
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地理空间索引
- en: Geospatial indexes were introduced early on in MongoDB, and the fact that Foursquare
    was one of the earliest customers and success stories for MongoDB (then 10gen
    Inc.) is probably no coincidence. There are three distinct types of geospatial
    indexes that we will explore in this chapter, and they will be covered in the
    following sections.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 地理空间索引在MongoDB早期就被引入，而Foursquare是MongoDB（当时是10gen Inc.）最早的客户和成功案例之一，这可能并非巧合。在本章中，我们将探讨三种不同类型的地理空间索引，并将在以下部分中进行介绍。
- en: 2d geospatial indexes
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2D地理空间索引
- en: A `2d` geospatial index stores geospatial data as points on a two-dimensional
    plane. It is mostly kept for legacy reasons, for coordinate pairs created before
    MongoDB 2.2, and in most cases, it should not be used with the latest versions.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`2d`地理空间索引将地理空间数据存储为二维平面上的点。它主要用于传统原因，用于MongoDB 2.2之前创建的坐标对，并且在大多数情况下，不应该与最新版本一起使用。'
- en: 2dsphere geospatial indexes
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2dsphere地理空间索引
- en: A `2dsphere` geospatial index supports queries calculating geometries in an
    earth-like plane. It is more accurate than the simplistic `2d` index, and can
    support both GeoJSON objects and coordinate pairs as input.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`2dsphere`地理空间索引支持在类似地球的平面上计算几何。它比简单的`2d`索引更精确，并且可以支持GeoJSON对象和坐标对作为输入。'
- en: 'Its current version, since MongoDB 3.2, is version 3\. It is a sparse index
    by default, only indexing documents that have a `2dsphere` field value. Assuming
    that we have a location field in our `books` collection, tracking the home address
    of the main author of each book, we could create an index on this field as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 自MongoDB 3.2以来的当前版本是版本3。默认情况下，它是稀疏索引，只索引具有`2dsphere`字段值的文档。假设我们的`books`集合中有一个位置字段，跟踪每本书的主要作者的家庭地址，我们可以按如下方式在该字段上创建索引：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `location` field needs to be a GeoJSON object, like this one:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`location`字段需要是一个GeoJSON对象，就像这样一个：'
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'A `2dsphere` index can also be a part of a compound index, as the first field
    or otherwise:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`2dsphere`索引也可以作为复合索引的一部分，作为第一个字段或其他字段：'
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: geoHaystack indexes
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: geoHaystack索引
- en: '`geoHaystack` indexes are useful when we need to search for geographical-based
    results in a small area. Like searching for a needle in a haystack, with a `geoHaystack`
    index, we can define buckets of geolocation points and get back all of the results
    that belong in this area.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要在一个小区域内搜索基于地理位置的结果时，`geoHaystack`索引非常有用。就像在干草堆中搜索针一样，使用`geoHaystack`索引，我们可以定义地理位置点的存储桶，并返回属于该区域的所有结果。
- en: 'We will create a `geoHaystack` index, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`geoHaystack`索引，如下所示：
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This will create buckets of documents within `2` units of latitude or longitude
    from each document.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在每个文档周围的纬度或经度`2`单位内创建文档的存储桶。
- en: 'Here, with the preceding example `location`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用前面的`location`示例：
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Based on the `bucketSize: 2`, every document with the `location` `[49.5876..53.5876,
    -2.1643..2.1643]` will belong in the same bucket as our location.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '基于`bucketSize: 2`，每个具有`location` `[49.5876..53.5876, -2.1643..2.1643]`的文档将属于与我们的位置相同的存储桶。'
- en: A document can appear in multiple buckets. If we want to use spherical geometry, `2dsphere`
    is a better solution. `geoHaystack` indexes are sparse, by default.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一个文档可以出现在多个存储桶中。如果我们想使用球面几何，`2dsphere`是一个更好的解决方案。`geoHaystack`索引默认是稀疏的。
- en: If we need to calculate the nearest document to our location and it is outside
    of our `bucketSize` (that is, greater than 2 units of latitude/longitude, in our
    example), queries will be inefficient, and possibly inaccurate. Use a `2dsphere`
    index for such queries.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要计算最接近我们位置的文档，而它超出了我们的`bucketSize`（即，在我们的示例中大于2个纬度/经度单位），查询将是低效的，可能不准确。对于这样的查询，请使用`2dsphere`索引。
- en: Building and managing indexes
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和管理索引
- en: Indexes can be built using the MongoDB shell or any of the available drivers.
    By default, indexes are built in the foreground, blocking all other operations
    in the database. This is faster, but is often undesirable, especially in production
    instances.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 索引可以使用MongoDB shell或任何可用的驱动程序构建。默认情况下，索引是在前台构建的，会阻塞数据库中的所有其他操作。这样更快，但通常是不可取的，特别是在生产实例中。
- en: 'We can also build indexes in the background by adding the `{background: true}`
    parameter in our index commands in the shell. Background indexes will only block
    the current connection/thread. We can open a new connection (that is, using `mongo`
    in the command line) to connect to the same database:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还可以通过在shell中的索引命令中添加`{background: true}`参数来在后台构建索引。后台索引只会阻塞当前连接/线程。我们可以打开一个新连接（即在命令行中使用`mongo`）连接到同一个数据库：'
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Background index building can take significantly more time than foreground index
    building, especially if the indexes can't fit into the available RAM.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 后台索引构建可能比前台索引构建需要更长的时间，特别是如果索引无法适应可用的RAM。
- en: Index early and revisit indexes regularly for consolidation. Queries won't see
    partial index results. Queries will start getting results from an index only after
    it is completely created.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 尽早创建索引，并定期重新审视索引以进行合并。查询不会看到部分索引结果。只有在索引完全创建后，查询才会开始从索引中获取结果。
- en: Do not use the main application code to create indexes, as it can impose unpredictable
    delays. Instead, get a list of indexes from the application, and mark these for
    creation during maintenance windows.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用主要应用程序代码来创建索引，因为这可能会导致不可预测的延迟。相反，从应用程序获取索引列表，并在维护窗口期间标记这些索引进行创建。
- en: Forcing index usage
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制使用索引
- en: 'We can force MongoDB to use an index by applying the `hint()` parameter:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过应用`hint()`参数来强制MongoDB使用索引：
- en: '[PRE44]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output from `createIndex` notifies us that the index was created (`"ok"
    : 1`), no collection was automatically created as a part of index creation (`"createdCollectionAutomatically"
    : false`), the number of indexes before this index creation was `8`, and now there
    are nine indexes for this collection, in total.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`createIndex`的输出通知我们索引已创建（`"ok" : 1`），索引创建过程中没有自动创建集合（`"createdCollectionAutomatically"
    : false`），在此索引创建之前，该集合中的索引数量为`8`，现在总共有九个索引。'
- en: 'Now, if we try to search for a book by `isbn`, we can use the `explain()` command
    to see the `winningPlan` sub-document, where we can find which query plan was
    used:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试通过`isbn`搜索书籍，我们可以使用`explain()`命令来查看`winningPlan`子文档，从中我们可以找到使用的查询计划：
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This means that an index with `isbn` is `1` and `name` is `1` was used instead
    of our newly created index. We can also view our index in the `rejectedPlans`
    sub-document of the output, as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着使用了具有`isbn`为`1`和`name`为`1`的索引，而不是我们新创建的索引。我们还可以在输出的`rejectedPlans`子文档中查看我们的索引，如下所示：
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is, in fact, correct, as MongoDB is trying to reuse an index that is more
    specific than a generic one.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这是正确的，因为MongoDB正在尝试重用比通用索引更具体的索引。
- en: We may not be sure though in cases where our `isbn_1` index is performing better
    than the `isbn_1_name_1` one.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`isbn_1`索引表现比`isbn_1_name_1`更好的情况下，我们可能不确定。
- en: 'We can force MongoDB to use our newly created index, as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以强制MongoDB使用我们新创建的索引，如下所示：
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, the `winningPlan` sub-document contains our index, `isbn_1`, and there
    are no `rejectedPlans` elements. It's an empty array in the result set.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`winningPlan`子文档包含我们的索引`isbn_1`，并且没有`rejectedPlans`元素。结果集中是一个空数组。
- en: We cannot use `hint()` with the special type of text indexes.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在特殊类型的文本索引上使用`hint()`。
- en: Hint and sparse indexes
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提示和稀疏索引
- en: By design, sparse indexes do not include some documents in the index, based
    on the presence/absence of a field. Queries that may include documents that are
    not present in the index will not use a sparse index.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 根据设计，稀疏索引不包括索引中的某些文档，根据字段的存在/缺失。可能包含不在索引中的文档的查询将不使用稀疏索引。
- en: Using `hint()` with a sparse index may result in incorrect counts, since it
    is forcing MongoDB to use an index that may not include all of the results that
    we want.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用稀疏索引的`hint()`可能导致不正确的计数，因为它强制MongoDB使用可能不包含我们想要的所有结果的索引。
- en: Older versions of `2dsphere`, `2d`, `geoHaystack`, and text indexes are sparse,
    by default. `hint()` should be used with caution, and after careful consideration
    of its implications.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版本的`2dsphere`、`2d`、`geoHaystack`和文本索引默认是稀疏的。应谨慎使用`hint()`，并在仔细考虑其影响后使用。
- en: Building indexes on replica sets
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在副本集上构建索引
- en: In replica sets, if we issue a `createIndex()` command, secondaries will begin
    to create the index after the primary server has finished creating it. Similarly,
    in sharded environments, primaries will start to build indexes, and secondaries
    will start after the primary for each shard that is finished.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在副本集中，如果我们发出`createIndex()`命令，主服务器完成创建后，次要服务器将开始创建索引。同样，在分片环境中，主服务器将开始构建索引，而分片的每个次要服务器将在主服务器完成后开始。
- en: 'Recommended approaches to building indexes in replica sets are as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在副本集中构建索引的推荐方法如下：
- en: Stop one secondary from the replica set
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止副本集中的一个次要节点
- en: Restart it as a standalone server in a different port
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同端口上重新启动为独立服务器
- en: Build the index from the shell as a standalone index
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在shell中构建独立索引
- en: Restart the secondary in the replica set
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重启副本集中的次要节点
- en: Allow for the secondary to catch up with the primary
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许次要节点赶上主节点
- en: We need to have a large enough oplog size in the primary to make sure that the
    secondary will be able to catch up once it's reconnected. The oplog size is defined
    in MB in the configuration, and it defines how many operations will be kept in
    the log in the primary server. If the oplog size can only hold up to the last
    100 operations happening in the primary, and 101 or more operations happen, this
    means that the secondary will not be able to sync with the primary. This is a
    consequence of the primary not having enough memory to keep track of its operations
    and inform the secondary of them. Building indexes in replica sets is a manual
    process, involving several steps for each primary and secondary server.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在主服务器中有足够大的oplog大小，以确保辅助服务器在重新连接后能够追赶上来。oplog大小在配置中以MB定义，它定义了主服务器中日志中将保留多少个操作。如果oplog大小只能容纳主服务器中发生的最后100个操作，而发生了101个或更多的操作，这意味着辅助服务器将无法与主服务器同步。这是主服务器没有足够的内存来跟踪其操作并通知辅助服务器的后果。在副本集中构建索引是一个手动过程，涉及每个主服务器和辅助服务器的几个步骤。
- en: 'This approach can be repeated for each secondary server in the replica set.
    Then, for the primary server, we can do either of these things:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以在副本集中的每个辅助服务器上重复。然后，对于主服务器，我们可以执行以下操作之一：
- en: Build the index in the background
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后台构建索引
- en: Step down the primary by using `rs.stepDown()`, and repeat the preceding process
    with the server as a secondary
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`rs.stepDown()`将主服务器降级，然后使用服务器作为辅助服务器重复前面的过程
- en: Using approach number two, when the primary steps down, there will be a brief
    period when our cluster won't be taking any writes. Our application shouldn't
    timeout during this (usually less than) 30-60 second period.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第二种方法时，当主服务器降级时，我们的集群将在一段时间内不接受任何写入。我们的应用程序在此期间不应该超时（通常不到30-60秒）。
- en: Building an index in the background in the primary will build it in the background
    for the secondaries too. This may impact writes in our servers during index creation,
    but on the plus side, it has no manual steps. It is always a good idea to have
    a staging environment that mirrors production, and dry run operations that affect
    the live cluster in staging, in order to avoid surprises.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在主服务器后台构建索引也会在辅助服务器上后台构建。这可能会影响索引创建期间我们服务器的写入，但好处是没有手动步骤。在生产环境中建立一个与生产环境相似的临时环境，并在其中运行影响实时集群的操作，以避免意外。
- en: Managing indexes
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理索引
- en: In this section, you will learn how to give human-friendly names to your indexes,
    as well as some special considerations and limitations that we have to keep in
    mind for indexing.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何为您的索引指定人性化的名称，以及一些特殊的考虑和限制，我们必须牢记索引。
- en: Naming indexes
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名索引
- en: 'By default, index names are assigned by MongoDB automatically, based on the
    fields indexed and the direction of the index (`1`, `-1`). If we want to assign
    our own `name`, we can do so at creation time:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，索引名称是根据字段索引和索引方向（`1`，`-1`）自动分配的。如果我们想在创建时分配自己的`name`，我们可以这样做：
- en: '[PRE48]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now, we have a new index called `international_standard_book_number_index`,
    instead of what MongoDB would have named it (`"isbn_1"`).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个名为`international_standard_book_number_index`的新索引，而不是MongoDB将会命名的(`"isbn_1"`)。
- en: We can view all of the indexes in our `books` collection by using `db.books.getIndexes()`.
    A fully qualified index name has to be less than or equal to 128 characters. That
    also includes `database_name`, `collection_name`, and the dots separating them.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`db.books.getIndexes()`来查看我们的`books`集合中的所有索引。完全限定的索引名称必须少于或等于128个字符。这也包括`database_name`，`collection_name`和它们之间的点。
- en: Special considerations
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊考虑
- en: 'The following are a few limitations to keep in mind concerning indexing:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于索引的限制需要牢记：
- en: Index entries have to be less than 1,024 bytes. This is mostly an internal consideration,
    but we can keep it in mind if we run into issues with indexing.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引条目必须少于1,024字节。这主要是一个内部考虑，但如果我们在索引方面遇到问题，我们可以牢记这一点。
- en: A collection can have up to 64 indexes.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个集合最多可以有64个索引。
- en: A compound index can have up to 31 fields.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合索引最多可以有31个字段。
- en: Special indexes cannot be combined in queries. This includes special query operators
    that have to use special indexes, such as `$text` for text indexes and `$near`
    for geospatial indexes. This is because MongoDB can use multiple indexes to fulfill
    a query, but not in all cases. There will be more about this issue in the *Index
    intersection* section.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊索引不能在查询中组合使用。这包括必须使用特殊索引的特殊查询操作符，例如文本索引的`$text`和地理空间索引的`$near`。这是因为MongoDB可以使用多个索引来满足查询，但并非在所有情况下都可以。关于这个问题将在*索引交集*部分有更多内容。
- en: Multikey and geospatial indexes cannot cover a query. This means that index
    data alone will not be enough to fulfill the query, and the underlying documents
    will need to be processed by MongoDB to get back the complete set of results.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多键和地理空间索引无法覆盖查询。这意味着仅仅使用索引数据将不足以满足查询，MongoDB需要处理底层文档才能获取完整的结果集。
- en: Indexes have a unique constraint on fields. We cannot create multiple indexes
    on the same fields, differing only in options. This is a limitation for sparse
    and partial indexes, as we cannot create multiple variations of these indexes
    that differ only in the filtering query.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引对字段有唯一约束。我们不能在相同的字段上创建多个索引，只是选项不同。这是稀疏和部分索引的限制，因为我们不能创建多个这些索引的变体，这些变体只在过滤查询上有所不同。
- en: Using indexes efficiently
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效使用索引
- en: Creating indexes is a decision that should not be taken lightly. As easy as
    it is to create indexes via the shell, it can create problems down the line if
    we end up with too many, or inadequately efficient, indexes. In this section,
    you will learn how to measure the performance of existing indexes, some tips for
    improving performance, and how we can consolidate the number of indexes so that
    we have better-performing indexes.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 创建索引是一个不应轻率对待的决定。尽管通过shell创建索引很容易，但如果我们最终拥有太多或效率不高的索引，它可能会在后续出现问题。在本节中，您将学习如何测量现有索引的性能，一些改进性能的技巧，以及如何合并索引数量，以便拥有性能更好的索引。
- en: Measuring performance
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量性能
- en: Learning how to use the `explain()` command will help you in both optimizing
    and understanding the performance of an index. The `explain()` command, when used
    in conjunction with a query, will return the query plan that MongoDB would use
    for this query, instead of the actual results.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何使用`explain()`命令将有助于您优化和理解索引的性能。当与查询一起使用时，`explain()`命令将返回MongoDB为此查询使用的查询计划，而不是实际结果。
- en: 'It is invoked by chaining it at the end of our query, as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在查询末尾链接它来调用它，如下所示：
- en: '[PRE49]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'It can take three options: `queryPlanner` (the default), `executionStats`,
    and `allPlansExecution`.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以有三个选项：`queryPlanner`（默认值），`executionStats`和`allPlansExecution`。
- en: 'Let''s use the most verbose output, `allPlansExecution`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用最详细的输出，`allPlansExecution`：
- en: '[PRE50]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we can get information for both the winning query plan and some partial
    information about query plans that were considered during the planning phase,
    but were rejected because the query planner considered them slower. The `explain()`
    command returns a rather verbose output anyway, allowing for deep insights into
    how the query plan works to return our results.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以获取获胜查询计划的信息，以及在规划阶段考虑过但被拒绝的查询计划的部分信息，因为查询规划程序认为它们更慢。`explain()`命令无论如何都会返回相当冗长的输出，允许深入了解查询计划如何工作以返回我们的结果。
- en: At first glance, we need to focus on whether the indexes that should be used
    are being used, and if the number of scanned documents matches the number of returned
    documents as much as possible.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，我们需要关注应该使用的索引是否被使用，以及扫描的文档数量是否尽可能与返回的文档数量匹配。
- en: For the first one, we can inspect the `stage` field and look for `IXSCAN`, which
    means that an index was used. Then, in the sibling `indexName` field, we should
    see the name of our expected index.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个，我们可以检查`stage`字段并查找`IXSCAN`，这意味着使用了索引。然后，在兄弟`indexName`字段中，我们应该看到我们期望的索引名称。
- en: For the second one, we need to compare `keysExamined` with the `nReturned` fields.
    We ideally want our indexes to be as selective as possible with regard to our
    queries, meaning that to return 100 documents, these would be the 100 documents
    that our index examines.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个，我们需要比较`keysExamined`和`nReturned`字段。理想情况下，我们希望我们的索引在查询方面尽可能具有选择性，这意味着为了返回100个文档，这些将是我们的索引检查的100个文档。
- en: Of course, this is a trade-off as indexes increase in number and size in our
    collection. We can have a limited number of indexes per collection, and we definitely
    have a limited amount of RAM to fit these indexes, so we must balance the trade-off
    between having the best available indexes, and these indexes not fitting into
    our memory and getting slowed down.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个权衡，因为索引在我们的集合中数量和大小增加。我们每个集合可以有限数量的索引，而且我们的RAM可以容纳这些索引的数量是有限的，因此我们必须在拥有最佳可用索引和这些索引不适合我们的内存并变慢之间取得平衡。
- en: Improving performance
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高性能
- en: Once we get comfortable with measuring the performance of the most common and
    important queries for our users, we can start to try to improve them.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始熟悉测量用户最常见和重要查询的性能，我们就可以开始尝试改进它们。
- en: The general idea is that we need indexes when we expect (or already have) repeatable
    queries that are starting to run slowly. Indexes do not come for free, as they
    impose a performance penalty in creation and maintenance, but they are more than
    worth it for frequent queries, and can reduce the lock percentage in our database,
    if designed correctly.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 总体思路是，当我们期望（或已经有）重复查询开始运行缓慢时，我们需要索引。索引并非免费，因为它们在创建和维护时会带来性能损失，但对于频繁查询来说，它们是非常值得的，并且可以减少数据库中的锁定百分比，如果设计正确的话。
- en: 'Recapping on our suggestions from the previous section, we want our indexes
    to do the following:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾上一节的建议，我们希望我们的索引能够做到以下几点：
- en: Fit in the RAM
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适应RAM
- en: Ensure selectivity
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保选择性
- en: Be used to sort our query results
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于对查询结果进行排序
- en: Be used in our most common and important queries
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于我们最常见和重要的查询
- en: Fitting in the RAM can be ensured by using `getIndexes()` in our collections
    and making sure that we are not creating large indexes by inspecting the system
    level available RAM and if swap is being used.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的集合中使用`getIndexes()`并确保我们不会通过检查系统级可用RAM和是否使用交换来创建大型索引来确保适应RAM。
- en: Selectivity, as mentioned previously, is ensured by comparing `nReturned` with
    `keysExamined` in each `IXSCAN` phase of our queries. We want these two numbers
    to be as close as possible.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，通过比较每个查询的`IXSCAN`阶段中的`nReturned`和`keysExamined`来确保选择性。我们希望这两个数字尽可能接近。
- en: Ensuring that our indexes are used to sort our query results is a combination
    of using compound indexes (which will be used as a whole, and also for any prefix-based
    query) and declaring the direction of our indexes to be in accordance with our
    most common queries.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们的索引用于对查询结果进行排序是使用复合索引（将作为整体使用，也用于任何基于前缀的查询）并声明我们的索引方向与我们最常见的查询一致的组合。
- en: Finally, aligning indexes with our query is a matter of application usage patterns,
    which can uncover that queries are used most of the time, and then by using `explain()`
    on these queries to identify the query plan that is being used each time.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将索引与我们的查询对齐是应用使用模式的问题，这可以揭示大部分时间使用的查询，然后通过在这些查询上使用`explain()`来识别每次使用的查询计划。
- en: Index intersection
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引交集
- en: Index intersection refers to the concept of using more than one index to fulfill
    a query. This was added fairly recently, and is not perfect yet; however we can
    exploit it to consolidate our indexes.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 索引交集是指使用多个索引来满足查询的概念。这是最近添加的功能，还不完美；然而我们可以利用它来 consolodate 我们的索引。
- en: We can verify whether an index intersection happened in a query by using `explain()`
    on the query and witnessing an `AND_SORTED` or `AND_HASH` stage in the executed
    query plan.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在查询上使用`explain()`并在执行的查询计划中观察`AND_SORTED`或`AND_HASH`阶段来验证查询中是否发生了索引交集。
- en: Index intersection can happen when we use `OR` (`$or`) queries, by using a different
    index for each `OR` clause. Index intersection can happen when we use `AND` queries,
    and we have either complete indexes for each `AND` clause or index prefixes for
    some (or all) of the clauses.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 索引交集可能发生在我们使用`OR`(`$or`)查询时，通过为每个`OR`子句使用不同的索引。索引交集可能发生在我们使用`AND`查询时，我们对每个`AND`子句都有完整的索引或者对一些（或全部）子句有索引前缀。
- en: 'For example, consider a query on our `books` collection, as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑对我们的`books`集合的查询如下：
- en: '[PRE51]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, with two indexes (one on `isbn` and the other on `price`), MongoDB can
    use each index to get the related results, and then intersect on the index results
    to get the result set.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用两个索引（一个在`isbn`上，另一个在`price`上），MongoDB可以使用每个索引来获取相关结果，然后在索引结果上进行交集运算以获取结果集。
- en: With compound indexes, as you learned previously in this chapter, we can use
    index prefixing to support queries that contain the first *1…n-1* fields of an
    *n *field compound index.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用复合索引，正如您在本章中之前学到的，我们可以使用索引前缀来支持包含复合索引的前 *1…n-1* 个字段的查询。
- en: What we cannot support with compound indexes are queries that are looking for
    fields in the compound index, missing one or more of the previously defined fields.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法通过复合索引支持寻找复合索引中字段的查询，其中一个或多个之前定义的字段缺失。
- en: The order matters in compound indexes.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 复合索引中的顺序很重要。
- en: To satisfy these queries, we can create indexes on the individual fields, which
    will then use index intersection and fulfill our needs. The down side to this
    approach is that as the number of fields (*n*) increases, the number of indexes
    that we have to create grows exponentially, thus increasing our need for storage
    and memory.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这些查询，我们可以在各个字段上创建索引，然后使用索引交集来满足我们的需求。这种方法的缺点是，随着字段数（*n*）的增加，我们需要创建的索引数量呈指数增长，因此增加了我们对存储和内存的需求。
- en: Index intersection will not work with `sort()`. We can't use one index for querying
    and a different index for applying `sort()` to our results.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 索引交集不适用于`sort()`。我们不能使用一个索引来查询，然后使用不同的索引对结果应用`sort()`。
- en: However, if we have an index that can fulfill a part for the whole of our query
    and the `sort()` field, then this index will be used.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们有一个索引可以满足查询的一部分和`sort()`字段，那么这个索引将被使用。
- en: Further reading
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can refer to the following links for further references:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下链接以获取更多信息：
- en: '[http://bigocheatsheet.com/](http://bigocheatsheet.com/)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://bigocheatsheet.com/](http://bigocheatsheet.com/)'
- en: '[https://commons.wikimedia.org/](https://commons.wikimedia.org/)'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://commons.wikimedia.org/](https://commons.wikimedia.org/)'
- en: '[https://docs.mongodb.com/manual/core/index-intersection/](https://docs.mongodb.com/manual/core/index-intersection/)'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.mongodb.com/manual/core/index-intersection/](https://docs.mongodb.com/manual/core/index-intersection/)'
- en: Summary
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about the foundations of indexing and index internals.
    We then explored how to use the different index types available in MongoDB, such
    as single field, compound, and multikey, as well as some special types, such as
    text, hashed, TTL, partial, parse, unique, case-insensitive, and geospatial.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了索引和索引内部的基础知识。然后我们探讨了如何使用MongoDB中可用的不同索引类型，如单字段、复合和多键索引，以及一些特殊类型，如文本、哈希、TTL、部分、解析、唯一、不区分大小写和地理空间。
- en: In the next part of the chapter, you learned how to build and manage indexes
    using the shell, which is a basic part of administration and database management,
    even for NoSQL databases. Finally, we discussed how to improve our indexes, at
    a high level, and also how we can use index intersection in practice, in order
    to consolidate the number of indexes.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一部分，您将学习如何使用shell构建和管理索引，这是管理和数据库管理的基本部分，即使对于NoSQL数据库也是如此。最后，我们讨论了如何在高层次上改进我们的索引，以及我们如何在实践中使用索引交集，以便
    consolodate 索引数量。
- en: In the next chapter, we will discuss how we can monitor our MongoDB cluster
    and keep consistent backups. You will also learn how to handle security in MongoDB.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何监视我们的MongoDB集群并保持一致的备份。您还将学习如何处理MongoDB中的安全性。
