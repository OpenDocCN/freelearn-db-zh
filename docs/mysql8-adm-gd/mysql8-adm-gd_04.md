# 第四章：MySQL 8 数据类型

在上一章中，我们学习了如何使用 MySQL 8 命令行程序和实用程序对 MySQL 8 数据库执行各种操作。拥有对命令行工具的掌握总是很好的。它提供了在非 GUI 环境中工作的灵活性。本章的重点是数据类型。了解编程语言支持的数据类型或存储引擎可以存储的数据类型是不是很有趣？这是任何编程语言或数据库的基本特性。同时，它也是最被忽视的话题。大多数程序员没有足够的时间来评估代码中使用的`变量`的存储需求。实际上，了解数据库支持的基本和自定义数据类型非常重要，这也是本章存在的原因。

以下是本章要涵盖的主题列表：

+   MySQL 8 数据类型概述

+   数值数据类型

+   日期和时间数据类型

+   字符串数据类型

+   JSON 数据类型

+   数据类型的存储要求

+   为列选择正确的数据类型

# MySQL 8 数据类型概述

MySQL 支持所有标准 SQL 数据类型。这些数据类型分为几个类别，如数值类型、字符串类型、日期和时间类型以及 JSON 数据类型。当我们为列分配数据类型时，必须遵循某些约定。这些约定对于 MySQL 允许在列中存储值是必要的：

+   **M**表示整数类型的最大显示宽度。对于浮点和定点类型，它是可以存储的总位数。对于字符串类型，它是最大长度。允许的最大值取决于数据类型。

+   **D** 适用于浮点和定点类型。它表示小数点后的位数。允许的最大值为 30，但必须小于或等于 M-2。

+   **fsp** 适用于日期和时间类型。它表示分数秒精度，即小数点后秒的小数部分的位数。

本概述简要介绍了每种数据类型的特性，详细描述将在后续主题中涵盖。

# 数值数据类型

MySQL 8 数值数据类型包括整数或精确数据类型、十进制或近似数据类型和位数据类型。

默认情况下，`REAL`数据类型的值存储为`DOUBLE`。如果我们在 MySQL 上设置了`REAL_AS_FLOAT`标志，`REAL`数据类型的值将存储为`FLOAT`。与`DOUBLE`相比，`FLOAT`占用的空间更小。

# 整数类型

MySQL 支持所有标准 SQL 整数类型。

以下是描述每种整数类型所需存储和范围的表。除了标准整数数据类型外，MySQL 还支持`TINYINT`、`MEDIUMINT`和`BIGINT`：

| **类型** | **存储（字节）** | **最小值** | **最大值** |
| --- | --- | --- | --- |
|  |  | **有符号/无符号** | **有符号/无符号** |
| `TINYINT` | 1 | -128 | 127 |
|  |  | 0 | 255 |
| `SMALLINT` | 2 | -32768 | 32767 |
|  |  | 0 | 65535 |
| `MEDIUMINT` | 3 | -8388608 | 8388607 |
|  |  | 0 | 16777215 |
| `INT` | 4 | -2147483648 | 2147483647 |
|  |  | 0 | 4294967295 |
| `BIGINT` | 8 | -9223372036854775808 | 9223372036854775807 |
|  |  | 0 | 18446744073709551615 |

参考：[`dev.mysql.com/doc/refman/8.0/en/integer-types.html`](https://dev.mysql.com/doc/refman/8.0/en/integer-types.html)

有符号数的范围包括负数和正数，而无符号数的范围仅包括正数。

以下是无符号整数列的列声明：

```go
CREATE TABLE employees
(salary INTEGER(5) UNSIGNED);
```

`INT`和`INTEGER`可以互换使用。但是考虑一下，如果我们声明一个列：

```go
CREATE TABLE employees
(id INT(255));
```

`INTEGER`列可以存储的最大值要么是 2147483647（对于有符号的`INTEGER`），要么是 4294967295（对于无符号的`INTEGER`）。这里的`255`定义了数字的可见长度。一方面，显示一个 255 位长的数字是不切实际的。另一方面，`INTEGER`支持最大值为 10 位数。因此，在前面的情况下，它将被转换为`INT(11)`。现在，这又引发了另一个问题：如果最大整数数字的位数为 10，那么为什么应该将其转换为`INT(11)`而不是`INT(10)`？原因是保留了一位数字用于存储符号。

`ZEROFILL`是一个属性，它表示如果数字值的长度小于列的长度，那么数字值应该以零填充。`CREATE`语句演示了声明带有`ZEROFILL`属性的列的方法。以下是一个例子：

```go
CREATE TABLE documents
(document_no INT(5) ZEROFILL);
```

我们指定要存储的值为`111`；如果我们提供了`ZEROFILL`选项，它将被存储为`00111`。

# 固定点类型

固定点类型表示小数点或基数点后具有固定位数的数字。MySQL 有`DECIMAL`和`NUMERIC`作为固定点或精确值数据类型。这些值以二进制格式存储。固定点数据类型在存储货币值进行乘法和除法运算时特别有用。固定点数据类型的值是由特定因子缩放的整数。例如，值 1.11 可以以`111`的形式表示为固定点，缩放因子为 1/100。同样，1,110,000 可以以`1110`的形式表示，缩放因子为 1000。

以下代码块演示了`DECIMAL`数据类型的声明：

```go
CREATE TABLE taxes
(tax_rate DECIMAL(3, 2));
```

在前面的例子中，`3`是精度，`2`是标度。一个例子值可以是 4.65，其中`4`是精度，`65`是标度。

+   **精度**：表示存储值的有效数字位数

+   **标度**：表示小数点后的数字位数

精度和标度定义了可以存储在列中的值的范围。因此，在前面的列声明中，`tax_rate`可以存储在-9.99 和 9.99 之间的值。

标准 SQL 中定义`DECIMAL`类型的语法如下：

```go
DECIMAL(M)
```

在 MySQL 中，这相当于：

```go
DECIMAL(M, 0)
```

在 MySQL 中，声明带有`DECIMAL`的列等同于`DECIMAL(M, 0)`。

在 MySQL 中，如果没有提供`M`，则`10`是`M`的默认值。

`DECIMAL`类型支持的最大数字位数为 65，包括精度和标度。我们可以通过精度和标度限制可以输入列的值的数字位数。如果用户输入的值的数字位数大于标度允许的数字位数，那么该值将被截断以匹配允许的标度。

`DECIMAL`通常被认为是`DOUBLE`或`FLOAT`的替代品。如前所述，`DECIMAL`数字是数学中`REAL`数字的精确表示。`DECIMAL`数据类型唯一的问题是，即使对于小数字，它也占用了更多的空间。例如，要存储值 0.000003，列声明应该将数据类型定义为`DECIMAL(7, 6)`。

如果标度为`0`，则列值没有小数点或分数值。

# 浮点类型

浮点数在计算中表示实数。实数对于测量连续值（如重量、高度或速度）非常有用。

MySQL 有两种用于存储近似值的浮点数据类型：`FLOAT`和`DOUBLE`。

对于浮点数，精度是一个重要因素。精度定义了准确度的度量。MySQL 支持单精度和双精度浮点数。使用`FLOAT`数据类型存储单精度浮点数需要四个字节，而使用`DOUBLE`数据类型存储双精度浮点数需要八个字节。

在 MySQL 中，`REAL`是`DOUBLE PRECISION`的同义词。如前所述，如果启用了`REAL_AS_FLOAT`，则使用`REAL`数据类型定义的列将类似于`FLOAT`。

前面的描述将`FLOAT`或`DOUBLE`描述为类似于`DECIMAL`。不，它不是。它们之间有很大的区别。如前所述，固定点数据类型如`DECIMAL`或`NUMERIC`可以存储精确值，直到小数点后的最大数字位数，而浮点数据类型如`FLOAT`或`DOUBLE`存储近似值。存储的值足够详细，但并非完全准确。仍然存在一些小的不准确性。

让我们通过以下代码示例来理解这一点：

```go
mysql> CREATE TABLE typed_numbers(id TINYINT, float_values FLOAT, decimal_values DECIMAL(3, 2));

mysql> INSERT INTO typed_numbers VALUES(1, 1.1, 1.1), (2, 1.1, 1.1), (3, 1.1, 1.1);

mysql> SELECT * FROM typed_numbers;
+------+--------------+------------------+
| id   | float_values | decimal_values   |
+------+--------------+------------------+
|   1  |          1.1 |             1.10 |
|   2  |          1.1 |             1.10 |
|   3  |          1.1 |             1.10 |
+------+--------------+------------------+
mysql> SELECT SUM(float_values), SUM(decimal_values) FROM typed_numbers;
+--------------------+---------------------+
| SUM(float_values)  | SUM(decimal_values) |
+--------------------+---------------------+
| 3.3000000715255737 |                3.30 |
+--------------------+---------------------+
```

在前面的例子中：

1.  我们创建了一个包含`FLOAT`和`DECIMAL`类型列的表。

1.  我们在两个列中插入了相同的值，分别命名为`float_values`和`decimal_values`。

1.  我们执行了一个`select`查询来获取存储值的总和。

尽管值相同，输出却不同。`decimal_values`的总和看起来比`float_values`的更精确。`float_values`的总和看起来不够精确。这是因为 MySQL 引擎对浮点数据类型执行的内部舍入，导致存储的值是近似值。

标准 SQL 允许在定义`FLOAT`列时指定精度。精度是在关键字`FLOAT`后的括号内指定的位数。MySQL 也支持为`FLOAT`或`DOUBLE`指定精度值，但精度用于确定大小：

+   从 0 到 23 的精度会导致 4 字节单精度`FLOAT`列

+   从 24 到 53 的精度会导致 8 字节双精度`DOUBLE`列

以下是`FLOAT`列声明属性的示例：

```go
FLOAT(M, D) 
where,
M - number of digits in total
D - number of digits may be after the decimal point
```

因此，定义为以下内容的列将存储值，例如 99.99：

```go
FLOAT(4, 2)
```

在存储浮点值时，MySQL 执行舍入。因此，插入为 99.09 的值到`FLOAT(4, 2)`列可能会以 99.01 的近似结果存储。

尽管浮点列定义支持指定精度，但建议使用没有精度或数字位数的`FLOAT`或`DOUBLE PRECISION`，以便充分利用最大的灵活性和可移植性。

# 浮点值的问题

如前所述，浮点数据类型存储近似的实数。尝试存储精确值并在比较操作中考虑精确值可能会导致各种问题。此外，浮点值以平台和实现相关的方式进行解释。例如，不同的 CPU 或操作系统可能以不同的方式评估浮点数。这基本上意味着，打算存储在浮点数据类型列中的值可能与实际存储或内部表示的值不同。

当我们在比较中使用浮点数时，前面的观点变得至关重要。考虑以下例子：

```go
mysql> CREATE TABLE temp(id INT, col1 DOUBLE, col2 DOUBLE);

mysql> INSERT INTO temp VALUES (1, 5.30, 2.30), (1, -3.00, 0.00),
 (2, 0.10, -10.00), (2, -15.20, 4.00), (2, 0.00, -7.10),
 (3, 0.00, 2.30), (3, 0.00, 0.00);

mysql> SELECT id, SUM(col1) as v1, SUM(col2) as v2 FROM temp
 GROUP BY id HAVING v1 <> v2;
+------+--------+--------+
|  id  |   v1   |   v2   |
+------+--------+--------+
|    1 |    2.3 |    2.3 |
|    2 |  -15.1 |  -13.1 |
|    3 |    0.0 |    2.3 |
+------+--------+--------+
```

在前面的例子中，输出的前两行似乎有相似的数字。在浮点类型的情况下可能不是这样。如果我们想要确保在前面的情况下，类似的值被认为是相似的，我们必须根据精度比较差异。例如，在前面的情况下，如果我们修改`HAVING`子句以检查条件`ABS(v1 - v2) > 0.1`，它将返回预期的输出。

由于浮点数的解释取决于平台，如果我们尝试插入超出浮点数据类型支持的值范围的值，可能会插入+- inf 或+- 0。

# 位值类型

您是否曾经遇到过存储数字的二进制表示的要求？您能想到这样的用例吗？这样的用例之一是存储一年中每周的工作日信息。我们稍后将在本节中介绍这个例子。

`BIT`数据类型用于存储二进制位或位值组。它也是存储布尔值、是/否或`0/1`值的选项之一。

`BIT`类型的列可以定义为：

```go
column_name BIT
or
column_name BIT(m)
where m = number of bits to be stored
```

对于`BIT`数据类型，`m`可以从`1`变化到`64`。提供`m`是可选的。`m`的默认值为`1`。

以下是定义`BIT`列的示例：

```go
CREATE TABLE working_days (
year INT,
week INT,
days BIT(7),
PRIMARY KEY (year, week));
```

在`BIT`数据类型列声明之后，接下来是在列中存储位值。位值是零（0）和一（1）的组合。使用`b'value'`表示法来指定位值。

以下是在`BIT`列中存储 11 和 55 的示例：

```go
CREATE TABLE bit_values (val BIT(7));

INSERT INTO bit_values VALUES(b'1011');
INSERT INTO bit_values VALUES(b'110111');
```

如果存储在`BIT`列中的值少于列定义中指定的位数(`m`)，会发生什么？MySQL 将在数字左侧用 0 填充该值。因此，对于前面的示例，存储的值将分别为 0001011 和 0110111。

我们如何定义一个`BIT`列来存储`boolean_values`？以下代码块显示了这一点：

```go
CREATE TABLE boolean_values (value BIT(1));
or
CREATE TABLE boolean_values (value BIT);

INSERT INTO boolean_values VALUES(b'0');
INSERT INTO boolean_values VALUES(b'1');
```

# 位值字面值

要在表列中存储位值，我们必须了解位字面值。如前所述，位字面值可以使用`b'val'`表示法编写。还有另一种表示法，即`0bval`表示法。

关于`b'val'`或`0bval`表示法的一个重要说明是，前导`b`的大小写不重要。我们可以指定`b`或`B`。前导的`0b`是大小写敏感的，不能用`0B`替换。

以下是合法和非法的位值字面值列表。

合法的位值字面值：

+   `b'10'`

+   `B'11'`

+   `0b10`

非法的位值字面值：

+   `b'3'`（`1`和`0`是唯一的二进制数字）

+   `0B01`（`0B`无效；应为`0b`）

作为默认值，位字面值是一个二进制字符串。我们可以通过查询来确认这一点，如下面的代码块所示：

```go
mysql> SELECT b'1010110', CHARSET(b'1010110');
+--------------+----------------------+
| b'1010110'  | CHARSET(b'1010110') |
+--------------+----------------------+
|    V         |     binary           |
+--------------+----------------------+

mysql> SELECT 0b1100100, CHARSET(0b1100100);
+--------------+----------------------+
|  0b1100100   |  CHARSET(0b1100100)  |
+--------------+----------------------+
|    d         |     binary           |
+--------------+----------------------+
```

# BIT 的实际用途

让我们继续以一年中每周的工作日为例。请参考之前提供的`working_days`表模式。

我们如何指定`2017`年第`4`周的星期一和星期五为非工作日？以下是此操作的`INSERT`查询：

```go
INSERT INTO working_days VALUES(2017, 4, 0111011);
```

如果我们使用`SELECT`查询获取`working_days`记录，输出如下：

```go
mysql> SELECT year, week, days FROM working_days;
+--------+---------+--------+
|  year  |   week  |  days  |
+--------+---------+--------+
|   2017 |       4 |     59 |
+--------+---------+--------+
```

在前面的输出中，尽管日期是位数据类型，但显示的是整数值。我们如何在输出中显示位值呢？

答案是`BIN()` MySQL 函数。该函数将整数值转换为其二进制表示：

```go
mysql> SELECT year, week, BIN(days) FROM working_days;
+--------+---------+------------+
|  year  |   week  |    days    |
+--------+---------+------------+
|   2017 |       4 |    111011  |
+--------+---------+------------+
```

如您所见，在输出中，日期的位值中的前导零被移除了。为了在输出中实现表示，除了`BIN`函数之外，我们还可以使用`LPAD` MySQL 函数：

```go
mysql> SELECT year, week, LPAD(BIN(days), 7, '0') FROM working_days;
+--------+---------+------------+
|  year  |   week  |    days    |
+--------+---------+------------+
|   2017 |       4 |    0111011 |
+--------+---------+------------+
```

# 类型属性

如前所示，在定义整数列时，我们还可以指定一个可选的显示宽度属性。例如，`INT(5)`表示具有`5`位数字的整数。当此列在`SELECT`查询中使用时，输出将显示左填充空格的数字。因此，如果存储在`INT(5)`列中的值为`123`，则将显示为`__123`。`_`在实际输出中将是一个空格。

然而，显示宽度不限制可以存储在`INT(5)`列中的值的范围。那么问题来了：如果我们存储的值大于指定的显示宽度，会怎么样？显示宽度不会阻止比列的显示宽度更宽的值正确显示。因此，比列显示宽度更宽的值将以全宽显示，使用的数字数量超过了显示宽度指定的数量。

如前所述，MySQL 列定义提供了一个名为`ZEROFILL`的可选属性。当指定了这个可选属性时，它会用零替换左填充的空格。例如，对于以下定义的列，检索到的值为 00082：

```go
INT(5) ZEROFILL
```

这个可选属性在需要正确格式化数字的情况下非常有用。

当列值用于表达式或`UNION`查询时，`ZEROFILL`属性将被忽略。

当在查询中使用复杂的连接来存储中间结果时，MySQL 会创建临时表。在这种情况下，如果我们指定了具有显示宽度的列，可能会遇到问题。在这些情况下，MySQL 认为数据值适合于显示宽度。

另一个重要的属性是`UNSIGNED`。`UNSIGNED`属性只允许在列中存储非负值。当我们需要支持相同数据类型的更大范围的值时，这也是非常有用的。

`UNSIGNED`也支持浮点类型和定点类型。

如果为列指定了`ZEROFILL`属性，`UNSIGNED`会自动添加到列中。

整数和浮点列的另一个重要属性是`AUTO_INCREMENT`。当我们在具有`AUTO_INCREMENT`属性的列中插入一个`NULL`值时，MySQL 会存储`value+1`而不是`NULL`。值为 0 将被视为`NULL`值，除非启用了`NO_AUTO_VALUE_ON_ZERO`模式。在这里，值是存储在列中的最大值。非常重要的是，列被定义为`NOT NULL`。否则，`NULL`值将被存储为`NULL`，即使提供了`AUTO_INCREMENT`属性。

# 溢出处理

当在 MySQL 中的数字类型列中存储超出范围的值时，存储的值取决于 MySQL 模式：

+   如果启用了`strict`模式，MySQL 将不接受该值并抛出错误。`insert`操作失败。

+   如果启用了`restrictive`模式，MySQL 会将值裁剪为适当的值，并将其存储在列中。

# 日期和时间数据类型

`DATE`、`TIME`、`DATETIME`、`TIMESTAMP`和`YEAR`构成了用于存储时间值的日期和时间数据类型组。每种类型都有一定范围的允许值。除了允许的值之外，还可以使用特殊的`零`值来指定 MySQL 无法表示的无效值。零值可以是 00-00-0000。MySQL 允许将此值存储在`date`列中。这有时比存储`NULL`值更方便。

在处理日期和时间类型时，我们必须注意以下一般考虑事项。

MySQL 对于日期或时间类型的存储和检索操作在格式的上下文中是不同的。基本上，对于存储在表中的日期或时间类型值，MySQL 以标准输出格式检索值。在输入日期或时间类型值的情况下，MySQL 尝试对提供的输入值应用不同的格式。因此，预期提供的值是有效的，否则如果使用不受支持的格式中的值，则可能会出现意外结果。

尽管 MySQL 可以解释多种不同格式的输入值，但日期值的部分必须以年-月-日的格式提供。例如，2017-10-22 或 16-02-14。

提供两位数年份会导致 MySQL 解释年份时出现歧义，因为世纪未知。以下是必须遵循的规则，使用这些规则，MySQL 解释两位数年份值：

+   70-99 年之间的年份值会被转换为 1970-1999

+   00-69 年之间的年份值会被转换为 2000-2069

可以按照一定的规则将一个时间类型的数值转换为另一个时间类型。我们将在本章后面讨论这些规则。

如果日期或时间数值在数值上下文中使用，MySQL 会自动将该数值转换为数字。

我们有一个有趣的用例。我们想要开发一个审计日志功能，用于存储用户输入的每个数值。假设在其中一个日期字段中，用户输入了一个无效的日期，2017-02-31。这会被存储在审计日志表中吗？当然不会。那么我们该如何完成这个功能呢？MySQL 有一个 `ALLOW_INVALID_DATES` 模式。如果启用了这个模式，它将允许存储无效的日期。启用了这个模式后，MySQL 会验证月份是否在 1-12 的范围内，日期是否在 1-31 的范围内。

由于 ODBC 无法处理日期或时间的零值，通过 Connector/ODBC 使用这些数值时会被转换为 `NULL`。

下表显示了不同数据类型的零值：

| **数据类型** | **零值** |
| --- | --- |
| `DATE` | 0000-00-00 |
| `TIME` | 00:00:00 |
| `DATETIME` | 0000-00-00 00:00:00 |
| `TIMESTAMP` | 0000-00-00 00:00:00 |
| `YEAR` | 0000 |

参考：[`dev.mysql.com/doc/refman/8.0/en/date-and-time-types.html`](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-types.html)

上表显示了不同时间数据类型的零值。这些是特殊值，因为它们被 MySQL 允许，并且在某些情况下非常有用。我们还可以使用 `'0'` 或 `0` 来指定零值。MySQL 有一个有趣的模式配置：`NO_ZERO_DATE`。如果启用了这个配置，当时间类型的数值为零时，MySQL 会显示警告。

# DATE、DATETIME 和 TIMESTAMP 类型

本节描述了最常用的 MySQL 日期和时间数据类型：`DATE`、`DATETIME` 和 `TIMESTAMP`。本节解释了这些数据类型之间的相似之处和不同之处。

`DATE` 数据类型适用于我们希望存储的数值具有日期部分，但缺少时间部分的情况。标准的 MySQL 日期格式是 YYYY-MM-DD。日期数值在未应用 `DATE` 函数的情况下以标准格式检索和显示。MySQL 支持的数值范围是 1000-01-01 到 9999-12-31。这里的“支持”意味着这些数值可能有效，但不能保证。`DATETIME` 数据类型也是如此。

`DATETIME` 数据类型适用于包含日期和时间部分的数值。标准的 MySQL `DATETIME` 格式是 YYYY-MM-DD HH:MM:SS。支持的数值范围是 1000-01-01 00:00:00 到 9999-12-31 23:59:59。

与 `DATETIME` 类似，`TIMESTAMP` 数据类型也适用于包含日期和时间部分的数值。然而，`TIMESTAMP` 数据类型支持的数值范围是从 1970-01-01 00:00:01 UTC 到 2038-01-19 03:14:07 UTC。

尽管它们看起来相似，`DATETIME` 和 `TIMESTAMP` 数据类型有着显著的不同：

+   `TIMESTAMP` 数据类型需要 4 个字节来存储日期和时间数值。`DATETIME` 数据类型需要 5 个字节来存储日期和时间数值。

+   `TIMESTAMP` 可以存储值直到 2038-01-19 03:14:07 UTC。如果希望存储超过 2038 年的值，则应使用 `DATETIME` 数据类型。

+   `TIMESTAMP` 在存储数值时将 UTC 视为时区，`DATETIME` 则在存储数值时不考虑时区。

让我们通过一个例子来理解 `time_zone` 上下文中 `DATETIME` 和 `TIMESTAMP` 之间的差异。

假设初始的 `time_zone` 值设置为 `+00:00`：

```go
SET time_zone = '+00:00';
```

让我们创建一个名为`datetime_temp`的表。该表有两列；一列是`DATETIME`，另一列是`TIMESTAMP`类型。我们将在两列中存储相同的日期和时间值。借助`SELECT`查询，我们将尝试了解输出中表示的差异：

```go
mysql> CREATE TABLE datetime_temp(
 ts TIMESTAMP,
 dt DATETIME);

mysql> INSERT INTO datetime_temp
VALUES(NOW(), NOW());

mysql> SELECT ts, dt FROM datetime_temp;
+------------------------+-------------------------+
>|          ts            |            dt           |
+------------------------+-------------------------+
|  2017-10-14 18:10:25   |  2017-10-14 18:10:25    |
+------------------------+-------------------------+
```

在上面的例子中，`NOW()`是 MySQL 函数，它返回当前的日期和时间值。从输出来看，似乎`TIMESTAMP`和`DATETIME`的表示是相同的。这是因为`time_zone`值设置为 UTC。默认情况下，`TIMESTAMP`显示考虑 UTC `time_zone`的日期时间值。另一方面，`DATETIME`显示不带`time_zone`的日期时间。

让我们更改`time_zone`并观察输出：

```go
mysql> SET time_zone = '+03:00';

mysql> SELECT ts, dt FROM datetime_temp;
+------------------------+-------------------------+
|          ts            |            dt           |
+------------------------+-------------------------+
|  2017-10-14 21:10:25   |  2017-10-14 18:10:25    |
+------------------------+-------------------------+
```

从输出来看，很明显`TIMESTAMP`考虑了 MySQL 中设置的`time_zone`值。因此，当我们更改时区时，`TIMESTAMP`值会调整。`DATETIME`不受影响，因此即使在更改时区后，输出也不会改变。

如果使用`TIMESTAMP`存储日期和时间值，我们在将数据迁移到位于不同时区的不同服务器时必须认真考虑它。

如果需要更高精度的时间值，`DATETIME`和`TIMESTAMP`可以包括最多微秒（六位数字）的尾随分数秒。因此，如果我们插入一个带有微秒值的日期时间值，它将存储在数据库中。格式，包括分数部分，是 YYYY-MM-DD HH:MM:SS[.fraction]，范围是从 1000-01-01 00:00:00.000000 到 9999-12-31 23:59:59.999999。`TIMESTAMP`的范围，包括分数，是 1970-01-01 00:00:01.000000 到 2038-01-19 03:14:07.999999。

时间值的小数部分通过小数点与时间值分隔，因为 MySQL 不识别其他分数秒的分隔符。

使用`TIMESTAMP`数据类型存储的日期和时间值会从服务器的时区转换为 UTC 进行存储，并从 UTC 转换为服务器的时区进行检索。如果我们存储了一个`TIMESTAMP`值，然后更改了服务器的时区并检索该值，则检索到的值将与我们存储的值不同。

以下是 MySQL 中日期值解释的属性列表：

+   MySQL 支持以字符串指定的值的宽松格式。在宽松格式中，任何标点字符都可以用作日期部分或时间部分之间的分隔符。这有点令人困惑。例如，值`10:11:12`可能看起来像一个时间值，因为使用了`:`，但被解释为`2010-11-12`日期。

+   在其余时间部分和分数秒部分之间的唯一识别分隔符是小数点。

+   预期月份和日期值是有效的。在禁用`strict`模式的情况下，无效日期将转换为相应的`zero`值，并显示警告消息。

+   在`TIMESTAMP`值中，如果日期或月份列中包含零，则不是有效日期。这条规则的例外是`zero`值。

如果 MySQL 以启用`MAXDB`模式运行，`TIMESTAMP`与`DATETIME`相同。如果在表创建时启用了此模式，则`TIMESTAMP`值将转换为`DATETIME`。

# MySQL DATETIME 函数

`NOW()`是用于获取系统当前日期和时间的函数：

```go
mysql> SET @dt = NOW();
mysql> SELECT @dt;
+---------------------+
|       @dt           |
+---------------------+
| 2017-10-15 13:43:17 |
+---------------------+
```

`DATE()`函数用于从`DATETIME`值中提取日期信息：

```go
mysql> SELECT DATE(@dt);
+------------------+
|    DATE(@dt)     |
+------------------+
|    2017-10-15    |
+------------------+
```

`TIME()`函数用于从日期时间值中提取时间信息：

```go
mysql> SELECT TIME(@dt);
+------------------+
|    TIME(@dt)     |
+------------------+
|     13:43:17     |
+------------------+
```

当您希望基于日期或时间值显示或查询数据库表时，`DATE()`和`TIME()`函数非常有用，但表中存储的实际值包含日期和时间信息。

如果我们想从`DATETIME`或`TIMESTAMP`值中提取`YEAR`、`MONTH`、`DAY`、`QUARTER`、`WEEK`、`HOUR`、`MINUTE`和`SECOND`信息，相应的函数是可用的：

```go
mysql> SELECT
 HOUR(@dt),
 MINUTE(@dt),
 SECOND(@dt),
 DAY(@dt),
 WEEK(@dt),
 MONTH(@dt),
 QUARTER(@dt),
 YEAR(@dt);
+-----------+-------------+-------------+---------+----------+
| HOUR(@dt) | MINUTE(@dt) | SECOND(@dt) | DAY(@dt)| WEEK(@dt)| 
+-----------+-------------+-------------+---------+----------+
+------------+--------------+-----------+
| MONTH(@dt) | QUARTER(@dt) | YEAR(@dt) |
+------------+--------------+-----------+
+-----------+-------------+-------------+---------+----------+
|        13 |          43 |          17 |      15 |       41 | 
+-----------+-------------+-------------+---------+----------+
+------------+--------------+-----------+
|         10 |            4 |      2017 |
+------------+--------------+-----------+
```

# TIME 类型

MySQL 的`DATETIME`或`TIMESTAMP`数据类型用于表示特定日期的特定时间。只存储一天中的时间或两个事件之间的时间差怎么办？MySQL 的`TIME`数据类型可以满足这一需求。

存储或显示`TIME`数据类型值的标准 MySQL 格式是`HH:MM:SS`。时间值表示一天中的时间，小于 24 小时，但是如前所述，`TIME`数据类型也可以用于存储经过的时间或两个事件之间的时间差。因此，`TIME`列可以存储大于 24 小时的值。

MySQL 的`TIME`列定义如下：

```go
column_name TIME;
```

`TIME`数据类型列中可以存储的值的范围是-838:59:59 到 838:59:59。

MySQL 的`TIME`列还可以存储小数秒部分，最多可以达到微秒（六位数字），类似于`DATETIME`列。考虑到小数秒精度，值的范围从-838:59:59.000000 到 838:59:59.00000。

MySQL 的`TIME`列也可以有一个可选值：

```go
column_name TIME(N);
where N represents number of fractional part, which is up to 6 digits.
```

`TIME`值通常需要 3 个字节来存储。在包括小数秒精度的`TIME`值的情况下，将需要额外的字节，取决于小数秒精度的数量。

以下表格显示了存储小数秒精度所需的额外字节数：

| **小数秒精度** | **存储（字节）** |
| --- | --- |
| 0 | 0 |
| 1, 2 | 1 |
| 3, 4 | 2 |
| 5, 6 | 3 |

MySQL 支持`TIME`列的缩写值。MySQL 有两种不同的方式来解释缩写值：

+   如果缩写值有冒号（`:`），MySQL 将其解释为一天中的时间。例如，11:12 被解释为 11:12:00，而不是 00:11:12。

+   如果缩写值没有冒号（`:`），MySQL 假定最右边的两位数字代表秒。这意味着该值被解释为经过的时间，而不是一天中的时间。例如，'1214'和 1214 被 MySQL 解释为 00:12:14。

MySQL 接受的唯一分隔符是小数点，用于将小数秒精度与时间值的其余部分分开。

MySQL 默认情况下，将超出允许值范围的值裁剪到范围的最近端点。例如，-880:00:00 和 880:00:00 存储为-838:59:59 和 838:59:59。无效的`TIME`值转换为 00:00:00。由于 00:00:00 本身是有效的`TIME`值，很难知道值 00:00:00 是有意存储的，还是从无效的`TIME`值转换而来。

MySQL 接受字符串和数字值作为`TIME`值。

# 时间函数

`CURRENT_TIME()`函数可用于查找服务器上的当前时间。还可以使用`ADDTIME`和`SUBTIME`函数添加或减去时间值。例如，以下示例将两小时添加到服务器的当前时间：

```go
mysql> SELECT 
 CURRENT_TIME() AS 'CUR_TIME',
 ADDTIME(CURRENT_TIME(), 020000) AS 'ADDTIME',
 SUBTIME(CURRENT_TIME(), 020000) AS 'SUBTIME';

+----------+-----------+-----------+
| CUR_TIME |  ADDTIME  |  SUBTIME  |
+----------+-----------+-----------+
| 10:12:34 |  12:12:34 | 08:12:34  |
+----------+-----------+-----------+
```

`UTC_TIME()`函数可用于获取 UTC 时间。

# 年份类型

存储制造年份的首选数据类型是什么？MySQL 的答案是`YEAR`数据类型。`YEAR`数据类型需要 1 个字节来存储年份信息。

`YEAR`列可以声明为：

```go
manufacturing_year YEAR
or
manufacturing_year YEAR(4)
```

值得注意的是，早期的 MySQL 版本支持`YEAR(2)`类型的列声明。从 MySQL 8 开始，不再支持`YEAR(2)`。可能需要将旧的 MySQL 数据库升级到 MySQL 8 数据库。在后面的部分中，我们将解释从`YEAR(2)`到`YEAR(4)`的迁移细节。

MySQL 以 YYYY 格式表示`YEAR`值。值的范围是从 1901 年到 2155 年和 0000 年。

以下是输入`YEAR`值支持的格式列表：

+   从 1901 年到 2155 年的四位数。

+   从 1901 年到 2155 年的四位字符串。

+   0 到 99 范围内的一位或两位数字。`YEAR`值从 1 到 69 转换为 2001 到 2069，从 70 到 99 转换为 1970 到 1999。

+   范围为 0 到 99 的一位或两位数字字符串。`YEAR`值从 1 到 69 转换为 2001 到 2069，从 70 到 99 转换为 1970 到 1999。

+   插入数字 0 的显示值为 0000，内部值为 0000。如果我们想要插入 0 并希望它被解释为 2000，我们应该将其指定为字符串 0 或 00。

+   返回可接受值`YEAR`上下文的函数的结果，例如`NOW()`。

MySQL 将无效的`YEAR`值转换为 0000。

# 将 YEAR(2)迁移到 YEAR(4)

如前所述，MySQL 8 不支持`YEAR(2)`类型。尝试创建一个数据类型为`YEAR(2)`的列将会产生以下错误：

```go
mysql> CREATE TABLE temp(year YEAR(2));
ERROR 1818 (HY000): Supports only YEAR or YEAR(4) column.
```

重建表的`ALTER TABLE`查询将自动将`YEAR(2)`转换为`YEAR(4)`。在将数据库升级到 MySQL 8 数据库后，`YEAR(2)`列仍然保持为`YEAR(2)`，但查询会报错。

有多种方法可以从`YEAR(2)`迁移到`YEAR(4)`：

+   使用带有`FORCE`属性的`ALTER TABLE`查询将`YEAR(2)`列转换为`YEAR(4)`。但它不会转换值。如果`ALTER TABLE`查询应用于复制主机，复制从机将复制`ALTER TABLE`语句。因此，更改将在所有复制节点上可用。

+   使用二进制升级，无需转储或重新加载数据，是将`YEAR(2)`升级到`YEAR(4)`的另一种方法。随后运行`mysql_upgrade`会执行`REPAIR_TABLE`并将`YEAR(2)`转换为`YEAR(4`，而不更改值。与前一个替代方案类似，如果应用于复制主机，则会在复制从机中复制此更改。

需要注意的一点是，在升级时，我们不应该使用`mysqldump`转储`YEAR(2)`数据，并在升级后重新加载转储文件。这种方法有可能显著改变`YEAR(2)`的值。

在进行`YEAR(2)`到`YEAR(4)`迁移之前，必须审查应用程序代码：

+   选择以两位数字显示`YEAR`值的代码。

+   不处理数字`0`插入的代码。将`0`插入`YEAR(2)`会得到`2000`，而将`0`插入`YEAR(4)`会得到`0000`。

# 字符串数据类型

哪种数据类型是表示值最广泛需要和使用的？字符串还是字符数据类型；很容易，对吧？MySQL 支持各种字符串数据类型，以满足不同的存储需求。字符串数据类型分为两类：固定长度和可变长度。`CHAR`、`VARCHAR`、`BINARY`、`VARBINARY`、`BLOB`、`TEXT`、`ENUM`和`SET`是 MySQL 支持的字符串数据类型。每种数据类型的存储需求都不同，将在单独的部分中进行解释。

# CHAR 和 VARCHAR 数据类型

`CHAR`数据类型是 MySQL 中的固定长度字符串数据类型。`CHAR`数据类型通常声明为可以存储的最大字符数，如下所示：

```go
data CHAR(20);
```

在前面的例子中，数据列可以存储能够存储最大字符的字符串值。

`CHAR`和`VARCHAR`在许多方面相似，但也有一些区别。如果要存储的字符串值是固定大小的，首选`CHAR`数据类型。与对固定大小字符串使用`VARCHAR`相比，它将提供更好的性能。

长度从 0 到 255 不等。`CHAR`列中的值不能超过表创建时声明的最大长度。如果字符串的长度小于允许的最大长度，MySQL 会在右侧添加填充以达到指定的长度。在检索时，尾随空格会被移除。以下是一个例子：

```go
mysql> CREATE TABLE char_temp (
 data CHAR(3)
);

mysql> INSERT INTO char_temp(data) VALUES('abc'), (' a ');

mysql> SELECT data, LENGTH(data) 
 FROM char_temp;
+-------+--------------+
| data  | LENGTH(data) |
+-------+--------------+
|  abc  |      3       |
+-------+--------------+
|   a   |      2       |
+-------+--------------+
```

正如我们在前面的例子中所观察到的，第二条记录被插入为`' a '`, 但在输出中，尾随空格被移除。因此，长度显示为`2`而不是`3`。

大多数 MySQL 排序规则都有填充属性。它确定如何处理非二进制字符串的尾随空格进行比较。有两种类型的排序规则：`PAD SPACE`和`NO PAD`。在`PAD SPACE`排序规则的情况下，尾随空格在比较时不被考虑。字符串在不考虑尾随空格的情况下进行比较。

在`NO PAD`排序规则的情况下，尾随空格被视为任何其他字符。以下是一个示例：

```go
mysql> CREATE TABLE employees (emp_name CHAR(10));

mysql> INSERT INTO employees VALUES ('Jack');

mysql> SELECT emp_name = 'Jack', emp_name = 'Jack ' FROM employees;
+-------------------+--------------------+ 
| emp_name = 'Jack' | emp_name = 'Jack ' | 
+-------------------+--------------------+ 
|                1  |                 1  | 
+-------------------+--------------------+ 
mysql> SELECT emp_name LIKE 'Jack', emp_name LIKE 'Jack ' FROM employees; 
+----------------------+------------------------+ 
| emp_name LIKE 'Jack' | emp_name LIKE 'Jack '  | 
+----------------------+------------------------+ 
|                    1 |                      0 | 
+----------------------+------------------------+
```

`LIKE`是 MySQL 中用于`WHERE`子句中的比较的运算符。它专门用于在字符串中进行模式搜索。在使用`LIKE`运算符比较字符串值时，尾随空格是重要的。

如果启用了`PAD_CHAR_TO_FULL_LENGTH`模式，在检索时，尾随空格将不会被移除。

MySQL `VARCHAR`数据类型是一个最大长度为 65,535 个字符的可变长度字符串数据类型。`VARCHAR`值由 MySQL 存储为一个或两个字节的长度前缀，以及实际数据。`VARCHAR`的实际最大长度取决于最大行大小，最大行大小为 65,536 字节，共享在所有列之间。

如果`VARCHAR`值需要的字节数少于 255 字节，则使用一个字节来确定长度前缀。如果值需要的字节数超过 255 字节，则使用两个字节来确定长度前缀。

如果启用了 MySQL 严格模式，并且要插入的`CHAR`或`VARCHAR`列值超过了最大长度，则会生成错误。如果禁用了严格模式，则该值将被截断为最大允许长度，并生成警告。

与`CHAR`数据类型不同，要存储在`VARCHAR`中的值不会填充。此外，检索值时也不会去除尾随空格。

# BINARY 和 VARBINARY 数据类型

另一组 MySQL 字符串数据类型是`BINARY`和`VARBINARY`。这些与`CHAR`和`VARCHAR`数据类型类似。`CHAR`/`VARCHAR`和`BINARY`/`VARBINARY`之间的一个重要区别是`BINARY`/`VARBINARY`数据类型包含的是二进制字符串而不是字符字符串。`BINARY`/`VARBINARY`使用二进制字符集和排序规则。`BINARY`/`VARBINARY`与`CHAR BINARY`和`VARCHAR BINARY`数据类型不同。基本区别在于所涉及的字符集和排序规则。

允许值的最大长度与`CHAR`和`VARCHAR`的最大长度类似。唯一的区别是`BINARY`和`VARBINARY`的长度是以字节而不是字符计算的。

MySQL 如何比较二进制值？答案是基于值中字节的数值进行比较。

与`CHAR`/`VARCHAR`数据类型类似，如果值的长度超过列长度，将截断值并生成警告（如果未启用`strict`模式）。如果启用了`strict`模式，将生成错误。

`BINARY`值在指定列长度右侧填充了填充值 0x00（零字节）。插入时添加填充值，但在检索时不会删除尾随字节。在比较`BINARY`值时，所有字节都被视为重要。这也适用于`ORDER BY`和`DISTINCT`运算符。当与*0x00 < space*进行比较时，零字节和空格是不同的。以下是插入二进制值的示例：

```go
mysql> CREATE TABLE temp(
 data BINARY(3));

mysql> INSERT INTO temp(data) VALUES('a ');
```

在这种情况下，插入时`'a'`变成`'a\0'`。`'a\0'`转换为`'a\0\0'`。在检索时，值保持不变。

`VARBINARY`是一个可变长度字符串数据类型。与`BINARY`不同，`VARBINARY`在插入时不会添加填充，在检索时也不会去除字节。与`BINARY`类似，所有字节在比较`VARBINARY`时都是重要的。

如果表在列上有唯一索引，那么在列中插入仅在尾随填充字节数量上不同的值将导致重复键错误。例如，如果这样的列包含`'a '`，并且我们尝试插入`'a\0'`，将导致重复键错误。

以下示例解释了在比较中`BINARY`值的填充：

```go
mysql> CREATE TABLE bin_temp (data BINARY(3));

mysql> INSERT INTO bin_temp(data) VALUES('c');

mysql> SELECT data = 'c', data = 'c\0\0' from bin_temp;
+------------+-------------------+
| data = 'c' |    data = 'c\0\0' |
+------------+-------------------+
|          0 |                 1 |
+------------+-------------------+
```

在需要检索与指定的相同值但不需要填充的情况下，最好使用`VARBINARY`。

如果检索的值必须与指定的存储值相同且不填充，可能更适合使用`VARBINARY`或`BLOB`数据类型之一。

# BLOB 和 TEXT 数据类型

在什么情况下我们可能需要将数据存储在**二进制大对象**（**BLOB**）列中？有任何想法吗？存储文件或图像，你说？这部分是正确的。在我们决定将图像或文件存储在数据库或文件系统之前，我们需要评估情况。如果文件存储在文件系统中并迁移到另一个操作系统，可能会导致文件指针损坏。这将需要额外的工作来修复文件指针。在这种情况下，将文件存储在数据库中更可取。但是，如果我们在数据库中存储大型拥挤的文件或图像数据，可能会影响性能。

`BLOB`是 MySQL 用于存储可变长度大型二进制信息的解决方案。MySQL 有四种`BLOB`类型：`TINYBLOB`，`BLOB`，`MEDIUMBLOB`和`LONGBLOB`。这些数据类型之间的唯一区别是我们可以存储的值的最大长度。这些数据类型的存储要求在本章后面的部分中有解释。

与`BLOB`类似，`TEXT`数据类型有`TINYTEXT`，`TEXT`，`MEDIUMTEXT`和`LONGTEXT`。它们具有与`BLOB`数据类型类似的最大长度和存储要求。

与`BINARY`数据类型一样，`BLOB`值被存储为字节字符串，并具有二进制字符集和排序。对列值的数字值进行比较和排序。`TEXT`值被存储为非二进制字符串。

对于`BLOB`或`TEXT`数据类型，如果值包含多余的尾随空格，MySQL 会截断并发出警告，无论 MySQL 模式如何。MySQL 在插入时不会填充`BLOB`或`TEXT`列的值，并且在检索时不会剥离字节。

对于索引的`TEXT`列，索引比较会在值的末尾添加尾随空格作为填充。因此，如果现有`TEXT`值和要插入的`TEXT`值之间的唯一区别在于尾随空格，则可能会在插入时发生重复键错误。`BLOB`可以被视为`VARBINARY`，`TEXT`可以被视为`VARCHAR`，对值的长度没有限制。

以下是`VARBINARY`，`VARCHAR`和`BLOB`，`TEXT`之间的区别：

+   在`BLOB`或`TEXT`列上创建索引时，必须指定索引前缀长度。

+   `BLOB`和`TEXT`不能有默认值

`BLOB`或`TEXT`值在内部表示为具有单独分配的对象，与其他数据类型不同，其他数据类型的存储是每列分配一次。

# ENUM 数据类型

MySQL 提供了一种数据类型，可以在创建表时预定义允许的值列表。该数据类型是`ENUM`。如果我们希望限制用户插入超出一定范围的值，应该定义数据类型为`ENUM`的列。MySQL 将用户输入的字符串值编码为`ENUM`数据类型的数字。

`ENUM`提供了以下提到的好处：

+   紧凑的数据存储

+   可读的查询和输出

以下是展示`ENUM`何时有用的示例：

```go
mysql> CREATE TABLE subjects (
 name VARCHAR(40),
 stream ENUM('arts', 'commerce', 'science')
);

mysql> INSERT INTO subjects (name, stream) VALUES ('biology','science'), ('statistics','commerce'), ('history','arts');

```

```go
mysql> SELECT name, stream FROM subjects WHERE stream = 'commerce';
+------------+----------+
|    name    |  stream  |
+------------+----------+
| statistics | commerce |
+------------+----------+

mysql> UPDATE subjects SET stream = 'science' WHERE stream = 'commerce';
```

`ENUM`值需要一个字节的存储。在这个表中存储一百万条这样的记录将需要一百万字节的存储空间，而不是`VARCHAR`列所需的六百万字节。

以下是需要考虑的重要限制：

+   `ENUM`值在内部存储为数字。因此，如果`ENUM`值看起来像数字，字面值可能会与其内部索引数字混淆。

+   在 `ORDER BY` 子句中使用 `ENUM` 列需要额外小心。`ENUM` 值根据列出顺序分配索引号。`ENUM` 值根据其索引号排序。因此，重要的是确保 `ENUM` 值列表按字母顺序排列。此外，列应按字母顺序而不是按索引号排序。 

+   `ENUM` 值必须是带引号的字符串文字。

+   每个 `ENUM` 值都有一个从 1 开始的索引。空字符串或错误值的索引为 0。我们可以通过在 `WHERE` 子句中查询具有 `enum_column_value = 0` 的表来找到无效的 `ENUM` 值。`NULL` 值的索引为 `NULL`。索引是指值在 `ENUM` 值列表中的位置。

+   在创建表时，MySQL 会自动删除 `ENUM` 成员值的尾随空格。检索时，`ENUM` 列中的值以列定义中使用的大小写显示。如果要在 `ENUM` 列中存储数字，则该数字将被视为可能值的索引。存储的值是具有该索引的 `ENUM` 值。对于带引号的数字值，如果在枚举值列表中没有匹配的字符串，则仍将其解释为索引。

+   如果声明 `ENUM` 列包含 `NULL` 值，则将考虑 `NULL` 值作为列的有效值，并且 `NULL` 成为默认值。如果不允许 `NULL`，则第一个 `ENUM` 值将成为默认值。

如果在数字上下文中使用 `ENUM` 值，则使用索引。以下是在数字上下文中使用 `ENUM` 值的示例查询：

```go
mysql> SELECT stream+1 FROM subjects;
+--------------+
|   stream+1   |
+--------------+
|      4       |
|      3       |
|      2       |
+--------------+
```

# SET 数据类型

MySQL `SET` 是一种数据类型，可以具有零个或多个值。在创建表时指定了一个允许值列表。每个值必须来自允许值列表中。多个集合成员由逗号（`,`）分隔的值列表指定。`SET` 最多可以有 64 个不同的成员。如果启用了 `strict` 模式，则如果在列定义中发现重复的值，则会生成错误。

必须注意 `SET` 成员值不包含逗号；否则，它们将被解释为 `SET` 成员分隔符。

指定为 `SET('yes', 'no') NOT NULL` 的列可以具有以下任一值：

+   ''

+   '是'

+   '否'

+   '是，否'

`SET` 成员值会自动删除尾随空格。检索时，`SET` 列值将使用在列定义中使用的大小写显示。

以下是在 `SET` 数据类型中插入值的示例：

```go
mysql> CREATE TABLE temp(
 hobbies SET('Travel', 'Sports', 'Fine Dining', 'Dancing'));

mysql> INSERT INTO temp(hobbies) VALUES(9);
```

`SET` 值存储在 MySQL 表中，其中每个元素由一个位表示。在前面的情况下，`SET` 中的每个元素都被分配一个位。如果行具有给定元素，则相关位将为一。由于这种方法，每个元素都有一个关联的十进制值。此外，由于位图，尽管只有四个值，`SET` 将占用一个字节。以下是解释这一点的表：

| **元素** | **SET 值** | **十进制值** |
| --- | --- | --- |
| 旅行 | 00000001 | 1 |
| 体育 | 00000010 | 2 |
| 精致餐饮 | 00000100 | 4 |
| 跳舞 | 00001000 | 8 |

可以通过添加它们的十进制值来表示多个 `SET` 元素。在前面的情况下，十进制值 9 被解释为旅行，跳舞。

`SET` 数据类型并不常用。这是因为虽然它是一个字符串数据类型，但在实现上有点复杂。可以存储的值限制为 64 个元素。我们不能将逗号作为 `SET` 值的一部分添加，因为逗号是标准的 `SET` 值分隔符。从数据库设计的角度来看，使用 `SET` 意味着数据库不是规范化的。

# JSON 数据类型

JSON 代表 JavaScript 对象表示法。假设我们想要在数据库中存储 Web 应用程序的用户偏好设置。通常，我们可能选择创建一个单独的表，其中包含`id`、`user_id`、`key`、`value`字段。这对于少量用户可能效果不错，但对于成千上万的用户来说，维护成本是无法承受的，与其增加 Web 应用程序的价值相比。

在 MySQL 中，我们可以利用 JSON 数据类型来满足这个需求。MySQL 支持原生的 JSON 数据类型，可以有效地存储 JSON 文档。MySQL 支持对存储在 JSON 列中的 JSON 文档进行自动验证。尝试存储无效的 JSON 文档会产生错误。存储在 JSON 列中的 JSON 文档会被转换为内部格式。该格式是二进制的，并且结构化，使服务器能够直接查找`subojbects`或嵌套值，通过键或数组索引，而无需读取其他值。

JSON 列不能有默认值。JSON 数据类型需要与`LONGTEXT`或`LONGBLOB`相似的存储。与其他字符串数据类型不同，JSON 列不会直接进行索引。

以下是在表中插入 JSON 值的示例：

```go
mysql> CREATE TABLE users(
 user_id INT UNSIGNED NOT NULL,
 preferences JSON NOT NULL);

mysql> INSERT INTO users(user_id, preferences)
 VALUES(1, '{"page_size": 10, "hobbies": {"sports": 1}}');

mysql> SELECT preferences FROM users;
+---------------------------------------------------------+
|                   preferences                           |
+---------------------------------------------------------+
|    {"hobbies": {"sports": 1}, "page_size": 10}          |
+---------------------------------------------------------+
```

在前面的示例中，我们已经格式化了 JSON 值。作为替代，我们也可以使用内置的`JSON_OBJECT`函数。该函数接受一组键/值对并返回一个 JSON 对象。以下是一个示例：

```go
mysql> INSERT INTO users(user_id, preferences)
 VALUES(2, JSON_OBJECT("page_size", 1, "network", JSON_ARRAY("GSM", "CDMA", "WIFI")));
```

前面的`INSERT`查询将插入 JSON 值`{"page_size": 1, "network": ["GSM", "CDMA", "WIFI"]}`。我们也可以使用嵌套的`JSON_OBJECT`函数。`JSON_ARRAY`函数在传递一组值时返回一个 JSON 数组。

如果多次指定相同的键，则只保留第一个键值对。在 JSON 数据类型的情况下，对象键会被排序，并且键值对之间的尾随空格会被移除。JSON 对象中的键必须是字符串。

只有在 JSON 文档有效的情况下，才能在 JSON 列中插入 JSON 值。如果 JSON 文档无效，MySQL 会产生错误。

MySQL 还有一个重要且有用的操作 JSON 值的函数。`JSON_MERGE`函数接受多个 JSON 对象并生成一个单一的聚合对象。

`JSON_TYPE`函数以 JSON 作为参数并尝试将其解析为 JSON 值。如果有效，则返回值的 JSON 类型，否则会产生错误。

# JSON 值的部分更新

如果我们想要更新存储在 JSON 数据类型列中的 JSON 文档中的值，我们应该怎么做？其中一种方法是删除旧文档并插入带有更新的新文档。这种方法似乎不太好，对吧？MySQL 8.0 支持对存储在 JSON 数据类型列中的 JSON 文档进行部分、就地更新。优化器要求更新必须满足以下条件：

+   列必须是 JSON 类型。

+   `JSON_SET()`、`JSON_REPLACE()`或`JSON_REMOVE()`三个函数中的一个可以用来更新列。MySQL 不允许直接对列值进行部分更新。

+   输入列和目标列必须相同。例如，像`UPDATE temp SET col1 = JSON_SET(col2, 'one', 10)`这样的语句不能作为部分更新执行。

+   更改只会更新现有数组或对象，不会向父对象或数组添加新元素。

+   替换值不能大于被替换的值。

# 数据类型的存储要求

本节解释了 MySQL 中不同数据类型的存储要求。存储要求取决于不同的因素。存储引擎以不同的方式表示数据类型并存储原始数据。

表的最大行大小为 65,535 字节，即使存储引擎能够支持更大的行。`BLOB`和`TEXT`数据类型被排除在外。

以下表格解释了数字数据类型的存储细节：

| **数据类型** | **所需存储空间** |
| --- | --- |
| `TINYINT` | 1 字节 |
| SMALLINT | 2 字节 |
| MEDIUMINT | 3 字节 |
| INT，INTEGER | 4 字节 |
| BIGINT | 8 字节 |
| FLOAT(p) | 如果*0<=p<=24*，则为 4 字节，如果*25<=p<=53*，则为 8 字节 |
| 浮点 | 4 字节 |
| DOUBLE [精度]，REAL | 8 字节 |
| DECIMAL(M, D)，NUMERIC(M, D) | 变化 |
| BIT(M) | 大约*(M+7)/8*字节 |

参考：[`dev.mysql.com/doc/refman/8.0/en/storage-requirements.html`](https://dev.mysql.com/doc/refman/8.0/en/storage-requirements.html)

以下表格解释了 DATE 和 TIME 数据类型的存储需求：

| 数据类型 | 存储需求 |
| --- | --- |
| YEAR | 1 字节 |
| 日期 | 3 字节 |
| 时间 | 3 字节 + 分数秒存储 |
| 日期时间 | 5 字节 + 分数秒存储 |
| TIMESTAMP | 4 字节 + 分数秒存储 |

以下表格解释了分数秒精度所需的存储空间：

| 分数秒精度 | 存储需求 |
| --- | --- |
| 0 | 0 字节 |
| 1, 2 | 1 字节 |
| 3, 4 | 2 字节 |
| 5, 6 | 3 字节 |

以下表格解释了字符串数据类型的存储需求：

| 数据类型 | 存储需求 |
| --- | --- |
| --- | --- |
| CHAR(M) | *M* × *w* 字节，*0 <= M <= 255*，其中*w*是字符集中最大长度字符所需的字节数 |
| BINARY(M) | *M* 字节，*0 <= M <= 255* |
| VARCHAR(M)，VARBINARY(M) | 如果列值需要 0 − 255 字节，则为*L* + 1 字节，如果值可能需要超过 255 字节，则为*L* + 2 字节 |
| TINYBLOB，TINYTEXT | *L* + 1 字节，其中*L* < 28 |
| BLOB，TEXT | *L* + 2 字节，其中*L* < 216 |
| `MEDIUMBLOB`，`MEDIUMTEXT` | *L* + 3 字节，其中*L* < 224 |
| LONGBLOB，LONGTEXT | *L* + 4 字节，其中***L*** < 232 |
| ENUM('value1','value2',...) | 取决于枚举值的数量，为 1 或 2 字节（最多 65,535 个值） |
| SET('value1','value2',...) | 取决于集合成员的数量，为 1、2、3、4 或 8 字节（最多 64 个成员） |

参考：[`dev.mysql.com/doc/refman/8.0/en/storage-requirements.html`](https://dev.mysql.com/doc/refman/8.0/en/storage-requirements.html)

在字符串数据类型的情况下，使用值的长度和长度前缀存储可变长度字符串。长度前缀根据数据类型的不同而变化，可以是一到四个字节。

JSON 数据类型的存储需求与 LONGBLOB 和 LONGTEXT 相似。然而，由于 JSON 文档以二进制表示存储，因此在存储 JSON 文档时会产生开销。

# 选择列的正确数据类型

作为一般惯例，我们应该使用最精确的类型来存储数据。例如，应该使用 CHAR 数据类型来存储长度从 1 到 255 个字符的字符串值。另一个例子是，应该使用 MEDIUMINT UNSIGNED 来存储从 1 到 99999 的数字。

基本操作，如`加法`，`减法`，`乘法`和`除法`，使用`DECIMAL`数据执行，精度为 65 个小数位。

根据准确性或速度的重要性，应选择使用 FLOAT 或 DOUBLE。存储在 BIGINT 中的定点值可用于更高的精度。

这些是一般指导方针，但是应该根据前面各数据类型单独解释的详细特性来决定使用正确的数据类型。

# 总结

这是一个有重要内容需要学习的有趣章节，对吧？在这一章中，我们了解了 MySQL 中数据类型的重要性。我们看到了 MySQL 数据类型被分类的不同类别。我们深入学习和了解了每种数据类型的特性和规格。我们还学习了 MySQL 数据操作函数，并了解了一些 MySQL 设置和模式。在本章的后面部分，我们学习了数据类型的存储需求。最后，我们学习了选择正确数据类型的一般指导方针。

进入下一章，我们将学习 MySQL 数据库管理。本章将重点介绍服务器管理，了解 MySQL 服务器的基本构建模块，如数据字典、系统数据库等。本章将解释如何在单台机器上运行多个服务器实例以及 MySQL 角色和权限。
