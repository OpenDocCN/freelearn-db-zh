- en: MySQL 8 Data Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQL 8数据类型
- en: In the previous chapter, we learned how to use MySQL 8 command-line programs
    and utilities to perform various operations on the MySQL 8 database. It is always
    good to have hold on command-line tools. It provides flexibility to work in non-GUI
    environments. The focus of this chapter is data types. Isn't it fascinating to
    know the type of data the programming language supports or the storage engine
    can store? It is a fundamental feature of any programming language or database.
    At the same time, it is the most ignored topic, as well. The majority of programmers
    don't spend enough time assessing the storage requirements for `variables` used
    in a piece of code. Actually, it is extremely important to understand the basic
    and custom data types that the database supports, which is why this chapter exists.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用MySQL 8命令行程序和实用程序对MySQL 8数据库执行各种操作。拥有对命令行工具的掌握总是很好的。它提供了在非GUI环境中工作的灵活性。本章的重点是数据类型。了解编程语言支持的数据类型或存储引擎可以存储的数据类型是不是很有趣？这是任何编程语言或数据库的基本特性。同时，它也是最被忽视的话题。大多数程序员没有足够的时间来评估代码中使用的`变量`的存储需求。实际上，了解数据库支持的基本和自定义数据类型非常重要，这也是本章存在的原因。
- en: 'The following is a list of topics to be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章要涵盖的主题列表：
- en: Overview of MySQL 8 data types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL 8数据类型概述
- en: Numeric data types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值数据类型
- en: Date and time data types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期和时间数据类型
- en: String data types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串数据类型
- en: JSON data type
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON数据类型
- en: Storage requirements for data types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型的存储要求
- en: Choosing the right data type for columns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为列选择正确的数据类型
- en: Overview of MySQL 8 data types
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQL 8数据类型概述
- en: 'All standard SQL data types are supported in MySQL. These data types are classified
    in a few categories, such as numeric types, string types, date and time types,
    and the JSON data type. When we assign a data type to a column, certain conventions
    must be followed. These conventions are necessary for MySQL to allow values to
    be stored in a column:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL支持所有标准SQL数据类型。这些数据类型分为几个类别，如数值类型、字符串类型、日期和时间类型以及JSON数据类型。当我们为列分配数据类型时，必须遵循某些约定。这些约定对于MySQL允许在列中存储值是必要的：
- en: '**M** denotes the maximum display width for integer types. For floating point
    and fixed point types, it is the total number of digits that can be stored. For
    string types, it is the maximum length. The maximum value allowed depends on the
    data type.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**M**表示整数类型的最大显示宽度。对于浮点和定点类型，它是可以存储的总位数。对于字符串类型，它是最大长度。允许的最大值取决于数据类型。'
- en: '**D** is applicable to floating points and fixed point types. It denotes the
    number of digits after the decimal point. The maximum allowed value is 30, but
    must be less than or equal to M-2.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D** 适用于浮点和定点类型。它表示小数点后的位数。允许的最大值为30，但必须小于或等于M-2。'
- en: '**fsp** is applicable to date and time types. It denotes the fractional seconds
    precision, which means the number of digits following the decimal point for the
    fractional part of seconds.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fsp** 适用于日期和时间类型。它表示分数秒精度，即小数点后秒的小数部分的位数。'
- en: This overview is brief so that the detailed descriptions of the features of
    each data type can be covered in topics to follow.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本概述简要介绍了每种数据类型的特性，详细描述将在后续主题中涵盖。
- en: Numeric data types
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值数据类型
- en: The MySQL 8 numeric data types include integer or exact data types, decimal
    or approximate data types, and bit data types.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8数值数据类型包括整数或精确数据类型、十进制或近似数据类型和位数据类型。
- en: By default, `REAL` data type values are stored as `DOUBLE`. If we have set the
    `REAL_AS_FLOAT` flag on MySQL, `REAL` data type values are stored as `FLOAT`.
    `FLOAT` occupies less space compared to `DOUBLE`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`REAL`数据类型的值存储为`DOUBLE`。如果我们在MySQL上设置了`REAL_AS_FLOAT`标志，`REAL`数据类型的值将存储为`FLOAT`。与`DOUBLE`相比，`FLOAT`占用的空间更小。
- en: Integer types
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数类型
- en: All standard SQL integer types are supported by MySQL.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL支持所有标准SQL整数类型。
- en: 'The following is a table describing the required storage and range for each
    integer type. Along with standard integer data types, MySQL also supports `TINYINT`,
    `MEDIUMINT`, and `BIGINT`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是描述每种整数类型所需存储和范围的表。除了标准整数数据类型外，MySQL还支持`TINYINT`、`MEDIUMINT`和`BIGINT`：
- en: '| **Type** | **Storage (Bytes)** | **Minimum Value** | **Maximum Value** |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **存储（字节）** | **最小值** | **最大值** |'
- en: '|  |  | **Signed / Unsigned** | **Signed / Unsigned** |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|  |  | **有符号/无符号** | **有符号/无符号** |'
- en: '| `TINYINT` | 1 | -128 | 127 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `TINYINT` | 1 | -128 | 127 |'
- en: '|  |  | 0 | 255 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 0 | 255 |'
- en: '| `SMALLINT` | 2 | -32768 | 32767 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `SMALLINT` | 2 | -32768 | 32767 |'
- en: '|  |  | 0 | 65535 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 0 | 65535 |'
- en: '| `MEDIUMINT` | 3 | -8388608 | 8388607 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `MEDIUMINT` | 3 | -8388608 | 8388607 |'
- en: '|  |  | 0 | 16777215 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 0 | 16777215 |'
- en: '| `INT` | 4 | -2147483648 | 2147483647 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `INT` | 4 | -2147483648 | 2147483647 |'
- en: '|  |  | 0 | 4294967295 |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 0 | 4294967295 |'
- en: '| `BIGINT` | 8 | -9223372036854775808 | 9223372036854775807 |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `BIGINT` | 8 | -9223372036854775808 | 9223372036854775807 |'
- en: '|  |  | 0 | 18446744073709551615 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 0 | 18446744073709551615 |'
- en: Reference: [https://dev.mysql.com/doc/refman/8.0/en/integer-types.html](https://dev.mysql.com/doc/refman/8.0/en/integer-types.html)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 参考：[https://dev.mysql.com/doc/refman/8.0/en/integer-types.html](https://dev.mysql.com/doc/refman/8.0/en/integer-types.html)
- en: The range of signed numbers includes both -ve and +ve numbers, whereas the range
    of unsigned numbers includes +ve numbers only.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有符号数的范围包括负数和正数，而无符号数的范围仅包括正数。
- en: 'The following is the column declaration for the unsigned integer column:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是无符号整数列的列声明：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`INT` and `INTEGER` can be used interchangeably. But consider if we declared
    a column as:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`INT`和`INTEGER`可以互换使用。但是考虑一下，如果我们声明一个列：'
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The maximum value that an `INTEGER` column can store is either 2147483647 (in
    case of a signed `INTEGER`) or 4294967295 (in case of an unsigned `INTEGER`). `255`
    here defines the visible length of a number. On the one handed, it is impractical
    to display a number `255` digits long. On the other hand, `INTEGER` supports 10
    digit numbers as a maximum value. So, it will be converted to `INT(11)` in the
    preceding case. Now, this raises another question: if the number of digits for
    a maximum integer number is 10, then why should it be converted to `INT(11)` and
    not `INT(10)`? The reason is that one digit is kept for storing the sign.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`INTEGER`列可以存储的最大值要么是2147483647（对于有符号的`INTEGER`），要么是4294967295（对于无符号的`INTEGER`）。这里的`255`定义了数字的可见长度。一方面，显示一个255位长的数字是不切实际的。另一方面，`INTEGER`支持最大值为10位数。因此，在前面的情况下，它将被转换为`INT(11)`。现在，这又引发了另一个问题：如果最大整数数字的位数为10，那么为什么应该将其转换为`INT(11)`而不是`INT(10)`？原因是保留了一位数字用于存储符号。'
- en: '`ZEROFILL` is an attribute which indicates that the number value should be
    prefixed with zeros if the length of the number value is smaller than the length
    of the column. The `CREATE` statement demonstrates a way to declare a column with
    the `ZEROFILL` attribute. The following is an example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`ZEROFILL`是一个属性，它表示如果数字值的长度小于列的长度，那么数字值应该以零填充。`CREATE`语句演示了声明带有`ZEROFILL`属性的列的方法。以下是一个例子：'
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We specified the value to be stored as `111`; it will be stored as `00111` if
    we provided the `ZEROFILL` option.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定要存储的值为`111`；如果我们提供了`ZEROFILL`选项，它将被存储为`00111`。
- en: Fixed point types
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固定点类型
- en: Fixed point types represent numbers with a fixed number of digits after the
    decimal or radix point. MySQL has `DECIMAL` and `NUMERIC` as fixed point, or exact,
    value data types. These values are stored in a binary format. Fixed point data
    types are useful, especially in storing monetary values in multiplication and
    division operations. The value of a fixed point data type is an integer number
    scaled by a specific factor, according to the type. For example, the value of
    1.11 can be represented in fixed point as `111`, with a scaling factor of 1/100\.
    Similarly, 1,110,000 can be represented as `1110`, with a scaling factor of 1000.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 固定点类型表示小数点或基数点后具有固定位数的数字。MySQL有`DECIMAL`和`NUMERIC`作为固定点或精确值数据类型。这些值以二进制格式存储。固定点数据类型在存储货币值进行乘法和除法运算时特别有用。固定点数据类型的值是由特定因子缩放的整数。例如，值1.11可以以`111`的形式表示为固定点，缩放因子为1/100。同样，1,110,000可以以`1110`的形式表示，缩放因子为1000。
- en: 'The following code block demonstrates the declaration of a `DECIMAL` data type:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块演示了`DECIMAL`数据类型的声明：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding example, `3` is the precision and `2` is the scale. An example
    value could be 4.65, where `4` is the precision and `65` is the scale:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`3`是精度，`2`是标度。一个例子值可以是4.65，其中`4`是精度，`65`是标度。
- en: '**Precision**: Denotes the number of significant digits stored for the values'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精度**：表示存储值的有效数字位数'
- en: '**Scale**: Represents the number of digits after the decimal point'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标度**：表示小数点后的数字位数'
- en: Precision and scale define the range of values that can be stored in the column.
    So, in the preceding column declaration, `tax_rate` can store values falling between
    -9.99 and 9.99.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 精度和标度定义了可以存储在列中的值的范围。因此，在前面的列声明中，`tax_rate`可以存储在-9.99和9.99之间的值。
- en: 'The syntax for defining the `DECIMAL` type in standard SQL is as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 标准SQL中定义`DECIMAL`类型的语法如下：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In MySQL, this is equivalent to:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在MySQL中，这相当于：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Declaring a column with `DECIMAL` is equivalent to `DECIMAL(M, 0)` in MySQL.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在MySQL中，声明带有`DECIMAL`的列等同于`DECIMAL(M, 0)`。
- en: In MySQL, 10 is the default value for `M`, if it's not provided.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在MySQL中，如果没有提供`M`，则`10`是`M`的默认值。
- en: The maximum number of digits supported for the `DECIMAL` type is 65, including
    precision and scale. We can limit the number of digits on values which can be
    entered for a column by using precision and scale. If a user enters a value with
    a larger number of digits than permitted in scale, the value will be truncated
    to match the permitted scale.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`DECIMAL`类型支持的最大数字位数为65，包括精度和标度。我们可以通过精度和标度限制可以输入列的值的数字位数。如果用户输入的值的数字位数大于标度允许的数字位数，那么该值将被截断以匹配允许的标度。'
- en: '`DECIMAL` is often considered to be an alternative to `DOUBLE` or `FLOAT`.
    As mentioned earlier, `DECIMAL` numbers are an exact representation of `REAL`
    numbers in mathematics. The only problem with the `DECIMAL` data type is that
    it occupies much more space, even for small numbers. For example, to store a value
    of 0.000003, the column declaration should have the data type defined as `DECIMAL(7,
    6)`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`DECIMAL`通常被认为是`DOUBLE`或`FLOAT`的替代品。如前所述，`DECIMAL`数字是数学中`REAL`数字的精确表示。`DECIMAL`数据类型唯一的问题是，即使对于小数字，它也占用了更多的空间。例如，要存储值0.000003，列声明应该将数据类型定义为`DECIMAL(7,
    6)`。'
- en: If the scale is `0`, the column values don't have decimal points or fractional
    values.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标度为`0`，则列值没有小数点或分数值。
- en: Floating point types
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮点类型
- en: Floating point numbers represent real numbers in computing. Real numbers are
    useful for measuring continuous values, such as weight, height, or speed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数在计算中表示实数。实数对于测量连续值（如重量、高度或速度）非常有用。
- en: 'MySQL has two floating point data types for storing approximate values: `FLOAT`
    and `DOUBLE`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL有两种用于存储近似值的浮点数据类型：`FLOAT`和`DOUBLE`。
- en: For floating point numbers, precision is an important factor. Precision defines
    the measure of accuracy. MySQL supports single precision and double precision
    floating point numbers. It consumes four bytes to store a single precision floating
    point number with the `FLOAT` data type, whereas it consumes eight bytes to store
    a double precision floating point number with the `DOUBLE` data type.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于浮点数，精度是一个重要因素。精度定义了准确度的度量。MySQL支持单精度和双精度浮点数。使用`FLOAT`数据类型存储单精度浮点数需要四个字节，而使用`DOUBLE`数据类型存储双精度浮点数需要八个字节。
- en: In MySQL, `REAL` is a synonym for `DOUBLE PRECISION`. As mentioned earlier,
    if `REAL_AS_FLOAT` is enabled, a column defined with the `REAL` data type will
    be treated similarly to `FLOAT`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在MySQL中，`REAL`是`DOUBLE PRECISION`的同义词。如前所述，如果启用了`REAL_AS_FLOAT`，则使用`REAL`数据类型定义的列将类似于`FLOAT`。
- en: The preceding description depicts `FLOAT` or `DOUBLE` as similar to `DECIMAL`.
    No, it is not. There is a huge difference. As described earlier, fixed point data
    types such as `DECIMAL` or `NUMERIC` can store exact values, up to the maximum
    digit after the decimal point, whereas floating point data types, such as `FLOAT`
    or `DOUBLE`, store approximate values. The values stored are detailed enough,
    but not completely accurate. There remains a minor inaccuracy.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的描述将`FLOAT`或`DOUBLE`描述为类似于`DECIMAL`。不，它不是。它们之间有很大的区别。如前所述，固定点数据类型如`DECIMAL`或`NUMERIC`可以存储精确值，直到小数点后的最大数字位数，而浮点数据类型如`FLOAT`或`DOUBLE`存储近似值。存储的值足够详细，但并非完全准确。仍然存在一些小的不准确性。
- en: 'Let''s understand this through the following code example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下代码示例来理解这一点：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中：
- en: We created a table containing `FLOAT` and `DECIMAL` type columns.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个包含`FLOAT`和`DECIMAL`类型列的表。
- en: We inserted the same values in two columns, named `float_values` and `decimal_values`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在两个列中插入了相同的值，分别命名为`float_values`和`decimal_values`。
- en: We executed a `select` query to fetch the sum of stored values.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们执行了一个`select`查询来获取存储值的总和。
- en: Though the same values, the output is different. The sum of `decimal_values`
    looks more precise compared to that of the `float_values`. The sum of `float_values`
    looks less precise. This is because of internal rounding performed by the MySQL
    engine for floating point data types, which results in the approximation stored
    value.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管值相同，输出却不同。`decimal_values`的总和看起来比`float_values`的更精确。`float_values`的总和看起来不够精确。这是因为MySQL引擎对浮点数据类型执行的内部舍入，导致存储的值是近似值。
- en: 'Standard SQL has a provision for specifying precision while defining a `FLOAT`
    column. The precision is in bits specified following the keyword `FLOAT` within
    parenthesis. MySQL also supports specifying precision values for `FLOAT` or `DOUBLE`,
    but the precision is used to determine the size:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 标准SQL允许在定义`FLOAT`列时指定精度。精度是在关键字`FLOAT`后的括号内指定的位数。MySQL也支持为`FLOAT`或`DOUBLE`指定精度值，但精度用于确定大小：
- en: Precision from 0 to 23 results in a 4 byte single precision `FLOAT` column
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从0到23的精度会导致4字节单精度`FLOAT`列
- en: Precision from 24 to 53 results in an 8 byte double precision `DOUBLE` column
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从24到53的精度会导致8字节双精度`DOUBLE`列
- en: 'The following is an example of `FLOAT` column declaration attributes:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`FLOAT`列声明属性的示例：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So, the column defined as the following will store a value such as 99.99:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，定义为以下内容的列将存储值，例如99.99：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: While storing floating point values, MySQL performs rounding. So, the value
    inserted as 99.09 into a `FLOAT(4, 2)` column may be stored as 99.01 as an approximate
    result.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储浮点值时，MySQL执行舍入。因此，插入为99.09的值到`FLOAT(4, 2)`列可能会以99.01的近似结果存储。
- en: Though the floating point column definition supports specifying precision, it
    is advisable to use `FLOAT` or `DOUBLE PRECISION` with no precision or number
    of digits, so as to take advantage of maximum flexibility and portability.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管浮点列定义支持指定精度，但建议使用没有精度或数字位数的`FLOAT`或`DOUBLE PRECISION`，以便充分利用最大的灵活性和可移植性。
- en: Problems with floating point values
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮点值的问题
- en: As described earlier, floating point data types store approximate real numbers.
    Trying to store an exact value and use it in comparison operations considering
    exact values may lead to various problems. Also, floating point values are interpreted
    in a platform and implementation-dependent manner. For example, different CPUs
    or operating systems may evaluate floating point numbers differently. This essentially
    means that the value intended to be stored in the floating point data type column
    may not be the same as the actual value stored or represented internally.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，浮点数据类型存储近似的实数。尝试存储精确值并在比较操作中考虑精确值可能会导致各种问题。此外，浮点值以平台和实现相关的方式进行解释。例如，不同的CPU或操作系统可能以不同的方式评估浮点数。这基本上意味着，打算存储在浮点数据类型列中的值可能与实际存储或内部表示的值不同。
- en: 'The previous point becomes essential when we use floating point numbers in
    comparison. Consider the following example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在比较中使用浮点数时，前面的观点变得至关重要。考虑以下例子：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding example, it seems that the first two rows in the output have
    similar numbers. It is possible that they might not be, in the case of floating
    point types. If we want to ensure, in the preceding case, that similar-looking
    values are considered, we have to compare the difference against a predefined
    number with precision. For example, in the preceding case, if we modify the `HAVING`
    clause to check the condition `ABS(v1 - v2) > 0.1`, it will return the expected
    output.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，输出的前两行似乎有相似的数字。在浮点类型的情况下可能不是这样。如果我们想要确保在前面的情况下，类似的值被认为是相似的，我们必须根据精度比较差异。例如，在前面的情况下，如果我们修改`HAVING`子句以检查条件`ABS(v1
    - v2) > 0.1`，它将返回预期的输出。
- en: As interpretation of floating point numbers is platform dependent, if we try
    to insert a value which is outside of the range of floating point data type supported
    values, it may insert +- inf or +- 0.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浮点数的解释取决于平台，如果我们尝试插入超出浮点数据类型支持的值范围的值，可能会插入+- inf或+- 0。
- en: Bit value type
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位值类型
- en: Have you ever come across a requirement to store binary representations of numbers?
    Can you think of such use cases? One such use case is to store weekly working
    days information for a year. We will touch base on this example later in the section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否曾经遇到过存储数字的二进制表示的要求？您能想到这样的用例吗？这样的用例之一是存储一年中每周的工作日信息。我们稍后将在本节中介绍这个例子。
- en: The `BIT` data type is used to store binary bits or groups of bit values. It
    is also one of the options to store Boolean, yes/no or `0/1` values.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`BIT`数据类型用于存储二进制位或位值组。它也是存储布尔值、是/否或`0/1`值的选项之一。'
- en: 'The `BIT` type column can be defined as:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`BIT`类型的列可以定义为：'
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For a `BIT` data type, `m` can vary from `1` to `64`. Supplying `m` is optional.
    The default value for `m` is `1`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`BIT`数据类型，`m`可以从`1`变化到`64`。提供`m`是可选的。`m`的默认值为`1`。
- en: 'The following is an example of how a `BIT` column can be defined:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是定义`BIT`列的示例：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After the `BIT` data type column declaration, next is storing bit values in
    a column. The bit values are a combination of zeros (0s) and ones (1s). The `b'value'`
    notation is used to specify bit values.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BIT`数据类型列声明之后，接下来是在列中存储位值。位值是零（0）和一（1）的组合。使用`b'value'`表示法来指定位值。
- en: 'The following are the examples of how to store 11 and 55 in a `BIT` column:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`BIT`列中存储11和55的示例：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What happens if the value stored in the `BIT` column is less than the number
    of bits (`m`) specified in the column definition? MySQL will pad the value with
    0s on the left of the number. So, for the preceding example, the values stored
    will be 0001011 and 0110111, respectively.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存储在`BIT`列中的值少于列定义中指定的位数(`m`)，会发生什么？MySQL将在数字左侧用0填充该值。因此，对于前面的示例，存储的值将分别为0001011和0110111。
- en: 'How do we define a `BIT` column to store `boolean_values`? The following code
    block shows that:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何定义一个`BIT`列来存储`boolean_values`？以下代码块显示了这一点：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Bit value literals
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位值字面值
- en: To store bit values in a table column, we must understand bit literals. As mentioned
    earlier, bit literals can be written using the `b'val'` notation. There is another
    notation, which is the `0bval` notation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要在表列中存储位值，我们必须了解位字面值。如前所述，位字面值可以使用`b'val'`表示法编写。还有另一种表示法，即`0bval`表示法。
- en: One important note about `b'val'` or `0bval` notations is that the letter case
    of the leading `b` doesn't matter. We can specify `b` or `B`. A leading `0b` is
    case-sensitive, and can't be replaced with `0B`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`b'val'`或`0bval`表示法的一个重要说明是，前导`b`的大小写不重要。我们可以指定`b`或`B`。前导的`0b`是大小写敏感的，不能用`0B`替换。
- en: The following is the list of legal and illegal bit value literals.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是合法和非法的位值字面值列表。
- en: 'Legal bit value literals:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 合法的位值字面值：
- en: '`b''10''`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b''10''`'
- en: '`B''11''`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`B''11''`'
- en: '`0b10`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0b10`'
- en: 'Illegal bit value literals:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 非法的位值字面值：
- en: '`b''3''` (`1` and `0` are the only binary digits)'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b''3''`（`1`和`0`是唯一的二进制数字）'
- en: '`0B01` (`0B` is not valid; it should be `0b`)'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0B01`（`0B`无效；应为`0b`）'
- en: 'As a default, a bit literal is a binary string. We can confirm this with the
    query, as shown in the following code block:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 作为默认值，位字面值是一个二进制字符串。我们可以通过查询来确认这一点，如下面的代码块所示：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Practical uses of BIT
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BIT的实际用途
- en: Let's continue with the working days per week in a year example. Please refer
    to the `working_days` table schema provided earlier.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续以一年中每周的工作日为例。请参考之前提供的`working_days`表模式。
- en: 'How can we specify that the Monday and Friday in the week `4` in the year `2017`
    are non-working days? The following is the `INSERT` query for this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何指定`2017`年第`4`周的星期一和星期五为非工作日？以下是此操作的`INSERT`查询：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we fetch the `working_days` records using the `SELECT` query, the following
    is the output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`SELECT`查询获取`working_days`记录，输出如下：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding output, the days, though being of bit data types, show integer
    values. How can we show bit values in the output?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，尽管日期是位数据类型，但显示的是整数值。我们如何在输出中显示位值呢？
- en: 'The answer is the `BIN()` MySQL function. The function converts an integer
    value to its binary representation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是`BIN()` MySQL函数。该函数将整数值转换为其二进制表示：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see, the leading zeros are removed from the days'' bit value in
    the output. To accomplish the representation in the output, on top of the `BIN`
    function, we can use the `LPAD` MySQL function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在输出中，日期的位值中的前导零被移除了。为了在输出中实现表示，除了`BIN`函数之外，我们还可以使用`LPAD` MySQL函数：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Type attributes
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型属性
- en: As shown earlier, while defining integer columns, we can also specify an optional
    display width attribute. For example, `INT(5)` indicates an integer number with
    a display width of `5` digits. When this column is used in the `SELECT` query,
    the output will display the number left padded with spaces. So, if the value stored
    in the `INT(5)` column is `123`, then it will be displayed as `__123`. The `_`
    will be a space in the actual output.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，在定义整数列时，我们还可以指定一个可选的显示宽度属性。例如，`INT(5)`表示具有`5`位数字的整数。当此列在`SELECT`查询中使用时，输出将显示左填充空格的数字。因此，如果存储在`INT(5)`列中的值为`123`，则将显示为`__123`。`_`在实际输出中将是一个空格。
- en: 'However, the display width doesn''t limit the range of values which can be
    stored in the `INT(5)` column. The question then arises: What if we store a value
    for which the display width is larger than the display width specified? The display
    width doesn''t prevent values wider than the display width of a column from being
    displayed correctly. So, values wider than the column display width are displayed
    in full width, using more than the number of digits specified with the display
    width.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，显示宽度不限制可以存储在`INT(5)`列中的值的范围。那么问题来了：如果我们存储的值大于指定的显示宽度，会怎么样？显示宽度不会阻止比列的显示宽度更宽的值正确显示。因此，比列显示宽度更宽的值将以全宽显示，使用的数字数量超过了显示宽度指定的数量。
- en: 'As mentioned earlier, MySQL column definition provides an optional attribute
    called `ZEROFILL`. This optional attribute, when specified, replaces left padded
    spaces with zeros. For example, for a column defined as the following, a value
    of 82 is retrieved as 00082:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，MySQL列定义提供了一个名为`ZEROFILL`的可选属性。当指定了这个可选属性时，它会用零替换左填充的空格。例如，对于以下定义的列，检索到的值为00082：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This optional attribute is useful where the proper formatting of numbers is
    important.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可选属性在需要正确格式化数字的情况下非常有用。
- en: The `ZEROFILL` attribute is ignored when the column value is used in expressions
    or in a `UNION` query.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当列值用于表达式或`UNION`查询时，`ZEROFILL`属性将被忽略。
- en: MySQL creates temporary tables when complicated joins are used in a query to
    store intermediate results. In such a case, we may face issues if we specified
    a column with display width. In these cases, MySQL considers that the data values
    fit within the display width.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当在查询中使用复杂的连接来存储中间结果时，MySQL会创建临时表。在这种情况下，如果我们指定了具有显示宽度的列，可能会遇到问题。在这些情况下，MySQL认为数据值适合于显示宽度。
- en: Another important attribute is `UNSIGNED`. The `UNSIGNED` attribute permits
    only non-negative values to be stored in the column. It is also useful when we
    need support for a larger range of values to be stored with the same data type.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的属性是`UNSIGNED`。`UNSIGNED`属性只允许在列中存储非负值。当我们需要支持相同数据类型的更大范围的值时，这也是非常有用的。
- en: '`UNSIGNED` is also supported by floating point types and fixed point types.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`UNSIGNED`也支持浮点类型和定点类型。'
- en: If we specify a `ZEROFILL` attribute for a column, `UNSIGNED` is automatically
    added to the column.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为列指定了`ZEROFILL`属性，`UNSIGNED`会自动添加到列中。
- en: Another important attribute for integer and floating point columns is `AUTO_INCREMENT`.
    When we insert a `NULL` value in the column defined with the `AUTO_INCREMENT`
    attribute, MySQL stores `value+1` instead of `NULL`. A value of 0 will be treated
    the same as that of a `NULL` value, unless the `NO_AUTO_VALUE_ON_ZERO` mode is
    enabled. Here, the value is the largest value stored in the column. It is extremely
    important that the column is defined as `NOT NULL`. Otherwise, the `NULL` value
    will be stored as `NULL`, even though the `AUTO_INCREMENT` attribute is provided.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 整数和浮点列的另一个重要属性是`AUTO_INCREMENT`。当我们在具有`AUTO_INCREMENT`属性的列中插入一个`NULL`值时，MySQL会存储`value+1`而不是`NULL`。值为0将被视为`NULL`值，除非启用了`NO_AUTO_VALUE_ON_ZERO`模式。在这里，值是存储在列中的最大值。非常重要的是，列被定义为`NOT
    NULL`。否则，`NULL`值将被存储为`NULL`，即使提供了`AUTO_INCREMENT`属性。
- en: Overflow handling
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 溢出处理
- en: 'When an out-of-range value is stored in the numeric type column in MySQL, the
    value stored depends on the MySQL mode:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当在MySQL中的数字类型列中存储超出范围的值时，存储的值取决于MySQL模式：
- en: If `strict` mode is enabled, MySQL will not accept the value and throw an error.
    The `insert` operation fails.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果启用了`strict`模式，MySQL将不接受该值并抛出错误。`insert`操作失败。
- en: If `restrictive` modes are enabled, the value is clipped by MySQL to an appropriate
    value, and that is what is stored in the column.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果启用了`restrictive`模式，MySQL会将值裁剪为适当的值，并将其存储在列中。
- en: Date and time data types
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期和时间数据类型
- en: '`DATE`, `TIME`, `DATETIME`, `TIMESTAMP`, and `YEAR` form the group of date
    and time data types for storing temporal values. Each of these types has a range
    of permitted values. Apart from the permitted values, a special `zero` value can
    also be used to specify an invalid value which MySQL cannot represent. The zero
    value can be 00-00-0000\. MySQL allows this value to be stored in a `date` column.
    This is sometimes more convenient than storing `NULL` values.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`DATE`、`TIME`、`DATETIME`、`TIMESTAMP`和`YEAR`构成了用于存储时间值的日期和时间数据类型组。每种类型都有一定范围的允许值。除了允许的值之外，还可以使用特殊的`零`值来指定MySQL无法表示的无效值。零值可以是00-00-0000。MySQL允许将此值存储在`date`列中。这有时比存储`NULL`值更方便。'
- en: The following are the general considerations we must take care of while working
    with date and time types.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理日期和时间类型时，我们必须注意以下一般考虑事项。
- en: The way MySQL treats storage and retrieval operations for date or time types
    is different in the context of the format. Basically, for a date or time type
    value stored in the table, MySQL retrieves values in a standard output format.
    In the case of inputting a date or time type value, MySQL attempts to apply different
    formats on the supplied input value. So, it is expected that the supplied value
    is valid, or unexpected results may occur if used values in unsupported formats.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL对于日期或时间类型的存储和检索操作在格式的上下文中是不同的。基本上，对于存储在表中的日期或时间类型值，MySQL以标准输出格式检索值。在输入日期或时间类型值的情况下，MySQL尝试对提供的输入值应用不同的格式。因此，预期提供的值是有效的，否则如果使用不受支持的格式中的值，则可能会出现意外结果。
- en: Though MySQL can interpret input values with several different formats, parts
    of the date value must be supplied in a year-month-day format. For example, 2017-10-22
    or 16-02-14.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管MySQL可以解释多种不同格式的输入值，但日期值的部分必须以年-月-日的格式提供。例如，2017-10-22或16-02-14。
- en: 'Supplying a two-digit year creates ambiguity for MySQL to interpret the year
    because of the unknown century. The following are the rules that must be followed,
    using which MySQL interprets two-digit year values:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 提供两位数年份会导致 MySQL 解释年份时出现歧义，因为世纪未知。以下是必须遵循的规则，使用这些规则，MySQL 解释两位数年份值：
- en: Year values between 70-99 are converted to 1970-1999
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 70-99 年之间的年份值会被转换为 1970-1999
- en: Year values between 00-69 are converted to 2000-2069
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 00-69 年之间的年份值会被转换为 2000-2069
- en: It is possible to convert a value from one temporal type to another temporal
    type following certain rules. We will discuss these rules later in the chapter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按照一定的规则将一个时间类型的数值转换为另一个时间类型。我们将在本章后面讨论这些规则。
- en: If the date or time value is used in a numeric context, MySQL will automatically
    convert the value to a number.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果日期或时间数值在数值上下文中使用，MySQL 会自动将该数值转换为数字。
- en: We have one interesting use case. We want to develop an audit log feature where
    we store every user-entered value. Suppose that in one of the date fields, the
    user entered an invalid date, 2017-02-31\. Will this be stored in the audit log
    table? Certainly not. How do we complete the feature, then? MySQL has the `ALLOW_INVALID_DATES`
    mode. If enabled, it will allow invalid dates to be stored. With this mode enabled,
    MySQL verifies that the month is in the range of 1-12 and day is in the range
    of 1-31.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个有趣的用例。我们想要开发一个审计日志功能，用于存储用户输入的每个数值。假设在其中一个日期字段中，用户输入了一个无效的日期，2017-02-31。这会被存储在审计日志表中吗？当然不会。那么我们该如何完成这个功能呢？MySQL
    有一个 `ALLOW_INVALID_DATES` 模式。如果启用了这个模式，它将允许存储无效的日期。启用了这个模式后，MySQL 会验证月份是否在 1-12
    的范围内，日期是否在 1-31 的范围内。
- en: As ODBC cannot handle zero values for date or time, such values used through
    Connector/ODBC are converted to `NULL`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ODBC无法处理日期或时间的零值，通过 Connector/ODBC 使用这些数值时会被转换为 `NULL`。
- en: 'Following table shows zero values for different data types:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了不同数据类型的零值：
- en: '| **Data Type** | **Zero Value** |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| **数据类型** | **零值** |'
- en: '| `DATE` | 0000-00-00 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `DATE` | 0000-00-00 |'
- en: '| `TIME` | 00:00:00 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `TIME` | 00:00:00 |'
- en: '| `DATETIME` | 0000-00-00 00:00:00 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `DATETIME` | 0000-00-00 00:00:00 |'
- en: '| `TIMESTAMP` | 0000-00-00 00:00:00 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `TIMESTAMP` | 0000-00-00 00:00:00 |'
- en: '| `YEAR` | 0000 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `YEAR` | 0000 |'
- en: Reference: [https://dev.mysql.com/doc/refman/8.0/en/date-and-time-types.html](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-types.html)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 参考：[https://dev.mysql.com/doc/refman/8.0/en/date-and-time-types.html](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-types.html)
- en: 'The preceding table shows `zero` values for different temporal data types.
    These are special values, as these are allowed by MySQL and are very useful in
    certain cases. We can also specify `zero` values using `''0''` or `0`. MySQL has
    an interesting mode configuration: `NO_ZERO_DATE`. If this configuration is enabled,
    MySQL shows a warning if the temporal type has a value with the date as `zero`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 上表显示了不同时间数据类型的零值。这些是特殊值，因为它们被 MySQL 允许，并且在某些情况下非常有用。我们还可以使用 `'0'` 或 `0` 来指定零值。MySQL
    有一个有趣的模式配置：`NO_ZERO_DATE`。如果启用了这个配置，当时间类型的数值为零时，MySQL 会显示警告。
- en: DATE, DATETIME, and TIMESTAMP types
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DATE、DATETIME 和 TIMESTAMP 类型
- en: This section describes the most commonly used MySQL date and time data types: `DATE`,
    `DATETIME`, and `TIMESTAMP`. This section explains the similarities and differences
    between these data types.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了最常用的 MySQL 日期和时间数据类型：`DATE`、`DATETIME` 和 `TIMESTAMP`。本节解释了这些数据类型之间的相似之处和不同之处。
- en: The `DATE` data type is suitable when the values we wish to store have a date
    part, but the time part is missing. The standard MySQL date format is YYYY-MM-DD.
    The date values are retrieved and displayed in the standard format unless `DATE`
    functions are applied. The MySQL supported range of values is 1000-01-01 to 9999-12-31\.
    Supported, here, means the values may work, but there is no guarantee. The same
    is the case for the `DATETIME` data type.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`DATE` 数据类型适用于我们希望存储的数值具有日期部分，但缺少时间部分的情况。标准的 MySQL 日期格式是 YYYY-MM-DD。日期数值在未应用
    `DATE` 函数的情况下以标准格式检索和显示。MySQL 支持的数值范围是 1000-01-01 到 9999-12-31。这里的“支持”意味着这些数值可能有效，但不能保证。`DATETIME`
    数据类型也是如此。'
- en: The `DATETIME` data type is suitable for values containing date and time parts.
    The standard MySQL `DATETIME` format is YYYY-MM-DD HH:MM:SS. The supported range
    of values is 1000-01-01 00:00:00 to 9999-12-31 23:59:59.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`DATETIME` 数据类型适用于包含日期和时间部分的数值。标准的 MySQL `DATETIME` 格式是 YYYY-MM-DD HH:MM:SS。支持的数值范围是
    1000-01-01 00:00:00 到 9999-12-31 23:59:59。'
- en: Similar to `DATETIME`, the `TIMESTAMP` data type is also suitable for values
    containing date and time parts. However, the range of values supported by the `TIMESTAMP`
    data type is 1970-01-01 00:00:01 UTC to 2038-01-19 03:14:07 UTC.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `DATETIME` 类似，`TIMESTAMP` 数据类型也适用于包含日期和时间部分的数值。然而，`TIMESTAMP` 数据类型支持的数值范围是从
    1970-01-01 00:00:01 UTC 到 2038-01-19 03:14:07 UTC。
- en: 'Though they look similar, the `DATETIME` and `TIMESTAMP` data types differ
    significantly:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们看起来相似，`DATETIME` 和 `TIMESTAMP` 数据类型有着显著的不同：
- en: The `TIMESTAMP` data type requires 4 bytes to store date and time values. The `DATETIME`
    data type requires 5 bytes to store date and time values.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIMESTAMP` 数据类型需要 4 个字节来存储日期和时间数值。`DATETIME` 数据类型需要 5 个字节来存储日期和时间数值。'
- en: '`TIMESTAMP` can store values till 2038-01-19 03:14:07 UTC. If we wish to store
    values beyond 2038, the `DATETIME` data type should be used.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIMESTAMP` 可以存储值直到 2038-01-19 03:14:07 UTC。如果希望存储超过 2038 年的值，则应使用 `DATETIME`
    数据类型。'
- en: '`TIMESTAMP` considers UTC as the time zone while storing values. `DATETIME`
    stores values without time zone consideration.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIMESTAMP` 在存储数值时将UTC视为时区，`DATETIME` 则在存储数值时不考虑时区。'
- en: Let's use an example to understand the difference between `DATETIME` and `TIMESTAMP`
    within the context of `time_zone`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解 `time_zone` 上下文中 `DATETIME` 和 `TIMESTAMP` 之间的差异。
- en: 'Suppose the initial `time_zone` value is set to `+00:00`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 假设初始的 `time_zone` 值设置为 `+00:00`：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s create a table called `datetime_temp`. The table has two columns; one
    is `DATETIME` and another is of the type `TIMESTAMP`. We will store the same date
    and time values in both columns. With the help of the `SELECT` query, we will
    try to understand how the representations differ in output:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`datetime_temp`的表。该表有两列；一列是`DATETIME`，另一列是`TIMESTAMP`类型。我们将在两列中存储相同的日期和时间值。借助`SELECT`查询，我们将尝试了解输出中表示的差异：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding example, `NOW()` is the MySQL function which returns the current
    date and time values. Looking at the output, it seems that both the `TIMESTAMP`
    and `DATETIME` representations are same. It is because the `time_zone` value is
    set to UTC. By default, `TIMESTAMP` shows the date time value considering the
    UTC `time_zone`. On the other part, `DATETIME` shows date time without a `time_zone`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`NOW()`是MySQL函数，它返回当前的日期和时间值。从输出来看，似乎`TIMESTAMP`和`DATETIME`的表示是相同的。这是因为`time_zone`值设置为UTC。默认情况下，`TIMESTAMP`显示考虑UTC
    `time_zone`的日期时间值。另一方面，`DATETIME`显示不带`time_zone`的日期时间。
- en: 'Let''s change the `time_zone` and observe the output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改`time_zone`并观察输出：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Looking at the output, it is clear that the `TIMESTAMP` considers the `time_zone`
    value set in MySQL. So, the `TIMESTAMP` value got adjusted when we changed the
    time zone. `DATETIME` isn't impacted, so the output is not changed, even after
    changing the time zone.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出来看，很明显`TIMESTAMP`考虑了MySQL中设置的`time_zone`值。因此，当我们更改时区时，`TIMESTAMP`值会调整。`DATETIME`不受影响，因此即使在更改时区后，输出也不会改变。
- en: If `TIMESTAMP` is used to store date and time values, we must consider it seriously
    when migrating data to a different server located in a different time zone.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`TIMESTAMP`存储日期和时间值，我们在将数据迁移到位于不同时区的不同服务器时必须认真考虑它。
- en: If higher precision for the time value is required, `DATETIME` and `TIMESTAMP`
    can include trailing fractional seconds as small as microseconds (six digits).
    So, if we insert a date time value with a microseconds value, it will be stored
    in the database. The format, including the fractional part, is YYYY-MM-DD HH:MM:SS[.fraction],
    and the range is from 1000-01-01 00:00:00.000000 to 9999-12-31 23:59:59.999999\.
    The range for `TIMESTAMP`, including the fraction, is 1970-01-01 00:00:01.000000
    to 2038-01-19 03:14:07.999999.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更高精度的时间值，`DATETIME`和`TIMESTAMP`可以包括最多微秒（六位数字）的尾随分数秒。因此，如果我们插入一个带有微秒值的日期时间值，它将存储在数据库中。格式，包括分数部分，是YYYY-MM-DD
    HH:MM:SS[.fraction]，范围是从1000-01-01 00:00:00.000000到9999-12-31 23:59:59.999999。`TIMESTAMP`的范围，包括分数，是1970-01-01
    00:00:01.000000到2038-01-19 03:14:07.999999。
- en: The fractional part is separated from the time value by a decimal point because
    MySQL doesn't recognize any other delimiter for fractional seconds.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 时间值的小数部分通过小数点与时间值分隔，因为MySQL不识别其他分数秒的分隔符。
- en: Date and time values stored with the `TIMESTAMP` data type are converted from
    the server's time zone to UTC for storage and from UTC to the server's time zone
    for retrieval. If we stored a `TIMESTAMP` value and then changed the server's
    time zone and retrieved the value, the retrieved value would be different from
    the one we stored.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`TIMESTAMP`数据类型存储的日期和时间值会从服务器的时区转换为UTC进行存储，并从UTC转换为服务器的时区进行检索。如果我们存储了一个`TIMESTAMP`值，然后更改了服务器的时区并检索该值，则检索到的值将与我们存储的值不同。
- en: 'The following is the list of properties of date value interpretation in MySQL:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是MySQL中日期值解释的属性列表：
- en: MySQL supports a relaxed format for values specified as string. In a relaxed
    format, any punctuation character can be used as the delimiter between date parts
    or time parts. This is a little bit confusing. For example, a value `10:11:12`
    might look like a time value because of the use of `:`, but is interpreted as
    a `2010-11-12` date.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL支持以字符串指定的值的宽松格式。在宽松格式中，任何标点字符都可以用作日期部分或时间部分之间的分隔符。这有点令人困惑。例如，值`10:11:12`可能看起来像一个时间值，因为使用了`:`，但被解释为`2010-11-12`日期。
- en: The only recognized delimiter between the rest of the time part and the fractional
    seconds part is the decimal point.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其余时间部分和分数秒部分之间的唯一识别分隔符是小数点。
- en: It is expected that month and day values are valid. With `strict` mode disabled,
    invalid dates are converted to respective `zero` values and a warning message
    is shown.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期月份和日期值是有效的。在禁用`strict`模式的情况下，无效日期将转换为相应的`zero`值，并显示警告消息。
- en: '`TIMESTAMP` values that include zero in the day or month column are not a valid
    date. The exception to this rule is the `zero` value.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`TIMESTAMP`值中，如果日期或月份列中包含零，则不是有效日期。这条规则的例外是`zero`值。
- en: If MySQL is run with `MAXDB` mode enabled, `TIMESTAMP` is identical to `DATETIME`.
    If this mode is enabled at the time of table creation, `TIMESTAMP` values are
    converted to `DATETIME`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果MySQL以启用`MAXDB`模式运行，`TIMESTAMP`与`DATETIME`相同。如果在表创建时启用了此模式，则`TIMESTAMP`值将转换为`DATETIME`。
- en: MySQL DATETIME functions
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQL DATETIME函数
- en: '`NOW()` is the function used to get the current date and time of the system:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`NOW()`是用于获取系统当前日期和时间的函数：'
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `DATE()` function is used to extract date information from the `DATETIME`
    value:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`DATE()`函数用于从`DATETIME`值中提取日期信息：'
- en: '[PRE24]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `TIME()` function is used to extract time information from a date time
    value:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`TIME()`函数用于从日期时间值中提取时间信息：'
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `DATE()` and `TIME()` functions are very useful when you want to display
    or query a database table based on the date or time value, but the actual value
    stored in the table contains date and time information.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当您希望基于日期或时间值显示或查询数据库表时，`DATE()`和`TIME()`函数非常有用，但表中存储的实际值包含日期和时间信息。
- en: 'If we want to extract `YEAR`, `MONTH`, `DAY`, `QUARTER`, `WEEK`, `HOUR`, `MINUTE`,
    and `SECOND` information from `DATETIME` or `TIMESTAMP` values, respective functions
    are available:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想从`DATETIME`或`TIMESTAMP`值中提取`YEAR`、`MONTH`、`DAY`、`QUARTER`、`WEEK`、`HOUR`、`MINUTE`和`SECOND`信息，相应的函数是可用的：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: TIME type
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TIME类型
- en: MySQL `DATETIME` or `TIMESTAMP` data types are used to represent specific times
    at particular dates. How about storing only the time of the day or the time difference
    between two events? MySQL's `TIME` data type serves the purpose.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL的`DATETIME`或`TIMESTAMP`数据类型用于表示特定日期的特定时间。只存储一天中的时间或两个事件之间的时间差怎么办？MySQL的`TIME`数据类型可以满足这一需求。
- en: The standard MySQL format for storing or displaying `TIME` data type values
    is `HH:MM:SS`. The time value represents the time of the day, which is less than
    24 hours, but the `TIME` data type, as mentioned earlier, can also be used to
    stored elapsed time or time difference between two events. So, the `TIME` column
    can store values greater than 24 hours.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 存储或显示`TIME`数据类型值的标准MySQL格式是`HH:MM:SS`。时间值表示一天中的时间，小于24小时，但是如前所述，`TIME`数据类型也可以用于存储经过的时间或两个事件之间的时间差。因此，`TIME`列可以存储大于24小时的值。
- en: 'The MySQL `TIME` column is defined as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL的`TIME`列定义如下：
- en: '[PRE27]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The range of values that can be stored in the `TIME` data type column is -838:59:59
    to 838:59:59.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`TIME`数据类型列中可以存储的值的范围是-838:59:59到838:59:59。'
- en: The MySQL `TIME` column can also store the fractional seconds part up to microseconds
    (six digits), similar to the `DATETIME` column. Considering the fractional second
    precision, the range of values varies from -838:59:59.000000 to 838:59:59.00000.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL的`TIME`列还可以存储小数秒部分，最多可以达到微秒（六位数字），类似于`DATETIME`列。考虑到小数秒精度，值的范围从-838:59:59.000000到838:59:59.00000。
- en: 'The MySQL `TIME` column can also have an optional value:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL的`TIME`列也可以有一个可选值：
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `TIME` value usually takes 3 bytes for storage. In the case of the `TIME`
    value including fractional second precision, it will require additional bytes,
    based on the number of fractional second precision.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`TIME`值通常需要3个字节来存储。在包括小数秒精度的`TIME`值的情况下，将需要额外的字节，取决于小数秒精度的数量。'
- en: 'The following table shows the number of additional bytes required to store
    fractional-second precision:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了存储小数秒精度所需的额外字节数：
- en: '| **Fractional Second Precision** | **Storage (bytes)** |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| **小数秒精度** | **存储（字节）** |'
- en: '| 0 | 0 |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 |'
- en: '| 1, 2 | 1 |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 1, 2 | 1 |'
- en: '| 3, 4 | 2 |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 3, 4 | 2 |'
- en: '| 5, 6 | 3 |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 5, 6 | 3 |'
- en: 'MySQL supports abbreviated values for the `TIME` column. There are two distinct
    ways for MySQL to interpret abbreviated values:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL支持`TIME`列的缩写值。MySQL有两种不同的方式来解释缩写值：
- en: If the abbreviated value has a colon(`:`), MySQL interprets it as time of the
    day. For example, 11:12 is interpreted as 11:12:00 and not as 00:11:12.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果缩写值有冒号（`:`），MySQL将其解释为一天中的时间。例如，11:12被解释为11:12:00，而不是00:11:12。
- en: If the abbreviated value doesn't have a colon(`:`), MySQL assumes that the two
    rightmost digits represent seconds. This means the value is interpreted as elapsed
    time, rather than time of the day. For example, '1214' and 1214 are interpreted
    by MySQL as 00:12:14.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果缩写值没有冒号（`:`），MySQL假定最右边的两位数字代表秒。这意味着该值被解释为经过的时间，而不是一天中的时间。例如，'1214'和1214被MySQL解释为00:12:14。
- en: The decimal point is the only delimiter accepted by MySQL to separate fractional
    second precision from the rest of the time value parts.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL接受的唯一分隔符是小数点，用于将小数秒精度与时间值的其余部分分开。
- en: MySQL, by default, clips the values that lie outside of the permitted range
    of values to the closest endpoint of the range. For example, -880:00:00 and 880:00:00
    are stored as -838:59:59 and 838:59:59\. Invalid `TIME` values are converted to
    00:00:00\. As 00:00:00 itself is a valid `TIME` value, it is difficult to know
    if the value 00:00:00 was stored intentionally, or converted from an invalid `TIME`
    value.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL默认情况下，将超出允许值范围的值裁剪到范围的最近端点。例如，-880:00:00和880:00:00存储为-838:59:59和838:59:59。无效的`TIME`值转换为00:00:00。由于00:00:00本身是有效的`TIME`值，很难知道值00:00:00是有意存储的，还是从无效的`TIME`值转换而来。
- en: MySQL accepts string and numeric values as the `TIME` values.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL接受字符串和数字值作为`TIME`值。
- en: Time functions
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间函数
- en: 'The `CURRENT_TIME()` function can be used to find the current time on the server.
    It is also possible to add or subtract time values using the `ADDTIME` and `SUBTIME`
    functions. For example, the following example adds two hours to the server''s
    current time:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`CURRENT_TIME()`函数可用于查找服务器上的当前时间。还可以使用`ADDTIME`和`SUBTIME`函数添加或减去时间值。例如，以下示例将两小时添加到服务器的当前时间：'
- en: '[PRE29]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `UTC_TIME()` function can be used to fetch the UTC time.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`UTC_TIME()`函数可用于获取UTC时间。'
- en: YEAR type
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 年份类型
- en: What is the preferred data type for storing manufacturing year? MySQL's answer
    to this is a `YEAR` data type. The `YEAR` data type requires 1 byte to store year
    information.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 存储制造年份的首选数据类型是什么？MySQL的答案是`YEAR`数据类型。`YEAR`数据类型需要1个字节来存储年份信息。
- en: 'A `YEAR` column can be declared as:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`YEAR`列可以声明为：'
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: One notable thing is that earlier MySQL versions supported the `YEAR(2)` type
    column declaration. The support for `YEAR(2)` has been discontinued from MySQL
    8\. It is possible that we might want to upgrade the older MySQL database to the
    MySQL 8 database. In a later section, we will explain the migration details from
    `YEAR(2)` to `YEAR(4)`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，早期的MySQL版本支持`YEAR(2)`类型的列声明。从MySQL 8开始，不再支持`YEAR(2)`。可能需要将旧的MySQL数据库升级到MySQL
    8数据库。在后面的部分中，我们将解释从`YEAR(2)`到`YEAR(4)`的迁移细节。
- en: MySQL represents `YEAR` values in a YYYY format. The range of values is from
    1901 to 2155 and 0000.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL以YYYY格式表示`YEAR`值。值的范围是从1901年到2155年和0000年。
- en: 'The following is the list of formats supported for inputting `YEAR` values:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输入`YEAR`值支持的格式列表：
- en: Four digit number from 1901 to 2155.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从1901年到2155年的四位数。
- en: Four digit string from 1901 to 2155.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从1901年到2155年的四位字符串。
- en: One or two digit number with the range of 0 to 99\. `YEAR` values from 1 to
    69 are converted to 2001 to 2069 and from 70 to 99 are converted to 1970 to 1999.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0到99范围内的一位或两位数字。`YEAR`值从1到69转换为2001到2069，从70到99转换为1970到1999。
- en: One or two digit string with the range of 0 to 99\. `YEAR` values from 1 to
    69 are converted to 2001 to 2069 and from 70 to 99 are converted to 1970 to 1999.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围为0到99的一位或两位数字字符串。`YEAR`值从1到69转换为2001到2069，从70到99转换为1970到1999。
- en: Inserting a numeric 0 has a display value of 0000 and an internal value of 0000\.
    If we want to insert 0 and want it to be interpreted as 2000, we should specify
    it as a string 0 or 00.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入数字0的显示值为0000，内部值为0000。如果我们想要插入0并希望它被解释为2000，我们应该将其指定为字符串0或00。
- en: The result of a function that returns an acceptable value `YEAR` context, for
    example, `NOW()`.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回可接受值`YEAR`上下文的函数的结果，例如`NOW()`。
- en: MySQL converts invalid `YEAR` values to 0000.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL将无效的`YEAR`值转换为0000。
- en: Migrating YEAR(2) to YEAR(4)
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将YEAR(2)迁移到YEAR(4)
- en: 'As mentioned earlier, MySQL 8 doesn''t support the `YEAR(2)` type. Trying to
    create a column with `YEAR(2)` as a data type will give an error as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，MySQL 8不支持`YEAR(2)`类型。尝试创建一个数据类型为`YEAR(2)`的列将会产生以下错误：
- en: '[PRE31]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `ALTER TABLE` query, which rebuilds the table, will automatically convert
    `YEAR(2)` to `YEAR(4)`. The `YEAR(2)` column, after upgrading the database to
    the MySQL 8 database, remains as `YEAR(2)`, but the queries give errors.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 重建表的`ALTER TABLE`查询将自动将`YEAR(2)`转换为`YEAR(4)`。在将数据库升级到MySQL 8数据库后，`YEAR(2)`列仍然保持为`YEAR(2)`，但查询会报错。
- en: 'There are multiple ways to migrate from `YEAR(2)` to `YEAR(4)`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以从`YEAR(2)`迁移到`YEAR(4)`：
- en: Using the `ALTER TABLE` query with `FORCE` attribute converts the `YEAR(2)`
    column to `YEAR(4)`. It doesn't convert the values, though. If the `ALTER TABLE`
    query is applied to a replication master, the replication slaves will replicate
    the `ALTER TABLE` statement. So, the change will be available on all the replication
    nodes.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用带有`FORCE`属性的`ALTER TABLE`查询将`YEAR(2)`列转换为`YEAR(4)`。但它不会转换值。如果`ALTER TABLE`查询应用于复制主机，复制从机将复制`ALTER
    TABLE`语句。因此，更改将在所有复制节点上可用。
- en: Using binary upgrade, without dumping or reloading data, is another way of upgrading
    `YEAR(2)` to `YEAR(4)`. Running `mysql_upgrade` subsequently executes `REPAIR_TABLE` and
    converts `YEAR(2)` to `YEAR(4)` without changing values. Similar to the previous
    alternative, this will be replicated in replication slaves if it is applied to
    a replication master.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用二进制升级，无需转储或重新加载数据，是将`YEAR(2)`升级到`YEAR(4)`的另一种方法。随后运行`mysql_upgrade`会执行`REPAIR_TABLE`并将`YEAR(2)`转换为`YEAR(4`，而不更改值。与前一个替代方案类似，如果应用于复制主机，则会在复制从机中复制此更改。
- en: An important thing to note is that while upgrading, we must not dump the `YEAR(2)`
    data with `mysqldump` and reload the dump file after upgrading. This method has
    the potential to change the `YEAR(2)` values significantly.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，在升级时，我们不应该使用`mysqldump`转储`YEAR(2)`数据，并在升级后重新加载转储文件。这种方法有可能显著改变`YEAR(2)`的值。
- en: 'Before `YEAR(2)` to `YEAR(4)` migration, application code must be reviewed
    for:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行`YEAR(2)`到`YEAR(4)`迁移之前，必须审查应用程序代码：
- en: Code that selects the `YEAR` value in two digits.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择以两位数字显示`YEAR`值的代码。
- en: Code that doesn't handle numeric `0` insertions. Inserting `0` into `YEAR(2)`
    results in `2000`, whereas inserting `0` into `YEAR(4)` results into `0000`.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不处理数字`0`插入的代码。将`0`插入`YEAR(2)`会得到`2000`，而将`0`插入`YEAR(4)`会得到`0000`。
- en: String data types
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串数据类型
- en: 'Which is the most widely required and used data type for representing values?
    String or character data types; it''s easy, right? MySQL supports a wide range
    of string data types to fulfill different storage requirements. String data types
    are categorized into two categories: fixed length and variable length. `CHAR`,
    `VARCHAR`, `BINARY`, `VARBINARY`, `BLOB`, `TEXT`, `ENUM`, and `SET` are the MySQL-supported
    string data types. The storage requirement for each data type is different and
    will be explained later in a separate section.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种数据类型是表示值最广泛需要和使用的？字符串还是字符数据类型；很容易，对吧？MySQL支持各种字符串数据类型，以满足不同的存储需求。字符串数据类型分为两类：固定长度和可变长度。`CHAR`、`VARCHAR`、`BINARY`、`VARBINARY`、`BLOB`、`TEXT`、`ENUM`和`SET`是MySQL支持的字符串数据类型。每种数据类型的存储需求都不同，将在单独的部分中进行解释。
- en: CHAR and VARCHAR data types
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CHAR和VARCHAR数据类型
- en: 'The `CHAR` data type is a fixed-length string data type in MySQL. The `CHAR`
    data type is often declared with a maximum number of characters that can be stored
    as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`CHAR`数据类型是MySQL中的固定长度字符串数据类型。`CHAR`数据类型通常声明为可以存储的最大字符数，如下所示：'
- en: '[PRE32]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding example, the data column can store string values that are capable
    of storing maximum characters.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，数据列可以存储能够存储最大字符的字符串值。
- en: '`CHAR` and `VARCHAR` are similar in many ways, with certain differences. The `CHAR`
    data type is preferred if the string values to be stored are of fixed size. It
    will give better performance compared to if `VARCHAR` is used for fixed size strings.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`CHAR`和`VARCHAR`在许多方面相似，但也有一些区别。如果要存储的字符串值是固定大小的，首选`CHAR`数据类型。与对固定大小字符串使用`VARCHAR`相比，它将提供更好的性能。'
- en: 'The lengths vary from 0 to 255\. The value in the `CHAR` column cannot exceed
    the maximum length declared at the time of table creation. If the length of the
    string is less than the maximum allowed length, MySQL adds padding on the right
    to the length specified. At the time of retrieval, trailing spaces are removed.
    The following is an example:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 长度从0到255不等。`CHAR`列中的值不能超过表创建时声明的最大长度。如果字符串的长度小于允许的最大长度，MySQL会在右侧添加填充以达到指定的长度。在检索时，尾随空格会被移除。以下是一个例子：
- en: '[PRE33]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As we can observe in the preceding example, the second record was inserted as
    `' a '`, but in the output, the trailing space is removed. So, the length is displayed
    to be `2` instead of `3`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的例子中所观察到的，第二条记录被插入为`' a '`, 但在输出中，尾随空格被移除。因此，长度显示为`2`而不是`3`。
- en: Most MySQL collations have a pad attribute. It determines how trailing spaces
    are treated for comparison of non-binary strings. There are two types of collations: `PAD
    SPACE` and `NO PAD`. In case of `PAD SPACE` collation, trailing spaces are not
    considered in comparison. Strings are compared without regard to trailing spaces.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数MySQL排序规则都有填充属性。它确定如何处理非二进制字符串的尾随空格进行比较。有两种类型的排序规则：`PAD SPACE`和`NO PAD`。在`PAD
    SPACE`排序规则的情况下，尾随空格在比较时不被考虑。字符串在不考虑尾随空格的情况下进行比较。
- en: 'In the case of `NO PAD` collation, the trailing spaces are treated as any other
    character. The following is an example:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在`NO PAD`排序规则的情况下，尾随空格被视为任何其他字符。以下是一个示例：
- en: '[PRE34]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`LIKE` is a MySQL operator used for comparison in the `WHERE` clause. It is
    specifically used for pattern searching in a string. Trailing spaces are significant
    when comparing string values with the `LIKE` operator.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`LIKE`是MySQL中用于`WHERE`子句中的比较的运算符。它专门用于在字符串中进行模式搜索。在使用`LIKE`运算符比较字符串值时，尾随空格是重要的。'
- en: If `PAD_CHAR_TO_FULL_LENGTH` mode is enabled, at the time of retrieval, the
    trailing spaces will not be removed.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了`PAD_CHAR_TO_FULL_LENGTH`模式，在检索时，尾随空格将不会被移除。
- en: The MySQL `VARCHAR` data type is a variable length string data type with a maximum
    length of up to 65,535 characters. `VARCHAR` values are stored by MySQL as a one
    or two byte length prefix, along with actual data. The actual maximum length of
    a `VARCHAR` is subject to the maximum row size, which is 65,536 bytes shared among
    all columns.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL `VARCHAR`数据类型是一个最大长度为65,535个字符的可变长度字符串数据类型。`VARCHAR`值由MySQL存储为一个或两个字节的长度前缀，以及实际数据。`VARCHAR`的实际最大长度取决于最大行大小，最大行大小为65,536字节，共享在所有列之间。
- en: If the `VARCHAR` value requires less than 255 bytes, one byte is used for determining
    length prefix. If the value requires more than 255 bytes, two bytes are used for
    determining length prefix.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`VARCHAR`值需要的字节数少于255字节，则使用一个字节来确定长度前缀。如果值需要的字节数超过255字节，则使用两个字节来确定长度前缀。
- en: If MySQL strict mode is enabled and a value to be inserted in the `CHAR` or
    `VARCHAR` column value exceeds the maximum length, an error will be generated.
    If strict mode is disabled, the value will be truncated to the maximum allowed
    length with a warning.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了MySQL严格模式，并且要插入的`CHAR`或`VARCHAR`列值超过了最大长度，则会生成错误。如果禁用了严格模式，则该值将被截断为最大允许长度，并生成警告。
- en: Unlike in the `CHAR` data type, values to be stored in `VARCHAR` are not padded.
    Also, trailing spaces are not removed when the values are retrieved.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 与`CHAR`数据类型不同，要存储在`VARCHAR`中的值不会填充。此外，检索值时也不会去除尾随空格。
- en: BINARY and VARBINARY data types
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BINARY和VARBINARY数据类型
- en: Another set of MySQL string data types is `BINARY` and `VARBINARY`. These are
    similar to `CHAR` and `VARCHAR` data types. An important difference between `CHAR`/`VARCHAR`
    and `BINARY`/`VARBINARY` is that `BINARY`/`VARBINARY` data types contain binary
    strings than character strings. `BINARY`/`VARBINARY` uses binary character sets
    and collation. `BINARY`/`VARBINARY` are different from `CHAR BINARY` and `VARCHAR
    BINARY` data types. The basic difference lies in the character set and collation
    referred to.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 另一组MySQL字符串数据类型是`BINARY`和`VARBINARY`。这些与`CHAR`和`VARCHAR`数据类型类似。`CHAR`/`VARCHAR`和`BINARY`/`VARBINARY`之间的一个重要区别是`BINARY`/`VARBINARY`数据类型包含的是二进制字符串而不是字符字符串。`BINARY`/`VARBINARY`使用二进制字符集和排序规则。`BINARY`/`VARBINARY`与`CHAR
    BINARY`和`VARCHAR BINARY`数据类型不同。基本区别在于所涉及的字符集和排序规则。
- en: The maximum length for permitted values is similar to that of `CHAR` and `VARCHAR`.
    The only difference is that the length of `BINARY` and `VARBINARY` is in bytes,
    rather than characters.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 允许值的最大长度与`CHAR`和`VARCHAR`的最大长度类似。唯一的区别是`BINARY`和`VARBINARY`的长度是以字节而不是字符计算的。
- en: How would MySQL compare binary values? The answer is that the comparison happens
    based on the numeric values for the bytes in the values.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL如何比较二进制值？答案是基于值中字节的数值进行比较。
- en: Similar to `CHAR`/`VARCHAR` data types, the values are truncated if the length
    of the value exceeds the column length, and a warning is generated. This is if `strict`
    mode is not enabled. If `strict` mode is enabled, an error is generated.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 与`CHAR`/`VARCHAR`数据类型类似，如果值的长度超过列长度，将截断值并生成警告（如果未启用`strict`模式）。如果启用了`strict`模式，将生成错误。
- en: '`BINARY` values are right-padded with the pad value 0x00 (zero bytes) to the
    specified column length. The pad value is added on insert, but no trailing bytes
    are removed on retrieval. While comparing `BINARY` values, all bytes are considered
    significant. This applies to `ORDER BY` and `DISTINCT` operators, as well. Zero
    bytes and spaces are different when compared with *0x00 < space*. The following
    is an example of inserting a binary value:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`BINARY`值在指定列长度右侧填充了填充值0x00（零字节）。插入时添加填充值，但在检索时不会删除尾随字节。在比较`BINARY`值时，所有字节都被视为重要。这也适用于`ORDER
    BY`和`DISTINCT`运算符。当与*0x00 < space*进行比较时，零字节和空格是不同的。以下是插入二进制值的示例：'
- en: '[PRE35]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this case, `'a '` becomes `'a \0'` on insertion. `'a\0'` is converted to
    `'a\0\0`'. On retrieval, values remain unchanged.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，插入时`'a'`变成`'a\0'`。`'a\0'`转换为`'a\0\0'`。在检索时，值保持不变。
- en: '`VARBINARY` is a variable length string data type. Unlike `BINARY`, for `VARBINARY`,
    padding is not added on insertion and bytes are not stripped on retrieval. Similar
    to `BINARY`, all bytes are significant in comparison for `VARBINARY`.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`VARBINARY`是一个可变长度字符串数据类型。与`BINARY`不同，`VARBINARY`在插入时不会添加填充，在检索时也不会去除字节。与`BINARY`类似，所有字节在比较`VARBINARY`时都是重要的。'
- en: If the table has a unique index on columns, insertion of values in the column
    differing only in number of trailing pad bytes will give a duplicate-key error.
    For example, if such a column contains `'a '` and we try to insert `'a\0'`, it
    will cause a duplicate-key error.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表在列上有唯一索引，那么在列中插入仅在尾随填充字节数量上不同的值将导致重复键错误。例如，如果这样的列包含`'a '`，并且我们尝试插入`'a\0'`，将导致重复键错误。
- en: 'The following example explains the padding of `BINARY` values in comparison:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例解释了在比较中`BINARY`值的填充：
- en: '[PRE36]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the case that it is required to retrieve the same value as specified without
    padding, `VARBINARY` is preferable.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要检索与指定的相同值但不需要填充的情况下，最好使用`VARBINARY`。
- en: If the value retrieved must be the same as the value specified for storage with
    no padding, it might be preferable to use `VARBINARY` or one of the `BLOB` data
    types instead.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果检索的值必须与指定的存储值相同且不填充，可能更适合使用`VARBINARY`或`BLOB`数据类型之一。
- en: BLOB and TEXT data types
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BLOB和TEXT数据类型
- en: In what situation could we be required to store data in a **Binary Large Object** (**BLOB**)
    column? Any idea? Storing a file or image, you said? It is partially true. Before
    we make a decision to store the images or files in a database or file system,
    we need to assess the situation. If the files are stored in a file system and
    migrated over to another operating system, it is possible that file pointers could
    get corrupted. It will require additional efforts to fix the file pointers. In
    such a case, storing files in a database is preferable. However, it might impact
    performance if we store a large clogged file or image data in the database.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在什么情况下我们可能需要将数据存储在**二进制大对象**（**BLOB**）列中？有任何想法吗？存储文件或图像，你说？这部分是正确的。在我们决定将图像或文件存储在数据库或文件系统之前，我们需要评估情况。如果文件存储在文件系统中并迁移到另一个操作系统，可能会导致文件指针损坏。这将需要额外的工作来修复文件指针。在这种情况下，将文件存储在数据库中更可取。但是，如果我们在数据库中存储大型拥挤的文件或图像数据，可能会影响性能。
- en: '`BLOB` is MySQL''s solution to storing large binary information of variable
    lengths. MySQL has four `BLOB` types: `TINYBLOB`, `BLOB`, `MEDIUMBLOB`, and `LONGBLOB`.
    The only difference among these data types is the maximum length of values we
    can store. The storage requirements for these data types are explained in later
    sections of the chapter.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`BLOB`是MySQL用于存储可变长度大型二进制信息的解决方案。MySQL有四种`BLOB`类型：`TINYBLOB`，`BLOB`，`MEDIUMBLOB`和`LONGBLOB`。这些数据类型之间的唯一区别是我们可以存储的值的最大长度。这些数据类型的存储要求在本章后面的部分中有解释。'
- en: Similar to `BLOB`, `TEXT` data types are `TINYTEXT`, `TEXT`, `MEDIUMTEXT`, and
    `LONGTEXT`. These have maximum lengths and storage requirements similar to that
    of `BLOB` data types.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 与`BLOB`类似，`TEXT`数据类型有`TINYTEXT`，`TEXT`，`MEDIUMTEXT`和`LONGTEXT`。它们具有与`BLOB`数据类型类似的最大长度和存储要求。
- en: Like `BINARY` data types, `BLOB` values are stored as byte strings and have
    binary character sets and collation. Comparisons and sorting are done on the numeric
    values of the column values. `TEXT` values are stored as non-binary strings.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 与`BINARY`数据类型一样，`BLOB`值被存储为字节字符串，并具有二进制字符集和排序。对列值的数字值进行比较和排序。`TEXT`值被存储为非二进制字符串。
- en: In the case of `BLOB` or `TEXT` data types, if the value contains excess trailing
    spaces, MySQL truncates with a warning, regardless of the MySQL mode. MySQL doesn't
    pad `BLOB` or `TEXT` column values on insertion and doesn't strip bytes on retrieval.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`BLOB`或`TEXT`数据类型，如果值包含多余的尾随空格，MySQL会截断并发出警告，无论MySQL模式如何。MySQL在插入时不会填充`BLOB`或`TEXT`列的值，并且在检索时不会剥离字节。
- en: For a `TEXT` column which is indexed, the index comparisons add trailing spaces
    as padding at the end of the values. So, a duplicate-key error may occur on insertion
    if the only difference between an existing `TEXT` value and the `TEXT` value to
    be inserted is in the trailing spaces. `BLOB` can be regarded as `VARBINARY` and
    `TEXT` can be regarded as `VARCHAR`, with no restriction on the length of the
    values.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对于索引的`TEXT`列，索引比较会在值的末尾添加尾随空格作为填充。因此，如果现有`TEXT`值和要插入的`TEXT`值之间的唯一区别在于尾随空格，则可能会在插入时发生重复键错误。`BLOB`可以被视为`VARBINARY`，`TEXT`可以被视为`VARCHAR`，对值的长度没有限制。
- en: 'The following are the differences between `VARBINARY`, `VARCHAR` and `BLOB`,
    `TEXT`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`VARBINARY`，`VARCHAR`和`BLOB`，`TEXT`之间的区别：
- en: When creating indexes on `BLOB` or `TEXT` columns, we must specify index prefix
    length
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`BLOB`或`TEXT`列上创建索引时，必须指定索引前缀长度。
- en: '`BLOB` and `TEXT` cannot have default values'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BLOB`和`TEXT`不能有默认值'
- en: '`BLOB` or `TEXT` values are represented internally as objects with separate
    allocations, unlike other data types, for which the storage is allocated once
    per column.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`BLOB`或`TEXT`值在内部表示为具有单独分配的对象，与其他数据类型不同，其他数据类型的存储是每列分配一次。'
- en: ENUM data type
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ENUM数据类型
- en: MySQL provides a data type for which lists of permitted values can be predefined
    when the table is created. The data type is `ENUM`. If we want to restrict the
    user from inserting values outside a range of values, we should define the column
    of data type `ENUM`. MySQL encodes the user input string values into numbers for
    `ENUM` data types.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL提供了一种数据类型，可以在创建表时预定义允许的值列表。该数据类型是`ENUM`。如果我们希望限制用户插入超出一定范围的值，应该定义数据类型为`ENUM`的列。MySQL将用户输入的字符串值编码为`ENUM`数据类型的数字。
- en: '`ENUM` provides the following mentioned benefits:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENUM`提供了以下提到的好处：'
- en: Compact data storage
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧凑的数据存储
- en: Readable queries and output
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可读的查询和输出
- en: 'The following is an example that showcases when `ENUM` is useful:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是展示`ENUM`何时有用的示例：
- en: '[PRE37]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`ENUM` values require one byte of storage. Storing one million such records
    in this table would require one million bytes of storage, opposed to the six million
    bytes required by the `VARCHAR` column.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENUM`值需要一个字节的存储。在这个表中存储一百万条这样的记录将需要一百万字节的存储空间，而不是`VARCHAR`列所需的六百万字节。'
- en: 'The following are important limitations to consider:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是需要考虑的重要限制：
- en: '`ENUM` values are stored internally as numbers. So, if the `ENUM` values look
    like numbers, literal values may mix up with their internal index numbers.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENUM`值在内部存储为数字。因此，如果`ENUM`值看起来像数字，字面值可能会与其内部索引数字混淆。'
- en: Using `ENUM` columns in `ORDER BY` clauses requires extra care. `ENUM` values
    are assigned index numbers based on the order of listing. `ENUM` values are sorted
    based on their index numbers. So, it is important to make sure that the `ENUM`
    values list is in alphabetical order. Also, the column should be sorted lexically
    than by index numbers.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在 `ORDER BY` 子句中使用 `ENUM` 列需要额外小心。`ENUM` 值根据列出顺序分配索引号。`ENUM` 值根据其索引号排序。因此，重要的是确保
    `ENUM` 值列表按字母顺序排列。此外，列应按字母顺序而不是按索引号排序。 '
- en: The `ENUM` value must be a quoted string literal.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENUM` 值必须是带引号的字符串文字。'
- en: Each `ENUM` value has an index beginning with 1\. The index of the empty string
    or error value is 0\. We can find invalid `ENUM` values by querying the table
    with `enum_column_value = 0` in the `WHERE` clause. The index of `NULL` value
    is `NULL`. Index refers to the position of a value within the `ENUM` list of values.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 `ENUM` 值都有一个从 1 开始的索引。空字符串或错误值的索引为 0。我们可以通过在 `WHERE` 子句中查询具有 `enum_column_value
    = 0` 的表来找到无效的 `ENUM` 值。`NULL` 值的索引为 `NULL`。索引是指值在 `ENUM` 值列表中的位置。
- en: MySQL automatically removes trailing spaces from `ENUM` member values when a
    table is created. Upon retrieval, values from an `ENUM` column are displayed in
    the case used in the column definition. If a number is to be stored in the `ENUM`
    column, the number is treated as an index into the possible values. The value
    stored is the `ENUM` value with that index. In the case of a quoted numeric value,
    it is still interpreted as an index if there is no matching string in the list
    of enumerated values.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建表时，MySQL 会自动删除 `ENUM` 成员值的尾随空格。检索时，`ENUM` 列中的值以列定义中使用的大小写显示。如果要在 `ENUM` 列中存储数字，则该数字将被视为可能值的索引。存储的值是具有该索引的
    `ENUM` 值。对于带引号的数字值，如果在枚举值列表中没有匹配的字符串，则仍将其解释为索引。
- en: If an `ENUM` column is declared to contain `NULL` values, the `NULL` value is
    considered a valid value for the column and `NULL` becomes the default value.
    If `NULL` is not allowed, the first `ENUM` value becomes the default value.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果声明 `ENUM` 列包含 `NULL` 值，则将考虑 `NULL` 值作为列的有效值，并且 `NULL` 成为默认值。如果不允许 `NULL`，则第一个
    `ENUM` 值将成为默认值。
- en: 'If `ENUM` values are used in a numeric context, the index is used. The following
    is an example query to use `ENUM` values in a numeric context:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在数字上下文中使用 `ENUM` 值，则使用索引。以下是在数字上下文中使用 `ENUM` 值的示例查询：
- en: '[PRE39]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: SET data type
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SET 数据类型
- en: MySQL `SET` is a data type which can have zero or more values. A permitted list
    of values is specified at the time of table creation. Each value must be from
    within the list of permitted values. Multiple set members are specified by a comma
    (`,`) separated list of values. A `SET` can have a maximum of 64 distinct members.
    If `strict` mode is enabled, an error is generated if duplicate values are found
    in the column definition.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL `SET` 是一种数据类型，可以具有零个或多个值。在创建表时指定了一个允许值列表。每个值必须来自允许值列表中。多个集合成员由逗号（`,`）分隔的值列表指定。`SET`
    最多可以有 64 个不同的成员。如果启用了 `strict` 模式，则如果在列定义中发现重复的值，则会生成错误。
- en: It must be taken care that `SET` member values do not contain commas; otherwise,
    they are interpreted as `SET` member separators.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意 `SET` 成员值不包含逗号；否则，它们将被解释为 `SET` 成员分隔符。
- en: 'A column specified as `SET(''yes'', ''no'') NOT NULL` can have any of the following
    values:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 指定为 `SET('yes', 'no') NOT NULL` 的列可以具有以下任一值：
- en: '`''''`'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ''''''
- en: '`''yes''`'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''是'''
- en: '`''no''`'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''否'''
- en: '`''yes,no''`'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''是，否'''
- en: Trailing spaces are removed automatically from `SET` member values. Upon retrieval,
    `SET` column values are displayed using the letter case which was used in the
    column definition.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`SET` 成员值会自动删除尾随空格。检索时，`SET` 列值将使用在列定义中使用的大小写显示。'
- en: 'The following is an example of inserting values in the `SET` data type:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 `SET` 数据类型中插入值的示例：
- en: '[PRE40]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `SET` values are stored in the MySQL table as a bitmap in which each element
    is represented by one bit. In the preceding case, each element in the `SET` is
    assigned a bit. If the row has a given element, the associated bit will be one.
    Because of this approach, each element has an associated decimal value. Also,
    because of the bitmap, though there are only four values, `SET` will occupy one
    byte. The following is the table explaining this:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`SET` 值存储在 MySQL 表中，其中每个元素由一个位表示。在前面的情况下，`SET` 中的每个元素都被分配一个位。如果行具有给定元素，则相关位将为一。由于这种方法，每个元素都有一个关联的十进制值。此外，由于位图，尽管只有四个值，`SET`
    将占用一个字节。以下是解释这一点的表：'
- en: '| **Element** | **SET value** | **Decimal value** |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| **元素** | **SET 值** | **十进制值** |'
- en: '| Travel | 00000001 | 1 |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| 旅行 | 00000001 | 1 |'
- en: '| Sports | 00000010 | 2 |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| 体育 | 00000010 | 2 |'
- en: '| Fine Dining | 00000100 | 4 |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| 精致餐饮 | 00000100 | 4 |'
- en: '| Dancing | 00001000 | 8 |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 跳舞 | 00001000 | 8 |'
- en: Multiple `SET` elements can be represented by adding their decimal values. In
    the preceding case, the decimal value 9 is interpreted as Travel, Dancing.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过添加它们的十进制值来表示多个 `SET` 元素。在前面的情况下，十进制值 9 被解释为旅行，跳舞。
- en: The `SET` data type is not so commonly used. This is because although it is
    a string data type, it is a bit complex in implementation. The values that can
    be stored are limited to 64 elements. We cannot add commas as part of `SET` values,
    because a comma is a standard `SET` value separator. From a database design point
    of view, using `SET` means the database is not normalized.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`SET` 数据类型并不常用。这是因为虽然它是一个字符串数据类型，但在实现上有点复杂。可以存储的值限制为 64 个元素。我们不能将逗号作为 `SET`
    值的一部分添加，因为逗号是标准的 `SET` 值分隔符。从数据库设计的角度来看，使用 `SET` 意味着数据库不是规范化的。'
- en: JSON data type
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON 数据类型
- en: JSON stands for JavaScript Object Notation. Suppose that we want to store user
    preferences for a web application in the database. Usually, we may choose to create
    a separate table with `id`, `user_id`, `key`, `value` fields. This may work well
    for a small number of users, but in the case of thousands of users, the cost of
    maintenance is unaffordable compared to the value it adds to the web application.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: JSON代表JavaScript对象表示法。假设我们想要在数据库中存储Web应用程序的用户偏好设置。通常，我们可能选择创建一个单独的表，其中包含`id`、`user_id`、`key`、`value`字段。这对于少量用户可能效果不错，但对于成千上万的用户来说，维护成本是无法承受的，与其增加Web应用程序的价值相比。
- en: In MySQL, we can utilize the JSON data type for this requirement. MySQL supports
    the native JSON data type, which enables efficient storage for JSON documents.
    MySQL supports automatic validation of JSON documents stored in the JSON column.
    Trying to store invalid JSON documents produces an error. JSON documents stored
    in JSON columns are converted to an internal format. The format is binary, and
    structured to enable the server to look up `subojbects` or nested values directly,
    by key or array index, without reading other values.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在MySQL中，我们可以利用JSON数据类型来满足这个需求。MySQL支持原生的JSON数据类型，可以有效地存储JSON文档。MySQL支持对存储在JSON列中的JSON文档进行自动验证。尝试存储无效的JSON文档会产生错误。存储在JSON列中的JSON文档会被转换为内部格式。该格式是二进制的，并且结构化，使服务器能够直接查找`subojbects`或嵌套值，通过键或数组索引，而无需读取其他值。
- en: A JSON column cannot have a default value. The JSON data type requires similar
    storage to that of `LONGTEXT` or `LONGBLOB`. JSON columns are not indexed directly,
    unlike other string data types.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: JSON列不能有默认值。JSON数据类型需要与`LONGTEXT`或`LONGBLOB`相似的存储。与其他字符串数据类型不同，JSON列不会直接进行索引。
- en: 'The following is an example of inserting JSON values in a table:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在表中插入JSON值的示例：
- en: '[PRE41]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the preceding example, we have formatted the JSON value. As an alternative,
    we can also use the built-in `JSON_OBJECT` function. The function accepts a list
    of key/value pairs and returns a JSON object. An example follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们已经格式化了JSON值。作为替代，我们也可以使用内置的`JSON_OBJECT`函数。该函数接受一组键/值对并返回一个JSON对象。以下是一个示例：
- en: '[PRE42]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding `INSERT` query will insert the JSON value `{"page_size": 1, "network":
    ["GSM", "CDMA", "WIFI"]}`. We can also use nested `JSON_OBJECT` functions. The `JSON_ARRAY`
    function returns a JSON array when passed a set of values.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '前面的`INSERT`查询将插入JSON值`{"page_size": 1, "network": ["GSM", "CDMA", "WIFI"]}`。我们也可以使用嵌套的`JSON_OBJECT`函数。`JSON_ARRAY`函数在传递一组值时返回一个JSON数组。'
- en: If the same key is specified multiple times, only the first key/value pair will
    be retained. In the case of the JSON data type, the object keys are sorted and
    the trailing space between the key/value pairs is removed. The keys in the JSON
    object must be strings.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多次指定相同的键，则只保留第一个键值对。在JSON数据类型的情况下，对象键会被排序，并且键值对之间的尾随空格会被移除。JSON对象中的键必须是字符串。
- en: Inserting a JSON value in a JSON column succeeds only if the JSON document is
    valid. In the case that the JSON document is invalid, MySQL produces an error.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在JSON文档有效的情况下，才能在JSON列中插入JSON值。如果JSON文档无效，MySQL会产生错误。
- en: MySQL has one more important and useful function which operates on JSON values.
    The `JSON_MERGE` function takes multiple JSON objects and produces a single, aggregate
    object.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL还有一个重要且有用的操作JSON值的函数。`JSON_MERGE`函数接受多个JSON对象并生成一个单一的聚合对象。
- en: The `JSON_TYPE` function takes a JSON as an argument and tries to parse it into
    a JSON value. It returns the value's JSON type if it is valid and produces an
    error if otherwise.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSON_TYPE`函数以JSON作为参数并尝试将其解析为JSON值。如果有效，则返回值的JSON类型，否则会产生错误。'
- en: Partial updates of JSON values
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON值的部分更新
- en: 'What should we do if we want to update a value in a JSON document stored in
    a JSON data type? One of the approaches is to remove the old document and insert
    a new document, with updates. The approach doesn''t seem good, right? MySQL 8.0
    supports partial, in place update of a JSON document stored in a JSON data type
    column. The optimizer requires that an update must meet the following conditions:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要更新存储在JSON数据类型列中的JSON文档中的值，我们应该怎么做？其中一种方法是删除旧文档并插入带有更新的新文档。这种方法似乎不太好，对吧？MySQL
    8.0支持对存储在JSON数据类型列中的JSON文档进行部分、就地更新。优化器要求更新必须满足以下条件：
- en: The column must be of JSON type.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列必须是JSON类型。
- en: One of three functions, `JSON_SET()`, `JSON_REPLACE()` or `JSON_REMOVE()`, can
    be used to update the column. MySQL doesn't permit direct assignment of the column
    value as a partial update.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JSON_SET()`、`JSON_REPLACE()`或`JSON_REMOVE()`三个函数中的一个可以用来更新列。MySQL不允许直接对列值进行部分更新。'
- en: The input column and target column must be the same. For example, a statement
    such as `UPDATE temp SET col1 = JSON_SET(col2, 'one', 10)` cannot be performed
    as a partial update.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入列和目标列必须相同。例如，像`UPDATE temp SET col1 = JSON_SET(col2, 'one', 10)`这样的语句不能作为部分更新执行。
- en: The changes only update existing arrays or objects, and no new elements are
    added to the parent object or array.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改只会更新现有数组或对象，不会向父对象或数组添加新元素。
- en: The replacement value must not be larger than the value being replaced.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换值不能大于被替换的值。
- en: Storage requirements for data types
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型的存储要求
- en: This section explains storage requirements for different data types in MySQL.
    The storage requirements depend on different factors. The storage engines represent
    data types and store raw data differently.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了MySQL中不同数据类型的存储要求。存储要求取决于不同的因素。存储引擎以不同的方式表示数据类型并存储原始数据。
- en: A table has a maximum row size of 65,535 bytes, even if the storage engine is
    capable of supporting larger rows. `BLOB` and `TEXT` data types are excluded.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 表的最大行大小为65,535字节，即使存储引擎能够支持更大的行。`BLOB`和`TEXT`数据类型被排除在外。
- en: 'The following table explains the storage details for numeric data types:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格解释了数字数据类型的存储细节：
- en: '| **Data Type** | **Storage required** |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| **数据类型** | **所需存储空间** |'
- en: '| `TINYINT` | 1 byte |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| `TINYINT` | 1字节 |'
- en: '| `SMALLINT` | 2 bytes |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: SMALLINT | 2字节
- en: '| `MEDIUMINT` | 3 bytes |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: MEDIUMINT | 3字节
- en: '| `INT`, `INTEGER` | 4 bytes |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: INT，INTEGER | 4字节
- en: '| `BIGINT` | 8 bytes |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: BIGINT | 8字节
- en: '| `FLOAT(p)` | 4 bytes if *0<=p<=24*,8 bytes if *25<=p<=53* |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: FLOAT(p) | 如果*0<=p<=24*，则为4字节，如果*25<=p<=53*，则为8字节
- en: '| `FLOAT` | 4 bytes |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: 浮点 | 4字节
- en: '| `DOUBLE [precision]`, `REAL` | 8 bytes |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: DOUBLE [精度]，REAL | 8字节
- en: '| `DECIMAL(M, D)`, `NUMERIC(M, D)` | Varies |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: DECIMAL(M, D)，NUMERIC(M, D) | 变化
- en: '| `BIT(M)` | Approximately *(M+7)/8* bytes |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: BIT(M) | 大约*(M+7)/8*字节
- en: Reference: [https://dev.mysql.com/doc/refman/8.0/en/storage-requirements.html](https://dev.mysql.com/doc/refman/8.0/en/storage-requirements.html)
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 参考：[https://dev.mysql.com/doc/refman/8.0/en/storage-requirements.html](https://dev.mysql.com/doc/refman/8.0/en/storage-requirements.html)
- en: 'The following table explains the storage requirements for `DATE` and `TIME`
    data types:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格解释了DATE和TIME数据类型的存储需求：
- en: '| **Data Type** | **Storage Required** |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: 数据类型 | 存储需求
- en: '| `YEAR` | 1 byte |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: YEAR | 1字节
- en: '| `DATE` | 3 bytes |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: 日期 | 3字节
- en: '| `TIME` | 3 bytes + fractional seconds storage |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: 时间 | 3字节 + 分数秒存储
- en: '| `DATETIME` | 5 bytes + fractional seconds storage |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: 日期时间 | 5字节 + 分数秒存储
- en: '| `TIMESTAMP` | 4 bytes + fractional seconds storage |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: TIMESTAMP | 4字节 + 分数秒存储
- en: 'The following table explains the storage required for fractional seconds precision:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格解释了分数秒精度所需的存储空间：
- en: '| **Fractional Seconds Precision** | **Storage Required** |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: 分数秒精度 | 存储需求
- en: '| 0 | 0 bytes |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: 0 | 0字节
- en: '| 1, 2 | 1 byte |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: 1, 2 | 1字节
- en: '| 3, 4 | 2 bytes |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: 3, 4 | 2字节
- en: '| 5, 6 | 3 bytes |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: 5, 6 | 3字节
- en: 'The following table explains storage requirements for string data types:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格解释了字符串数据类型的存储需求：
- en: '| **Data Type** | **Storage Required** |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: 数据类型 | 存储需求
- en: '| --- | --- |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '--- | ---'
- en: '| `CHAR(M)` | *M* × *w* bytes, *0 <= M <= 255*, where *w* is the number of
    bytes required for the maximum-length character in the character set |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: CHAR(M) | *M* × *w* 字节，*0 <= M <= 255*，其中*w*是字符集中最大长度字符所需的字节数
- en: '| `BINARY(M)` | *M* bytes, *0 <= M <= 255* |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: BINARY(M) | *M* 字节，*0 <= M <= 255*
- en: '| `VARCHAR(M)`, `VARBINARY(M`) | *L* + 1 bytes if the column values require
    0 − 255 bytes, *L* + 2 bytes if the values may require more than 255 bytes |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: VARCHAR(M)，VARBINARY(M) | 如果列值需要0 − 255字节，则为*L* + 1字节，如果值可能需要超过255字节，则为*L* +
    2字节
- en: '| `TINYBLOB`, `TINYTEXT` | *L* + 1 bytes, where *L* < 28 |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: TINYBLOB，TINYTEXT | *L* + 1字节，其中*L* < 28
- en: '| `BLOB`, `TEXT` | *L* + 2 bytes, where *L* < 216 |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: BLOB，TEXT | *L* + 2字节，其中*L* < 216
- en: '| `MEDIUMBLOB`, `MEDIUMTEXT` | *L* + 3 bytes, where *L* < 224 |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '`MEDIUMBLOB`，`MEDIUMTEXT` | *L* + 3字节，其中*L* < 224'
- en: '| `LONGBLOB`, `LONGTEXT` | *L* + 4 bytes, where ***L*** < 232 |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: LONGBLOB，LONGTEXT | *L* + 4字节，其中***L*** < 232
- en: '| ENUM(''value1'',''value2'',...) | 1 or 2 bytes, depending on the number of
    enumeration values (65,535 values maximum) |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: ENUM('value1','value2',...) | 取决于枚举值的数量，为1或2字节（最多65,535个值）
- en: '| `SET(''value1'',''value2'',...)` | 1, 2, 3, 4, or 8 bytes, depending on the
    number of set members (64 members maximum) |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: SET('value1','value2',...) | 取决于集合成员的数量，为1、2、3、4或8字节（最多64个成员）
- en: Reference: [https://dev.mysql.com/doc/refman/8.0/en/storage-requirements.html](https://dev.mysql.com/doc/refman/8.0/en/storage-requirements.html)
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 参考：[https://dev.mysql.com/doc/refman/8.0/en/storage-requirements.html](https://dev.mysql.com/doc/refman/8.0/en/storage-requirements.html)
- en: In the case of string data types, variable length strings are stored using the
    length of the value and the length prefix. The length prefix varies from one to
    four bytes, depending on the data type.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串数据类型的情况下，使用值的长度和长度前缀存储可变长度字符串。长度前缀根据数据类型的不同而变化，可以是一到四个字节。
- en: Storage requirements for the JSON data type are similar to that of `LONGBLOB`
    and `LONGTEXT`. However, as the JSON documents are stored in binary representations,
    it imposes an overhead in storing JSON documents.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: JSON数据类型的存储需求与LONGBLOB和LONGTEXT相似。然而，由于JSON文档以二进制表示存储，因此在存储JSON文档时会产生开销。
- en: Choosing the right data type for column
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择列的正确数据类型
- en: As a general practice, we should use the most precise type for storing data.
    For example, a `CHAR` data type should be used to store a string value that varies
    in length from 1 to 255 characters. Another example is that `MEDIUMINT UNSIGNED`
    should be used to store numbers ranging from 1 to 99999.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般惯例，我们应该使用最精确的类型来存储数据。例如，应该使用CHAR数据类型来存储长度从1到255个字符的字符串值。另一个例子是，应该使用MEDIUMINT
    UNSIGNED来存储从1到99999的数字。
- en: Basic operations such as `addition`, `subtraction`, `multiplication`, and division
    with `DECIMAL` data are performed with the precision of 65 decimal digits.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 基本操作，如`加法`，`减法`，`乘法`和`除法`，使用`DECIMAL`数据执行，精度为65个小数位。
- en: Based on the importance of accuracy or speed, use of `FLOAT` or `DOUBLE` should
    be chosen. Fixed point values stored in `BIGINT` can be used for higher precision.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 根据准确性或速度的重要性，应选择使用FLOAT或DOUBLE。存储在BIGINT中的定点值可用于更高的精度。
- en: These are general guidelines, but the decision to use the right data type should
    be made based on the detailed characteristics explained separately for each data
    type in the earlier sections.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一般指导方针，但是应该根据前面各数据类型单独解释的详细特性来决定使用正确的数据类型。
- en: Summary
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: It was an interesting chapter with important content to learn, right? In this
    chapter, we understood the significance of data types in MySQL. We saw different
    categories in which MySQL data types are classified. We learned and understood
    the characteristics and specifications of each data type in depth. We also learned
    MySQL data manipulation functions and understood some of the MySQL settings and
    modes. In the later section of the chapter, we learned storage requirements of
    data types. Finally, we learned general guidelines for choosing the right data
    types.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有重要内容需要学习的有趣章节，对吧？在这一章中，我们了解了MySQL中数据类型的重要性。我们看到了MySQL数据类型被分类的不同类别。我们深入学习和了解了每种数据类型的特性和规格。我们还学习了MySQL数据操作函数，并了解了一些MySQL设置和模式。在本章的后面部分，我们学习了数据类型的存储需求。最后，我们学习了选择正确数据类型的一般指导方针。
- en: Moving on to next chapter, we will learn MySQL database management. The chapter
    will focus on server administration, understanding the basic building blocks of
    the MySQL server, such as the data dictionary, system database, and so on. The
    chapter will explain how we can run multiple server instances on a single machine
    and MySQL roles and permissions.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 进入下一章，我们将学习MySQL数据库管理。本章将重点介绍服务器管理，了解MySQL服务器的基本构建模块，如数据字典、系统数据库等。本章将解释如何在单台机器上运行多个服务器实例以及MySQL角色和权限。
