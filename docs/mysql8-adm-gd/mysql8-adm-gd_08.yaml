- en: Replication in MySQL 8
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQL 8中的复制
- en: In the previous chapter, we dived deep into MySQL 8 indexing. Indexes are an
    important entity for any database management system. They help improve SQL query
    performance by limiting the number of records to be visited. Database administrators
    working on performance improvement must be aware of this important technique.
    This chapter explains in detail the types of indexes and their advantages. This
    chapter also explains how indexing works in MySQL 8\. It's going to be a pretty
    informative chapter!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们深入探讨了MySQL 8索引。索引是任何数据库管理系统的重要实体。它们通过限制要访问的记录数量来提高SQL查询性能。致力于性能改进的数据库管理员必须了解这一重要技术。本章详细解释了索引的类型及其优势。本章还解释了MySQL
    8中索引的工作原理。这将是一个非常信息丰富的章节！
- en: 'Moving further along the same line, in this chapter, we will discuss database
    replication. How much are we already aware about database replication? It doesn''t
    actually matter. This chapter covers insightful details about database replication.
    If you have prior knowledge of database replication, this chapter will add to
    it. If you have only just heard about it for the first time, you will find every
    detail that is required to make it work in this chapter. So, are we ready to jump
    in? The following is a list of topics that we will be covering in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着同样的线路继续前进，在本章中，我们将讨论数据库复制。我们已经对数据库复制有多少了解并不重要。本章涵盖了有关数据库复制的深入细节。如果您已经了解数据库复制，本章将为您增加更多知识。如果您第一次听说它，您将在本章中找到使其正常工作所需的每一个细节。那么，我们准备好开始了吗？以下是本章将涵盖的主题列表：
- en: Overview of replication
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制概述
- en: Configuring replication
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置复制
- en: Implementing replication
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施复制
- en: Group replication versus clustering
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组复制与集群
- en: Replication solutions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制解决方案
- en: Overview of replication
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制概述
- en: We will walk through the basics of database replication in this section. We
    will understand what replication is, the advantages it provides, and the scenarios
    in which replication can be beneficial.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍数据库复制的基础知识。我们将了解复制是什么，它提供的优势以及复制可能有益的场景。
- en: What is MySQL replication?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是MySQL复制？
- en: It is assumed that you are reading this for two reasons. You're familiar with
    MySQL replication and are willing to gain more knowledge, and perhaps you're unfamiliar
    with MySQL replication and want to learn.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在阅读本文有两个原因。您熟悉MySQL复制并愿意获取更多知识，也许您不熟悉MySQL复制并希望学习。
- en: MySQL replication is useful for serving lots of different purposes. Usually,
    people start thinking about MySQL replication when they start having more queries
    than a single database server can handle. Based on this, do you have any guesses
    on what MySQL replication is? Replication is the technique to have more than one
    databases set up to serve single or multiple client applications. A client can
    be an end user or person who sends a request for any query in terms of read data
    or write data from different devices, such as computers, mobiles, tablets, and
    so on. These databases are replicas of the same database. This means all databases
    participating in database replication are exactly the same as each other. Replication
    works by frequently copying data from one database to all other replica databases.
    These databases may be located on the same database server, different database
    servers, or different machines altogether.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL复制对于服务许多不同的目的都是有用的。通常，当人们开始有更多的查询超过单个数据库服务器可以处理时，他们开始考虑MySQL复制。基于此，你对MySQL复制有什么猜测吗？复制是一种技术，可以设置多个数据库来为单个或多个客户端应用程序提供服务。客户端可以是最终用户或发送来自不同设备（如计算机、手机、平板电脑等）的读取数据或写入数据的任何查询请求的人。这些数据库是相同数据库的副本。这意味着参与数据库复制的所有数据库彼此完全相同。复制通过频繁地将数据从一个数据库复制到所有其他副本数据库来工作。这些数据库可以位于同一数据库服务器上、不同的数据库服务器上或完全不同的机器上。
- en: As mentioned earlier, database replication serves various purposes. It depends
    on the reason why MySQL database replication is set up. MySQL replication is set
    up to scale up a database or an application that is backed up by the database.
    It is also useful for maintaining database backups and reporting purposes. We
    will discuss these in detail a little later in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，数据库复制有各种目的。这取决于为什么设置MySQL数据库复制。MySQL复制是为了扩展数据库或由数据库支持的应用程序。它还用于维护数据库备份和报告目的。我们稍后将在本章中详细讨论这些问题。
- en: MySQL replication is mostly set up for scaling reads. In any web application,
    the number of read operations is pretty higher compared to that of write database
    operations. Most common web applications are always read heavy. Consider an example
    of a social networking website. If we navigate to a user profile page, we see
    a lot of information such as the user's personal information, demographic information, social
    connections, some ratings, and so on. If observed carefully, we will find that
    the number of `SELECT` queries executed on a database are much higher than `INSERT`,
    `UPDATE`, or `DELETE` queries. With MySQL database replication, we can direct
    read operations to be performed on particular databases so that we can achieve
    higher performance.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL复制主要用于扩展读取。在任何Web应用程序中，读取操作的数量相对于写入数据库操作要高得多。大多数常见的Web应用程序都是读取密集型的。考虑一个社交网络网站的例子。如果我们导航到用户个人资料页面，我们会看到很多信息，如用户的个人信息、人口统计信息、社交关系、一些评分等等。如果仔细观察，我们会发现在数据库上执行的`SELECT`查询的数量要比`INSERT`、`UPDATE`或`DELETE`查询要高得多。通过MySQL数据库复制，我们可以将读取操作定向到特定的数据库上，以便实现更高的性能。
- en: MySQL replication looks pretty easy and can be set up in a couple of hours,
    but it gets complicated pretty easily. It is very easy to set up on a new database.
    On the contrary, it is pretty complex to set it up on a production database. We
    should not confuse MySQL replication with a distributed database system. In a
    distributed database system, the databases hold different sets of data. Database
    operations are routed to a particular database based on some key information.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL复制看起来很简单，可以在几个小时内设置好，但很容易变得复杂。在新数据库上设置非常容易。相反，在生产数据库上设置它非常复杂。我们不应该将MySQL复制与分布式数据库系统混淆。在分布式数据库系统中，数据库保存不同的数据集。数据库操作根据一些关键信息路由到特定的数据库。
- en: In a traditional MySQL replication, one of the databases acts as a master and
    the rest of the databases play the role of slaves. It is not always necessary
    that we have only one master database. We can have multiple master databases in
    a replication. This technique is called multi-master replication. The slaves copy
    data from master databases. The process of copying data is asynchronous in traditional
    MySQL replication. This means slave database servers are not permanently connected
    with master database servers. MySQL supports replication at different levels.
    We can replicate all master databases, selected databases, or selected tables
    from a master database in to slave databases.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的MySQL复制中，一个数据库充当主数据库，其余数据库充当从数据库。并不总是必须只有一个主数据库。我们可以在复制中有多个主数据库。这种技术称为多主复制。从服务器从主数据库复制数据。在传统的MySQL复制中，复制数据的过程是异步的。这意味着从数据库服务器与主数据库服务器并非永久连接。MySQL支持不同级别的复制。我们可以将所有主数据库、选定的数据库或选定的主数据库中的表复制到从数据库中。
- en: MySQL 8 provides different database replication methods. MySQL 8 has a binary
    log file. The contents of the file are events describing database changes. The
    event can be of type `statement based` or `row based`. The changes include data
    definition changes and data manipulation changes or statements that can potentially
    modify the database such as `DELETE` statements. The binary log also contains
    information on how much time each SQL statement took to update the database. The
    traditional MySQL database replication method synchronizes databases from master
    to slaves based on the binary log file on the master database server. The slaves
    replicate or copy the contents of binary log file from the master database server
    based on the positions of log records in the file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8提供了不同的数据库复制方法。MySQL 8有一个二进制日志文件。文件的内容是描述数据库更改的事件。事件可以是“基于语句”的或“基于行”的类型。更改包括数据定义更改和数据操作更改，或者可能修改数据库的语句，如“DELETE”语句。二进制日志还包含每个SQL语句更新数据库所花费的时间的信息。传统的MySQL数据库复制方法基于主数据库服务器上的二进制日志文件同步数据库到从服务器。从服务器根据文件中日志记录的位置复制或复制主数据库服务器的二进制日志文件的内容。
- en: 'MySQL 8 also supports newer database replication methods along with the one
    based on the binary log file. Every transaction committed on the MySQL 8 database
    server is treated as unique. A unique **global transaction identifier** (**GTID**)
    is associated with every committed transaction on the master database server.
    As the name suggests, the global identifier is not unique only to the master database
    server on which it is created, but across all the databases participating in MySQL
    8 replication. So, essentially, there is a 1 to 1 mapping between each committed
    transaction and global transaction identifier. The newer method of MySQL replication
    is based on the GTID. It greatly simplifies the replication process as it is not
    dependent on events from binary log files and their positions. GTID is represented
    as a pair of colon (`:`) separated coordinates, as shown in the following block:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8还支持基于二进制日志文件的数据库复制方法以及新的方法。在MySQL 8数据库服务器上提交的每个事务都被视为唯一的。每个在主数据库服务器上提交的事务都与唯一的全局事务标识符（GTID）相关联。正如其名称所示，全局标识符不仅仅是在创建它的主数据库服务器上唯一的，而且在参与MySQL
    8复制的所有数据库中都是唯一的。因此，每个提交的事务和全局事务标识符之间存在一对一的映射。MySQL复制的新方法基于GTID。它极大地简化了复制过程，因为它不依赖于二进制日志文件及其位置的事件。GTID表示为一对冒号（“：”）分隔的坐标，如下所示：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `source_id` is the identifier for database servers originated from the
    GTID. Usually, a database server''s `server_uuid` is used as the `source_id`.
    The `transaction_id` is the sequence number in which the transaction was committed
    on the database server. For example, the following example shows the GTID for
    the first committed transaction:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: “source_id”是源自GTID的数据库服务器的标识符。通常，数据库服务器的“server_uuid”用作“source_id”。 “transaction_id”是事务在数据库服务器上提交的顺序号。例如，以下示例显示了第一个提交事务的GTID：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The sequence number for transactions committed starts with `1`. It can never
    be `0`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 提交的事务的序列号从“1”开始。它永远不可能是“0”。
- en: A GTID-based MySQL replication method is transactional and so this is why it
    is more reliable than a binary log file-based replication method. GTID guarantees
    the replication accuracy and consistency between master and slave databases as
    long as all the transactions committed on master database servers have also been
    applied on all of the slave database servers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 基于GTID的MySQL复制方法是事务性的，这就是为什么它比基于二进制日志文件的复制方法更可靠。只要在主数据库服务器上提交的所有事务也在所有从数据库服务器上应用，GTID就可以保证复制的准确性和一致性。
- en: As mentioned earlier, MySQL database replication is usually asynchronous. However,
    MySQL 8 supports different types of synchronization for replication. The usual
    method of synchronization is asynchronous. It means one server acts as a master
    database server. It writes all events to a binary log file. Other database servers
    act as slaves. Slave database servers read and copy position-based event records
    within binary log files from the master database server. So, it is always from
    a master database server to a slave database server. MySQL 8 also supports semisynchronous
    synchronization methods. In semisynchronous methods of replication, any transaction
    committed on a master database server is blocked until the master database server
    receives acknowledgement from at least one of the slave database servers that
    it has received and logged the transaction event. Delayed replication is another
    replication method supported by MySQL 8\. In delayed replication, slave database
    servers intentionally log the transaction event behind master database servers
    by some amount of time.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，MySQL数据库复制通常是异步的。但是，MySQL 8支持不同类型的复制同步。同步的常规方法是异步的。这意味着一个服务器充当主数据库服务器。它将所有事件写入二进制日志文件。其他数据库服务器充当从服务器。从服务器从主数据库服务器中读取和复制基于位置的事件记录。因此，它总是从主数据库服务器到从数据库服务器。MySQL
    8还支持半同步同步方法。在半同步复制方法中，任何在主数据库服务器上提交的事务都会被阻塞，直到主数据库服务器收到至少一个从数据库服务器已接收并记录了事务事件的确认。延迟复制是MySQL
    8支持的另一种复制方法。在延迟复制中，从数据库服务器故意将事务事件记录在主数据库服务器之后一段时间。
- en: Advantages of MySQL replication
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQL复制的优势
- en: As we are now familiar with what MySQL database replication is, it's time to
    assess if the added complexity of maintaining multiple database servers is worth
    it or not.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了MySQL数据库复制是什么，是时候评估维护多个数据库服务器的增加复杂性是否值得了。
- en: 'The advantages of MySQL 8 database replication are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8数据库复制的优势如下：
- en: '**Scale out solutions**: As described earlier, usually web applications are
    read-heavy applications. The read operations are much higher in number than the
    write operations. The applications provide features that require heavy, complex
    SQL queries to be executed on the database server. These are not the queries that
    take milliseconds to execute. Such complex queries may take a few seconds to minutes
    for execution. Execution of such queries put up heavy load on database server.
    In such cases, it is always better to have such read operations performed on a
    separate database server than master database servers. Write database operations
    will always be performed on master database servers. Do you know why? It''s because
    it triggers database modifications. Events of these modifications must be written
    to binary log files for replication synchronization by slave servers. Also, the
    synchronization is from master to slaves. So, if we performed write database operations
    on slaves, those will never be available on master database servers. This approach
    improves performance of write operations with increased speed for read operations
    as the read operations are performed across the number of slave servers.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**扩展解决方案**：如前所述，通常Web应用程序是读密集型应用程序。读操作的数量远远高于写操作。这些应用程序提供需要在数据库服务器上执行复杂的SQL查询的功能。这些不是毫秒级执行的查询。这样复杂的查询可能需要几秒到几分钟的执行时间。执行这样的查询会给数据库服务器带来沉重的负载。在这种情况下，最好将这些读操作在主数据库服务器上执行而不是在主数据库服务器上执行。写数据库操作将始终在主数据库服务器上执行。你知道为什么吗？因为它触发数据库修改。这些修改的事件必须写入二进制日志文件，以便从从服务器进行复制同步。此外，同步是从主服务器到从服务器。因此，如果我们在从服务器上执行写数据库操作，这些操作将永远不会在主数据库服务器上可用。这种方法通过在多个从服务器上执行读操作来提高写操作的性能，并增加读操作的速度。'
- en: '**Data Security**: Security, in general, is an important feature that every
    web application needs. The security can on at an application layer or on a database
    layer. Data security protects against loss of data. Data security is achieved
    by backing up a database on a regular basis. If replication is not set up, backing
    up production databases requires the application to be put on maintenance mode.
    This is required because simultaneous access to a database by an application and
    the back up process may corrupt the data. With replication in place, we can use
    one of the slaves for backup. As the slave database server is always in synchronization
    with the master database server, we can back up the slave database server. For
    that, we can make the slave database server stop replicating from a master database
    server while the back up process is running. This doesn''t require the web application
    to stop using a master database server. In fact, it doesn''t impact the master
    database server in any way. Another data security aspect is to provide role-based
    access to production or master database servers. We can have only a few roles
    who can access the master database server from the backend. The rest of the users
    or roles have access to the slave database server. This reduces the risk of accidental
    data loss because of human error.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据安全**：安全性通常是每个Web应用程序都需要的重要功能。安全性可以在应用程序层或数据库层上进行。数据安全性可防止数据丢失。通过定期备份数据库来实现数据安全性。如果没有设置复制，备份生产数据库需要将应用程序置于维护模式。这是必需的，因为应用程序和备份过程同时访问数据库可能会损坏数据。有了复制，我们可以使用其中一个从服务器进行备份。由于从数据库服务器始终与主数据库服务器同步，我们可以备份从数据库服务器。为此，我们可以使从数据库服务器在备份过程运行时停止从主数据库服务器复制。这不需要Web应用程序停止使用主数据库服务器。事实上，它不会以任何方式影响主数据库服务器。另一个数据安全性方面是为生产或主数据库服务器提供基于角色的访问。我们只能让少数角色从后端访问主数据库服务器。其余用户或角色可以访问从数据库服务器。这减少了由于人为错误而导致的意外数据丢失的风险。'
- en: '**Analytics**: Analytics and reporting are always important features for a
    database backed application. These features require fetching of information from
    a database on a frequent basis so that analysis on the data can be performed.
    If database replication is set up, we can fetch the data required for analytics
    from the slave database server without affecting the master database server performance.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分析**：分析和报告始终是数据库支持的应用程序的重要功能。这些功能需要频繁地从数据库中获取信息，以便对数据进行分析。如果设置了数据库复制，我们可以从从数据库服务器获取分析所需的数据，而不会影响主数据库服务器的性能。'
- en: '**Long distance data distribution**: It is a common requirement for application
    developers to replicate production data on local development environments. In
    a database replication enabled infrastructure, a slave database server can be
    used to prepare database copy on a development database server without constant
    access to the master database server.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**远程数据分发**：应用程序开发人员通常需要在本地开发环境中复制生产数据。在启用数据库复制的基础设施中，可以使用从数据库服务器在开发数据库服务器上准备数据库副本，而无需经常访问主数据库服务器。'
- en: Configuring replication
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置复制
- en: In this section, we will learn configuration for different types of MySQL 8
    replication methods. It includes step by step instructions for setting up and
    configuring replication.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习不同类型的MySQL 8复制方法的配置。它包括逐步设置和配置复制的说明。
- en: Binary log file based replication
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于二进制日志文件的复制
- en: One of the most common traditional methods of MySQL database replication is
    the binary log file position method. This section focuses on configuration of
    the binary log file position method of replication. Before we jump into the configuration
    section, it would be good to revise and understand the basics of binary log position
    based replication.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL数据库复制最常见的传统方法之一是二进制日志文件位置方法。本节重点介绍了二进制日志文件位置复制的配置。在我们进入配置部分之前，最好复习和了解基于二进制日志位置的复制的基础知识。
- en: As described earlier, one of the MySQL database servers acts as master and the
    rest of the MySQL database servers become slaves. The master database server is
    the origin for the database changes. The master database server writes events
    based on updates or changes to the database in the binary log file. The format
    of the information record being written in the binary log file varies based on
    the database change being recorded. MySQL `REPLICATION SLAVE` database servers
    are configured so that they read the binary log events from the master database
    server. Slaves execute the events on local database binary log files. This way
    slaves synchronize the database with the master database. When slave database
    servers read the binary log file from the master database server, slaves get an
    entire copy of the binary log file. Once the binary log file is received, it is
    up to the slaves to decide which statements to execute on the slave binary log
    file. It is possible to specify that all statements from the master database server
    binary log file should be executed on the slave database servers binary log file.
    It is also possible to process events filtered by particular databases or tables.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，MySQL数据库服务器之一充当主服务器，其余的MySQL数据库服务器成为从服务器。主数据库服务器是数据库更改的起点。主数据库服务器根据数据库的更新或更改在二进制日志文件中写入事件。写入二进制日志文件的信息记录的格式根据记录的数据库更改而变化。MySQL
    `REPLICATION SLAVE`数据库服务器被配置为从主数据库服务器读取二进制日志事件。从服务器在本地数据库二进制日志文件上执行事件。这样从服务器就可以将数据库与主数据库同步。当从数据库服务器从主数据库服务器读取二进制日志文件时，从服务器会获得整个二进制日志文件的副本。一旦接收到二进制日志文件，就由从服务器决定在从服务器二进制日志文件上执行哪些语句。可以指定应在从数据库服务器的二进制日志文件上执行来自主数据库服务器二进制日志文件的所有语句。也可以处理特定数据库或表过滤的事件。
- en: Only slave database servers can be configured to filter events from master database
    server log files. It is not possible to configure the master database server to
    log only specific events.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 只有从数据库服务器可以配置过滤来自主数据库服务器日志文件的事件。无法配置主数据库服务器仅记录特定事件。
- en: MySQL 8 provides a system variable that helps identify the database server uniquely.
    All the database servers participating in MySQL replication must be configured
    to have a unique ID. Each of the slave database servers must be configured with
    the master database server hostname, log file name, and position within the log
    file. Once set up, it is possible to modify these details from within a MySQL
    session using the `CHANGE MASTER TO` statement executed on the slave database
    server.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8提供了一个系统变量，可以帮助唯一标识数据库服务器。参与MySQL复制的所有数据库服务器都必须配置为具有唯一的ID。每个从数据库服务器都必须配置主数据库服务器的主机名、日志文件名和日志文件中的位置。设置完成后，可以在从数据库服务器上使用`CHANGE
    MASTER TO`语句在MySQL会话中修改这些细节。
- en: When the slave database server reads the information from the master database
    binary log file, it keeps track of a record of the binary log coordinates. The
    binary log coordinates consists of the filename and position within the file,
    which is read and processed from the master database server. The efficiency of
    slave database servers reading the binary log file from the master database server
    is very high because multiple slave database servers can be connected to the master
    database server and process different parts of the binary log file from the master
    database server. The master database server operations remain unaffected because
    the connecting and disconnecting of slave database servers from the master database
    server is controlled by slaves themselves. As mentioned earlier, each slave database
    server keeps track of the current position within the binary log file. So, it
    is possible for the slave database server to disconnect and reconnect with the
    master database server and resume the binary log file processing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当从数据库服务器从主数据库二进制日志文件中读取信息时，它会跟踪二进制日志坐标的记录。 二进制日志坐标包括文件名和文件内的位置，从主数据库服务器读取和处理。
    从数据库服务器读取主数据库服务器的二进制日志文件的效率非常高，因为可以将多个从数据库服务器连接到主数据库服务器，并从主数据库服务器处理二进制日志文件的不同部分。
    主数据库服务器的操作保持不变，因为从主数据库服务器连接和断开从数据库服务器的控制由从服务器自己控制。 如前所述，每个从数据库服务器都会跟踪二进制日志文件中的当前位置。
    因此，从数据库服务器可以断开连接并重新连接到主数据库服务器，并恢复二进制日志文件处理。
- en: A number of methods for setting up database replication are available in MySQL.
    The exact method for replication depends on if data already exists in the database
    and how replication is being set up. Each of the following sections are a step
    for configuring MySQL replication.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL中提供了多种设置数据库复制的方法。 复制的确切方法取决于数据库中是否已存在数据以及如何设置复制。 以下各节中的每个部分都是配置MySQL复制的步骤。
- en: Replication master configuration
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制主配置
- en: Before we set up the replication master database server, it must be ensured
    that the database server has a unique ID established and binary logging is enabled.
    It may be required to restart the database server after these configurations are
    made. The master database server binary log is the basis for MySQL 8 database
    replication.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置复制主数据库服务器之前，必须确保数据库服务器已建立唯一ID并启用了二进制日志记录。 可能需要在进行这些配置后重新启动数据库服务器。 主数据库服务器二进制日志是MySQL
    8数据库复制的基础。
- en: To enable binary logging, the `log_bin` system variable should be set to `ON`.
    Binary logging is enabled for a MySQL database server by default. If `mysqld`
    is used to initialize the data directory manually with a `--initialize` or `--initialize-insecure`
    option, the binary logging is disabled by default. It has to be enabled by specifying
    the `--log-bin` option. The `--log-bin` option specifies the base name to be used
    for the binary log files.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用二进制日志记录，应将`log_bin`系统变量设置为`ON`。 默认情况下，MySQL数据库服务器启用了二进制日志记录。 如果使用`mysqld`手动使用`--initialize`或`--initialize-insecure`选项初始化数据目录，则默认情况下禁用了二进制日志记录。
    必须通过指定`--log-bin`选项来启用它。 `--log-bin`选项指定要用于二进制日志文件的基本名称。
- en: If the filename is not specified with the startup option, the binary log filenames
    will be set based on the database server hostname. It is recommended that the
    binary log filename is specified with the `--log-bin` option. If the log filename
    is specified with `--log_bin=old_host_name-bin`, the log filename will be retained
    even after the database server host is changed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启动选项未指定文件名，则二进制日志文件名将基于数据库服务器主机名进行设置。 建议使用`--log-bin`选项指定二进制日志文件名。 如果使用`--log_bin=old_host_name-bin`指定日志文件名，则即使更改数据库服务器主机，日志文件名也将保留。
- en: 'To set up the master database server, open the MySQL configuration file on
    the master database server:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置主数据库服务器，请在主数据库服务器上打开MySQL配置文件：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the configuration file, make the following changes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置文件中进行以下更改。
- en: 'First of all, find the section that binds the server to localhost:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，找到将服务器绑定到localhost的部分：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Replace the local IP address with the actual database server IP address. This
    step is important because the slaves can access the master database server using
    the public IP address of the master database server:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 用实际数据库服务器IP地址替换本地IP地址。 这一步很重要，因为从服务器可以使用主数据库服务器的公共IP地址访问主数据库服务器：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following changes are required to configure a unique ID for the master
    database server. It also includes the configuration required for setting up the
    master binary log file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 需要对主数据库服务器进行配置以配置唯一ID。 还包括设置主二进制日志文件所需的配置：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let''s configure the database to be replicated on the slave database servers.
    If more than one database is required to be replicated on slave database servers,
    repeat the following line multiple times:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置数据库在从数据库服务器上进行复制。 如果需要在从数据库服务器上复制多个数据库，则多次重复以下行：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once these changes are done, restart the database server using the following
    command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些更改后，使用以下命令重新启动数据库服务器：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we have the master database server set up. The next step is to grant privileges
    to the slave user as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置好了主数据库服务器。 下一步是授予从用户权限如下：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding commands creates the slave user, grants privileges on the master
    database server, and flushes database cached privileges.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令创建了从用户，在主数据库服务器上授予了权限，并刷新了数据库缓存的权限。
- en: 'Now, we have to back up the database that we want to replicate. We will back
    up the database using the `mysqldump` command. This database will be used for
    creating the `slave` database. The master status output displays the name of the
    binary log filename, current position, and the name of the database to be replicated:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须备份要复制的数据库。 我们将使用`mysqldump`命令备份数据库。 此数据库将用于创建`slave`数据库。 主状态输出显示要复制的二进制日志文件名、当前位置和数据库名称：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Before we take the database backup using the `mysqldump` command, we have to
    lock the database to check the current position. This information will be used
    later to set up the slave database server.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`mysqldump`命令进行数据库备份之前，我们必须锁定数据库以检查当前位置。稍后将使用此信息设置从数据库服务器。
- en: 'After the database dump is taken, the database should be unlocked using the
    following commands:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库转储完成后，应使用以下命令解锁数据库：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are done with all the configuration required to set up a replication master
    database server and make it accessible by the `REPLICATION SLAVE` database servers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了设置复制主数据库服务器所需的所有配置，并使其可以被`REPLICATION SLAVE`数据库服务器访问。
- en: 'The following options have an impact on the master database server setup:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下选项对主数据库服务器设置产生影响：
- en: '`innodb_flush_log_at_trx_commit=1` and `sync_binlog=1` options should be set
    to achieve higher durability and consistency. The options can be set in the `my.cnf`
    configuration file.'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`innodb_flush_log_at_trx_commit=1`和`sync_binlog=1`选项应该设置为实现更高的耐久性和一致性。这些选项可以在`my.cnf`配置文件中设置。'
- en: The `skip-networking` option must not be enabled. If it is enabled, the slave
    cannot communicate with the master and database replication fails.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`skip-networking`选项不能被启用。如果启用了，从服务器就无法与主服务器通信，数据库复制将失败。'
- en: REPLICATION SLAVE configuration
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REPLICATION SLAVE配置
- en: 'Similar to the master database server, each slave database server must have
    a unique ID. Once set up, this will require database server restart:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与主数据库服务器类似，每个从数据库服务器必须有一个唯一的ID。设置完成后，这将需要数据库服务器重启：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For setting up multiple slave database servers, a unique non zero `server-id`
    must be configured that is different from that of master or any other slave database
    servers. Binary logging on a slave database server is not required for replication
    to be set up. If enabled, a binary log file on a slave database server can be
    used for database backups and crash recovery.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置多个从数据库服务器，必须配置一个唯一的非零`server-id`，该ID与主服务器或任何其他从数据库服务器不同。不需要在从数据库服务器上启用二进制日志记录以设置复制。如果启用了，在从数据库服务器上的二进制日志文件可以用于数据库备份和崩溃恢复。
- en: 'Now, create a new database that will become the replica of the master database
    and import the database from the database dump prepared from the master database
    as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个新的数据库，它将成为主数据库的副本，并从主数据库的数据库转储中导入数据库如下：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we have to configure a few other options in the `my.cnf` file. Like the
    binary log, a relay log consists of numbered files with database change events
    as contents of the file. It also contains an index file that has the names of
    all the used relay log files. The following configurations set the relay log file,
    binary log file, and name of the slave database, which is a replica of the master
    database as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须在`my.cnf`文件中配置其他一些选项。与二进制日志类似，中继日志由带有数据库更改事件的编号文件组成。它还包含一个索引文件，其中包含所有已使用的中继日志文件的名称。以下配置设置了中继日志文件、二进制日志文件和从服务器数据库的名称，该名称是主数据库的副本，如下所示：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A database server restart is required after this configuration change. The
    next step is to enable slave replication from within MySQL shell prompt. Execute
    the following command to set the `master` database information required by the
    `slave` database server:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行此配置更改后，需要重新启动数据库服务器。下一步是在MySQL shell提示符中启用从服务器复制。执行以下命令设置`slave`数据库服务器所需的`master`数据库信息：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As a final step, activate the slave server:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，激活从服务器：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If the binary logging is enabled on the `slave` database server, a slave can
    participate in a complex replication strategy. In such a replication setup, database
    server `A` acts as a master for database server `B`. `B` acts as a slave to the `A`
    `master` database server. Now, `B` in turn can act as a master database server
    for the `C` `slave` database server. Something like this can be seen as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`slave`数据库服务器上启用了二进制日志记录，从服务器可以参与复杂的复制策略。在这样的复制设置中，数据库服务器`A`充当数据库服务器`B`的主服务器。`B`充当`A`的`master`数据库服务器的从服务器。现在，`B`反过来可以充当`C`的`slave`数据库服务器的主数据库服务器。类似的情况如下所示：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Adding slaves to replication
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加从服务器进行复制
- en: It is possible to add a new slave database server to an existing replication
    configuration. This doesn't require the master database server to be stopped.
    The approach should be to make a copy of an existing `slave` database server.
    Once copied, we have to modify the value for a `server-id` configuration option.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 可以向现有的复制配置中添加一个新的从数据库服务器。这不需要停止主数据库服务器。方法是复制现有的`slave`数据库服务器。复制后，我们必须修改`server-id`配置选项的值。
- en: 'The following instructions set up a new slave database to an existing replication
    configuration. First, an existing slave database server should be shut down as
    follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下说明设置了一个新的从数据库服务器到现有的复制配置。首先，应该关闭现有的从数据库服务器如下：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, a data directory from the existing slave should be copied to the new slave
    database server. Along with the data directory, binary logs and relay log files
    must be copied as well. It is recommended to use the same value for `--relay-log`
    for the new slave database server as that of the existing slave database server.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应该将现有从服务器的数据目录复制到新的从数据库服务器。除了数据目录，还必须复制二进制日志和中继日志文件。建议为新的从数据库服务器使用与现有从数据库服务器相同的`--relay-log`值。
- en: If the master info and relay log info repositories use files then those files
    must be copied from an existing slave database server to a new slave database
    server. These files hold a master's current binary log coordinates and a slave's
    relay logs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主信息和中继日志信息存储库使用文件，则必须从现有的从数据库服务器复制这些文件到新的从数据库服务器。这些文件保存了主服务器的当前二进制日志坐标和从服务器的中继日志。
- en: Now, start the existing slave server that was stopped earlier.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动之前停止的现有从服务器。
- en: Now, we should be able to start the new slave database server. We must have
    the unique `server-id` configured before starting the new slave server, if it
    is not set up already.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该能够启动新的从服务器。如果尚未设置，必须在启动新的从服务器之前配置唯一的`server-id`。
- en: Global transaction identifiers based replication
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于全局事务标识符的复制
- en: This section focuses on global transaction identifiers based replication. It
    explains how GTIDs are defined, created, and represented in MySQL server. It describes
    the procedure for setting up and starting GTID-based replication.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本节重点介绍基于全局事务标识符的复制。它解释了在MySQL服务器中如何定义、创建和表示GTID。它描述了设置和启动基于GTID的复制的过程。
- en: 'With GTID-based replication, each transaction is assigned a unique transaction
    ID as it is committed to the originating database server, known as **GTID**. The
    unique identifier is global, which means it is unique across all the database
    servers participating in replication. With GTID, it is easier to track and process
    each transaction as it is committed on to a `master` database server. With this
    replication method, it is not necessary to rely on the log files for synchronization
    between `master` and `slave` databases. It is also easier to identify if the `master`
    and `slave` databases are consistent as this method of replication is transaction
    based. Consistency between master and slave databases is guaranteed as long as
    all the transactions committed on the `master` database are applied on the slave
    databases as well. Either statement-based or row-based replication can be used
    with GTID. As mentioned earlier, GTID is represented with a pair of coordinates
    separated by colons (`:`), as shown in the following example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于GTID的复制，每个事务在提交到原始数据库服务器时都被分配一个唯一的事务ID，称为**GTID**。这个唯一标识符是全局的，这意味着它在参与复制的所有数据库服务器中是唯一的。使用GTID，更容易跟踪和处理每个事务在提交到`master`数据库服务器时。使用这种复制方法，不需要依赖日志文件来同步`master`和`slave`数据库。也更容易确定`master`和`slave`数据库是否一致，因为这种复制方法是基于事务的。只要在`master`数据库上提交的所有事务也在从服务器上应用，`master`和`slave`数据库之间的一致性就是有保证的。可以使用基于语句或基于行的复制与GTID。如前所述，GTID用由冒号(`:`)分隔的一对坐标表示，如下例所示：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The advantages of using the GTID based replication method are:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于GTID的复制方法的优点是：
- en: With this method of replication, it is possible to switch the master database
    server in the event of server failover. The global transaction identifier is unique
    across all participating database servers. The slaves maintain track of the last
    executed transaction using GTID. This means if the master database server is switched
    over to a new database server, it is a little easier for slaves to continue with
    the new master database server and resume the replication processing.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这种复制方法，可以在服务器故障转移的情况下切换主数据库服务器。全局事务标识符在所有参与的数据库服务器上是唯一的。从服务器使用GTID跟踪最后执行的事务。这意味着如果主数据库服务器切换到新的数据库服务器，从服务器更容易继续使用新的主数据库服务器并恢复复制处理。
- en: The state of the slave database server is maintained in a crash-safe way. With
    the newer replication technique, `slave` database server keeps track of the current
    position in a system table named `mysql.gtid_slave_pos`. Using a transactional
    storage engine such as `InnoDB`, updates to the state are recorded within the
    same transaction as that of the database operation. So, if the slave server goes
    down, on booting up again, the slave server starts the crash recovery and makes
    sure that the recorded replication position matches the replicated changes. This
    is not possible with traditional binary log file based replication because the
    relay log file that is updated independently of the actual database changes can
    easily go out of synchronization if the slave server crashes.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从服务器数据库服务器的状态以一种崩溃安全的方式维护。使用更新的复制技术，`slave`数据库服务器在名为`mysql.gtid_slave_pos`的系统表中跟踪当前位置。使用诸如`InnoDB`之类的事务存储引擎，状态的更新记录在与数据库操作相同的事务中。因此，如果从服务器崩溃，重新启动后，从服务器将启动崩溃恢复，并确保记录的复制位置与复制的更改匹配。这在传统的基于二进制日志文件的复制中是不可能的，因为中继日志文件独立于实际数据库更改而更新，如果从服务器崩溃，很容易出现不同步。
- en: Before diving into the GTID based replication configuration, let's understand
    a few more terms.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解基于GTID的复制配置之前，让我们先了解一些其他术语。
- en: 'A `gtid_set` is a set of global transaction identifiers. It is represented
    in the following example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`gtid_set`是一组全局事务标识符。它在以下示例中表示：'
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There are several ways in which GTID sets are used. System variables `gtid_executed`
    and `gtid_purged` are represented with GTID sets. The MySQL functions `GTID_SUBSET()`
    and `GTID_SUBTRACT()` require GTID sets as input parameters.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: GTID集的使用方式有几种。系统变量`gtid_executed`和`gtid_purged`用GTID集表示。MySQL函数`GTID_SUBSET()`和`GTID_SUBTRACT()`需要GTID集作为输入参数。
- en: Both master and slave database servers preserve GTIDs. Once a transaction is
    committed with one GTID on one server, any subsequent transaction with similar
    GTID is ignored by that server. This means a transaction committed on a `master`
    database server can only be committed or applied on a `slave` database server
    only once. This helps to maintain the consistency between `master` and `slave`
    databases.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 主数据库服务器和从数据库服务器都保留GTID。一旦在一个服务器上使用一个GTID提交了一个事务，那个服务器就会忽略任何后续具有相似GTID的事务。这意味着在`master`数据库服务器上提交的事务只能在`slave`数据库服务器上提交或应用一次。这有助于保持`master`和`slave`数据库之间的一致性。
- en: 'The following is a summary of the lifecycle of a GTID:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是GTID的生命周期摘要：
- en: A transaction is executed and committed on the master database server. This
    transaction is assigned a GTID using the master's UUID. The GTID is written to
    the binary log file of a master database server.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事务在主数据库服务器上执行并提交。使用主服务器的UUID为该事务分配一个GTID。GTID被写入主数据库服务器的二进制日志文件。
- en: Once the binary log file is received by the slave and recorded in the the slave's
    relay log, the slave sets the value of the `gtid_next` system variable to the
    GTID read. This indicates to `slave` that the next transaction to be executed
    is the one with this GTID.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦二进制日志文件被从服务器接收并记录在从服务器的中继日志中，从服务器会将`gtid_next`系统变量的值设置为读取的GTID。这表示给`slave`指示下一个要执行的事务是具有此GTID的事务。
- en: The `slave` database server maintains its set of GTID for already processed
    transactions in a binary log file. Before applying the transaction with GTID indicated
    by `gtid_next`, it checks if the GTID is recorded or logged in its binary log
    file. If the GTID is not found in the binary log file, the slave processes the
    transaction associated with the GTID and writes the GTID in the binary log file.
    This way the slave guarantees that the same transaction is not executed more than
    once.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`slave`数据库服务器在二进制日志文件中维护其已处理事务的GTID集。在应用由`gtid_next`指示的事务之前，它会检查二进制日志文件中是否记录了或记录了该GTID。如果在二进制日志文件中找不到GTID，则从服务器会处理与GTID相关联的事务，并将GTID写入二进制日志文件。这样，从服务器可以保证同一个事务不会被执行多次。'
- en: 'Let''s now move to the master configuration for GTID-based MySQL replication.
    As a first step, open the `my.cnf` file and make the following changes:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到基于GTID的MySQL复制的主配置。首先，打开`my.cnf`文件并进行以下更改：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These configuration changes require server restart. The preceding configurations
    are self-explanatory. The `gtid_mode` option enables the GTID based database replication.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配置更改需要服务器重启。前面的配置是不言自明的。`gtid_mode`选项启用了基于GTID的数据库复制。
- en: Now, create a user for accessing the master database from the slave database
    server. Also, take a database backup using the `mysqldump` command. The database
    backup will be used for setting up the slave database server.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在从服务器上为访问主数据库创建一个用户。同时，使用`mysqldump`命令进行数据库备份。数据库备份将用于设置从服务器。
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is all for the master database configuration. Let's move onto the slave
    side of configurations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是主数据库配置的全部内容。让我们继续进行从服务器端的配置。
- en: 'Using the shell prompt on the `slave` database server, import the database
    from the `master` database server backup as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`slave`数据库服务器的shell提示符上，按照以下步骤从`master`数据库服务器备份中导入数据库：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, add the following configurations in the `my.cnf` file on the slave:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在从服务器的`my.cnf`文件中添加以下配置：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once these configurations are made, restart the database server using the following
    command:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些配置后，使用以下命令重新启动数据库服务器：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The next step is to set up master database server information on the `slave`
    database server using the `CHANGE MASTER TO` command:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在`slave`数据库服务器上使用`CHANGE MASTER TO`命令设置主数据库服务器信息：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, start the `slave` server:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，启动`slave`服务器：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this replication method, the master database backup already has GTID information.
    So, we just need to provide the position from which the slave server should start
    synchronizing.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种复制方法中，主数据库备份已经包含了GTID信息。因此，我们只需要提供从服务器应该开始同步的位置。
- en: 'This is done by setting up the `GTID_PURGED` system variable:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是通过设置`GTID_PURGED`系统变量来完成的：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: MySQL multi-source replication
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQL多源复制
- en: This section focuses on replicating from multiple immediate masters in parallel.
    The method is known as **multi-source replication**. With multi-source replication,
    a `REPLICATION SLAVE` receives transactions from multiple sources at the same
    time. A channel is created by a `REPLICATION SLAVE` for each `master` from which
    it should receive transactions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 本节重点介绍了并行从多个主服务器复制的方法。这种方法称为**多源复制**。使用多源复制，`REPLICATION SLAVE`可以同时从多个源接收事务。每个`master`都会为`REPLICATION
    SLAVE`创建一个通道，从中接收事务。
- en: The multi-source replication configuration requires at least two masters and
    a slave to be configured. The masters can be configured using binary log position
    based replication or GTID-based replication. Replication repositories are stored
    in `FILE` or `TABLE` based repositories. A `TABLE` based repository is crash safe.
    MySQL multi-source replication requires a `TABLE` based repository. There are
    two ways to set up a `TABLE` repository.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 多源复制配置需要至少配置两个主服务器和一个从服务器。主服务器可以使用基于二进制日志位置的复制或基于GTID的复制进行配置。复制存储库存储在`FILE`或`TABLE`存储库中。`TABLE`存储库是崩溃安全的。MySQL多源复制需要`TABLE`存储库。设置`TABLE`存储库有两种方法。
- en: 'One is to start `mysqld` with options as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一种是使用以下选项启动`mysqld`：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Another preferred way of doing this is to modify the `my.cnf` file as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种做法是修改`my.cnf`文件如下：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It is possible to modify an existing `REPLICATION SLAVE` that is using a `FILE`
    repository to use a `TABLE` repository. The following commands convert the existing
    repositories dynamically:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 可以修改正在使用`FILE`存储库的现有`REPLICATION SLAVE`以使用`TABLE`存储库。以下命令动态转换现有存储库：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following commands can be used to add a new GTID-based replication master
    to an existing multi-source `REPLICATION SLAVE`. It adds a master to the existing
    slave channel:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可用于将基于GTID的新复制主服务器添加到现有的多源`REPLICATION SLAVE`。它将主服务器添加到现有的从服务器通道：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following commands can be used to add a new binary log file position based
    replication master to an existing multi-source `REPLICATION SLAVE`. It adds a
    master to the existing slave channel:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可用于将基于二进制日志文件位置的新复制主服务器添加到现有的多源`REPLICATION SLAVE`。它将主服务器添加到现有的从服务器通道：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following commands `START`/`STOP`/`RESET` all the configured replication
    channels:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令`START`/`STOP`/`RESET`所有配置的复制通道：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following commands `START`/`STOP`/`RESET` a named channel using a `FOR
    CHANNEL` clause:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令使用`FOR CHANNEL`子句`START`/`STOP`/`RESET`命名通道：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Replication administration tasks
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制管理任务
- en: This section describes a few commonly required MySQL replication administrative
    tasks. Usually, once set up, MySQL replication doesn't require regular monitoring.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了一些常见的MySQL复制管理任务。通常情况下，一旦设置好，MySQL复制就不需要定期监控。
- en: 'One of the most common tasks is to ensure that replication is taking place
    without errors between master and slave database servers. A `SHOW SLAVE STATUS`
    MySQL statement is used for this as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的任务之一是确保主数据库服务器和从数据库服务器之间的复制没有错误。使用`SHOW SLAVE STATUS` MySQL语句进行如下检查：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding output, a few of the key fields are explained as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，以下是一些关键字段的解释：
- en: '`Slave_IO_State`: Current state of the slave'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slave_IO_State`：从服务器的当前状态'
- en: '`Slave_IO_Running`: Indicates if the I/O thread for reading a master''s log
    file is running'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slave_IO_Running`：指示读取主日志文件的I/O线程是否正在运行'
- en: '`Slave_SQL_Running`: Indicates if the SQL thread for executing events is running'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slave_SQL_Running`：指示执行事件的SQL线程是否正在运行'
- en: '`Last_IO_Error, Last_SQL_Error`: Last errors reported by I/O or SQL threads
    processing the relay thread'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Last_IO_Error, Last_SQL_Error`：I/O或SQL线程处理中继线程报告的最后错误'
- en: '`Seconds_Behind_Master`**:** Indicates the number of seconds the slave SQL
    thread is running behind the master processing the master binary log'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Seconds_Behind_Master`**：**指示从服务器SQL线程运行落后于主服务器处理主二进制日志的秒数'
- en: 'We can check the status of connected slaves using a `SHOW_PROCESSLIST` statement:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`SHOW_PROCESSLIST`语句来检查连接的从服务器的状态：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `SHOW_SLAVE_HOSTS` statement, when executed on master, provides information
    about slaves as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当在主服务器上执行`SHOW_SLAVE_HOSTS`语句时，提供关于从服务器的信息如下：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Another important replication administrative task is to be able to start or
    stop the replication on a `slave` database server. The following commands are
    used to do that:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的复制管理任务是能够在`slave`数据库服务器上启动或停止复制。以下命令用于执行此操作：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It is also possible to stop and start individual threads by specifying the
    type of the thread as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过指定线程的类型来停止和启动单个线程，如下所示：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Implementing replication
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施复制
- en: The basis for replication is that the master database server keeps track of
    all the changes taking place on the master database. The changes are tracked in
    the binary log files in the form of events since the server was started. `SELECT`
    operations are not recorded as they modify neither the database nor the contents. Each
    of the `REPLICATION SLAVE` pull a copy of the binary log file from `master` instead
    of a master database pushing the log file to the `slave`. The slave in turn executes
    the events as it is read from the master's binary log file. This maintains the
    consistency between `master` and `slave` servers. In MySQL replication, each `slave`
    functions independently from `master` and other `slave` servers. So, it is up
    to the slave to request the master's binary log file at a convenient time without
    impacting the `master` or `slave` functioning.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 复制的基础是主数据库服务器跟踪主数据库上发生的所有更改。这些更改以事件的形式在二进制日志文件中进行跟踪，自服务器启动以来。`SELECT`操作不会被记录，因为它们既不修改数据库也不修改内容。每个`REPLICATION
    SLAVE`从`master`拉取二进制日志文件的副本，而不是主数据库推送日志文件到`slave`。从服务器依次执行从主二进制日志文件中读取的事件。这保持了`master`和`slave`服务器之间的一致性。在MySQL复制中，每个`slave`都独立于`master`和其他`slave`服务器。因此，从服务器可以在不影响`master`或`slave`功能的情况下，在方便的时候请求主的二进制日志文件。
- en: The focus for this section of the chapter is on MySQL replication details. We
    have already understood the basics, which will help us understand the in depth
    details.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的重点是MySQL复制的详细信息。我们已经了解了基础知识，这将帮助我们理解深入的细节。
- en: Replication formats
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制格式
- en: As we already know by now, MySQL replication works based on replicating events
    from the master server generated binary logs. Later, these events are read and
    processed by the slave. What we do not yet know is the format in which the events
    are recorded in binary log files. Replication formats is the emphasis of this
    section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们现在已经知道的那样，MySQL复制是基于从主服务器生成的二进制日志中的事件进行复制的。稍后，这些事件将被从服务器读取和处理。我们还不知道的是这些事件以何种格式记录在二进制日志文件中。复制格式是本节的重点。
- en: 'When the events are recorded in the master''s binary log files, the replication
    format used depends on the binary log format used. Basically, two binary logging
    formats exist: statement based and row based.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件记录在主二进制日志文件中时，使用的复制格式取决于使用的二进制日志格式。基本上，存在两种二进制日志格式：基于语句和基于行。
- en: With statement-based binary logging, SQL statements are written in the master's
    binary log file. Replication on the slave works by executing the SQL statements
    on the `slave` database. This approach is called **statement-based** replication.
    It corresponds with the MySQL statement-based binary logging format. This was
    the only traditional format that existed until MySQL versions 5.1.4 and earlier.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于语句的二进制日志记录，SQL语句被写入主二进制日志文件。从服务器上的复制通过在`slave`数据库上执行SQL语句来工作。这种方法称为**基于语句**复制。它对应于MySQL基于语句的二进制日志格式。这是直到MySQL版本5.1.4和更早版本存在的唯一传统格式。
- en: With row-based binary logging, the events written in the master binary log indicate
    how individual table rows changed. Replication in this case works by the slave
    copying the events representing changes to the table rows. This is called row-based
    replication. Row-based logging is the default MySQL replication method.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于行的二进制日志记录，主二进制日志中写入的事件指示单个表行如何更改。在这种情况下，复制是通过从服务器复制表示表行更改的事件来工作的。这称为基于行的复制。基于行的日志记录是默认的MySQL复制方法。
- en: MySQL supports configuration to mix statement-based and row-based logging. The
    decision to use the logging format depends on the change being logged. This is
    known as mixed-format logging. Statement-based logging is the default format when
    mixed-format logging is used. Based on the type of statements and storage engine
    being used, the log automatically switches to row-based format. Replication based
    on the mixed logging format is known as **mixed-format** replication.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL支持配置以混合基于语句和基于行的日志记录。使用日志格式的决定取决于被记录的更改。这被称为混合格式日志记录。当使用混合格式日志记录时，基于语句的日志记录是默认格式。根据使用的语句类型和存储引擎，日志会自动切换到基于行的格式。基于混合日志格式的复制被称为混合格式复制。
- en: The `binlog_format` system variable controls the logging format used in a running
    MySQL server. `SYSTEM_VARIABLES_ADMIN` or `SUPER` privileges are required to set
    the `binlog_format` system variable at a session or global scope.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`binlog_format`系统变量控制着运行中的MySQL服务器中使用的日志格式。在会话或全局范围设置`binlog_format`系统变量需要`SYSTEM_VARIABLES_ADMIN`或`SUPER`权限。'
- en: Statement-based versus row-based replication
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于语句与基于行的复制
- en: In the earlier section, we learned three different logging formats. Each one
    of these has its own advantages and disadvantages. In usual cases, mixed format
    should provide the best combination of integrity and performance. However, to
    achieve the best performance from either statement-based or row-based replication,
    the advantages and disadvantages described in this section are helpful.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们学习了三种不同的日志格式。每种格式都有其自己的优点和缺点。通常情况下，混合格式应该提供最佳的完整性和性能组合。然而，要从基于语句或基于行的复制中获得最佳性能，本节中描述的优点和缺点是有帮助的。
- en: Statement-based replication is a traditional and proven technique in comparison
    with row-based replication. The number of records or events recorded in the log
    files is smaller. If a statement impacts many rows, only one statement will be
    written to the binary log file. In case of row-based replication, a record will
    be entered for every table row modified though as part of the single statement.
    In essence, this means statement-based replication requires much less storage
    space for log files. It also means backing up and restoring or replicating the
    events is much quicker.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于行的复制相比，基于语句的复制是一种传统且经过验证的技术。日志文件中记录的记录或事件数量较少。如果一个语句影响了许多行，只有一个语句将被写入二进制日志文件。在基于行的复制中，对于每个修改的表行，都将输入一条记录，尽管作为单个语句的一部分。实质上，这意味着基于语句的复制需要更少的存储空间用于日志文件。这也意味着备份、恢复或复制事件的速度更快。
- en: 'Along with the advantages described previously, statement-based replication
    has disadvantages as well. As the replication works based on the SQL statements,
    it is possible that not all the statements that modify data can be replicated
    with statement-based replication. A few examples are described as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面描述的优点之外，基于语句的复制也有缺点。由于复制是基于SQL语句的，因此可能无法使用基于语句的复制复制修改数据的所有语句。以下是一些示例：
- en: SQL statements depend on a user-defined function that is non-deterministic when
    the value returned by such user-defined functions depend on factors other than
    the parameters supplied to it.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL语句依赖于用户定义的函数，当这些用户定义的函数返回的值依赖于除了提供给它的参数之外的因素时，它是不确定的。
- en: '`UPDATE` and `DELETE` statements with a `LIMIT` clause without an `ORDER BY`
    clause is non-deterministic as it is possible that the order may have changed
    while replicating.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有`LIMIT`子句但没有`ORDER BY`子句的`UPDATE`和`DELETE`语句是不确定的，因为在复制过程中可能已经改变了顺序。
- en: '`FOR UPDATE` or `FOR SHARE` locking read statements that use `NOWAIT` or `SKIP
    LOCKED` options.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`NOWAIT`或`SKIP LOCKED`选项的`FOR UPDATE`或`FOR SHARE`锁定读取语句。
- en: User-defined functions must be applied on the slave databases.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义的函数必须应用于从数据库。
- en: SQL statements using functions such as `LOAD_FILE()`, `UUID()`, `USER()`, `UUID_SHORT()`,
    `FOUND_ROWS()`, `SYSDATE()`, `GET_LOCK()`, and so on cannot be replicated properly
    using statement-based replication.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数的SQL语句，如`LOAD_FILE()`，`UUID()`，`USER()`，`UUID_SHORT()`，`FOUND_ROWS()`，`SYSDATE()`，`GET_LOCK()`等，无法使用基于语句的复制正确地进行复制。
- en: '`INSERT` or `SELECT` statements require higher number of row level locks.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INSERT`或`SELECT`语句需要更多的行级锁。'
- en: '`UPDATE` with table scan requires locking a higher number of rows.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用表扫描的`UPDATE`需要锁定更多的行。
- en: Complex SQL statements must be evaluated and executed on the slave database
    server before rows are inserted or updated.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂的SQL语句必须在从数据库服务器上执行和评估，然后再插入或更新行。
- en: Let's see advantages provided by row-based replication. Row-based replication
    is the safest form of replication because instead of depending on SQL statements,
    it depends on the values stored in the table rows. So, every change can be replicated.
    It requires fewer row locks in case `INSERT...SELECT` statements. `UPDATE` and
    `DELETE` statements with `WHERE` clauses that do not use keys require fewer row
    level locks.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看基于行的复制提供的优势。基于行的复制是最安全的复制形式，因为它不依赖于SQL语句，而是依赖于表行中存储的值。因此，每个更改都可以被复制。在`INSERT...SELECT`语句中需要更少的行锁。不使用键的`UPDATE`和`DELETE`语句需要更少的行级锁。
- en: The major disadvantage with row-based replication is that it generates more
    data that must be logged. With statement-based replication, one DML SQL statement
    is sufficient for logging though it modifies many rows. In case of row-based replication,
    it requires logging for every row that changed. The binary log file grows very
    quickly with row-based replication. It takes longer time to replicate deterministic
    user defined functions that generate large `BLOB` values.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 基于行的复制的主要缺点是它生成了更多必须记录的数据。使用基于语句的复制，一个DML SQL语句就足够记录，尽管它修改了许多行。在基于行的复制中，需要为每个更改的行记录日志。基于行的复制的二进制日志文件增长非常快。复制确定性用户定义的函数生成大型`BLOB`值需要更长的时间。
- en: Replication implementation details
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制实现细节
- en: 'There are three threads that participate in implementing replication in MySQL.
    Out of these three threads, one is on the master server and the two others are
    on the `slave` database server. Let''s dive into the details of these threads:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在MySQL中，有三个线程参与实现复制。这三个线程中，一个在主服务器上，另外两个在`slave`数据库服务器上。让我们深入了解这些线程的细节：
- en: '**Binlog dump thread**: When the slave database server requests the binary
    log file, the master server is responsible for sending the contents to the slave
    database server. To accomplish this, the master database server creates a thread
    when the slave database server connects to the master database server. The `binlog`
    dump thread sends the binary log contents to the slave database server. In the
    output of the `SHOW PROCESSLIST` command on the master database server, this thread
    can be identified as the `Binlog Dump` thread. The `binlog` dump thread locks
    the binary log file on the master for reading each event that is to be sent to
    the slave database server. The lock is released as soon as the event is read,
    even before it is sent to the slave database server.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Binlog转储线程：** 当从属数据库服务器请求二进制日志文件时，主服务器负责将内容发送到从属数据库服务器。为了实现这一点，当从属数据库服务器连接到主数据库服务器时，主数据库服务器会创建一个线程。`binlog`转储线程将二进制日志内容发送到从属数据库服务器。在主数据库服务器上执行`SHOW
    PROCESSLIST`命令的输出中，可以将此线程标识为`Binlog Dump`线程。`binlog`转储线程锁定主服务器上的二进制日志文件，以便读取要发送到从属数据库服务器的每个事件。一旦事件被读取，锁就会被释放，甚至在发送到从属数据库服务器之前。'
- en: '**Slave I/O thread:** The primary responsibility of the slave I/O thread is
    to request binary log updates from the master database server. The slave database
    server creates the I/O thread when a `START SLAVE` command is executed. The thread
    connects to the master database server and requests to send updates from the binary
    logs. Once the contents are sent by the master''s `binlog` dump thread, the slave
    I/O thread reads the contents and copies those to the local files including the
    slave''s relay log. The status of this thread can be obtained in the output of
    `SHOW SLAVE STATUS` or `SHOW STATUS` commands.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从属I/O线程：** 从属I/O线程的主要责任是从主数据库服务器请求二进制日志更新。当执行`START SLAVE`命令时，从属数据库服务器会创建I/O线程。该线程连接到主数据库服务器，并请求从二进制日志发送更新。一旦主服务器的`binlog`转储线程发送内容，从属I/O线程读取内容并将其复制到本地文件，包括从属的中继日志。可以通过`SHOW
    SLAVE STATUS`或`SHOW STATUS`命令获取此线程的状态。'
- en: '**Slave SQL thread:** The slave I/O thread writes the events in the slave''s
    relay logs. It is the responsibility of the slave SQL thread to execute those
    events on the slave database server. The slave SQL thread reads the events in
    the relay logs written by a slave I/O thread and executes them.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从属SQL线程：** 从属I/O线程将事件写入从属的中继日志。从属SQL线程负责在从属数据库服务器上执行这些事件。从属SQL线程读取从属I/O线程写入的中继日志中的事件并执行它们。'
- en: Based on the preceding description, every master-slave connection pair creates
    three threads. If a master has more than one `slave` databases servers, it creates
    one dedicated binary log dump thread for each slave connected currently. On the
    other end, each slave creates its own I/O and SQL threads. Why does the slave
    database server create two separate threads, one for writing the events and another
    one for executing the events? The reason is that with this approach, the task
    of reading the statements is not slowed down by the executing of the statements.
    Considering the slave server is not running, its I/O thread quickly fetches all
    the binary logs from a master database when the `slave` server starts regardless
    of the SQL thread lags behind. Also, if the `slave` database server stops before
    the SQL thread can execute all of these statements, the statements are recorded
    in the slave relay logs. So, when the slave starts again, the SQL thread can execute
    those statements. So, relay logs work as a safe copy of the statements read from
    the master database server.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前述描述，每个主从连接对都会创建三个线程。如果主服务器有多个`slave`数据库服务器，它会为每个当前连接的从属创建一个专用的二进制日志转储线程。另一方面，每个从属都会创建自己的I/O和SQL线程。从属数据库服务器为什么要创建两个单独的线程，一个用于写入事件，另一个用于执行事件？原因是通过这种方法，读取语句的任务不会被执行语句所减慢。考虑到从属服务器没有运行，其I/O线程在`slave`服务器启动时会快速从主数据库获取所有二进制日志，而不管SQL线程是否落后。此外，如果`slave`数据库服务器在SQL线程执行所有这些语句之前停止，这些语句将记录在从属中继日志中。因此，当从属再次启动时，SQL线程可以执行这些语句。因此，中继日志作为从主数据库服务器读取的语句的安全副本。
- en: 'The `SHOW PROCESSLIST` statement provides information about what is happening
    on the `master` or the `slave` database servers. The output of the statement when
    executed on the `master` database server looks as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`SHOW PROCESSLIST`语句提供了关于`master`或`slave`数据库服务器上发生的情况的信息。在`master`数据库服务器上执行该语句时的输出如下所示：'
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preceding output shows that thread 2 is the master's `binlog` dump thread.
    The state indicates that all the recent updates have been sent to the slave.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 前述输出显示线程2是主服务器的`binlog`转储线程。状态表明所有最近的更新都已发送到从属。
- en: 'When a `SHOW PROCESSLIST` statement is executed on the slave database server,
    the output looks as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当在从属数据库服务器上执行`SHOW PROCESSLIST`语句时，输出如下所示：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the output, thread 10 is the slave's I/O thread and thread 11 is the slave's
    SQL thread. The I/O thread is waiting for the master's `binlog` dump thread to
    send binary log contents. The SQL thread has read all the statements logged in
    the `slave` relay logs. From the `Time` column, it can be determined how slow
    the `slave` is running behind the `master`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，线程10是从属的I/O线程，线程11是从属的SQL线程。I/O线程正在等待主服务器的`binlog`转储线程发送二进制日志内容。SQL线程已经读取了在`slave`中继日志中记录的所有语句。从`Time`列可以确定`slave`落后于`master`的速度有多慢。
- en: Replication channels
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制通道
- en: A replication channel is a path of transaction flow from a master to a slave.
    This section explains how channels can be used in replication. The MySQL server
    automatically creates a default channel with the name as `""` (empty string) on
    startup. The default channel is always present and can't be created or destroyed
    by the user. Replication statements work on the default channel if no other channel
    is created. This section describes statements that are applied to replication
    channels when there exists at least one named channel.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 复制通道是从主服务器到从服务器的事务流路径。本节解释了通道在复制中的使用方式。MySQL服务器在启动时会自动创建一个名为`""`（空字符串）的默认通道。默认通道始终存在，用户无法创建或销毁。如果没有创建其他通道，则复制语句将在默认通道上执行。本节描述了在至少存在一个命名通道时应用于复制通道的语句。
- en: In multi-source replication, the `slave` database server opens multiple channels,
    one for each master. Each channel has its own relay log and SQL threads. The replication
    channel has a hostname and port association. Multiple channels can be assigned
    to the same hostname and port combination. A maximum of 256 channels can be added
    to one slave in a multi-source replication topology in MySQL 8\. The channel must
    have a nonempty unique name.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在多源复制中，`slave`数据库服务器打开多个通道，每个通道对应一个主服务器。每个通道都有自己的中继日志和SQL线程。复制通道具有主机名和端口关联。多个通道可以分配给相同的主机名和端口组合。在MySQL
    8中，多源复制拓扑结构中的一个从服务器最多可以添加256个通道。通道必须具有非空的唯一名称。
- en: 'The `FOR CHANNEL` clause is used with various MySQL statements for the replication
    operations to be performed on individual channels. The clause can be applied to
    the following statements:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`FOR CHANNEL`子句与各种MySQL语句一起使用，用于在单个通道上执行复制操作。该子句可应用于以下语句：'
- en: '`CHANGE MASTER TO`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CHANGE MASTER TO`'
- en: '`START SLAVE`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`START SLAVE`'
- en: '`STOP SLAVE`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STOP SLAVE`'
- en: '`RESET SLAVE`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RESET SLAVE`'
- en: '`SHOW RELAYLOG EVENTS`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHOW RELAYLOG EVENTS`'
- en: '`FLUSH RELAY LOGS`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刷新中继日志
- en: '`SHOW SLAVE STATUS`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHOW SLAVE STATUS`'
- en: 'Apart from these, the following functions have an additional channel parameter:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，以下函数具有额外的通道参数：
- en: '`MASTER_POS_WAIT()`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MASTER_POS_WAIT()`'
- en: '`WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS()`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS()`'
- en: 'For multi-source replication to work correctly, the following startup options
    must be configured:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为使多源复制正常工作，必须配置以下启动选项：
- en: '`--relay-log-info-repository`: As described earlier, this must be set to `TABLE`
    for multi-source replication. In MySQL 8, the `FILE` option is deprecated and
    `TABLE` is the default option.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --relay-log-info-repository：如前所述，对于多源复制，必须设置为`TABLE`。在MySQL 8中，`FILE`选项已被弃用，`TABLE`是默认选项。
- en: '`--master-info-repository`: This must be set to `TABLE`.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --master-info-repository：必须设置为`TABLE`。
- en: '`--log-slave-updates`: Transactions received from the master are written to
    the binary logs.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --log-slave-updates：从主服务器接收的事务写入二进制日志。
- en: '`--relay-log-purge`: Each channel purges its own relay logs automatically.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --relay-log-purge：每个通道自动清除自己的中继日志。
- en: '`--slave-transaction-retries`: SQL threads of all channels retry transactions.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --slave-transaction-retries：所有通道的SQL线程重试事务。
- en: '`--skip-slave-start`: No replication threads start on any channels.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --skip-slave-start：任何通道上都不启动复制线程。
- en: '`--slave-skip-errors`: Execution continues and errors are skipped for all channels.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --slave-skip-errors：所有通道继续执行并跳过错误。
- en: '`--max-relay-log-size=size`: The relay log file is rotated after reaching the
    maximum size.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --max-relay-log-size=size：中继日志文件在达到最大大小后进行轮换。
- en: '`--relay-log-space-limit=size`: Upper limit for total size of all relay logs
    for each individual channel.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --relay-log-space-limit=size：每个单独通道的所有中继日志的总大小上限。
- en: '`--slave-parallel-workers=value`: Number of slave parallel workers per channel.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --slave-parallel-workers=value：每个通道的从服务器并行工作者数量。
- en: '`--slave-checkpoint-group`: Waiting time by I/O thread.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --slave-checkpoint-group：I/O线程的等待时间。
- en: '`--relay-log-index=filename`: Each channel''s relay log index filename.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --relay-log-index=filename：每个通道的中继日志索引文件名。
- en: '`--relay-log=filename`: Each channel''s relay log filename.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --relay-log=filename：每个通道的中继日志文件名。
- en: '`--slave-net-timeout=N`: Each channel waits for N seconds to check for broken
    connection.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --slave-net-timeout=N：每个通道等待N秒以检查断开的连接。
- en: '`--slave-skip-counter=N`: Each channel skips N events from the master.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --slave-skip-counter=N：每个通道从主服务器跳过N个事件。
- en: Replication relay and status logs
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制中继和状态日志
- en: 'The `REPLICATION SLAVE` server creates logs that hold the binary log events
    sent from the master database server to the slave database server. The information
    is recorded about the current status and location in the relay log. Three types
    of logs are used in this process:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`REPLICATION SLAVE`服务器创建保存从主数据库服务器发送的二进制日志事件的日志。记录有关中继日志的当前状态和位置的信息。在此过程中使用三种类型的日志：'
- en: '**Relay log**: The relay log has events sent from the master''s binary log.
    The events are written by a slave''s I/O thread. Events from the slave''s relay
    log are executed on the slave by the slave''s SQL thread.'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**中继日志**：中继日志包含从主服务器二进制日志发送的事件。这些事件由从服务器的I/O线程写入。从服务器的中继日志中的事件由从服务器的SQL线程执行。'
- en: '**Master info log**: The master info log has information about status and current
    configuration for the slave''s connection to the master database server. The information
    held by the master info log includes hostname, login credentials, and coordinates
    indicating a slave''s position on reading the master''s binary log. These logs
    are written to the `mysql.slave_master_info` table.'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**主服务器信息日志**：主服务器信息日志包含有关从服务器连接到主数据库服务器的状态和当前配置的信息。主服务器信息日志中包含的信息包括主机名、登录凭据以及指示从服务器在读取主服务器二进制日志时的位置的坐标。这些日志写入`mysql.slave_master_info`表中。'
- en: '**Relay log info log**: The relay log info log stores information regarding
    the execution point within the slave''s relay log. The relay log info log is written
    in a `mysql.slave_relay_log_info` table.'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**中继日志信息日志**：中继日志信息日志存储有关从服务器中继日志内执行点的信息。中继日志信息日志写入`mysql.slave_relay_log_info`表中。'
- en: No attempt should be made to insert or update rows in the `slave_master_info`
    or `slave_relay_log_info` tables manually. This may cause unexpected behavior.
    It is not supported in MySQL replication.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 不应尝试手动在`slave_master_info`或`slave_relay_log_info`表中插入或更新行。这可能会导致意外行为。在MySQL复制中不支持这样做。
- en: The slave relay log consists of an index file along with a set of numbered log
    files. The index file contains the names of all relay log files. MySQL data directory
    is the default location for the relay log files. The relay log file indicates
    an individually numbered file containing events. Whereas the relay log denotes
    the set of numbered relay log files and an index file collectively. The format
    for relay log files is the same as that of the binary log files. The index filename
    for relay log is `host_name-relay-bin.index` by default for the default channel
    and `host_name-relay-bin-channel.index` for non-default replication channels.
    The default locations for the relay log file and relay log index file can be overridden
    with the `--relay-log` and `--relay-log-index` server startup options. If the
    slave's hostname is changed after replication has been set up and the slave uses
    default host-based relay log filenames, it can throw errors such as **Failed to
    open the relay log** and **Could not find target log** during relay log initialization.
    This may fail the replication. Such errors may be avoided by using `--relay-log`
    and `--relay-log-index` options to specify relay log filenames explicitly. Using
    these options on slave setup will make the names independent of the server's hostname.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器中继日志由一个索引文件和一组编号的日志文件组成。索引文件包含所有中继日志文件的名称。MySQL数据目录是中继日志文件的默认位置。中继日志文件指的是包含事件的单独编号文件。而中继日志指的是一组编号的中继日志文件和一个索引文件的集合。中继日志文件的格式与二进制日志文件相同。中继日志的索引文件名默认为`host_name-relay-bin.index`，用于默认通道，对于非默认复制通道，默认的中继日志文件和中继日志索引文件的位置可以通过`--relay-log`和`--relay-log-index`服务器启动选项进行覆盖。如果在设置了复制后更改了从服务器的主机名，并且从服务器使用默认基于主机名的中继日志文件名，可能会在中继日志初始化期间抛出错误，例如**无法打开中继日志**和**找不到目标日志**。这可能会导致复制失败。可以通过使用`--relay-log`和`--relay-log-index`选项来明确指定中继日志文件名来避免此类错误。在从服务器设置上使用这些选项将使名称与服务器主机名无关。
- en: Evaluating replication filtering rules
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估复制过滤规则
- en: This section focuses on the filtering rules and how servers evaluate these rules.
    Basically, if the master doesn't log the statement, the slave doesn't replicate
    the statement. If the master logs the statement in its binary log file, the slave
    receives the statement. However, it is up to the slave database server if it processes
    the statement or ignores it. Options are available for the master server to control
    which databases and tables should be replicated on the slaves. The recommended
    way is to use filters on the slave to control the events that are to be executed
    on the slave database server. The decision about whether to execute or ignore
    the statements received from the master are made based on the `--replicate-*`
    options used when the slave was started. Once the slave server is started, the
    `CHANGE REPLICATION FILTER` statement can be used to set the options dynamically.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 本节重点介绍了过滤规则以及服务器如何评估这些规则。基本上，如果主服务器不记录语句，则从服务器不会复制该语句。如果主服务器在其二进制日志文件中记录了该语句，则从服务器会接收该语句。但是，从服务器数据库服务器是否处理该语句或忽略它取决于从服务器启动时使用的`--replicate-*`选项。一旦从服务器启动，`CHANGE
    REPLICATION FILTER`语句可以用于动态设置选项。
- en: All replication filtering options follow the same rules for case sensitivity
    as names of databases and tables, including the `lower_case_table_names` system
    variable.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 所有复制过滤选项都遵循与数据库和表的名称大小写敏感性相同的规则，包括`lower_case_table_names`系统变量。
- en: Group replication
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组复制
- en: This section of the chapter explains what group replication is, setting up group
    replication, configure and monitor group replication. Basically, MySQL group replication
    is a plugin that enables us to create elastic, highly-available, fault-tolerant
    replication topologies.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节解释了组复制是什么，如何设置组复制，配置和监控组复制。基本上，MySQL组复制是一个插件，使我们能够创建弹性、高可用、容错的复制拓扑。
- en: The purpose of the group replication is to create a fault tolerant system. To
    create a fault tolerant system, the components should be made redundant. The component
    should be removed without impacting the way system operates. There are challenges
    in setting up such a system. The complexity of such a system is of a different
    level. Replicated databases require maintenance and administration of several
    servers instead of just one. The servers cooperate together to create a group,
    which raises the problems related to network partitioning and split-brain scenarios.
    So, the ultimate challenge is to have agreement from multiple servers on the state
    of the system and data after every change applied on the system. This means that
    the servers need to operate as a distributed state machine.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 组复制的目的是创建一个容错系统。为了创建一个容错系统，组件应该是冗余的。组件应该在不影响系统操作方式的情况下被移除。设置这样的系统存在挑战。这样一个系统的复杂性是不同层次的。复制的数据库需要维护和管理多个服务器，而不仅仅是一个。服务器合作创建一个组，这带来了与网络分区和脑裂场景相关的问题。因此，最终的挑战是让多个服务器就系统和数据的状态在每次对系统应用更改后达成一致意见。这意味着服务器需要作为分布式状态机运行。
- en: MySQL group replication can provide such a distributed state machine replication
    with strong coordination between servers. The servers that belong to the same
    group coordinate themselves automatically. In a group, only one server accepts
    updates at a time. The election of primary is done automatically. This mode is
    known as single-primary mode.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL组复制可以提供具有服务器之间强协调的分布式状态机复制。属于同一组的服务器会自动协调。在一个组中，一次只有一个服务器接受更新。主服务器的选举是自动进行的。这种模式称为单主模式。
- en: MySQL provides a group membership service, which is responsible for keeping
    the view of the group consistent and available for all servers. The view is kept
    updated when the servers join or leave the group. In case, any of the servers
    leaves the group unexpectedly, the failure detection mechanism notifies the group
    about view change. This behavior is automatic.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL提供了一个组成员服务，负责保持组的视图一致并对所有服务器可用。当服务器加入或离开组时，视图会得到更新。如果有任何服务器意外离开组，故障检测机制会通知组视图发生变化。这种行为是自动的。
- en: The majority of the group members have to agree on the order of the transaction
    to commit in the global sequence of transactions. It is up to the individual server
    to decide whether the transaction should be committed or aborted, but all servers
    make the same decision. The system does not proceed until the members are unable
    to reach to agreement as a result of split due to network partition. This means
    the system has built-in, automatic, split-brain protection mechanism. All this
    is done by **Group Communication System** (**GCS**) protocols. It provides a failure
    detection mechanism, group membership service, safe and completely ordered message
    delivery. The implementation of the Paxos algorithm is at the core of this technology,
    which acts as the group communication engine.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数组成员必须就事务在全局事务序列中的顺序达成一致意见。决定是否提交或中止事务取决于各个服务器，但所有服务器都做出相同的决定。如果由于网络分区而导致无法达成一致意见，系统将不会继续进行。这意味着系统具有内置的自动分裂脑保护机制。所有这些都是由**组通信系统**（**GCS**）协议完成的。它提供了故障检测机制、组成员服务、安全和完全有序的消息传递。Paxos算法的实现是这项技术的核心，它充当了组通信引擎。
- en: Primary-secondary replication versus group replication
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主从复制与组复制
- en: This section focuses on some background details of how replication works. This
    will be useful in understanding the requirements for group replication and how
    it is different from the classic asynchronous MySQL replication.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分侧重于复制工作的一些背景细节。这将有助于理解组复制的要求以及它与经典的异步MySQL复制有何不同。
- en: 'The following figure showcases how traditional asynchronous primary-secondary
    replication works. The primary is the master and the secondary is one or more
    slaves connected to the master, as shown in the following figure:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了传统的异步主从复制是如何工作的。主服务器是主服务器，从服务器是连接到主服务器的一个或多个从服务器，如下图所示：
- en: '![](img/c962f92a-671d-4742-8fc1-ea98b5b2f01a.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c962f92a-671d-4742-8fc1-ea98b5b2f01a.png)'
- en: Figure 1\. MySQL Asynchronous Replication
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图1. MySQL异步复制
- en: 'MySQL also supports semi synchronous replication in which the **master** waits
    for at least one of the slaves to acknowledge the transaction receipt:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL还支持半同步复制，其中**主服务器**等待至少一个从服务器确认事务接收：
- en: '![](img/b0c8f60a-a410-4436-83c2-d95c133dec8c.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0c8f60a-a410-4436-83c2-d95c133dec8c.png)'
- en: Figure 2\. MySQL Semisynchronous Replication
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图2. MySQL半同步复制
- en: The blue arrows in the figures indicate the messages passed between servers
    and the client application.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的蓝色箭头表示服务器和客户端应用程序之间传递的消息。
- en: 'With group replication, a communication layer is provided that guarantees atomic
    messages and total order message delivery. All read-write transactions are committed
    only after they are approved by the group. The read only transactions are committed
    immediately as it does not need coordination. So, in group replication, the decision
    to commit a transaction or not is not unilateral by the originating server. When
    the transaction is ready for commit, the originating server broadcasts the write
    values and corresponding write set. All servers receive the same set of transactions
    in the same order. So, all servers apply the same transactions in the same order.
    This way all servers remain consistent within the group:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组复制，提供了一个通信层，保证了原子消息和总序消息传递。所有读写事务只有在组批准后才提交。只读事务立即提交，因为它不需要协调。因此，在组复制中，提交事务的决定并不是由发起服务器单方面做出的。当事务准备提交时，发起服务器广播写入值和相应的写入集。所有服务器以相同的顺序接收相同的事务集。因此，所有服务器以相同的顺序应用相同的事务。这样所有服务器在组内保持一致：
- en: '![](img/e67efdc9-e8c3-4196-ab3f-6207e02ddd58.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e67efdc9-e8c3-4196-ab3f-6207e02ddd58.png)'
- en: Figure 3\. MySQL Group Replication Protocol
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图3. MySQL组复制协议
- en: Group replication configuration
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组复制配置
- en: This section focuses on configuring group replication.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分侧重于配置组复制。
- en: 'First of all, open the `my.cnf` configuration file and add the following entries
    in the `mysqld` section as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开`my.cnf`配置文件，并在`mysqld`部分中添加以下条目：
- en: '[PRE42]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: These are general configurations related to global transaction IDs and binary
    logging required for group replication.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是与组复制相关的全局事务ID和二进制日志记录所需的一般配置。
- en: 'The next step is to set up group replication configurations. These configurations
    include group UUID, group members white listing, and indicating seed members:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤是设置组复制配置。这些配置包括组UUID、组成员白名单和指示种子成员：
- en: '[PRE43]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The following configuration is required for deciding whether a single-master
    group or multi-master group is to be set up. For enabling the multi-master group,
    uncomment
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为决定是设置单主组还是多主组，需要以下配置。要启用多主组，取消注释
- en: '`loose-group_replication_single_primary_mode` and'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`loose-group_replication_single_primary_mode`和'
- en: '`loose-group_replication_enforce_update_everywhere_checks` directives. It will
    set up a multi-master or multi-primary group:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`loose-group_replication_enforce_update_everywhere_checks`指令。它将设置多主或多主组：'
- en: '[PRE44]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It must be ensured that these configurations are the same on all the servers.
    Any changes to these configurations require MySQL groups to be restarted.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 必须确保所有服务器上的这些配置都相同。对这些配置的任何更改都需要重新启动MySQL组。
- en: 'The following configurations are different on each of the servers in the group:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下配置在组中的每台服务器上都不同：
- en: '[PRE45]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `server-id` must be unique across all servers in the group. The port 33061
    is the one used by members to coordinate for group replication. MySQL server restart
    is required after these changes are made.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`server-id`必须在组中的所有服务器上是唯一的。端口33061是成员用于协调组复制的端口。在进行这些更改后需要重新启动MySQL服务器。'
- en: 'If not already done, we have to allow access to these ports using the following
    commands:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未完成，我们必须使用以下命令允许访问这些端口：
- en: '[PRE46]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The next step is to create a replication user and enable the replication plugin.
    The replication user is required for each server to establish group replication.
    We need to turn binary logging off during the replication user creation process
    as the user will be different for each server, as shown in the following block:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建复制用户并启用复制插件。每个服务器都需要复制用户来建立组复制。在复制用户创建过程中，我们需要关闭二进制日志记录，因为每个服务器的用户都不同，如下所示：
- en: '[PRE47]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, use `CHANGE MASTER TO` to configure the server to use the credentials
    for the `group_replication_recovery` channel:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`CHANGE MASTER TO`来配置服务器使用`group_replication_recovery`通道的凭据：
- en: '[PRE48]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we are all set to install the plugin. Connect to the server and execute
    the following command:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好安装插件了。连接到服务器并执行以下命令：
- en: '[PRE49]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Use the following statement to verify if the plugin is activated or not:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下语句验证插件是否已激活：
- en: '[PRE50]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The next step is to start up the group. Execute the following statements on
    one member of the group:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是启动组。在组的一个成员上执行以下语句：
- en: '[PRE51]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, we can start group replication on another server:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在另一台服务器上启动组复制：
- en: '[PRE52]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can check the group members list using the following SQL query:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下SQL查询检查组成员列表：
- en: '[PRE53]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Group replication use cases
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组复制用例
- en: The MySQL group replication feature provides a way to build fault tolerant systems
    by replicating the state of the system throughout a set of servers. The group
    replication system stays available as long as the majority of servers are functioning
    even if some of the servers fail. Server failures are tracked by a group membership
    service. The group membership service relies on the distributed failure detector,
    which signals if any server leaves the group, voluntarily or due to unexpected
    halt. The distributed recovery procedure ensures that when the servers join the
    group, they are brought up to date automatically. Therefore, continuous database
    service is guaranteed with MySQL group replication. There is one problem though.
    Although the database service is available, the clients connected to it must be
    redirected to a different server when the server crashes. The group replication
    does not attempt to resolve it. It should be dealt with by a connector, load balancer,
    router, or some other middleware.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL组复制功能提供了一种通过在一组服务器上复制系统状态来构建容错系统的方法。只要大多数服务器正常运行，组复制系统就会保持可用，即使其中一些服务器出现故障。服务器故障由组成员服务跟踪。组成员服务依赖于分布式故障检测器，如果任何服务器离开组（自愿或由于意外停机），则会发出信号。分布式恢复过程确保服务器加入组时会自动更新。因此，使用MySQL组复制可以保证持续的数据库服务。不过，存在一个问题。尽管数据库服务可用，但连接到它的客户端在服务器崩溃时必须被重定向到另一台服务器。组复制不会尝试解决这个问题。这应该由连接器、负载均衡器、路由器或其他中间件来处理。
- en: 'The following are the typical use cases of MySQL group replication:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是MySQL组复制的典型用例：
- en: '**Elastic replication**: Group replication is suitable for fluid environments
    where the number of servers grow or shrink dynamically with minimum side effects.
    The example is cloud-based database services.'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**弹性复制**：组复制适用于服务器数量在流动环境中动态增长或缩减，且副作用最小的情况。例如，云数据库服务。'
- en: '**Highly available shards**: MySQL group replication can be used to implement
    highly available write scale-out shards where each replication group maps to one
    shard.'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**高度可用的分片**：MySQL组复制可用于实现高度可用的写扩展分片，其中每个复制组映射到一个分片。'
- en: '**Alternative to master-slave replication**: Group replication can be an answer
    to contention problems arising in certain situations with single master server
    replication.'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**主从复制的替代方案**：组复制可以是单主服务器复制中出现争用问题的解决方案。'
- en: '**Autonomic systems**: MySQL group replication can be deployed for the automation
    built into the replication protocol.'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**自主系统**：MySQL组复制可以用于复制协议内置的自动化。'
- en: Replication solutions
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制解决方案
- en: MySQL replication is useful in many different scenarios to fulfill a range of
    purposes. This section focuses on specific use cases and provides general information
    on how to use the replication.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL复制在许多不同的场景中都很有用，以满足各种目的。本节重点介绍特定的用例，并提供有关如何使用复制的一般信息。
- en: One of the major use cases is to use replication for backup purposes. The data
    from the `master` can be replicated on the `slave` database server and then the
    data on the slave can be backed up. The `slave` database server can be shut down
    without affecting the operations running on the `master` database server.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个主要用例是将复制用于备份目的。`master`的数据可以在`slave`数据库服务器上复制，然后可以备份`slave`上的数据。`slave`数据库服务器可以关闭而不影响`master`数据库服务器上运行的操作。
- en: Another use case is to handle unexpected halt of the `REPLICATION SLAVE`. To
    accomplish this, once the `slave` restarts, the I/O thread must be able to recover
    information about the transactions received and the transactions that are executed
    by the SQL thread. This information is stored in the `InnoDB` tables. As the `InnoDB`
    storage engine is transactional, it is always recoverable. As mentioned earlier,
    for MySQL 8 replication to use tables, `relay_log_info_repository` and `master_info_repository`
    must be set to `TABLE`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用例是处理`REPLICATION SLAVE`的意外停止。为了实现这一点，一旦`slave`重新启动，I/O 线程必须能够恢复有关已接收事务和SQL线程执行的事务的信息。这些信息存储在
    `InnoDB` 表中。由于 `InnoDB` 存储引擎是事务性的，它总是可恢复的。正如前面提到的，为了使 MySQL 8 复制使用表，`relay_log_info_repository`
    和 `master_info_repository` 必须设置为 `TABLE`。
- en: 'In a row-based replication, it is possible to monitor the current progress
    of the slave''s SQL thread. It is done through performance schema instrument stages.
    To track the progress of all three row-based replication event types, use the
    following statement to enable three performance schema stages:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于行的复制中，可以通过性能模式工具阶段来监视从服务器的SQL线程的当前进度。要跟踪所有三种基于行的复制事件类型的进度，使用以下语句启用三个性能模式阶段：
- en: '[PRE54]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The MySQL 8 replication process can work even though the source table on the
    master and the destination table on the slave uses different engine types. The
    `default_storage_engine` system variable is not replicated. This is a huge advantage
    in replication wherein different engine types can be used for different replication
    scenarios. An example is a scale-out scenario where we want all read operations
    to be performed on the slave database server, whereas all write operations should
    be performed on the master database server. In such a case, we can use a transactional
    `InnoDB` engine on the master and a non-transactional `MyISAM` engine type on
    the slave database server.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8 复制过程可以工作，即使主服务器上的源表和从服务器上的目标表使用不同的引擎类型。`default_storage_engine` 系统变量不会被复制。这是复制中的一个巨大优势，不同的引擎类型可以用于不同的复制场景。一个例子是扩展场景，我们希望所有读操作在从数据库服务器上执行，而所有写操作应在主数据库服务器上执行。在这种情况下，我们可以在主服务器上使用事务性的
    `InnoDB` 引擎，在从数据库服务器上使用非事务性的 `MyISAM` 引擎类型。
- en: Consider an example of an organization that wants to distribute sales data to
    different departments to spread the load for data analysis. MySQL replication
    can be used to have a single master replicate different databases to different
    slaves. This can be achieved by limiting the binary log statements by using the
    `--replicate-wild-do-table` configuration option on each slave.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个想要将销售数据分发给不同部门以分担数据分析负载的组织的例子。MySQL 复制可以用于让单个主服务器将不同的数据库复制到不同的从服务器。这可以通过在每个从服务器上使用
    `--replicate-wild-do-table` 配置选项来限制二进制日志语句来实现。
- en: Once MySQL replication is set up, as the number of slaves connected to the master
    increase, the load also increases. The network load on the master also increases
    as each slave is supposed to receive a full copy of the binary logs. The master
    database server is also busy processing requests. In this scenario, it becomes
    necessary to improve the performance. One of the solutions to improve performance
    is to create a deeper replication structure that enables replication of a master
    to only one slave. The rest of the slaves connect to the primary slave for their
    operations.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了 MySQL 复制，随着连接到主服务器的从服务器数量的增加，负载也会增加。主服务器上的网络负载也会增加，因为每个从服务器都应该接收二进制日志的完整副本。主数据库服务器也忙于处理请求。在这种情况下，提高性能变得必要。提高性能的解决方案之一是创建更深层次的复制结构，使主服务器只复制到一个从服务器。其余的从服务器连接到主从服务器进行操作。
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned insightful details about MySQL 8 replication, what
    replication is, and how it helps solve specific problems. We also learned how
    to set up statement-based and row-based replication types. Along the way, we also
    learned about the system variables and server start up options for replication.
    In the later part of the chapter, we dived deep into group replication and how
    it is different from the traditional method of MySQL replication. We also learned
    logging and replication formats. Last but not least, we learned different replication
    solutions in brief. We covered a lot of stuff, huh?
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了关于 MySQL 8 复制的深刻细节，复制是什么，以及它如何帮助解决特定问题。我们还学习了如何设置基于语句和基于行的复制类型。在此过程中，我们还了解了复制的系统变量和服务器启动选项。在本章的后半部分，我们深入探讨了组复制以及它与传统的
    MySQL 复制方法的不同之处。我们还学习了日志记录和复制格式。最后但并非最不重要的是，我们简要了解了不同的复制解决方案。我们涵盖了很多东西，是吧？
- en: It's now time to move on to our next chapter, where we will be setting up several
    types of partitioning, and exploring the selection of partitioning, and pruning
    of partitioning. It also explains how to cope with restrictions and limitations
    while partitioning. The reader will be able to understand which type of partitioning
    suits a situation as per the requirement.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候进入我们的下一章了，在那里我们将设置几种类型的分区，并探索分区的选择和分区的修剪。它还解释了在分区时如何应对限制和限制。读者将能够根据需求了解哪种类型的分区适合某种情况。
