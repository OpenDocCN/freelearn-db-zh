# 第十二章：优化 MySQL 8

在上一章中，我们了解了安全性，这是任何生产级应用程序的重要方面。该章节以安全性介绍和识别常见安全问题开始。随后，该章节涵盖了 MySQL 8 中的访问控制机制、账户管理和加密。我们在该章节的后部分了解了各种 MySQL 8 安全插件。安全性是每个生产级应用程序的重要基准。这就是为什么上一章是重要的。

沿着类似的线路，为了开发高度优化的数据库，本章重点介绍了优化方法。它从 MySQL 8 优化的概述开始。它带领读者了解 MySQL 8 服务器和客户端的优化，优化数据库结构，以及优化常见查询和数据库表。在本章的后面部分，重点放在了缓冲和缓存技术上。

以下是要涵盖的主题列表：

+   MySQL 8 优化概述

+   优化 MySQL 8 服务器和客户端

+   优化数据库结构

+   优化查询

+   优化表

+   利用缓冲和缓存

# MySQL 8 优化概述

让我们从理解 MySQL 8 优化开始。优化是识别性能瓶颈并实施优化解决方案以克服这些问题的过程。MySQL 8 中的优化涉及在多个不同级别进行性能测量、配置和调整。对于管理员来说，在不同级别优化性能是一项重要任务，比如单个 SQL 查询、整个数据库应用程序、数据库服务器或分布式数据库服务器。在 CPU 和内存级别进行性能优化可以提高可伸缩性。它还允许数据库处理更复杂的查询而不会使数据库服务器变慢。

数据库的性能取决于多个因素。在数据库级别，这些因素可以是表、查询和配置。数据库服务器的启动和数据库查询执行是这些构造影响 CPU 或在硬件级别执行 I/O（输入/输出）操作的事件之一。这是 MySQL 8 数据库管理员的责任：确保硬件性能达到最佳水平。需要确保硬件以最大效率使用。在软件级别上，性能优化从学习通用规则和指南以及用时性能测量开始。逐渐地，我们了解各种数据库操作的内部。我们可以用 CPU 周期和 I/O 操作来衡量性能。为了获得最佳的数据库性能，我们可以在基本级别优化软件和硬件配置。在高级水平上，我们可以通过开发自定义存储引擎和硬件设备来改进 MySQL 本身，从而扩展 MySQL 生态系统。

# 优化数据库

使数据库以最佳速度运行的最重要因素是什么？答案是，基本的数据库设计。以下是数据库设计需要注意的检查表：

+   数据库列必须是正确的数据类型。表必须为所需的目的具有适当的列。对数据库执行频繁操作的应用程序具有较少的列的许多表，而分析大量数据的应用程序具有许多列的有限表。

+   正如我们在之前的章节中学到的，数据库索引在增强查询性能方面起着重要作用。因此，为了提高查询执行效率，正确的索引放置非常重要。

+   我们在早期章节中讨论了数据库存储引擎，比如 MyISAM 或 InnoDB。对于每个单独的表使用适当的存储引擎是重要的。InnoDB 对于事务性数据库表更为合适，而 MyISAM 对于定义非事务性数据库表更为合适。存储引擎的选择在定义数据库的性能和可伸缩性方面起着至关重要的作用。

+   在 MySQL 8 数据类型章节中，我们详细了解了行格式。对于每个表来说，拥有适当的行格式是非常重要的。行格式的选择取决于所选择的存储引擎。压缩表占用更少的磁盘空间，并且需要更少的磁盘 I/O 操作。对于 InnoDB 表，压缩适用于所有读写操作。相反，只有对于只读的 MyISAM 表才适用压缩。

+   MySQL 数据库支持多种锁定策略。锁定可以是表级别的，也可以是行级别的。应用程序必须使用适当的锁定策略。通过在适当的地方授予共享访问权限，可以实现并发运行数据库操作。此外，应该可以请求独占访问，以便可以执行关键的数据库操作，并保持数据完整性和优先级。在这种情况下，存储引擎的选择再次变得重要。InnoDB 存储引擎处理大多数锁定问题而无需用户参与。它允许更好的并发性，并减少了对代码的实验和调整的数量。

+   内存区域必须使用正确的缓存大小。它应该足够大，以容纳频繁访问的数据，同时又不会过载物理内存并导致分页。InnoDB 缓冲池和 MyISAM 关键缓存是需要配置的主要内存区域。

对于新创建的表，MyISAM 是默认的存储引擎。在实际使用中，InnoDB 的高级性能特性意味着使用 InnoDB 存储引擎的表在操作繁重的数据库中表现优于 MyISAM 表。

# 优化硬件

增长是每个软件应用的本质。随着应用程序的增长，数据库也会增长。数据库在执行操作时变得越来越繁忙。在某一点上，数据库应用程序最终会达到硬件限制。管理员必须评估调整应用程序或重新配置服务器以避免这些问题的可能性。还应该评估是否增加更多的硬件资源会有所帮助。系统瓶颈通常来自以下来源：

+   **磁盘搜索**：作为磁盘读取操作的一部分，查找数据需要时间。现代磁盘的平均查找数据时间通常低于 10 毫秒。因此，理论上应该是每秒 100 次搜索。随着技术的进步，新的磁盘在磁盘时间上有所改进，但很难为单个表进行优化。要优化搜索时间，需要将数据分布在多个磁盘上。

+   **磁盘读写**：要从磁盘读取或写入数据，需要磁盘处于正确的位置。一个磁盘至少提供每秒 10 到 20MB 的吞吐量（吞吐量是每秒读取或写入的数据量）。因此，读取和写入吞吐量比搜索时间更容易优化，因为我们可以从多个磁盘并行读取。

+   **CPU 周期**：我们必须在主内存中处理数据以获得所需的结果。对于大表来说，内存的数量是最常见的限制因素。然而，对于小表来说，速度通常不是问题。

+   **内存带宽**：在罕见的情况下，当 CPU 需要的数据超过 CPU 缓存内存的容量时，主内存带宽成为瓶颈。

# 优化 MySQL 8 服务器和客户端

本节重点介绍了 MySQL 8 数据库服务器和客户端的优化，从优化服务器开始，然后优化 MySQL 8 客户端实体。本节更适合数据库管理员，以确保多个服务器的性能和可伸缩性。这也将帮助准备脚本的开发人员（包括设置数据库）和运行 MySQL 进行开发和测试的用户，以最大限度地提高生产力。

# 优化磁盘 I/O

在本节中，我们将学习如何配置存储设备，以将更多和更快的存储硬件专用于数据库服务器。磁盘寻址（查找磁盘上正确位置以读取或写入内容）是一个主要的性能瓶颈。当数据量足够大以至于无法进行缓存时，磁盘寻址的问题就会显现出来。在大型数据库中，数据访问基本上是随机进行的，因此我们需要至少进行一次磁盘寻址操作来读取数据，以及进行多次磁盘寻址操作来写入数据。我们应该使用适当的磁盘来调节或最小化磁盘寻址时间。

为了解决磁盘寻址性能问题，可以增加可用磁盘轴承的数量，将文件符号链接到不同的磁盘，或者进行磁盘分区。以下是详细信息：

+   **使用符号链接**：在使用符号链接时，我们可以为索引和数据文件创建 Unix 符号链接。在`MyISAM`表的情况下，符号链接从数据目录中的默认位置指向另一个磁盘。这些链接也可以进行条带化。这将改善寻址和读取时间。假设磁盘没有同时用于其他目的。符号链接不支持`InnoDB`表。但是，我们可以将`InnoDB`数据和日志文件放在不同的物理磁盘上。

+   **条带化**：在条带化中，我们有许多磁盘。我们将第一个块放在第一个磁盘上，第二个块放在第二个磁盘上，依此类推。第*N*块放在（N % 磁盘数）磁盘上。如果条带大小完全对齐，正常数据大小将小于条带大小。这将有助于提高性能。条带化取决于条带大小和操作系统。在理想情况下，我们会使用不同的条带大小对应用程序进行基准测试。条带化的速度差异取决于我们使用的参数，如条带大小。性能差异还取决于磁盘数量。我们必须选择是要优化随机访问还是顺序访问。为了获得可靠性，我们可能决定设置条带化和镜像（RAID 0+1）。**RAID**代表**独立驱动器冗余阵列**。这种方法需要 2 x *N*驱动器来容纳*N*驱动器的数据。通过良好的卷管理软件，我们可以有效地管理这种设置。

+   还有另一种方法。根据数据类型的重要性，我们可以改变 RAID 级别。例如，我们可以将非常重要的数据，如主机信息和日志，存储在 RAID 0+1 或 RAID N 磁盘上，而将较重要的数据存储在 RAID 0 磁盘上。在 RAID 的情况下，奇偶校验位用于确保存储在每个驱动器上的数据的完整性。因此，如果要执行太多写操作，RAID N 将成为一个问题。在这种情况下，更新奇偶校验位所需的时间较长。

+   如果维护文件上次访问时间不重要，我们可以使用`-o noatime`选项挂载文件系统。此选项跳过文件系统上的更新，从而减少磁盘寻址时间。我们还可以使文件系统异步更新。根据文件系统是否支持，我们可以设置`-o async`选项。

# 使用 NFS 与 MySQL

在使用**网络文件系统**（**NFS**）时，可能会出现各种问题，这取决于操作系统和 NFS 版本。以下是详细信息：

+   NFS 系统存在数据不一致性的问题。这可能是因为接收到的消息顺序不正确或网络流量丢失。我们可以使用带有`hard`和`intr`挂载选项的 TCP 来避免这些问题。

+   MySQL 数据和日志文件如果放在 NFS 驱动器上，可能会被锁定并变得无法使用。如果多个 MySQL 实例访问相同的数据目录，可能会导致锁定问题。MySQL 的不正确关闭或断电是文件系统锁定问题的其他原因。最新版本的 NFS 支持咨询和基于租约的锁定，有助于解决锁定问题。但是，不建议在多个 MySQL 实例之间共享数据目录。

+   必须了解最大文件大小限制，以避免任何问题。使用 NFS 2，客户端只能访问文件的较低 2 GB。NFS 3 客户端支持更大的文件。最大文件大小取决于 NFS 服务器的本地文件系统。

# 优化内存的使用

为了提高数据库操作的性能，MySQL 分配缓冲区和缓存内存。默认情况下，MySQL 服务器在具有 512 MB RAM 的虚拟机（VM）上启动。我们可以修改 MySQL 的默认配置，使其在有限内存系统上运行。

以下列表描述了优化 MySQL 内存的方法：

+   用于缓存`InnoDB`数据的表、索引和其他辅助缓冲区的内存区域称为`InnoDB`缓冲池。缓冲池分为页面。页面包含多行。缓冲池实现为页面的链表，以实现高效的缓存管理。使用算法从缓存中删除很少使用的数据。缓冲池大小是系统性能的重要因素。`innodb__buffer_pool_size`系统变量定义了缓冲池大小。`InnoDB`在服务器启动时分配整个缓冲池大小。建议将系统内存的 50%至 75%用于缓冲池大小。

+   使用`MyISAM`，所有线程共享关键缓冲区。`key_buffer_size`系统变量定义了关键缓冲区的大小。索引文件为服务器打开的每个`MyISAM`表打开一次。对于访问表的每个并发线程，数据文件只打开一次。为每个并发线程分配一个表结构，每个列的列结构以及一个 3 x *N*大小的缓冲区。`MyISAM`存储引擎为内部使用维护了一个额外的行缓冲区。

+   优化器通过扫描来估计多行的读取。存储引擎接口使优化器能够提供有关记录缓冲区大小的信息。缓冲区的大小可以根据估计的大小而变化。为了利用行预取功能，`InnoDB`使用可变大小的缓冲能力。它减少了锁定和 B 树导航的开销。

+   通过将`myisam_use_mmap`系统变量设置为 1，可以为所有`MyISAM`表启用内存映射。

+   内存临时表的大小可以由`tmp_table_size`系统变量定义。堆表的最大大小可以使用`max_heap_table_size`系统变量定义。如果内存表变得太大，MySQL 会自动将表从内存转换为磁盘上。磁盘上临时表的存储引擎由`internal_tmp_disk_storage_engine`系统变量定义。

+   MySQL 配备了 MySQL 性能模式。这是一个监视 MySQL 低级执行的功能。性能模式通过根据实际服务器负载调整其内存使用来动态分配内存，而不是在服务器启动时分配内存。一旦分配了内存，直到服务器重新启动才会释放。

+   服务器用于管理客户端连接的每个线程都需要特定的空间。堆栈大小由`thread_stack`系统变量控制。连接缓冲区由`net_buffer_length`系统变量控制。结果缓冲区由`net_buffer_length`控制。连接缓冲区和结果缓冲区以`net_buffer_length`字节开始，但根据需要扩大到`max_allowed_packets`字节。

+   所有线程共享相同的基本内存。

+   所有连接子句都在单次执行中执行。大多数连接可以在不使用临时表的情况下执行。临时表是基于内存的哈希表。包含`BLOB`数据和行长度较大的表存储在磁盘上。

+   为每个请求分配一个读取缓冲区，该请求对表进行顺序扫描。读取缓冲区的大小由`read_buffer_size`系统变量确定。

+   在以任意方式读取行时分配了一个随机读取缓冲区，以避免磁盘寻道。缓冲区大小由`read_rnd_buffer_size`系统变量确定。

+   线程分配的内存在线程不再需要时被释放。释放的内存会被返回给系统，除非线程被放入线程缓存中。

+   当执行`FLUSH TABLES`或`mysqladmin` flush-table 命令时，MySQL 会立即关闭所有未使用的表。当当前线程执行完成时，它标记所有正在使用的表将被关闭。这会释放正在使用的内存。`FLUSH TABLES`仅在所有表关闭后才返回。

可以监视 MySQL 性能模式和内存使用情况的 sys 模式。在执行此操作之前，我们必须在 MySQL 性能模式上启用内存工具。可以通过更新性能模式`setup_instruments`表的`ENABLED`列来完成。以下是查询 MySQL 中可用内存工具的查询：

```go
mysql> SELECT * FROM performance_schema.setup_instruments WHERE NAME LIKE '%memory%';
```

如果在启动时启用了内存工具，则可以确保在启动时对内存分配进行计数。

此查询将返回数百个内存工具。我们可以通过指定代码区域来缩小范围。以下是将结果限制为`InnoDB`内存工具的示例：

```go
mysql> SELECT * FROM performance_schema.setup_instruments WHERE NAME LIKE '%memory/innodb%'; 
+-------------------------------------------+---------+-------+ 
|                    NAME                   | ENABLED | TIMED | 
+-------------------------------------------+---------+-------+ 
|     memory/innodb/adaptive hash index     |    NO   |   NO  | 
|     memory/innodb/buf_buf_pool            |    NO   |   NO  | 
| memory/innodb/dict_stats_bg_recalc_pool_t |    NO   |   NO  | 
|   memory/innodb/dict_stats_index_map_t    |    NO   |   NO  | 
| memory/innodb/dict_stats_n_diff_on_level  |    NO   |   NO  | 
|         memory/innodb/other               |    NO   |   NO  | 
|         memory/innodb/row_log_buf         |    NO   |   NO  | 
|          memory/innodb/row_merge_sort     |    NO   |   NO  | 
|             memory/innodb/std             |    NO   |   NO  | 
|      memory/innodb/trx_sys_t::rw_trx_ids  |    NO   |   NO  |
+-------------------------------------------+---------+-------+ 
```

以下是启用内存工具的配置：

```go
performance-schema-instrument='memory/%=COUNTED'
```

以下是在性能模式中的`memory_summary_global_by_event_name`表中查询内存工具数据的示例：

```go
mysql> SELECT * FROM performance_schema.memory_summary_global_by_event_name WHERE EVENT_NAME LIKE 'memory/innodb/buf_buf_pool'\G;

EVENT_NAME: memory/innodb/buf_buf_pool
COUNT_ALLOC: 1
COUNT_FREE: 0
SUM_NUMBER_OF_BYTES_ALLOC: 137428992
SUM_NUMBER_OF_BYTES_FREE: 0
LOW_COUNT_USED: 0
CURRENT_COUNT_USED: 1
HIGH_COUNT_USED: 1
LOW_NUMBER_OF_BYTES_USED: 0
CURRENT_NUMBER_OF_BYTES_USED: 137428992
HIGH_NUMBER_OF_BYTES_USED: 137428992
```

它通过`EVENT_NAME`对数据进行汇总。

以下是查询 sys 模式以按代码区域聚合当前分配的内存的示例：

```go
mysql> SELECT SUBSTRING_INDEX(event_name,'/',2) AS        
  code_area, sys.format_bytes(SUM(current_alloc))        
  AS current_alloc        
  FROM sys.x$memory_global_by_current_bytes        
  GROUP BY SUBSTRING_INDEX(event_name,'/',2)        
  ORDER BY SUM(current_alloc) DESC; 
+---------------------------+---------------+ 
| code_area                 | current_alloc | 
+---------------------------+---------------+ 
| memory/innodb             | 843.24 MiB    | 
| memory/performance_schema | 81.29 MiB     | 
| memory/mysys              | 8.20 MiB      | 
| memory/sql                | 2.47 MiB      | 
| memory/memory             | 174.01 KiB    | 
| memory/myisam             | 46.53 KiB     | 
| memory/blackhole          | 512 bytes     | 
| memory/federated          | 512 bytes     | 
| memory/csv                | 512 bytes     | 
| memory/vio                | 496 bytes     | 
+---------------------------+---------------+
```

# 优化网络的使用

MySQL 数据库服务器打开网络接口以与客户端连接，并开始监听这些接口。连接管理器线程负责处理客户端连接请求。连接管理器线程还处理 Unix 平台上的套接字文件。连接管理器线程处理共享内存连接请求，另一个线程处理 Windows 系统上的命名管道连接请求。不会为服务器不监听的接口创建线程。

连接管理器线程为每个客户端连接分配一个线程。该线程对该客户端连接进行身份验证并处理请求处理。管理器线程首先在线程缓存中检查是否有可用于客户端连接的线程。如果缓存中没有可用线程，则创建一个新线程。一旦客户端请求被处理并且连接结束，为服务客户端连接创建的线程将被返回到线程缓存，除非缓存已满。

在这种线程连接模型中，线程的数量与当前连接的客户端数量相同。它也有缺点。当服务器需要扩展以处理比当前处理的连接数更多的连接时，线程的创建和处理变得昂贵。在这种线程连接模型中，每个线程都需要服务器和内核资源。

有些服务器变量可用于设置服务器以实现优化的网络使用。`thread_cache_size`是定义线程缓存大小的系统变量。线程缓存大小的默认值为 0。这意味着对于每个新连接，都需要设置一个线程，并在连接终止时进行处理。如果我们将`thread_cache_size`设置为 10，它将启用 10 个非活动连接线程进行缓存。当与其关联的客户端的连接终止时，线程连接变为非活动状态。

服务器可以处理的 SQL 语句的复杂性受线程堆栈大小的限制。MySQL 8 服务器可以使用`--thread_stack=N`启动，为每个线程设置*N*字节的堆栈大小。

设置线程缓存大小后，监视其影响变得至关重要。`Threads_cached`和`Threads_created`是用于查找线程缓存中的线程数以及因无法从缓存中获取而创建的线程数的状态变量。以下是查找服务器状态变量值的示例命令：

```go
mysql> show global status;
+-----------------------------+--------+
| Variable_name               |  Value |
+-----------------------------+--------+
| Aborted_clients             |     0  |
| Aborted_connects            |     1  |
| Acl_cache_items_count       |     0  |
| Binlog_cache_disk_use       |     0  |
| Binlog_cache_use            |     0  |
| Binlog_stmt_cache_disk_use  |     0  |
| Binlog_stmt_cache_use       |     0  |
| Bytes_received              |    443 |
| Bytes_sent                  |    346 |
| Threads_cached              |     0  |
| Threads_connected           |     1  |
| Threads_created             |     1  |
| Threads_running             |     2  |
+-----------------------------+--------+
```

下面是过滤`status`变量的示例：

```go
mysql> show status like '%Thread%';
+------------------------------------------+-------+
| Variable_name                            | Value |
+------------------------------------------+-------+
| Delayed_insert_threads                   |     0 |
| Performance_schema_thread_classes_lost   |     0 |
| Performance_schema_thread_instances_lost |     0 |
| Slow_launch_threads                      |     0 |
| Threads_cached                           |     0 |
| Threads_connected                        |     1 |
| Threads_created                          |     1 |
| Threads_running                          |     2 |
+------------------------------------------+-------+
```

# 优化锁定操作

如前几章所讨论的，MySQL 8 使用锁定机制来管理争用。当多个线程中同时执行查询尝试同时获取一个表时，就会发生争用。如果这些查询同时在表上执行，表数据将处于不一致状态。MySQL 8 支持两种类型的锁定：内部锁定和外部锁定。

MySQL 服务器内部由多个线程执行内部锁定，以管理对表内容的争用。这种类型的锁定完全由 MySQL 服务器执行，不涉及任何其他程序。那么，为什么它被称为内部锁定？在外部锁定的情况下，MySQL 服务器和其他程序锁定表文件，以决定哪些程序可以同时访问表。

以下是内部锁定的两种方法：

+   行级锁定。

+   表级锁定。

MySQL 中的行级锁定支持多个会话的同时写访问。这使得多用户和高并发应用程序成为可能。在单个表上执行多个并发写操作时，很可能会发生死锁。

为了避免这种死锁情况，锁定机制在事务开始时使用`SELECT ... FOR UPDATE`语句获取每组要修改的行的锁定。如果事务锁定多个表，MySQL 会在每个事务内以相同的顺序应用语句。`InnoDB`数据库引擎会自动检测死锁条件并回滚受影响的事务。考虑到这一点，死锁会影响性能。

在高度并发的系统中，死锁检测可能会导致减速。在这种情况下，禁用死锁检测会更有效。当发生死锁时，我们可以依靠`innodb_lock_wait_timeout`设置来进行事务回滚。使用`innodb_deadlock_detect`配置选项，我们可以禁用死锁检测。

以下是行级锁定的优点：

+   当不同会话访问表中的不同行时，锁冲突的数量较少

+   要回滚的更改数量较少

+   可以长时间锁定单个表行

表级锁定由 MySQL 用于`MyISAM`，`MEMORY`和`MERGE`表。在表级锁定的情况下，MySQL 一次只允许一个会话更新这些表。通过表级锁定，这些存储引擎适用于只读或单用户应用程序。这些存储引擎在查询开始时一次性请求所有所需的锁，以避免任何死锁。它总是以相同的顺序锁定表。表级锁定的主要缺点是影响并发性。如果其他会话需要修改表，则必须等到并发数据更改语句完成。

表级锁定的优点如下：

+   与行级锁定相比，它需要更少的内存

+   当用于表的大部分时，速度很快，因为只需要一个锁

+   如果频繁执行`GROUP BY`操作，速度很快

MySQL 授予表写锁的策略如下：

1.  如果表上没有写锁，则在表上放置写锁

1.  如果表已经有写锁，则将锁请求放入写锁队列

MySQL 授予表读锁的策略如下：

1.  如果表上没有读锁，则在表上放置读锁

1.  如果表已经有读锁，则将锁请求放入读锁队列

对表的更新比表的检索给予更高的优先级。当锁被释放时，写锁请求首先可用，然后是读锁请求。

以下是分析表锁争用的示例：

```go
mysql> SHOW STATUS LIKE 'Table_locks%';
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| Table_locks_immediate |     5 |
| Table_locks_waited    |     0 |
+-----------------------+-------+
```

`MyISAM`存储引擎天然支持多个并发插入，以减少读者和写者对表的争用。它允许`MyISAM`表在数据文件中间插入行。如果表在数据文件中间没有空闲块，则行将插入到文件末尾。这使得 MySQL 能够同时在同一表上执行`INSERT`和`SELECT`查询。`concurrent_insert`是全局系统变量，控制`MyISAM`存储引擎允许执行并发`INSERT`和`SELECT`语句的行为。如果将此系统变量设置为`AUTO`，则允许并发`INSERT`和`SELECT`。

如果无法进行并发插入，并且我们想在表`tab1`上执行多个`INSERT`和`SELECT`操作，可以使用临时表`temp_tab1`来保存`tab1`表数据，并使用`temp_tab1`表中的行更新`tab1`表。以下是演示此场景的示例：

```go
mysql> LOCK TABLES tab1 WRITE, temp_tab1 WRITE;
mysql> INSERT INTO tab1 SELECT * FROM temp_tab1;
mysql> DELETE FROM temp_tab1;
mysql> UNLOCK TABLES;
```

# 性能基准测试

在衡量性能时，我们必须考虑以下因素：

+   在衡量单个操作或一组操作的速度时，重要的是在数据库工作负载繁重的情况下模拟场景以进行基准测试

+   在不同的环境中，测试结果可能不同

+   根据工作负载，某些 MySQL 功能可能无法提高性能

MySQL 8 支持衡量单个语句的性能。如果要衡量任何 SQL 表达式或函数的速度，则使用`BENCHMARK()`函数。以下是该函数的语法：

```go
BENCHMARK(loop_count, expression)
```

`BENCHMARK`函数的输出始终为零。速度可以通过 MySQL 在输出中打印的行来衡量。以下是一个例子：

```go
mysql> select benchmark(1000000, 1+1);
+-------------------------+
| benchmark(1000000, 1+1) |
+-------------------------+
|                       0 |
+-------------------------+
1 row in set (0.15 sec)
```

从上面的例子中，我们可以发现计算`1+1`1000000 次所需的时间为`0.15 秒`。

# 检查线程信息

有时，我们可能需要弄清楚 MySQL 服务器在做什么。因此，有必要找出进程列表。进程列表是 MySQL 服务器内当前正在执行的线程集合。

获取进程列表信息的来源如下：

+   `SHOW [FULL] PROCESSLIST`语句。以下是进程列表信息的示例：

```go
mysql> show processlist;
+----+-----------------+-----------------+------+---------+--------+
| Id |       User      |       Host      |   db | Command |  Time  |
+----+-----------------+-----------------+------+---------+--------+
+------------------------+-----------------------+
|         State          |         Info          |
+------------------------+-----------------------+
+----+-----------------+-----------------+------+---------+--------+
| 4  | event_scheduler |      localhost  | NULL | Daemon  | 214901 |
+----+-----------------+-----------------+------+---------+--------+
|  8 |  root           | localhost:58629 | NULL |  Query  |     0  |
+----+-----------------+-----------------+------+---------+--------+
+------------------------+-----------------------+
| Waiting on empty queue |         NULL          |
+------------------------+-----------------------+
| starting               | show full processlist |
+------------------------+-----------------------+
```

+   `SHOW PROFILE`语句。

+   `INFORMATION_SCHEMA PROCESSLIST`表：

```go
mysql> select * from information_schema.processlist;
+----+-----------------+-----------------+------+---------+--------+
| ID |       USER      |       HOST      |  DB  | COMMAND |  TIME  |
+----+-----------------+-----------------+------+---------+--------+
+------------------------+----------------------------------------------+
|         STATE          |                         INFO                 |
+------------------------+----------------------------------------------+
+----+-----------------+-----------------+------+---------+--------+
|  8 | root            | localhost:58629 | NULL | Query   |      0 |
+----+-----------------+-----------------+------+---------+--------+
|  4 | event_scheduler | localhost       | NULL | Daemon  | 215640 |
+----+-----------------+-----------------+------+---------+--------+
+------------------------+----------------------------------------------+
| executing              | select * from information_schema.processlist |
+------------------------+----------------------------------------------+
| Waiting on empty queue | NULL                                         |
+------------------------+----------------------------------------------+
```

+   `mysqladmin processlist`命令。

+   性能模式线程表，阶段表和锁表。

我们必须能够查看用户线程的信息。需要`PROCESS`权限才能查看正在执行的线程的信息。要访问线程，不需要互斥访问。对 MySQL 服务器性能的影响较小。访问`INFORMATION_SCHEMA.PROCESSLIST`和`SHOW PROCESSLIST`需要互斥访问，并会影响性能。线程还提供后台线程的详细信息。`INFORMATION_SCHEMA.PROCESSLIST`和`SHOW PROCESSLIST`不提供有关后台线程的信息。

以下表格显示了每个进程列表条目中包含的信息：

| **信息** | **详情** |
| --- | --- |
| Id | 与线程关联的客户端连接标识符。 |
| 用户，主机 | 与线程相关的帐户。 |
| db | 线程的默认数据库或`NULL`。 |
| 命令，状态 | 表示线程当前正在做什么。 |
| 时间 | 表示线程在当前状态下已经多久。 |
| 信息 | 包含线程执行的语句的信息。 |

以下是与一般查询处理相关的线程状态值：

+   `创建后`：当线程创建表时发生，包括内部临时表

+   分析：当线程正在计算`MyISAM`键分布时发生

+   `检查权限`：当检查服务器是否具有执行 SQL 语句所需的权限时发生

+   `检查表`：当线程执行表检查操作时发生

+   `清理`：当线程处理完一个命令并释放内存时发生

+   `关闭表`：当线程刷新更改的表数据到磁盘并关闭已使用的表时发生

+   `修改表`：当服务器处理`ALTER TABLE`语句时发生

+   `创建索引`：当线程处理`MyISAM`表的`ALTER TABLE ... ENABLE KEYS`时发生

+   `创建表`：当线程正在创建表时发生

+   `end`：在结束之前发生，但在清理`ALTER TABLE`，`CREATE VIEW`，`DELETE`，`INSERT`，`SELECT`或`UPDATE`语句之前

+   `执行`：当线程开始执行语句时发生

+   `init`：在`ALTER TABLE`，`DELETE`，`INSERT`，`SELECT`和`UPDATE`语句初始化之前发生

以下是复制主服务器线程的`binlog`转储线程中的常见状态列表：

+   完成读取一个`binlog`；切换到下一个`binlog`

+   主服务器已将所有`binlog`发送到从属服务器；等待更多更新

+   向从属服务器发送`binlog`事件

+   等待最终终止

以下是从属服务器 I/O 线程的常见状态列表：

+   检查主服务器版本

+   连接到主服务器

+   将主事件排队到中继日志

+   在失败的`binlog`转储请求后重新连接

+   在失败的主服务器事件读取后重新连接

+   在主服务器上注册从属服务器

+   请求`binlog`转储

+   等待轮到自己提交

+   等待主服务器发送事件

+   等待主服务器更新

+   等待从属服务器退出的互斥

+   等待从属服务器 SQL 线程释放足够的中继日志空间

+   在失败的`binlog`转储请求后等待重新连接

+   在失败的主服务器事件读取后等待重新连接

以下是从属服务器 SQL 线程的常见状态列表：

+   杀死从属服务器

+   在重放`LOAD DATA INFILE`之前制作临时文件（追加）

+   在重放`LOAD DATA INFILE`之前制作临时文件（创建）

+   从中继日志读取事件

+   从属服务器已读取所有中继日志；等待更多更新

+   等待来自协调器的事件

+   等待从属服务器退出的互斥

+   等待从属服务器工作线程释放挂起事件

+   等待中继日志中的下一个事件

+   等待`MASTER_DELAY`秒，直到主服务器执行事件

# 优化数据库结构

作为数据库管理员，我们必须寻找有效的方法来组织表模式、表和列。我们最小化 I/O，提前规划，并将相关项目放在一起，以调整应用程序代码，以保持性能高并增加数据量。通常从高效的数据库设计开始，这样可以更容易地编写高性能的应用程序代码。这也使得数据库在应用程序发展或重写时能够自我维持。

# 优化数据大小

为了最小化磁盘上的空间，我们应该开始设计数据库表。这会带来巨大的性能改进，因为它减少了要写入和从磁盘读取的数据量。较小的表通常需要较少的主内存，而在查询执行期间活动处理内容。表数据空间的任何减少都会导致需要更小的索引，这样可以更快地处理。

正如在 MySQL 8 数据类型章节中讨论的那样，MySQL 支持许多不同的存储引擎和行格式。我们可以决定每个表要使用的存储和索引方法。选择适当的表格式是一个很大的性能提升。

# 表列

我们应该为表列使用尽可能小的数据类型。这是最有效的方法。MySQL 支持专门的数据类型来节省内存和磁盘空间。例如，我们应该尽可能使用整数类型来获得较小的表。比较`MEDIUMINT`和`INT`，`MEDIUMINT`是一个更好的选择，因为它使用的空间比`INT`少 25%。

我们必须尽可能声明列为`NOT NULL`。这样可以更好地使用索引，并消除测试每个值是否为`NULL`的开销。这会导致更快的 SQL 操作。我们也可以节省每列一个位的存储空间。如果我们真的需要，应该使用`NULL`。`NULL`值不应该作为每列的默认设置而被允许。

通过以下技术可以获得表的巨大性能提升并最小化存储空间需求：

# 行格式

默认情况下，在创建`InnoDB`表时使用`DYNAMIC`行格式。我们可以配置`innodb_default_row_format`以使用除`DYNAMIC`之外的行格式。我们还可以在`CREATE TABLE`或`ALTER TABLE`语句中明确指定`ROW_FORMAT`选项。

行格式包括`COMPACT`、`DYNAMIC`和`COMPRESSED`。它们减少了行存储空间，但在某些操作上增加了 CPU 使用。对于平均工作负载，受到缓存命中率和磁盘速度的限制，它会更快。如果受到 CPU 速度的限制，它会更慢。

行格式还优化了使用可变长度字符集时`CHAR`数据类型列的存储。使用`REDUNDANT`行格式，`CHAR(N)`列值占用字符集中最大字节长度的*N*倍。`InnoDB`存储引擎在*N*到*N*倍字符集中最大字节长度范围内分配可变数量的存储空间。

如果在`MyISAM`表的情况下没有可变长度列，例如`VARCHAR`、`TEXT`或`BLOB`，则使用固定大小的行格式。

# 索引

表的主索引必须尽可能短。这样可以轻松识别每一行。这也很有效。在`InnoDB`表的情况下，主键列在每个次要索引条目中都会被复制。如果我们有一个较短的主键，那么在有许多次要索引的情况下可以节省空间。

我们应该只创建那些提高查询性能的索引。索引改善信息检索，但会减慢插入和更新操作。必须要注意索引的性能影响来创建索引。如果需要通过组合列进行搜索来访问表，最好在组合列上创建复合索引，而不是在每个列上单独创建索引。最常用的列应该是索引的第一部分。如果在表的选定操作中经常使用许多列，建议将具有最多重复项的列作为索引中的第一列。这样可以更好地压缩索引。

如果一个长字符串列应该有一个唯一的前缀作为前几个字符，建议只索引前缀，使用 MySQL 对列的最左边部分进行索引的支持。更短的索引更受青睐，不仅因为它们需要更少的空间，而且因为它们在索引缓存中提供更多的命中，并且需要更少的磁盘查找。

# 连接

如果一个表经常被扫描，如果可行的话，将表拆分成两个表是有益的。这尤其适用于动态格式表。还可以使用较小的静态格式表，用于在扫描表时搜索相关行。

具有相同信息的列应该在不同的表中声明，具有相同的数据类型。这加快了基于匹配列的连接。

列名必须保持简单，以便在表之间使用相同的名称。这简化了连接查询。例如，在客户表中，我们应该使用`name`作为列名，而不是使用`customer_name`。为了使名称可移植到其他 SQL 服务器，我们应该保持列名短于 18 个字符。

# 规范化

表列中的数据必须保持非冗余，考虑规范化理论中的第三范式。如果列包含重复的长数值，例如名称或地址，最好分配唯一的 ID，并在多个较小的表中重复这些 ID。在搜索时，应该通过在连接子句中引用 ID 来使用连接查询。

在应用程序中，如果偏好速度而不是磁盘空间或使用多个数据副本的维护成本，建议复制信息或创建摘要表以获得更快的速度。一个例子是商业智能系统，从大型表中分析数据。在这种情况下，规范化规则并不严格遵循。

# 优化 MySQL 数据类型

以下是优化数字数据类型的指南：

+   数字列必须优先于字符串列，用于存储唯一 ID 或其他可以表示为字符串或数字的值。它更快，占用更少的内存来传输和比较，因为与字符串相比，大的数字值存储在较少的字节中。

+   从数据库中访问信息比从文本文件中访问信息更快。当使用数字数据时，这一点尤为真实。数据库中的信息以比文本文件更紧凑的格式存储。因此，它需要更少的磁盘访问。

以下是优化字符和字符串数据类型的指南：

+   二进制排序顺序（逻辑顺序）应该用于更快的比较和排序操作。二进制运算符也可以在查询中使用二进制排序顺序。

+   对于`InnoDB`表，当我们使用随机生成的值作为主键时，如果可行的话，应该以升序值作为前缀，例如日期和时间。在这种情况下，主键值在物理上更接近。`InnoDB`可以更快地插入或检索这些值。

+   对于预计保存少于 8KB 数据的列值，应使用二进制 VARCHAR 数据类型而不是 BLOB。如果原始表没有任何 BLOB 列，GROUP BY 和 ORDER BY 子句会生成临时表。这些临时表可以使用 MEMORY 存储引擎。

+   为了在运行查询时避免字符串转换，应尽可能在比较来自不同列的值时使用相同的字符集和排序声明列。

+   如果表包含不经常在检索操作中使用的字符串列，应考虑将字符串列拆分为单独的表。在检索操作中，应根据需要使用外键进行连接查询。当检索任何行的值时，MySQL 读取包含该行的所有列的数据块。当我们保持行较小，仅包含经常使用的列时，可以使更多的行适应每个数据块。这些紧凑的表减少了内存使用和磁盘 I/O。

以下是优化 BLOB 数据类型的指南：

+   检索和显示信息时，BLOB 列的性能要求可能会有所不同。因此，应考虑将 BLOB 特定表存储在不同的存储设备或单独的数据库实例中。例如，需要在大型顺序磁盘读取中检索 BLOB。因此，传统硬盘驱动器或 SSD 设备可能更适合需求。

+   为了减少不使用 BLOB 列的查询的内存需求，对于具有多个列的表，应考虑将 BLOB 拆分为单独的表，并根据需要使用连接查询进行引用。

+   如果表列是一个包含文本数据的大型 blob，应首先考虑压缩。如果整个表由存储引擎（如 InnoDB 或 MyISAM）压缩，就不应该使用这种技术。

# 优化多个表

我们学习了在某些情况下将表拆分为多个表以加快查询执行的技术。这种技术并不适用于所有情况，因为如果表的数量达到数千个，管理所有这些表的开销将成为另一个性能噩梦。

在本节中，我们将看到 MySQL 如何打开和关闭表。以下显示了如何在 MySQL 服务器上发现打开的文件：

```go
> mysqladmin status
Uptime: 262200 Threads: 2 Questions: 16 Slow queries: 0 Opens: 111 Flush tables: 2 Open tables: 87 Queries per second avg: 0.000
```

MySQL 8 服务器是多线程的。可能会有许多客户端同时为一个表发出查询。MySQL 为每个并发会话独立打开表，以最小化同一表上具有不同状态的多个客户端会话的问题。这提高了性能，尽管需要额外的内存。每个打开 MyISAM 表的客户端需要一个额外的文件描述符。

table_open_cache 系统变量确定所有线程的打开表的数量。通过增加这个值可以增加 mysqld 需要的文件描述符的数量。max_connections 系统变量确定允许的最大同时客户端连接数。在某种程度上，这两个系统变量影响 MySQL 服务器可以保持打开的文件的最大数量。如果我们增加这两个值，可能会受到操作系统对每个进程打开文件数量的限制。

以下是 MySQL 关闭未使用表的情况：

+   当表缓存已满且有线程尝试打开不在表缓存中的表时。

+   当表缓存包含的条目多于 table_open_cache 系统变量中指定的条目，并且缓存中的表不再被任何线程使用时。

+   当有人发出 FLUSH TABLES 语句或执行 mysqladmin flush-tables 或 mysqladmin refresh 命令时，表刷新操作会发生。MySQL 在此事件上关闭表。

MySQL 8 服务器在表缓存已满时使用以下过程来定位缓存条目：

+   从最近最少使用的表开始释放未使用的表。

+   如果需要打开一个新表，表缓存已满且无法释放表，则根据需要临时扩展缓存。如果在表缓存处于临时扩展状态时，表从已使用状态转换为未使用状态，则关闭该表并从表缓存中释放。

以下是查找打开表数量的示例：

```go
mysql> SHOW GLOBAL STATUS LIKE '%Opened_Tables%';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| Opened_tables | 112   |
+---------------+-------+
```

# 在 MySQL 中使用内部临时表

在处理 SQL 语句时，MySQL 8 服务器在某些情况下创建临时内部表。以下是服务器创建临时表的条件：

+   UNION 语句

+   使用`TEMPTABLE`算法、`UNION`或`聚合`的视图

+   派生表

+   公共表达式

+   为子查询或半连接材料化创建的表

+   包含`ORDER BY`和`GROUP BY`子句的语句

+   带有`DISTINCT`和`ORDER BY`的语句

+   使用`SQL_SMALL_RESULT`修饰符的查询

+   从相同表中选择并插入的`INSERT ... SELECT`语句

+   多表`UPDATE`语句

+   `GROUP_CONCAT()`或`COUNT(DISTINCT)`表达式

`EXPLAIN`语句可用于确定语句是否需要临时表。`EXPLAIN`语句有限制。它不会指示语句是否需要为派生或材料化临时表创建临时表。

`Created_tmp_tables`状态变量跟踪在内部内存中创建的临时表的数量。当 MySQL 服务器创建临时表时，它会增加`Created_tmp_tables`状态变量中的值。`Created_tmp_disk_tables`是另一个状态变量，用于跟踪在磁盘上创建的表的数量。

根据查询条件，服务器阻止在内存中使用临时表。在这种情况下，服务器在磁盘上创建表。以下是一些实例：

+   如果表具有`BLOB`或`TEXT`列

+   如果`SELECT`列表中的字符串列的最大长度大于 512 字节，并且使用了`UNION`或`UNION ALL`

+   如果`SHOW COLUMNS`和`DESCRIBE`语句使用`BLOB`作为列的类型

在以下条件下，`UNION`会在不创建临时表的情况下进行评估：

+   联合是`UNION ALL`而不是`UNION`或`UNION DISTINCT`

+   没有全局`ORDER BY`子句

+   在`SELECT`查询中，联合不在顶层查询块

# 优化查询

与表类似，数据库查询是任何数据库的最关键元素。应用程序使用查询与数据库交互。查询也称为可执行的 SQL 语句。本节重点介绍了改进查询执行性能的技术。

# 优化 SQL 语句

SQL 语句用于执行任何数据库应用程序的核心逻辑。无论语句是直接通过解释器发出还是通过 API 在后台提交，都无关紧要。本节概述了改进数据库中读写数据的 SQL 操作性能的准则。

`SELECT`语句在数据库中执行所有查找操作。考虑到`SELECT`语句的频率，调整这些语句变得至关重要。调整技术必须应用于像`CREATE TABLE...AS SELECT`、`INSERT INTO...SELECT`和`DELETE`语句中的`WHERE`子句等构造。

以下是优化查询的主要考虑因素：

+   为了优化`SELECT ... WHERE`查询，首先要检查的是是否可以添加索引。我们应该在`SELECT`查询的`WHERE`子句中使用的列上添加索引。这将加快评估、过滤和检索结果。策略应该是构建一小组可以加速应用程序中许多相关查询的索引。这也避免了浪费的磁盘空间。

+   索引对于引用使用连接和外键的不同表的查询非常重要。`EXPLAIN`语句可用于确定在`SELECT`语句执行中使用了哪些索引。

+   下一步应该是隔离和调整查询的部分；例如，需要大量时间的函数调用。根据查询的结构，函数调用可以针对表中的每一行或结果集中的每一行进行。

+   查询中全表扫描的次数必须最小化，特别是对于大表。

+   应定期使用`ANALYZE TABLE`语句来保持表统计信息的最新。优化器提供了构建高效查询执行计划所需的信息。

+   如果基本指导方针不能解决性能问题，应该通过阅读`EXPLAIN`计划并调整索引、`WHERE`子句、连接子句等内部细节来调查查询。

+   应避免将查询转换为难以理解的方式，特别是当优化器自动执行一些相同的转换时。

+   `InnoDB`缓冲池、`MyISAM`键缓存和 MySQL 查询缓存必须有效地用于重复查询，以便在第一次后从内存中检索结果后更快地运行。内存区域的大小和属性必须进行调整，因为 MySQL 用于缓存。

+   如果查询使用缓存内存区域运行得更快，我们仍然应该进一步优化它，以便需要更少的缓存内存。这使应用程序更具可扩展性，使应用程序能够处理更多的同时用户、更大的请求等，而不会出现性能下降。

+   如果查询的速度受其他会话同时访问表的影响，我们应该处理锁定问题。

以下是优化`WHERE`子句的指导方针。这些优化适用于`SELECT`、`DELETE`或`UPDATE`查询中的`WHERE`子句：

+   不必要的括号应该被移除。以下是一个括号移除的例子：

```go
 ((a AND b) AND c OR (((a AND b) AND (c AND d)))) 
        -> (a AND b AND c) OR (a AND b AND c AND d)
```

+   常量折叠是在编译时而不是运行时评估值的过程。如果我们已经将一个常量值赋给一个变量，然后在表达式中使用该变量，我们应该使用常量值。以下是一个常量折叠的例子：

```go
 (a<b AND b=c) AND a=5 
        -> b>5 AND b=c AND a=5
```

+   由于常量折叠，我们应该移除常量条件。以下是一个常量条件移除的例子：

```go
 (B>=5 AND B=5) OR (B=6 AND 5=5) OR (B=7 AND 5=6) 
        -> B=5 OR B=6
```

# 优化索引

索引的基本用途是快速查找具有特定列值的行。如果索引不存在，MySQL 将从第一行开始并读取整个表以查找所有匹配的行。这需要更多时间，取决于表有多大。如果索引存在于适当的列中，MySQL 能够快速确定在数据文件中寻找的位置，而不必查看整个表数据。

以下是 MySQL 使用索引的操作列表：

+   基于`WHERE`子句快速查找匹配行。

+   在选择多个索引以消除考虑的行时，MySQL 使用行数最少的索引（最具选择性的索引）。

+   如果表具有复合索引，优化器使用索引的最左前缀来查找行。例如，在一个有三列索引的表中（在 col1、col2、col3 上），优化器可以查找具有索引搜索能力的行（col1）、（col1，col2）和（col1，col2，col3）。

+   MySQL 在使用连接从其他表中提取行时使用索引。如果索引声明为相同类型和大小，MySQL 可以在列上有效地使用它们。当声明为相同大小时，`VARCHAR`和`CHAR`被视为相同。

+   MySQL 还使用索引查找索引列`key_col`的`最小值（MIN（））`或`最大值（MAX（））`。预处理器检查是否在所有关键部分上使用`WHERE key_part_N = constant`来优化它。

+   还可以优化查询以检索值而不需要查询数据行。（覆盖索引是为查询提供所有结果的索引。）如果查询仅使用某个索引中包含的表中的那些列，所选值将从索引树中获取。这将更快地检索值。

# 查询执行计划

MySQL 优化器考虑优化技术，以有效地执行查询中涉及的查找，具体取决于表、列和索引的细节，以及`WHERE`子句中的条件。查询也可以在不读取大表上的所有行的情况下执行。SQL 连接也可以在不比较每个行的组合的情况下执行。查询执行计划是 MySQL 优化器选择执行最有效查询的一组操作。它也被称为`EXPLAIN`计划。作为管理员，目标是识别查询执行计划的方面，以确定查询是否经过优化。

`EXPLAIN`语句用于确定查询执行计划。以下是`EXPLAIN`语句提供的信息集：

+   `EXPLAIN`语句与`SELECT`、`DELETE`、`INSERT`、`UPDATE`和`REPLACE`语句一起工作。

+   当`EXPLAIN`与 SQL 语句一起使用时，MySQL 显示有关查询执行计划的 MySQL 优化器的信息。这意味着 MySQL 解释了语句执行的过程。它包括有关表如何连接以及连接顺序的信息。

+   如果`EXPLAIN`显示了命名连接中语句执行的执行计划，而不是可解释的 SQL 语句，则使用`FOR CONNECTION`连接 ID。

+   `EXPLAIN`为`SELECT`语句显示了额外的执行计划信息。

+   `EXPLAIN`还可用于检查涉及分区表的查询。

+   `EXPLAIN`支持`FORMAT`选项，可用于选择输出格式。`TRADITIONAL`格式以表格格式显示输出。这是默认的格式选项。**JavaScript 对象表示**（**JSON**）格式选项以 JSON 格式生成信息。

根据`EXPLAIN`语句的输出，可以确定在表中添加索引的位置，以便语句执行更快。还可以确定优化器是否按优化顺序连接表。使用`SELECT STRAIGHT_JOIN`开始语句，而不仅仅是`SELECT`，以向优化器提供使用与`SELECT`语句中命名表的顺序相对应的连接顺序的提示。由于`STRAIGHT_JOIN`禁用半连接转换，它可能会阻止索引的使用。

优化器跟踪是另一个工具，用于查找有关查询执行的信息。优化器跟踪可能提供与`EXPLAIN`不同的信息。优化器跟踪的格式和内容会根据版本而有所不同。

以下表格显示了`EXPLAIN`语句的输出格式：

| **列** | **JSON 名称** | **细节** |
| --- | --- | --- |
| `id` | `select_id` | `SELECT`标识符 |
| `select_type` | `None` | `SELECT`类型 |
| `table` | `table_name` | 输出行的表 |
| `partitions` | `partitions` | 匹配的分区 |
| `type` | `access_type` | 连接类型 |
| `possible_keys` | `possible_keys` | 可能选择的索引 |
| `key` | `key` | 实际选择的索引 |
| `key_len` | `key_length` | 所选键的长度 |
| `ref` | `ref` | 与索引进行比较的列 |
| `rows` | `rows` | 预计要检查的行数 |
| `filtered` | `filtered` | 表条件过滤的行的百分比 |
| `Extra` | `None` | 附加信息 |

参考：[`dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-output-column-table`](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-output-column-table)

# 优化表

数据库表是任何数据库的最基本构建块。在本章节的这一部分，我们将专注于优化表。本节提供了通过表优化技术来改善性能的详细指南。

# InnoDB 表的优化

在生产环境中，`InnoDB`存储引擎是首选，特别是在可靠性和并发性很重要的情况下。它是 MySQL 表的默认存储引擎。本节重点介绍了优化`InnoDB`表的数据库操作。

以下是优化`InnoDB`表的指南：

+   应考虑使用`OPTIMIZE TABLE`语句来重新组织表并压缩浪费空间，一旦数据达到稳定大小或表增加了数十兆字节。对于重新组织的表来说，执行完整的表扫描需要更少的磁盘 I/O。

+   `OPTIMIZE TABLE`语句会复制表中的数据并重建索引。这是有益的，因为它可以改善索引内数据的打包，并减少磁盘上表空间的碎片。收益可能会有所不同，取决于每个表中的数据。在某些情况下，收益可能是显著的，而在其他情况下则不是。收益也可能随着时间的推移而减少，直到进行下一次表优化。如果表很大或正在重建的索引不适合缓冲池，操作可能会很慢。

+   在`InnoDB`表中，长主键会浪费大量磁盘空间，应该避免使用。

+   在`InnoDB`表中，应优先选择`VARCHAR`数据类型，而不是`CHAR`数据类型来存储可变长度字符串，或者用于预期包含`NULL`值的列。`CHAR(N)`列始终占用*N*个字符来存储数据，即使值为`NULL`。较小的表更适合适应缓冲池并减少磁盘 I/O。

+   考虑为大表或包含大量重复文本或数字数据的表使用`COMPRESSED`行格式。

# MyISAM 表的优化

对于只读或读取频率较高的数据，或低并发操作，`MyISAM`存储引擎最适合。这是因为表锁限制了同时进行更新的能力。在本节中，重点将放在优化要在`MyISAM`表上执行的查询上。

以下是加快`MyISAM`表查询的指南：

+   避免在频繁更新的`MyISAM`表上执行复杂的`SELECT`查询。这样可以避免由于写入者和读取者之间的争用而导致的表锁定问题。

+   `MyISAM`存储引擎支持并发插入。如果表数据文件中间没有空闲块，我们可以在其他线程从表中读取数据的同时向其中`INSERT`新行。如果重要的是能够进行并发读写操作，可以考虑使用该表来避免删除行。另一个选择是在删除行后执行`OPTIMIZE TABLE`来对表进行碎片整理。这种行为可以通过设置`concurrent_insert`系统变量来进行控制或修改。

+   对于频繁更改的`MyISAM`表，应避免所有可变长度列。如果表中包含至少一个可变长度列，则使用动态行格式。

+   `myisamchk --sort-index --sort-records=1`命令可用于对索引进行排序。它还根据索引对数据进行排序。如果我们有唯一索引，并且希望按照索引的顺序读取所有行，这样可以使查询运行更快。第一次对大表进行这种排序会花费很长时间。

+   如果我们通常按照`expression1`，`expression2`等顺序检索行，可以使用`ALTER TABLE ... ORDER BY expression1, expression2,..`，这样会提高性能，如果在对表进行大量更改后使用此选项。

# 内存表的优化

MySQL 的`MEMORY`表应该只用于经常访问的非关键数据，而且是只读且很少更新的数据。应该对应用程序进行基准测试，以确认额外的性能是否值得冒失去数据的风险。

我们应该检查针对每个表的查询类型，以获得`MEMORY`表的最佳性能。我们还应该指定每个相关索引的使用类型。它可以是 B 树索引或哈希索引。在`CREATE INDEX`语句上使用`USING BTREE`或`USING HASH`子句。

# 利用缓冲和缓存

这一部分关注使用缓冲和缓存技术来提高性能。

# InnoDB 缓冲池优化

`InnoDB`存储引擎维护一个称为缓冲池的存储区域，用于在内存中缓存数据和索引。了解`InnoDB`缓冲池的工作原理非常重要，以便利用它将经常访问的数据保留在内存中。这是 MySQL 调优的一个重要方面。

以下是改进`InnoDB`缓冲池性能的一般指导方针：

+   在理想情况下，缓冲池的大小应该足够大，同时留出足够的内存供服务器上的其他进程运行，而不会过度分页。有了更大的缓冲池，`InnoDB`的功能也更多，比如内存数据库。在这种情况下，它只需从磁盘读取数据一次，然后在后续读取中从内存中访问数据。

+   我们可以考虑将缓冲池分成多个部分，用于具有大内存的 64 位系统。这样可以在并发操作期间最大程度地减少内存争用。

+   经常访问的数据应该保留在内存中。

+   可以控制`InnoDB`何时以及如何执行预读请求，以异步方式将页面预取到缓冲池中。`InnoDB`使用两种预读算法来提高 I/O 性能。线性预读可以根据顺序访问缓冲池中的页面来预测可能很快需要的页面。随机预读可以根据缓冲池中的页面来预测可能需要的页面，而不考虑页面读取的顺序。`innodb_read_ahead_threshold`配置参数控制线性预读的灵敏度。我们可以通过将`innodb_random_read_ahead`设置为`ON`来启用随机预读。

+   `innodb_buffer_pool_read_ahead`确定读入`InnoDB`缓冲池的页面数。`innodb_buffer_pool_read_ahead_evicted`确定后台预读线程读入缓冲池的页面数，随后被查询访问。`innodb_buffer_pool_read_ahead_rnd`确定`InnoDB`发起的随机预读次数。

# MyISAM 键缓存

`MyISAM`存储引擎采用了一种被许多数据库管理系统支持的策略，以最小化磁盘 I/O。`MyISAM`使用缓存机制将最常访问的表块保留在内存中。

+   为索引块维护了一个称为键缓存的特殊结构。最常用的索引块被放置在包含多个块缓冲区的结构中。

+   MySQL 依赖于本机操作系统文件系统缓存来存储数据块。

`key_buffer_size`系统变量确定关键缓存的大小。如果设置为零，则不使用关键缓存。如果`key_buffer_size`值太小而无法分配最小顺序的块缓冲区，则也不使用关键缓存。关键缓存结构中的所有块缓冲区大小相同。这个大小可以等于、大于或小于表索引块的大小。通常情况下，这两个值中的一个是另一个的倍数。

当需要从任何表索引块访问数据时，服务器首先检查它是否在关键缓存的某个块缓冲区中可用。如果数据可用，服务器将从关键缓存中访问数据，而不是从磁盘上访问。如果数据不可用，服务器选择包含不同表索引块的缓存块缓冲区，并通过复制所需的表索引块来替换其中的数据。一旦新的索引块在缓存中可用，就可以访问索引数据。

MySQL 服务器遵循**最近最少使用**（LRU）策略。根据这个策略，在选择要替换的块时，它选择最近最少使用的索引块。关键缓存模块包含 LRU 链中的所有使用的块（一个特殊列表）。列表按使用时间排序。当访问块时，它是最近使用的。块被放置在列表的末尾。当需要替换块时，列表开头的块是最近最少使用的。因此，顶部的块成为首选的驱逐候选。

如果选择用于替换的块已被修改，则该块被视为脏块。在替换之前，块内容被刷新到它们来自的表索引中。

根据以下条件，线程可以同时访问关键缓存缓冲区：

+   未被更新的缓冲区可以被多个会话访问。

+   正在更新的缓冲区会导致需要等待更新完成的会话使用它

+   只要会话是独立的并且不相互干扰，多个会话可以发起请求，导致缓存块替换。

通过这种方式，对关键缓存的共享访问显著提高了性能。

# 总结

在本章中，我们详细学习了优化 MySQL 8 组件的技术。该章节从优化的基础知识开始，包括硬件和软件优化指南。我们还讨论了 MySQL 8 服务器和客户端、数据库结构、查询和表的优化指南。我们还涵盖了属于不同存储引擎的表的优化，如`MyISAM`、`InnoDB`和`MEMORY`。我们学习了工具，如`EXPLAIN`和`EXPLAIN ANALYZE`，以了解查询执行计划。在本章的后部分，我们学习了缓冲和缓存技术以提高性能。

现在是时候转到下一章了。下一章将重点介绍扩展 MySQL 8 的技术。该章节将详细介绍 MySQL 8 插件，这些插件有助于扩展默认的 MySQL 8 功能。它还将解释调用这些插件的服务。该章节将讨论添加新功能、调试和移植方法。这对数据库管理员来说将是一个重要的章节。
