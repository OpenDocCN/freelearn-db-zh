- en: Optimizing MySQL 8
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化 MySQL 8
- en: In the previous chapter, we learned about security, which is an important aspect
    of any production-grade application. The chapter started with an introduction
    to security and identifying common security issues. Moving on, the chapter covered
    access control mechanisms, account management, and encryption in MySQL 8\. We
    learned various MySQL 8 security plugins in the later part of the chapter. Security
    is an important benchmark for every production-grade application. That's why the
    previous chapter is an important one.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了安全性，这是任何生产级应用程序的重要方面。该章节以安全性介绍和识别常见安全问题开始。随后，该章节涵盖了 MySQL 8 中的访问控制机制、账户管理和加密。我们在该章节的后部分了解了各种
    MySQL 8 安全插件。安全性是每个生产级应用程序的重要基准。这就是为什么上一章是重要的。
- en: Moving along a similar line, with the objective of developing highly optimized
    databases, this chapter focuses on optimization methods. It starts with an overview
    of what optimization means in MySQL 8\. It takes the reader through MySQL 8 server
    and client optimization, optimizing database structure, and optimizing common
    queries and database tables. Later in the chapter, emphasis is given to buffering
    and caching techniques.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着类似的线路，为了开发高度优化的数据库，本章重点介绍了优化方法。它从 MySQL 8 优化的概述开始。它带领读者了解 MySQL 8 服务器和客户端的优化，优化数据库结构，以及优化常见查询和数据库表。在本章的后面部分，重点放在了缓冲和缓存技术上。
- en: 'The following is a list of topics to be covered:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是要涵盖的主题列表：
- en: Overview of MySQL 8 optimization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL 8 优化概述
- en: Optimizing MySQL 8 servers and clients
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化 MySQL 8 服务器和客户端
- en: Optimizing database structure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化数据库结构
- en: Optimizing queries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化查询
- en: Optimizing tables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化表
- en: Leveraging buffering and caching
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用缓冲和缓存
- en: Overview of MySQL 8 optimization
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQL 8 优化概述
- en: Let's start with understanding MySQL 8 optimization. Optimization is the process
    of identifying performance bottlenecks and implementing optimized solutions to
    overcome these issues. Optimization in MySQL 8 involves performance measurement,
    configuration, and tuning at several different levels. It is an important task
    for an administrator to optimize the performance at different levels, like individual
    SQL queries, entire database applications, database servers, or distributed database
    servers. Performance optimization at the CPU and memory levels improves scalability.
    It also allows the database to handle more complex queries without slowing down
    the database server.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从理解 MySQL 8 优化开始。优化是识别性能瓶颈并实施优化解决方案以克服这些问题的过程。MySQL 8 中的优化涉及在多个不同级别进行性能测量、配置和调整。对于管理员来说，在不同级别优化性能是一项重要任务，比如单个
    SQL 查询、整个数据库应用程序、数据库服务器或分布式数据库服务器。在 CPU 和内存级别进行性能优化可以提高可伸缩性。它还允许数据库处理更复杂的查询而不会使数据库服务器变慢。
- en: 'The performance of a database depends on multiple factors. At the database
    level, these factors can be tables, queries, and configurations. Database server
    startups and database query executions are a couple of the events when these constructs
    impact the CPU or perform I/O (Input/Output) operations at the hardware level.
    This is a responsibility of the MySQL 8 database administrator: to make sure that
    the hardware performance stands at an optimum level. It is required that the hardware
    is used with the maximum efficiency possible. At the software level, performance
    optimization starts by learning generic rules and guidelines and measuring performance
    with clock time. Gradually, we understand the internals of various database operations.
    We can measure the performance in terms of CPU cycles and I/O operations. To attain
    the best database performance, we can optimize the software and hardware configurations
    at a basic level. At an advanced level, we can improve MySQL itself by developing
    custom storage engines and hardware appliances, which expand the MySQL ecosystem.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的性能取决于多个因素。在数据库级别，这些因素可以是表、查询和配置。数据库服务器的启动和数据库查询执行是这些构造影响 CPU 或在硬件级别执行 I/O（输入/输出）操作的事件之一。这是
    MySQL 8 数据库管理员的责任：确保硬件性能达到最佳水平。需要确保硬件以最大效率使用。在软件级别上，性能优化从学习通用规则和指南以及用时性能测量开始。逐渐地，我们了解各种数据库操作的内部。我们可以用
    CPU 周期和 I/O 操作来衡量性能。为了获得最佳的数据库性能，我们可以在基本级别优化软件和硬件配置。在高级水平上，我们可以通过开发自定义存储引擎和硬件设备来改进
    MySQL 本身，从而扩展 MySQL 生态系统。
- en: Optimizing the database
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化数据库
- en: 'What is the most important factor in making the database perform at the optimum
    speed? The answer is, basic database design. The following is a checklist to keep
    an eye on for database design:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使数据库以最佳速度运行的最重要因素是什么？答案是，基本的数据库设计。以下是数据库设计需要注意的检查表：
- en: The database columns have to be of the right data types. Tables must have appropriate
    columns for the purposes to be served. Applications that have frequent operations
    to be performed on the database have many tables with fewer columns, whereas applications
    that analyze large amounts of data have limited tables with many columns.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库列必须是正确的数据类型。表必须为所需的目的具有适当的列。对数据库执行频繁操作的应用程序具有较少的列的许多表，而分析大量数据的应用程序具有许多列的有限表。
- en: As we learned in one of the previous chapters, database indexing plays an important
    role in enhancing query performance. So, it is important to have correct indexes
    in place for query execution efficiency.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们在之前的章节中学到的，数据库索引在增强查询性能方面起着重要作用。因此，为了提高查询执行效率，正确的索引放置非常重要。
- en: We discussed database storage engines, such as `MyISAM` or `InnoDB`, in earlier
    chapters. Use of an appropriate storage engine for each individual table is important.
    `InnoDB` is preferable for transactional database tables, whereas `MyISAM` is
    preferable for defining non-trasactional database tables. The choice of storage
    engine plays a vital role in defining the performance and scalability of the database.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在早期章节中讨论了数据库存储引擎，比如MyISAM或InnoDB。对于每个单独的表使用适当的存储引擎是重要的。InnoDB对于事务性数据库表更为合适，而MyISAM对于定义非事务性数据库表更为合适。存储引擎的选择在定义数据库的性能和可伸缩性方面起着至关重要的作用。
- en: In the chapter on MySQL 8 data types, we learned about row formats in detail.
    It is again important for each to have an appropriate row format. The choice of
    row format depends on the storage engine chosen. Compressed tables occupy less
    disk space and require fewer disk I/O operations. For `InnoDB` tables, compression
    is available for all read and write operations. On the contrary, compression is
    available for read-only `MyISAM` tables.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MySQL 8数据类型章节中，我们详细了解了行格式。对于每个表来说，拥有适当的行格式是非常重要的。行格式的选择取决于所选择的存储引擎。压缩表占用更少的磁盘空间，并且需要更少的磁盘I/O操作。对于InnoDB表，压缩适用于所有读写操作。相反，只有对于只读的MyISAM表才适用压缩。
- en: The MySQL database supports multiple locking strategies. The locking can be
    at a table-level or a row-level. The application must use an appropriate locking
    strategy. By granting shared access wherever appropriate, it becomes possible
    to run database operations concurrently. Also, it should be possible to request
    exclusive access, so that critical database operations can be executed with data
    integrity issues and priority can be maintained. In this case, the choice of storage
    engine is again significant. The `InnoDB` storage engine handles most locking
    issues without user involvement. It allows for better concurrency and reduces
    the amount of experimentation and tuning for the code.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL数据库支持多种锁定策略。锁定可以是表级别的，也可以是行级别的。应用程序必须使用适当的锁定策略。通过在适当的地方授予共享访问权限，可以实现并发运行数据库操作。此外，应该可以请求独占访问，以便可以执行关键的数据库操作，并保持数据完整性和优先级。在这种情况下，存储引擎的选择再次变得重要。InnoDB存储引擎处理大多数锁定问题而无需用户参与。它允许更好的并发性，并减少了对代码的实验和调整的数量。
- en: The memory areas must use the correct caching size. It should be large enough
    to hold frequently accessed data, and at the same time, not so large that they
    overload physical memory and cause paging. The `InnoDB` buffer pool and `MyISAM`
    key cache are the main memory areas to be configured.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存区域必须使用正确的缓存大小。它应该足够大，以容纳频繁访问的数据，同时又不会过载物理内存并导致分页。InnoDB缓冲池和MyISAM关键缓存是需要配置的主要内存区域。
- en: For newly created tables, `MyISAM` is the default storage engine. In practical
    use, `InnoDB` advanced performance features mean that tables with `InnoDB` storage
    engines outperform the `MyISAM` tables for an operations-heavy database.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新创建的表，MyISAM是默认的存储引擎。在实际使用中，InnoDB的高级性能特性意味着使用InnoDB存储引擎的表在操作繁重的数据库中表现优于MyISAM表。
- en: Optimizing the hardware
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化硬件
- en: 'Growth is the nature of every software application. As the application grows,
    so does the database. The database becomes more and more busy in performing operations.
    At a certain point, the database application eventually hits the hardware limits.
    An administrator must evaluate the possibility of tuning the application or re-configuring
    the server to avoid these issues. It should also be evaluated whether deploying
    more hardware resources would help. System bottlenecks usually arise from the
    following sources:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 增长是每个软件应用的本质。随着应用程序的增长，数据库也会增长。数据库在执行操作时变得越来越繁忙。在某一点上，数据库应用程序最终会达到硬件限制。管理员必须评估调整应用程序或重新配置服务器以避免这些问题的可能性。还应该评估是否增加更多的硬件资源会有所帮助。系统瓶颈通常来自以下来源：
- en: '**Disk seeks**: As part of the disk read operation, finding a piece of data
    takes time for the disk. The mean time for finding a piece of data is usually
    lower than 10 milliseconds with modern disks. So, in theory, it should be 100
    seeks per second. With technological evolution, the new disks have improvements
    on the disk time, but it is very hard to optimize for single tables. To optimize
    the seek time, it is necessary to distribute data across more than one disk.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**磁盘搜索**：作为磁盘读取操作的一部分，查找数据需要时间。现代磁盘的平均查找数据时间通常低于10毫秒。因此，理论上应该是每秒100次搜索。随着技术的进步，新的磁盘在磁盘时间上有所改进，但很难为单个表进行优化。要优化搜索时间，需要将数据分布在多个磁盘上。'
- en: '**Disk reading and writing**: To read or write data from a disk, it is required
    for the disk to be at the correct position. One disk delivers at least 10 to 20
    MB of throughput per second (throughput is the amount of data read or written
    per second). So, the read and write throughput is more easily optimized than the
    seek time, as we can read in parallel from multiple disks.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**磁盘读写**：要从磁盘读取或写入数据，需要磁盘处于正确的位置。一个磁盘至少提供每秒10到20MB的吞吐量（吞吐量是每秒读取或写入的数据量）。因此，读取和写入吞吐量比搜索时间更容易优化，因为我们可以从多个磁盘并行读取。'
- en: '**CPU cycles**: We must process the data when it is in the main memory to get
    the desired result. With large tables, the amount of memory is the most common
    limiting factor. With small tables, however, speed is usually not an issue.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU周期**：我们必须在主内存中处理数据以获得所需的结果。对于大表来说，内存的数量是最常见的限制因素。然而，对于小表来说，速度通常不是问题。'
- en: '**Memory bandwidth**: In an uncommon scenario, the main memory bandwidth becomes
    a bottleneck when the CPU needs more data than can be fit in the CPU cache memory.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存带宽**：在罕见的情况下，当CPU需要的数据超过CPU缓存内存的容量时，主内存带宽成为瓶颈。'
- en: Optimizing MySQL 8 servers and clients
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化MySQL 8服务器和客户端
- en: This section focuses on optimization for MySQL 8 database servers and clients,
    starting with optimizing the server and followed by optimizing MySQL 8 client-side
    entities. This section is more relevant to database administrators, to ensure
    performance and scalability across multiple servers. It would also help developers
    preparing scripts (which includes setting up the database) and users running MySQL
    for development and testing to maximize the productivity.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本节重点介绍了MySQL 8数据库服务器和客户端的优化，从优化服务器开始，然后优化MySQL 8客户端实体。本节更适合数据库管理员，以确保多个服务器的性能和可伸缩性。这也将帮助准备脚本的开发人员（包括设置数据库）和运行MySQL进行开发和测试的用户，以最大限度地提高生产力。
- en: Optimizing disk I/O
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化磁盘I/O
- en: In this section, we will learn ways to configure storage devices to devote more
    and faster storage hardware to the database server. A major performance bottleneck
    is disk seeking (finding the correct place on the disk to read or write content).
    When the amount of data grows large enough to make caching impossible, the problem
    with disk seeds becomes apparent. We need at least one disk seek operation to
    read, and several disk seek operations to write things in large databases where
    the data access is done more or less randomly. We should regulate or minimize
    the disk seek times using appropriate disks.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何配置存储设备，以将更多和更快的存储硬件专用于数据库服务器。磁盘寻址（查找磁盘上正确位置以读取或写入内容）是一个主要的性能瓶颈。当数据量足够大以至于无法进行缓存时，磁盘寻址的问题就会显现出来。在大型数据库中，数据访问基本上是随机进行的，因此我们需要至少进行一次磁盘寻址操作来读取数据，以及进行多次磁盘寻址操作来写入数据。我们应该使用适当的磁盘来调节或最小化磁盘寻址时间。
- en: 'In order to resolve the disk seek performance issue, increasing the number
    of available disk spindles, symlinking the files to different disks, or stripping
    disks can be done. The following are the details:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决磁盘寻址性能问题，可以增加可用磁盘轴承的数量，将文件符号链接到不同的磁盘，或者进行磁盘分区。以下是详细信息：
- en: '**Using symbolic links**: When using symbolic links, we can create a Unix symbolic
    links for index and data files. The symlink points from default locations in the
    data directory to another disk in the case of `MyISAM` tables. These links may
    also be striped. This improves the seek and read times. The assumption is that
    the disk is not used concurrently for other purposes. Symbolic links are not supported
    for `InnoDB` tables. However, we can place `InnoDB` data and log files on different
    physical disks.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用符号链接**：在使用符号链接时，我们可以为索引和数据文件创建Unix符号链接。在`MyISAM`表的情况下，符号链接从数据目录中的默认位置指向另一个磁盘。这些链接也可以进行条带化。这将改善寻址和读取时间。假设磁盘没有同时用于其他目的。符号链接不支持`InnoDB`表。但是，我们可以将`InnoDB`数据和日志文件放在不同的物理磁盘上。'
- en: '**Striping**: In striping, we have many disks. We put the first block on the
    first disk, the second block on the second disk, and so on. The *N* block on the
    (N % number-of-disks) disk. If the stripe size is perfectly aligned, the normal
    data size will be less than the stripe size. This will help to improve the performance.
    Striping is dependent on the stripe size and the operating system. In an ideal
    case, we would benchmark the application with different stripe sizes. The speed
    difference while striping depends on the parameters we have used, like stripe
    size. The difference in performance also depends on the number of disks. We have
    to choose if we want to optimize for random access or sequential access. To gain
    reliability, we may decide to set up with striping and mirroring (RAID 0+1). **RAID**
    stands for **Redundant Array of Independent Drives**. This approach needs 2 x
    *N* drives to hold *N* drives of data. With a good volume management software,
    we can manage this setup efficiently.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条带化**：在条带化中，我们有许多磁盘。我们将第一个块放在第一个磁盘上，第二个块放在第二个磁盘上，依此类推。第*N*块放在（N % 磁盘数）磁盘上。如果条带大小完全对齐，正常数据大小将小于条带大小。这将有助于提高性能。条带化取决于条带大小和操作系统。在理想情况下，我们会使用不同的条带大小对应用程序进行基准测试。条带化的速度差异取决于我们使用的参数，如条带大小。性能差异还取决于磁盘数量。我们必须选择是要优化随机访问还是顺序访问。为了获得可靠性，我们可能决定设置条带化和镜像（RAID
    0+1）。**RAID**代表**独立驱动器冗余阵列**。这种方法需要2 x *N*驱动器来容纳*N*驱动器的数据。通过良好的卷管理软件，我们可以有效地管理这种设置。'
- en: There is another approach to it, as well. Depending on how critical the type
    of data is, we may vary the RAID level. For example, we can store really important
    data, such as host information and logs, on a RAID 0+1 or RAID N disk, whereas
    we can store semi-important data on a RAID 0 disk. In the case of RAID, parity
    bits are used to ensure the integrity of the data stored on each drive. So, RAID
    N becomes a problem if we have too many write operations to be performed. The
    time required to update the parity bits in this case is high.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有另一种方法。根据数据类型的重要性，我们可以改变RAID级别。例如，我们可以将非常重要的数据，如主机信息和日志，存储在RAID 0+1或RAID N磁盘上，而将较重要的数据存储在RAID
    0磁盘上。在RAID的情况下，奇偶校验位用于确保存储在每个驱动器上的数据的完整性。因此，如果要执行太多写操作，RAID N将成为一个问题。在这种情况下，更新奇偶校验位所需的时间较长。
- en: If it is not important to maintain when the file was last accessed, we can mount
    the file system with the `-o noatime` option. This option skips the updates on
    the file system, which reduces the disk seek time. We can also make the file system
    update asynchronously. Depending upon whether the file system supports it, we
    can set the `-o async` option.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果维护文件上次访问时间不重要，我们可以使用`-o noatime`选项挂载文件系统。此选项跳过文件系统上的更新，从而减少磁盘寻址时间。我们还可以使文件系统异步更新。根据文件系统是否支持，我们可以设置`-o
    async`选项。
- en: Using NFS with MySQL
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NFS与MySQL
- en: 'While using a **Network File System** (**NFS**), varying issues may occur,
    depending on the operating system and the NFS version. The following are the details:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用**网络文件系统**（**NFS**）时，可能会出现各种问题，这取决于操作系统和NFS版本。以下是详细信息：
- en: Data inconsistency is one issue with an NFS system. It may occur because of
    messages received out of order or lost network traffic. We can use TCP with `hard`
    and `intr` mount options to avoid these issues.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NFS系统存在数据不一致性的问题。这可能是因为接收到的消息顺序不正确或网络流量丢失。我们可以使用带有`hard`和`intr`挂载选项的TCP来避免这些问题。
- en: MySQL data and log files may get locked and become unavailable for use if placed
    on NFS drives. If multiple instances of MySQL access the same data directory,
    it may result in locking issues. Improper shut down of MySQL or power outage are
    other reasons for filesystem locking issues. The latest version of NFS supports
    advisory and lease-based locking, which helps in addressing the locking issues.
    Still, it is not recommended to share a data directory among multiple MySQL instances.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL数据和日志文件如果放在NFS驱动器上，可能会被锁定并变得无法使用。如果多个MySQL实例访问相同的数据目录，可能会导致锁定问题。MySQL的不正确关闭或断电是文件系统锁定问题的其他原因。最新版本的NFS支持咨询和基于租约的锁定，有助于解决锁定问题。但是，不建议在多个MySQL实例之间共享数据目录。
- en: Maximum file size limitations must be understood to avoid any issues. With NFS
    2, only the lower 2 GB of a file is accessible by clients. NFS 3 clients support
    larger files. The maximum file size depends on the local file system of the NFS
    server.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须了解最大文件大小限制，以避免任何问题。使用NFS 2，客户端只能访问文件的较低2 GB。NFS 3客户端支持更大的文件。最大文件大小取决于NFS服务器的本地文件系统。
- en: Optimizing the use of memory
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化内存的使用
- en: In order to improve the performance of database operations, MySQL allocates
    buffers and caches memory. As a default, the MySQL server starts on a **virtual
    machine** (**VM**) with 512 MB of RAM. We can modify the default configuration
    for MySQL to run on limited memory systems.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高数据库操作的性能，MySQL分配缓冲区和缓存内存。默认情况下，MySQL服务器在具有512 MB RAM的虚拟机（VM）上启动。我们可以修改MySQL的默认配置，使其在有限内存系统上运行。
- en: 'The following list describes the ways to optimize MySQL memory:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表描述了优化MySQL内存的方法：
- en: The memory area which holds cached `InnoDB` data for tables, indexes, and other
    auxiliary buffers is known as the `InnoDB` buffer pool. The buffer pool is divided
    into pages. The pages hold multiple rows. The buffer pool is implemented as a
    linked list of pages for efficient cache management. Rarely used data is removed
    from the cache using an algorithm. Buffer pool size is an important factor for
    system performance. The `innodb__buffer_pool_size` system variable defines the
    buffer pool size. `InnoDB` allocates the entire buffer pool size at server startup.
    50 to 75 percent of system memory is recommended for the buffer pool size.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于缓存`InnoDB`数据的表、索引和其他辅助缓冲区的内存区域称为`InnoDB`缓冲池。缓冲池分为页面。页面包含多行。缓冲池实现为页面的链表，以实现高效的缓存管理。使用算法从缓存中删除很少使用的数据。缓冲池大小是系统性能的重要因素。`innodb__buffer_pool_size`系统变量定义了缓冲池大小。`InnoDB`在服务器启动时分配整个缓冲池大小。建议将系统内存的50%至75%用于缓冲池大小。
- en: With `MyISAM`, all threads share the key buffer. The `key_buffer_size` system
    variable defines the size of the key buffer. The index file is opened once for
    each `MyISAM` table opened by the server. For each concurrent thread that accesses
    the table, the data file is opened once. A table structure, column structures
    for each column, and a 3 x *N* sized buffer are allocated for each concurrent
    thread. The `MyISAM` storage engine maintains an extra row buffer for internal
    use.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`MyISAM`，所有线程共享关键缓冲区。`key_buffer_size`系统变量定义了关键缓冲区的大小。索引文件为服务器打开的每个`MyISAM`表打开一次。对于访问表的每个并发线程，数据文件只打开一次。为每个并发线程分配一个表结构，每个列的列结构以及一个3
    x *N*大小的缓冲区。`MyISAM`存储引擎为内部使用维护了一个额外的行缓冲区。
- en: The optimizer estimates the reading of multiple rows by scanning. The storage
    engine interface enables the optimizer to provide information about the recorded
    buffer size. The size of the buffer can vary depending on the size of the estimate.
    In order to take advantage of row pre-fetching, `InnoDB` uses a variable size
    buffering capability. It reduces the overhead of latching and B-tree navigation.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化器通过扫描来估计多行的读取。存储引擎接口使优化器能够提供有关记录缓冲区大小的信息。缓冲区的大小可以根据估计的大小而变化。为了利用行预取功能，`InnoDB`使用可变大小的缓冲能力。它减少了锁定和B树导航的开销。
- en: Memory mapping can be enabled for all `MyISAM` tables by setting the `myisam_use_mmap`
    system variable to 1.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将`myisam_use_mmap`系统变量设置为1，可以为所有`MyISAM`表启用内存映射。
- en: The size of an in-memory temporary table can be defined by the `tmp_table_size`
    system variable. The maximum size of the heap table can be defined using the `max_heap_table_size`
    system variable. If the in-memory table becomes too large, MySQL automatically
    converts the table from in-memory to on-disk. The storage engine for an on-disk
    temporary table is defined by the `internal_tmp_disk_storage_engine` system variable.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存临时表的大小可以由`tmp_table_size`系统变量定义。堆表的最大大小可以使用`max_heap_table_size`系统变量定义。如果内存表变得太大，MySQL会自动将表从内存转换为磁盘上。磁盘上临时表的存储引擎由`internal_tmp_disk_storage_engine`系统变量定义。
- en: MySQL comes with the MySQL performance schema. It is a feature to monitor MySQL
    execution at low levels. The performance schema dynamically allocates memory by
    scaling its memory use to the actual server load, instead of allocating memory
    upon server startup. The memory, once allocated, is not freed until the server
    is restarted.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL配备了MySQL性能模式。这是一个监视MySQL低级执行的功能。性能模式通过根据实际服务器负载调整其内存使用来动态分配内存，而不是在服务器启动时分配内存。一旦分配了内存，直到服务器重新启动才会释放。
- en: Thread specific space is required for each thread that the server uses to manage
    client connections. The stack size is governed by the `thread_stack` system variable.
    The connection buffer is governed by the `net_buffer_length` system variable.
    A result buffer is governed by `net_buffer_length`. The connection buffer and
    result buffer starts with `net_buffer_length` bytes, but enlarges up to `max_allowed_packets`
    bytes, as needed.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器用于管理客户端连接的每个线程都需要特定的空间。堆栈大小由`thread_stack`系统变量控制。连接缓冲区由`net_buffer_length`系统变量控制。结果缓冲区由`net_buffer_length`控制。连接缓冲区和结果缓冲区以`net_buffer_length`字节开始，但根据需要扩大到`max_allowed_packets`字节。
- en: All threads share the same base memory.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有线程共享相同的基本内存。
- en: All join clauses are executed in a single pass. Most of the joins can be executed
    without a temporary table. Temporary tables are memory-based hash tables. Temporary
    tables that contain `BLOB` data and tables with large row lengths are stored on
    disk.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有连接子句都在单次执行中执行。大多数连接可以在不使用临时表的情况下执行。临时表是基于内存的哈希表。包含`BLOB`数据和行长度较大的表存储在磁盘上。
- en: A read buffer is allocated for each request, which performs a sequential scan
    on a table. The size of the read buffer is determined by the `read_buffer_size`
    system variable.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个请求分配一个读取缓冲区，该请求对表进行顺序扫描。读取缓冲区的大小由`read_buffer_size`系统变量确定。
- en: A random read buffer is allocated when reading rows in an arbitrary manner to
    avoid disk seeks. The buffer size is determined by the `read_rnd_buffer_size`
    system variable.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以任意方式读取行时分配了一个随机读取缓冲区，以避免磁盘寻道。缓冲区大小由`read_rnd_buffer_size`系统变量确定。
- en: The memory allocated to a thread is released as soon as the thread is no longer
    needed. The released memory is returned to the system unless the thread is put
    into the thread cache.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程分配的内存在线程不再需要时被释放。释放的内存会被返回给系统，除非线程被放入线程缓存中。
- en: MySQL closes all tables that are not in use at once when `FLUSH TABLES` or `mysqladmin`
    flush-table commands are executed. It marks all in-use tables to be closed when
    the current thread execution finishes. This frees in-use memory. `FLUSH TABLES`
    returns only after all tables have been closed.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当执行`FLUSH TABLES`或`mysqladmin` flush-table命令时，MySQL会立即关闭所有未使用的表。当当前线程执行完成时，它标记所有正在使用的表将被关闭。这会释放正在使用的内存。`FLUSH
    TABLES`仅在所有表关闭后才返回。
- en: 'It is possible to monitor the MySQL performance schema and sys schema for memory
    usage. Before we can execute commands for this, we have to enable memory instruments
    on the MySQL performance schema. It can be done by updating the `ENABLED` column
    of the performance schema `setup_instruments` table. The following is the query
    to view available memory instruments in MySQL:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可以监视MySQL性能模式和内存使用情况的sys模式。在执行此操作之前，我们必须在MySQL性能模式上启用内存工具。可以通过更新性能模式`setup_instruments`表的`ENABLED`列来完成。以下是查询MySQL中可用内存工具的查询：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If memory instruments are enabled on startup, it ensures memory allocations
    on startup are counted.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在启动时启用了内存工具，则可以确保在启动时对内存分配进行计数。
- en: 'This query will return hundreds of memory instruments. We can narrow it down
    by specifying a code area. The following is an example to limit results to `InnoDB`
    memory instruments:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询将返回数百个内存工具。我们可以通过指定代码区域来缩小范围。以下是将结果限制为`InnoDB`内存工具的示例：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is the configuration to enable memory instruments:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是启用内存工具的配置：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is an example to query memory instrument data in the `memory_summary_global_by_event_name`
    table in the performance schema:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在性能模式中的`memory_summary_global_by_event_name`表中查询内存工具数据的示例：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It summarizes data by `EVENT_NAME`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过`EVENT_NAME`对数据进行汇总。
- en: 'The following is an example of querying the sys schema to aggregate currently
    allocated memory by code area:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是查询sys模式以按代码区域聚合当前分配的内存的示例：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Optimizing use of the network
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化网络的使用
- en: The MySQL database server opens up network interfaces to connect with the clients
    and starts listening to these interfaces. The connection manager threads are responsible
    for handling client connection requests. The connection manager threads additionally
    handle socket files on the Unix platform. The connection manager thread takes
    care of shared-memory connection requests, and one other thread handles named-pipe
    connection requests on the Windows system. Threads are not created for the interfaces
    that the server does not listen to.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL数据库服务器打开网络接口以与客户端连接，并开始监听这些接口。连接管理器线程负责处理客户端连接请求。连接管理器线程还处理Unix平台上的套接字文件。连接管理器线程处理共享内存连接请求，另一个线程处理Windows系统上的命名管道连接请求。不会为服务器不监听的接口创建线程。
- en: The connection manager thread allocates a thread to each client connection.
    The thread authenticates and takes care of request processing for that client
    connection. The manager threads check within the thread cache for a thread first,
    which can be used for the client connection. If no thread is available in the
    cache, it creates a new thread. Once the client request is processed and the connection
    ends, the thread which was created to serve the client connection is returned
    to the thread cache unless the cache is full.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 连接管理器线程为每个客户端连接分配一个线程。该线程对该客户端连接进行身份验证并处理请求处理。管理器线程首先在线程缓存中检查是否有可用于客户端连接的线程。如果缓存中没有可用线程，则创建一个新线程。一旦客户端请求被处理并且连接结束，为服务客户端连接创建的线程将被返回到线程缓存，除非缓存已满。
- en: There are as many threads as the number of clients currently connected in this
    thread connection model. It has disadvantages, as well. When the server is required
    to be scaled to handle a higher number of connections than it is handling right
    now, thread creation and disposal becomes expensive. In this thread connection
    model, server and kernel resources are required for each thread.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种线程连接模型中，线程的数量与当前连接的客户端数量相同。它也有缺点。当服务器需要扩展以处理比当前处理的连接数更多的连接时，线程的创建和处理变得昂贵。在这种线程连接模型中，每个线程都需要服务器和内核资源。
- en: Few server variables can be used to set up the server for optimized network
    usage. The `thread_cache_size` is the system variable which defines the size of
    the thread cache. The default value for thread cache size is 0\. This means that
    for each new connection, a thread is to be set up and disposed when the connection
    terminates. If we set `thread_cache_size` to 10, it enables 10 inactive connection
    threads to be cached. The thread connection becomes inactive when the connection
    with the client it was associated with terminates.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有些服务器变量可用于设置服务器以实现优化的网络使用。`thread_cache_size`是定义线程缓存大小的系统变量。线程缓存大小的默认值为0。这意味着对于每个新连接，都需要设置一个线程，并在连接终止时进行处理。如果我们将`thread_cache_size`设置为10，它将启用10个非活动连接线程进行缓存。当与其关联的客户端的连接终止时，线程连接变为非活动状态。
- en: The complexity of the SQL statements a server can handle is limited by the size
    of the thread stack. The MySQL 8 server can be started with `--thread_stack=N`
    to set *N* bytes of stack size for each thread.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以处理的SQL语句的复杂性受线程堆栈大小的限制。MySQL 8服务器可以使用`--thread_stack=N`启动，为每个线程设置*N*字节的堆栈大小。
- en: 'After setting the thread cache size, it becomes critical to monitor the impact. `Threads_cached`
    and `Threads_created` are the status variables to find out the number of threads
    in the thread cache, and the number of threads created because it could not be
    taken from the cache. The following is an example command to find out server status
    variable values:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 设置线程缓存大小后，监视其影响变得至关重要。`Threads_cached`和`Threads_created`是用于查找线程缓存中的线程数以及因无法从缓存中获取而创建的线程数的状态变量。以下是查找服务器状态变量值的示例命令：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following is an example of filtering the `status` variables:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是过滤`status`变量的示例：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Optimizing locking operations
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化锁定操作
- en: 'As discussed in one of the earlier chapters, MySQL 8 uses locking mechanisms
    to manage contention. Contention occurs when concurrently executing queries in
    multiple threads try to get ahold of one table at the same time. If these queries
    are performed on the table concurrently, the table data is left in an inconsistent
    state. MySQL 8 supports two types of locking: internal locking and external locking.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所讨论的，MySQL 8使用锁定机制来管理争用。当多个线程中同时执行查询尝试同时获取一个表时，就会发生争用。如果这些查询同时在表上执行，表数据将处于不一致状态。MySQL
    8支持两种类型的锁定：内部锁定和外部锁定。
- en: Internal locking is performed by multiple threads within the MySQL server to
    manage contention for table contents. This type of locking is performed entirely
    by the MySQL server, without involving any other programs. So, why it is called
    internal locking? In the case of external locking, the MySQL server and other
    programs lock table files to decide which programs can access the table at a time.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL服务器内部由多个线程执行内部锁定，以管理对表内容的争用。这种类型的锁定完全由MySQL服务器执行，不涉及任何其他程序。那么，为什么它被称为内部锁定？在外部锁定的情况下，MySQL服务器和其他程序锁定表文件，以决定哪些程序可以同时访问表。
- en: 'The following are the two methods for internal locking:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是内部锁定的两种方法：
- en: Row-level locking.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行级锁定。
- en: Table-level locking.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表级锁定。
- en: Row-level locking in MySQL supports simultaneous write access to multiple sessions.
    This enables multi-user and highly concurrent applications. While performing multiple
    concurrent write operations on a single table, it is highly possible that a deadlock
    may occur.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL中的行级锁定支持多个会话的同时写访问。这使得多用户和高并发应用程序成为可能。在单个表上执行多个并发写操作时，很可能会发生死锁。
- en: In order to avoid such a deadlock situation, a locking mechanism acquires locks
    at the beginning of the transaction using the `SELECT ... FOR UPDATE` statement
    for each set of rows to be modified. MySQL applies the statements in the same
    order within each transaction if transactions lock more than one table. The `InnoDB`
    database engine automatically detects deadlock conditions and rolls back the affected
    transactions. Considering this, deadlocks affect performance.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种死锁情况，锁定机制在事务开始时使用`SELECT ... FOR UPDATE`语句获取每组要修改的行的锁定。如果事务锁定多个表，MySQL会在每个事务内以相同的顺序应用语句。`InnoDB`数据库引擎会自动检测死锁条件并回滚受影响的事务。考虑到这一点，死锁会影响性能。
- en: The deadlock detection may cause slowdown if many threads wait for the same
    lock in highly concurrent systems. In such cases, it becomes more efficient to
    disable deadlock detection. We can rely on the `innodb_lock_wait_timeout` setting
    for transaction rollback when deadlock occurs. Using the `innodb_deadlock_detect`
    configuration option, we can disable the deadlock detection.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在高度并发的系统中，死锁检测可能会导致减速。在这种情况下，禁用死锁检测会更有效。当发生死锁时，我们可以依靠`innodb_lock_wait_timeout`设置来进行事务回滚。使用`innodb_deadlock_detect`配置选项，我们可以禁用死锁检测。
- en: 'The following are the advantages of row-level locking:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是行级锁定的优点：
- en: When different sessions access different rows in a table, the number of lock
    conflicts is fewer
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当不同会话访问表中的不同行时，锁冲突的数量较少
- en: The number of changes to be rolled back is fewer
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要回滚的更改数量较少
- en: It becomes possible to lock a single table row for a long time
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以长时间锁定单个表行
- en: Table-level locking is used by MySQL for `MyISAM`, `MEMORY`, and `MERGE` tables.
    In the case of table-level locking, MySQL permits only one session to update these
    tables at a time. With table-level locking, these storage engines become suitable
    for read-only or single-user applications. These storage engines request all the
    required locks at once, when the query begins, to avoid any deadlocks. It always
    locks the tables in the same order. The major drawback with table-level locking
    is that it affects concurrency. If other sessions need to modify the table, they
    must wait until the concurrent data change statement finishes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 表级锁定由MySQL用于`MyISAM`，`MEMORY`和`MERGE`表。在表级锁定的情况下，MySQL一次只允许一个会话更新这些表。通过表级锁定，这些存储引擎适用于只读或单用户应用程序。这些存储引擎在查询开始时一次性请求所有所需的锁，以避免任何死锁。它总是以相同的顺序锁定表。表级锁定的主要缺点是影响并发性。如果其他会话需要修改表，则必须等到并发数据更改语句完成。
- en: 'The following are the advantages of table-level locking:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 表级锁定的优点如下：
- en: It requires less memory compared to row-level locking
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与行级锁定相比，它需要更少的内存
- en: When used on a large part of the table, it is fast, because only one lock is
    required
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用于表的大部分时，速度很快，因为只需要一个锁
- en: If `GROUP BY` operations are performed frequently, it is fast
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果频繁执行`GROUP BY`操作，速度很快
- en: 'The following is the strategy for MySQL to grant write locks on tables:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL授予表写锁的策略如下：
- en: Put a write lock on the table if there are no write locks on the table
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果表上没有写锁，则在表上放置写锁
- en: Put a lock request in the write lock queue if the table already has a write
    lock
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果表已经有写锁，则将锁请求放入写锁队列
- en: 'The following is the strategy for MySQL to grant read locks on tables:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL授予表读锁的策略如下：
- en: Put a read lock on the table if there are no read locks on the table
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果表上没有读锁，则在表上放置读锁
- en: Put a lock request in the read lock queue if the table already has a read lock
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果表已经有读锁，则将锁请求放入读锁队列
- en: More priority is given to table updates than table retrievals. The lock is available
    to the write lock requests first, and then to the read lock requests when a lock
    is released.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对表的更新比表的检索给予更高的优先级。当锁被释放时，写锁请求首先可用，然后是读锁请求。
- en: 'The following is an example to analyze table lock contention:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是分析表锁争用的示例：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `MyISAM` storage engine inherently supports multiple concurrent inserts
    in order to reduce contention between readers and writers for a table. It allows
    the `MyISAM` table to insert rows in the middle of a data file. If the table does
    not have any free blocks in the middle of the data file, the rows are inserted
    at the end of the file. This enables MySQL to execute `INSERT` and `SELECT` queries
    on the same table, concurrently. `concurrent_insert` is the global system variable
    which controls the behavior of the `MyISAM` storage engine to allow execution
    of concurrent `INSERT` and `SELECT` statements. If this system variable is set
    to `AUTO`, concurrent `INSERT` and `SELECT` are allowed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyISAM`存储引擎天然支持多个并发插入，以减少读者和写者对表的争用。它允许`MyISAM`表在数据文件中间插入行。如果表在数据文件中间没有空闲块，则行将插入到文件末尾。这使得MySQL能够同时在同一表上执行`INSERT`和`SELECT`查询。`concurrent_insert`是全局系统变量，控制`MyISAM`存储引擎允许执行并发`INSERT`和`SELECT`语句的行为。如果将此系统变量设置为`AUTO`，则允许并发`INSERT`和`SELECT`。'
- en: 'If concurrent inserts are not possible and we want to perform multiple `INSERT`
    and `SELECT` operations on a table `tab1`, we can use the temporary table `temp_tab1`
    to hold the `tab1` table data and update the `tab1` table with the rows from the `temp_tab1`
    table. The following is an example which demonstrates this scenario:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法进行并发插入，并且我们想在表`tab1`上执行多个`INSERT`和`SELECT`操作，可以使用临时表`temp_tab1`来保存`tab1`表数据，并使用`temp_tab1`表中的行更新`tab1`表。以下是演示此场景的示例：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Performance benchmarking
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能基准测试
- en: 'We must consider the following factors when measuring performance:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在衡量性能时，我们必须考虑以下因素：
- en: While measuring the speed of a single operation or a set of operations, it is
    important to simulate a scenario in the case of a heavy database workload for
    benchmarking
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在衡量单个操作或一组操作的速度时，重要的是在数据库工作负载繁重的情况下模拟场景以进行基准测试
- en: In different environments, the test results may be different
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同的环境中，测试结果可能不同
- en: Depending on the workload, certain MySQL features may not help with performance
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据工作负载，某些MySQL功能可能无法提高性能
- en: 'MySQL 8 supports measuring the performance of individual statements. If we
    want to measure the speed of any SQL expression or function, the `BENCHMARK()`
    function is used. The following is the syntax for the function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8支持衡量单个语句的性能。如果要衡量任何SQL表达式或函数的速度，则使用`BENCHMARK()`函数。以下是该函数的语法：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output of the `BENCHMARK` function is always zero. The speed can be measured
    by the line printed by MySQL in the output. The following is an example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`BENCHMARK`函数的输出始终为零。速度可以通过MySQL在输出中打印的行来衡量。以下是一个例子：'
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: From the preceding  example , we can find that the time taken to calculate `1+1`
    for `1000000` times is `0.15 seconds`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的例子中，我们可以发现计算`1+1`1000000次所需的时间为`0.15秒`。
- en: Examining thread information
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查线程信息
- en: At times, we may need to figure out what the MySQL server is doing. So, it becomes
    necessary to find out the process list. The process list is the set of threads
    currently being executed within the MySQL server.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能需要弄清楚MySQL服务器在做什么。因此，有必要找出进程列表。进程列表是MySQL服务器内当前正在执行的线程集合。
- en: 'The following are the sources for getting process list information:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 获取进程列表信息的来源如下：
- en: 'The `SHOW [FULL] PROCESSLIST` statement. The following is an example of process
    list information:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHOW [FULL] PROCESSLIST`语句。以下是进程列表信息的示例：'
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `SHOW PROFILE` statement.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHOW PROFILE`语句。'
- en: 'The `INFORMATION_SCHEMA PROCESSLIST` table:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INFORMATION_SCHEMA PROCESSLIST`表：'
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `mysqladmin processlist` command.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mysqladmin processlist`命令。'
- en: The performance schema threads table, stage tables, and lock tables.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能模式线程表，阶段表和锁表。
- en: We must be able to view the information of user threads. The `PROCESS` privilege
    is required to view the information about threads being executed. To access threads,
    a Mutex access is not required. It has less impact on the MySQL server performance.
    Accessing `INFORMATION_SCHEMA.PROCESSLIST` and `SHOW PROCESSLIST` requires a Mutex
    and has an impact on performance. Threads also provide details of background threads.
    `INFORMATION_SCHEMA.PROCESSLIST` and `SHOW PROCESSLIST` do not provide information
    about background threads.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须能够查看用户线程的信息。需要`PROCESS`权限才能查看正在执行的线程的信息。要访问线程，不需要互斥访问。对MySQL服务器性能的影响较小。访问`INFORMATION_SCHEMA.PROCESSLIST`和`SHOW
    PROCESSLIST`需要互斥访问，并会影响性能。线程还提供后台线程的详细信息。`INFORMATION_SCHEMA.PROCESSLIST`和`SHOW
    PROCESSLIST`不提供有关后台线程的信息。
- en: 'The following table shows the information contained in each process list entry:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了每个进程列表条目中包含的信息：
- en: '| **Information** | **Details** |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **信息** | **详情** |'
- en: '| Id | Client connection identifier for the client that the thread is associated
    with. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| Id | 与线程关联的客户端连接标识符。 |'
- en: '| User, Host | Account associated with the thread. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 用户，主机 | 与线程相关的帐户。 |'
- en: '| db | Default database for the thread or `NULL`. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| db | 线程的默认数据库或`NULL`。 |'
- en: '| Command, State | It indicates what the thread is currently doing. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 命令，状态 | 表示线程当前正在做什么。 |'
- en: '| Time | It indicates how long the thread has been in the current state. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 时间 | 表示线程在当前状态下已经多久。 |'
- en: '| Info | It contains the information of the statement being executed by the
    thread. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 信息 | 包含线程执行的语句的信息。 |'
- en: 'The following is the thread state values associated with general query processing:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与一般查询处理相关的线程状态值：
- en: '`After create`: It occurs when the thread creates a table, including internal
    temporary tables'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`创建后`：当线程创建表时发生，包括内部临时表'
- en: '`Analyzing`: It occurs when the thread is calculating `MyISAM` key distribution'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析：当线程正在计算`MyISAM`键分布时发生
- en: '`Checking permissions`: It occurs when checking if the server has the required
    privileges to execute the SQL statement'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`检查权限`：当检查服务器是否具有执行SQL语句所需的权限时发生'
- en: '`Checking table`: It occurs when the thread is performing a table check operation'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`检查表`：当线程执行表检查操作时发生'
- en: '`Cleaning up`: It occurs when the thread has processed one command and frees
    the memory'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`清理`：当线程处理完一个命令并释放内存时发生'
- en: '`Closing tables`: It occurs when the thread is flushing the changed table data
    to disk and closing the used tables'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`关闭表`：当线程刷新更改的表数据到磁盘并关闭已使用的表时发生'
- en: '`Altering table`: It occurs when the server is processing the `ALTER TABLE`
    statement'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`修改表`：当服务器处理`ALTER TABLE`语句时发生'
- en: '`Creating index`: It occurs when the thread is processing `ALTER TABLE ...
    ENABLE KEYS` for the `MyISAM` table'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`创建索引`：当线程处理`MyISAM`表的`ALTER TABLE ... ENABLE KEYS`时发生'
- en: '`Creating table`: It occurs when the thread is creating a table'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`创建表`：当线程正在创建表时发生'
- en: '`end`: It occurs at the end, but before the clean up of `ALTER TABLE`, `CREATE
    VIEW`, `DELETE`, `INSERT`, `SELECT`, or `UPDATE` statements'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end`：在结束之前发生，但在清理`ALTER TABLE`，`CREATE VIEW`，`DELETE`，`INSERT`，`SELECT`或`UPDATE`语句之前'
- en: '`executing`: It occurs when the thread has begun executing a statement'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`执行`：当线程开始执行语句时发生'
- en: '`init`: It occurs before the initialization of `ALTER TABLE`, `DELETE`, `INSERT`,
    `SELECT`, and `UPDATE` statements'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init`：在`ALTER TABLE`，`DELETE`，`INSERT`，`SELECT`和`UPDATE`语句初始化之前发生'
- en: 'The following is the list of common states in the master''s `binlog` dump thread
    for replication master threads:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是复制主服务器线程的`binlog`转储线程中的常见状态列表：
- en: Finished reading one `binlog`; switching to next `binlog`
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成读取一个`binlog`；切换到下一个`binlog`
- en: Master has sent all `binlog` to slave; waiting for more updates
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主服务器已将所有`binlog`发送到从属服务器；等待更多更新
- en: Sending `binlog` event to slave
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向从属服务器发送`binlog`事件
- en: Waiting to finalize termination
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待最终终止
- en: 'The following is a list of common states for a slave server I/O thread:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从属服务器I/O线程的常见状态列表：
- en: Checking master version
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查主服务器版本
- en: Connecting to master
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到主服务器
- en: Queueing master event to the relay log
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将主事件排队到中继日志
- en: Reconnecting after a failed `binlog` dump request
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在失败的`binlog`转储请求后重新连接
- en: Reconnecting after a failed master event read
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在失败的主服务器事件读取后重新连接
- en: Registering slave on master
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主服务器上注册从属服务器
- en: Requesting `binlog` dump
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求`binlog`转储
- en: Waiting for its turn to commit
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待轮到自己提交
- en: Waiting for master to send event
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待主服务器发送事件
- en: Waiting for master update
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待主服务器更新
- en: Waiting for slave Mutex on exit
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待从属服务器退出的互斥
- en: Waiting for the slave SQL thread to free enough relay log space
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待从属服务器SQL线程释放足够的中继日志空间
- en: Waiting to reconnect after a failed `binlog` dump request
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在失败的`binlog`转储请求后等待重新连接
- en: Waiting to reconnect after a failed master event read
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在失败的主服务器事件读取后等待重新连接
- en: 'The following is a list of common states for a slave server SQL thread:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从属服务器SQL线程的常见状态列表：
- en: Killing slave
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 杀死从属服务器
- en: Making temporary file (append) before replaying `LOAD DATA INFILE`
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在重放`LOAD DATA INFILE`之前制作临时文件（追加）
- en: Making temporary file (create) before replaying `LOAD DATA INFILE`
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在重放`LOAD DATA INFILE`之前制作临时文件（创建）
- en: Reading event from the relay log
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从中继日志读取事件
- en: Slave has read all relay log; waiting for more updates
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从属服务器已读取所有中继日志；等待更多更新
- en: Waiting for an event from coordinator
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待来自协调器的事件
- en: Waiting for slave Mutex on exit
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待从属服务器退出的互斥
- en: Waiting for slave workers to free pending events
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待从属服务器工作线程释放挂起事件
- en: Waiting for the next event in relay log
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待中继日志中的下一个事件
- en: Waiting until `MASTER_DELAY` seconds after master executed event
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待`MASTER_DELAY`秒，直到主服务器执行事件
- en: Optimizing database structure
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化数据库结构
- en: As a database administrator, we must look for efficient ways to organize table
    schema, tables, and columns. We minimize I/O, plan ahead, and keep related items
    together to tune the application code in order to keep performance high with an
    increase in data volume. It usually starts with efficient database design, which
    makes it easier for team members to write high-performance application code. It
    also makes the database likely to sustain itself as applications evolve or are
    rewritten.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 作为数据库管理员，我们必须寻找有效的方法来组织表模式、表和列。我们最小化I/O，提前规划，并将相关项目放在一起，以调整应用程序代码，以保持性能高并增加数据量。通常从高效的数据库设计开始，这样可以更容易地编写高性能的应用程序代码。这也使得数据库在应用程序发展或重写时能够自我维持。
- en: Optimizing data size
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化数据大小
- en: In order to minimize the space on the disk, we should start designing the database
    tables. This results in huge performance improvements, as it reduces the amount
    of data to be written to and read from the disk. Smaller tables usually need less
    main memory, while the contents are actively processed during query execution.
    Any reduction in table data space results in a need for smaller indexes that can
    be processed faster.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化磁盘上的空间，我们应该开始设计数据库表。这会带来巨大的性能改进，因为它减少了要写入和从磁盘读取的数据量。较小的表通常需要较少的主内存，而在查询执行期间活动处理内容。表数据空间的任何减少都会导致需要更小的索引，这样可以更快地处理。
- en: As discussed in the chapter on MySQL 8 data types, MySQL supports many different
    storage engines and row formats. We can decide the storage and indexing method
    to be used for each table. It is a big performance gain to choose the proper table
    format.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在MySQL 8数据类型章节中讨论的那样，MySQL支持许多不同的存储引擎和行格式。我们可以决定每个表要使用的存储和索引方法。选择适当的表格式是一个很大的性能提升。
- en: Table columns
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表列
- en: We should use the smallest feasible data type for a table column. This results
    in the most efficient approach. MySQL supports specialized data types to save
    memory and disk space. For example, we should use integer types wherever possible
    to get smaller tables. Comparing `MEDIUMINT` and `INT`, `MEDIUMINT` is a better
    choice, as it uses 25% less space compared to `INT`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该为表列使用尽可能小的数据类型。这是最有效的方法。MySQL支持专门的数据类型来节省内存和磁盘空间。例如，我们应该尽可能使用整数类型来获得较小的表。比较`MEDIUMINT`和`INT`，`MEDIUMINT`是一个更好的选择，因为它使用的空间比`INT`少25%。
- en: We must declare columns to be `NOT NULL` wherever possible. This enables better
    use of indexes and eliminates the overhead of testing whether each value is `NULL`
    or not. It results in faster SQL operations. We can also save one bit per column
    of storage space. We should use `NULL` if we really require it. `NULL` values
    should not be allowed as a result of default settings for every column.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须尽可能声明列为`NOT NULL`。这样可以更好地使用索引，并消除测试每个值是否为`NULL`的开销。这会导致更快的SQL操作。我们也可以节省每列一个位的存储空间。如果我们真的需要，应该使用`NULL`。`NULL`值不应该作为每列的默认设置而被允许。
- en: 'We can attain huge performance gain for a table and minimize storage space
    requirement by using following techniques:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下技术可以获得表的巨大性能提升并最小化存储空间需求：
- en: Row format
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行格式
- en: As a default, the `DYNAMIC` row format is used when creating `InnoDB` tables.
    We can configure `innodb_default_row_format` to use row formats other than `DYNAMIC`.
    We can also specify the `ROW_FORMAT` option explicitly in a `CREATE TABLE` or
    `ALTER TABLE` statement.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在创建`InnoDB`表时使用`DYNAMIC`行格式。我们可以配置`innodb_default_row_format`以使用除`DYNAMIC`之外的行格式。我们还可以在`CREATE
    TABLE`或`ALTER TABLE`语句中明确指定`ROW_FORMAT`选项。
- en: The row formats include `COMPACT`, `DYNAMIC`, and `COMPRESSED`. They decrease
    row storage space at the cost of increased CPU use for some operations. For the
    average workload, which is limited by the cache hit rates and disk speed, it will
    be faster. If it is limited by the CPU speed, it will be slower.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 行格式包括`COMPACT`、`DYNAMIC`和`COMPRESSED`。它们减少了行存储空间，但在某些操作上增加了CPU使用。对于平均工作负载，受到缓存命中率和磁盘速度的限制，它会更快。如果受到CPU速度的限制，它会更慢。
- en: The row formats also optimize the `CHAR` data type column storage when it uses
    a variable length character set. With the `REDUNDANT` row format, the `CHAR(N)`
    column value occupies *N* times the maximum byte length in the character set.
    The `InnoDB` storage engine allocates variable amounts of storage within the range
    of *N* to *N* times the maximum byte length in the character set.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 行格式还优化了使用可变长度字符集时`CHAR`数据类型列的存储。使用`REDUNDANT`行格式，`CHAR(N)`列值占用字符集中最大字节长度的*N*倍。`InnoDB`存储引擎在*N*到*N*倍字符集中最大字节长度范围内分配可变数量的存储空间。
- en: A fixed-size row format is used if we do not have variable-length columns, such
    as `VARCHAR`, `TEXT`, or `BLOB`, in the case of `MyISAM` tables.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`MyISAM`表的情况下没有可变长度列，例如`VARCHAR`、`TEXT`或`BLOB`，则使用固定大小的行格式。
- en: Indexes
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引
- en: A table's primary index must be as short as feasible. This enables easy identification
    of each row. It is efficient, too. In the case of `InnoDB` tables, the primary
    key column is duplicated in each secondary index entry. If we have a short primary
    key, it saves space in the case of many secondary indexes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 表的主索引必须尽可能短。这样可以轻松识别每一行。这也很有效。在`InnoDB`表的情况下，主键列在每个次要索引条目中都会被复制。如果我们有一个较短的主键，那么在有许多次要索引的情况下可以节省空间。
- en: We should create only those indexes which improve query performance. The indexes
    improve information retrieval, but they slow down the insert and update operations.
    Indexes must be created with proper attention to the performance impact. If it
    is required to access a table by searching on a combination of columns, it is
    preferred to have a composite index on the combination of columns, rather than
    a separate index on each of the columns. The most used column should be the first
    part of the index. If it is a common requirement to use many columns in selected
    operations on the table, it is advisable to have the column with the most duplicates
    as the first column in the index. This gives better compression of the index.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该只创建那些提高查询性能的索引。索引改善信息检索，但会减慢插入和更新操作。必须要注意索引的性能影响来创建索引。如果需要通过组合列进行搜索来访问表，最好在组合列上创建复合索引，而不是在每个列上单独创建索引。最常用的列应该是索引的第一部分。如果在表的选定操作中经常使用许多列，建议将具有最多重复项的列作为索引中的第一列。这样可以更好地压缩索引。
- en: If a long string column is supposed to have a unique prefix as the first few
    characters, it is advisable to index only the prefix, using MySQL's support for
    indexing on the leftmost part of the column. Shorter indexes are preferred, not
    only for the less space they require, but also because they provide more hits
    in the index cache and require fewer disk seeks.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个长字符串列应该有一个唯一的前缀作为前几个字符，建议只索引前缀，使用MySQL对列的最左边部分进行索引的支持。更短的索引更受青睐，不仅因为它们需要更少的空间，而且因为它们在索引缓存中提供更多的命中，并且需要更少的磁盘查找。
- en: Joins
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接
- en: If a table is scanned very often, it is beneficial to split the table into two
    tables, if feasible. This holds true especially if it is a dynamic-format table.
    It is also possible to use smaller static format tables, which can be used to
    search for relevant rows while scanning the tables.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个表经常被扫描，如果可行的话，将表拆分成两个表是有益的。这尤其适用于动态格式表。还可以使用较小的静态格式表，用于在扫描表时搜索相关行。
- en: The columns with identical information should be declared in different tables
    with identical data types. This speeds up joins based on matching columns.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相同信息的列应该在不同的表中声明，具有相同的数据类型。这加快了基于匹配列的连接。
- en: Column names must be kept simple, so as to use the same name across tables.
    It simplifies join queries. For example, in a customer table, we should use the
    column name of `name`, rather than using `customer_name`. In order to make the
    names portable to other SQL servers, we should keep the column names shorter than
    18 characters.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列名必须保持简单，以便在表之间使用相同的名称。这简化了连接查询。例如，在客户表中，我们应该使用`name`作为列名，而不是使用`customer_name`。为了使名称可移植到其他SQL服务器，我们应该保持列名短于18个字符。
- en: Normalization
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范化
- en: The data in the table columns must be kept non-redundant, considering the third
    normal form in the normalization theory. If the column holds repeating lengthy
    values, such as names or addresses, it is preferable to assign unique IDs and
    repeat these IDs across multiple smaller tables. In the event of searching, join
    queries should be used by referencing IDs in the join clauses.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 表列中的数据必须保持非冗余，考虑规范化理论中的第三范式。如果列包含重复的长数值，例如名称或地址，最好分配唯一的ID，并在多个较小的表中重复这些ID。在搜索时，应该通过在连接子句中引用ID来使用连接查询。
- en: In an application, if the preference is speed and not disk space or the maintenance
    costs of using multiple copies of data, it is advisable to duplicate the information
    or create summary tables to gain more speed. An example scenario could be a business
    intelligence system, where data is analyzed from large tables. In this case, normalization
    rules are not strictly followed.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，如果偏好速度而不是磁盘空间或使用多个数据副本的维护成本，建议复制信息或创建摘要表以获得更快的速度。一个例子是商业智能系统，从大型表中分析数据。在这种情况下，规范化规则并不严格遵循。
- en: Optimizing MySQL data types
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化MySQL数据类型
- en: 'The following are the guidelines for optimizing numeric data types:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是优化数字数据类型的指南：
- en: Numeric columns must be preferred over string columns to store unique IDs or
    other values that can be represented as either strings or numbers. It is faster
    and occupies less memory to transfer and compare, because large numeric values
    are stored in fewer bytes compared to strings.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字列必须优先于字符串列，用于存储唯一ID或其他可以表示为字符串或数字的值。它更快，占用更少的内存来传输和比较，因为与字符串相比，大的数字值存储在较少的字节中。
- en: It is faster to access information from a database than from a text file. This
    is especially true when numeric data is used. Information in the database is stored
    in a more compact format than in the text file. So, it requires fewer disk accesses.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据库中访问信息比从文本文件中访问信息更快。当使用数字数据时，这一点尤为真实。数据库中的信息以比文本文件更紧凑的格式存储。因此，它需要更少的磁盘访问。
- en: 'The following are the guidelines for optimizing character and string data types:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是优化字符和字符串数据类型的指南：
- en: The binary collation order (logical sequence) should be used for faster comparisons
    and sort operations. The binary operator can also be used within a query to use
    binary collation order.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制排序顺序（逻辑顺序）应该用于更快的比较和排序操作。二进制运算符也可以在查询中使用二进制排序顺序。
- en: With an `InnoDB` table, when we use a randomly generated value as a primary
    key, it should be prefixed with an ascending value, such as the date and time,
    if feasible. In this case, primary key values are stored nearer to each other,
    physically. `InnoDB` can insert or retrieve such values faster.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`InnoDB`表，当我们使用随机生成的值作为主键时，如果可行的话，应该以升序值作为前缀，例如日期和时间。在这种情况下，主键值在物理上更接近。`InnoDB`可以更快地插入或检索这些值。
- en: The binary `VARCHAR` data type should be used instead of `BLOB` for column values
    that are expected to hold less than 8 KB of data. If the original table does not
    have any `BLOB` columns, the `GROUP BY` and `ORDER BY` clauses generate temporary
    tables. These temporary tables can use the `MEMORY` storage engine.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于预计保存少于8KB数据的列值，应使用二进制VARCHAR数据类型而不是BLOB。如果原始表没有任何BLOB列，GROUP BY和ORDER BY子句会生成临时表。这些临时表可以使用MEMORY存储引擎。
- en: In order to avoid string conversions while running a query, the columns should
    be declared with the same character set and order wherever possible when comparing
    the values from different columns.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了在运行查询时避免字符串转换，应尽可能在比较来自不同列的值时使用相同的字符集和排序声明列。
- en: If the table holds string columns which are not frequently used in retrieval
    operations, splitting the string columns into a separate table should be considered.
    In the retrieval operations, join queries should be used with a foreign key wherever
    necessary. MySQL reads a data block containing all the columns of a row when it
    retrieves any value from a row. It allows more rows to fit within each data block
    when we keep the rows small, with only frequently used columns. These compact
    tables reduce memory usage and disk I/O.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表包含不经常在检索操作中使用的字符串列，应考虑将字符串列拆分为单独的表。在检索操作中，应根据需要使用外键进行连接查询。当检索任何行的值时，MySQL读取包含该行的所有列的数据块。当我们保持行较小，仅包含经常使用的列时，可以使更多的行适应每个数据块。这些紧凑的表减少了内存使用和磁盘I/O。
- en: 'The following are the guidelines for optimizing `BLOB` data types:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是优化BLOB数据类型的指南：
- en: The performance requirements for a `BLOB` column may be different when retrieving
    and displaying information. So, storing the `BLOB` specific table in a different
    storage device or a separate database instance should be considered. For example,
    it is required to retrieve a `BLOB` in a large sequential disk read. So, a traditional
    hard drive or an SSD device might better suit needs.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索和显示信息时，BLOB列的性能要求可能会有所不同。因此，应考虑将BLOB特定表存储在不同的存储设备或单独的数据库实例中。例如，需要在大型顺序磁盘读取中检索BLOB。因此，传统硬盘驱动器或SSD设备可能更适合需求。
- en: In order to reduce the memory requirements for a query which does not use a `BLOB`
    column, for a table with several columns, splitting the `BLOB` into separate tables
    and referencing with join queries should be considered, as needed.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了减少不使用BLOB列的查询的内存需求，对于具有多个列的表，应考虑将BLOB拆分为单独的表，并根据需要使用连接查询进行引用。
- en: If a table column is a large blob with textual data, compressing should be considered
    first. If the entire table is compressed by the storage engine, such as `InnoDB`
    or `MyISAM`, this technique should not be used.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表列是一个包含文本数据的大型blob，应首先考虑压缩。如果整个表由存储引擎（如InnoDB或MyISAM）压缩，就不应该使用这种技术。
- en: Optimizing for many tables
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化多个表
- en: We learned the technique of splitting a table into many tables for faster execution
    of queries in certain situations. This technique cannot be applied in all of the
    scenarios, as if the number of tables runs into thousands, the overhead of managing
    all these tables becomes another performance nightmare.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了在某些情况下将表拆分为多个表以加快查询执行的技术。这种技术并不适用于所有情况，因为如果表的数量达到数千个，管理所有这些表的开销将成为另一个性能噩梦。
- en: 'In this section, we will see how MySQL opens and closes tables. The following
    shows how to discover open files on the MySQL server:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到MySQL如何打开和关闭表。以下显示了如何在MySQL服务器上发现打开的文件：
- en: '[PRE13]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The MySQL 8 server is multi-threaded. It is possible that many clients issue
    queries for a table simultaneously. MySQL opens the table independently for each
    concurrent session, in order to minimize the problem of multiple client sessions
    with different states on the same table. This improves performance, though it
    requires additional memory. One extra file descriptor is required in the data
    file for each client that opens the `MyISAM` table.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8服务器是多线程的。可能会有许多客户端同时为一个表发出查询。MySQL为每个并发会话独立打开表，以最小化同一表上具有不同状态的多个客户端会话的问题。这提高了性能，尽管需要额外的内存。每个打开MyISAM表的客户端需要一个额外的文件描述符。
- en: The `table_open_cache` system variable determines the number of open tables
    for all the threads. The number of file descriptors `mysqld` requires can be increased
    by increasing this value. The `max_connections` system variable determines the
    maximum permitted number of simultaneous client connections. In a way, these two
    system variables affect the maximum number of files that the MySQL server can
    keep open. If we increase both values, we may run against a limit imposed by the
    operating system on the per process number of open files.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: table_open_cache系统变量确定所有线程的打开表的数量。通过增加这个值可以增加mysqld需要的文件描述符的数量。max_connections系统变量确定允许的最大同时客户端连接数。在某种程度上，这两个系统变量影响MySQL服务器可以保持打开的文件的最大数量。如果我们增加这两个值，可能会受到操作系统对每个进程打开文件数量的限制。
- en: 'The following are the circumstances under which MySQL closes unused tables:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是MySQL关闭未使用表的情况：
- en: A thread tries to open a table which is not in the table cache when the table
    cache is full.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当表缓存已满且有线程尝试打开不在表缓存中的表时。
- en: When the table cache contains more entries than specified in the `table_open_cache`
    system variable and a table in the cache is no longer used by any threads.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当表缓存包含的条目多于table_open_cache系统变量中指定的条目，并且缓存中的表不再被任何线程使用时。
- en: When someone issues the `FLUSH TABLES` statement or executes a `mysqladmin flush-tables`
    or `mysqladmin refresh` command, the table flushing operation occurs. MySQL closes
    the table on this event.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当有人发出FLUSH TABLES语句或执行mysqladmin flush-tables或mysqladmin refresh命令时，表刷新操作会发生。MySQL在此事件上关闭表。
- en: 'The MySQL 8 server uses the following process to locate a cache entry when
    the table cache is full:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8服务器在表缓存已满时使用以下过程来定位缓存条目：
- en: Unused tables are released, starting with the table used the least recently.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从最近最少使用的表开始释放未使用的表。
- en: If it is required to open a new table and the table cache is full and no tables
    can be released, the cache is temporarily extended, as needed. If a table transitions
    from a used to unused state when the table cache is in a temporarily extended
    state, the table is closed and released from the table cache.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要打开一个新表，表缓存已满且无法释放表，则根据需要临时扩展缓存。如果在表缓存处于临时扩展状态时，表从已使用状态转换为未使用状态，则关闭该表并从表缓存中释放。
- en: 'The following is an example of finding the number of open tables:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是查找打开表数量的示例：
- en: '[PRE14]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Use of an internal temporary table in MySQL
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在MySQL中使用内部临时表
- en: 'The MySQL 8 server creates temporary internal tables while processing SQL statements,
    in some cases. The following are the conditions under which the server creates
    temporary tables:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理SQL语句时，MySQL 8服务器在某些情况下创建临时内部表。以下是服务器创建临时表的条件：
- en: UNION statements
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UNION语句
- en: Views which uses the `TEMPTABLE` algorithm, `UNION`, or `aggregation`
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`TEMPTABLE`算法、`UNION`或`聚合`的视图
- en: Derived tables
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生表
- en: Common table expressions
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共表达式
- en: Tables created for subquery or semi join materialization
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为子查询或半连接材料化创建的表
- en: Statements that contain `ORDER BY` and `GROUP BY` clauses
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含`ORDER BY`和`GROUP BY`子句的语句
- en: Statements with `DISTINCT` combined with `ORDER BY`
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有`DISTINCT`和`ORDER BY`的语句
- en: Queries that use the `SQL_SMALL_RESULT` modifier
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SQL_SMALL_RESULT`修饰符的查询
- en: '`INSERT ... SELECT` statements that select from and insert into the same table'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从相同表中选择并插入的`INSERT ... SELECT`语句
- en: Multiple table `UPDATE` statements
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多表`UPDATE`语句
- en: '`GROUP_CONCAT()` or `COUNT(DISTINCT)` expressions'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GROUP_CONCAT()`或`COUNT(DISTINCT)`表达式'
- en: The `EXPLAIN` statement can be used to determine whether the statement requires
    a temporary table. The `EXPLAIN` statement has limitations. It will not indicate
    if the statement requires a temporary table for derived or materialized temporary
    tables.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPLAIN`语句可用于确定语句是否需要临时表。`EXPLAIN`语句有限制。它不会指示语句是否需要为派生或材料化临时表创建临时表。'
- en: The `Created_tmp_tables` status variable keeps track of the number of temporary
    tables created in internal memory. When the MySQL server creates a temporary table,
    it increments the value in the `Created_tmp_tables` status variable. `Created_tmp_disk_tables`
    is another status variable that keeps track of the number of tables created on
    the disk.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`Created_tmp_tables`状态变量跟踪在内部内存中创建的临时表的数量。当MySQL服务器创建临时表时，它会增加`Created_tmp_tables`状态变量中的值。`Created_tmp_disk_tables`是另一个状态变量，用于跟踪在磁盘上创建的表的数量。'
- en: 'Based on the query conditions, the server prevents the use of temporary tables
    in memory. In such cases, the server creates a table on the disk. The following
    are some instances:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 根据查询条件，服务器阻止在内存中使用临时表。在这种情况下，服务器在磁盘上创建表。以下是一些实例：
- en: If the table has a `BLOB` or `TEXT` column
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表具有`BLOB`或`TEXT`列
- en: If the statement has a string column with a maximum length larger than 512 bytes
    in the `SELECT` list, if `UNION` or `UNION ALL` is used
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`SELECT`列表中的字符串列的最大长度大于512字节，并且使用了`UNION`或`UNION ALL`
- en: If the `SHOW COLUMNS` and `DESCRIBE` statements use `BLOB` as the type of the
    column
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果“SHOW COLUMNS”和“DESCRIBE”语句使用“BLOB”作为列的类型
- en: 'The following are the conditions in which a `UNION` is evaluated without creating
    temporary tables:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下条件下，`UNION`会在不创建临时表的情况下进行评估：
- en: The union is `UNION ALL` and not `UNION` or `UNION DISTINCT`
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联合是`UNION ALL`而不是`UNION`或`UNION DISTINCT`
- en: There is no global `ORDER BY` clause
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有全局`ORDER BY`子句
- en: In a `SELECT` query, the union is not at the top-level query block
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`SELECT`查询中，联合不在顶层查询块
- en: Optimizing queries
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化查询
- en: Similar to tables, database queries are the most crucial element of any database.
    Applications interact with the databases using queries. Queries are also called
    executable SQL statements. This section focuses on techniques to improve the performance
    of query execution.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 与表类似，数据库查询是任何数据库的最关键元素。应用程序使用查询与数据库交互。查询也称为可执行的SQL语句。本节重点介绍了改进查询执行性能的技术。
- en: Optimizing SQL statements
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化SQL语句
- en: SQL statements are used to perform the core logic of any database application.
    It does not matter whether the statements are issued directly through an interpreter
    or submitted behind the scenes by an API. This section outlines guidelines to
    improve the performance of SQL operations that read and write data in the database.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: SQL语句用于执行任何数据库应用程序的核心逻辑。无论语句是直接通过解释器发出还是通过API在后台提交，都无关紧要。本节概述了改进数据库中读写数据的SQL操作性能的准则。
- en: '`SELECT` statements perform all of the lookup operations in the database. Considering
    the frequency of `SELECT` statements, it becomes important to tune these statements
    at the top priority. The tuning techniques must be applied to constructs like
    `CREATE TABLE...AS SELECT`, `INSERT INTO...SELECT`, and `WHERE` clauses in `DELETE`
    statements.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT`语句在数据库中执行所有查找操作。考虑到`SELECT`语句的频率，调整这些语句变得至关重要。调整技术必须应用于像`CREATE TABLE...AS
    SELECT`、`INSERT INTO...SELECT`和`DELETE`语句中的`WHERE`子句等构造。'
- en: 'The following are the main considerations for optimizing queries:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是优化查询的主要考虑因素：
- en: In order to optimize the `SELECT ... WHERE` query, the first thing to check
    is if an index can be added. We should add indexes on the columns used in the
    `WHERE` clause of the `SELECT` query. This will speed up the evaluation, filtering,
    and the retrieval of results. The strategy should be to construct a small set
    of indexes that can speed up many related queries used in the application. It
    also avoids the wasted disk space.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了优化`SELECT ... WHERE`查询，首先要检查的是是否可以添加索引。我们应该在`SELECT`查询的`WHERE`子句中使用的列上添加索引。这将加快评估、过滤和检索结果。策略应该是构建一小组可以加速应用程序中许多相关查询的索引。这也避免了浪费的磁盘空间。
- en: The indexes are important for queries which reference different tables using
    joins and foreign keys. The `EXPLAIN` statement can be used to determine which
    indexes are used in a `SELECT` statement execution.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引对于引用使用连接和外键的不同表的查询非常重要。`EXPLAIN`语句可用于确定在`SELECT`语句执行中使用了哪些索引。
- en: The next step should be to isolate and tune parts of the query; for example,
    a function call which takes excessive time. Depending upon the structure of the
    query, a function call can be done for every row in the table or for every row
    in the result set.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一步应该是隔离和调整查询的部分；例如，需要大量时间的函数调用。根据查询的结构，函数调用可以针对表中的每一行或结果集中的每一行进行。
- en: The number of full table scans in the query must be minimized, specifically
    for big tables.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询中全表扫描的次数必须最小化，特别是对于大表。
- en: The `ANALYZE TABLE` statement should be used periodically to keep the table
    statistics up-to-date. The optimizer provides the information required to build
    an efficient query execution plan.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应定期使用`ANALYZE TABLE`语句来保持表统计信息的最新。优化器提供了构建高效查询执行计划所需的信息。
- en: If the basic guidelines do not solve the performance issues, queries should
    be investigated for internal details by reading the `EXPLAIN` plan and adjusting
    your indexes, `WHERE` clauses, join clauses, and so on.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果基本指导方针不能解决性能问题，应该通过阅读`EXPLAIN`计划并调整索引、`WHERE`子句、连接子句等内部细节来调查查询。
- en: Transforming queries in a way that makes them hard to understand should be avoided,
    especially when the optimizer does some of the same transformations automatically.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应避免将查询转换为难以理解的方式，特别是当优化器自动执行一些相同的转换时。
- en: The `InnoDB` buffer pool, `MyISAM` key cache, and the MySQL query cache must
    be used efficiently for repeated queries to run faster as the results are retrieved
    from memory after the first time. The size and properties of the memory area must
    be adjusted, as MySQL uses it for caching.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InnoDB`缓冲池、`MyISAM`键缓存和MySQL查询缓存必须有效地用于重复查询，以便在第一次后从内存中检索结果后更快地运行。内存区域的大小和属性必须进行调整，因为MySQL用于缓存。'
- en: If the query runs faster using the cache memory area, we should still optimize
    it further, so that it requires less cache memory. It makes the application more
    scalable, which makes the application capable of handling more simultaneous users,
    larger requests, and so on, without experiencing performance drop.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果查询使用缓存内存区域运行得更快，我们仍然应该进一步优化它，以便需要更少的缓存内存。这使应用程序更具可扩展性，使应用程序能够处理更多的同时用户、更大的请求等，而不会出现性能下降。
- en: Where the speed of the query is affected by other sessions accessing the table
    at the same time, we should deal with locking issues.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果查询的速度受其他会话同时访问表的影响，我们应该处理锁定问题。
- en: 'The following are the guidelines to optimize the `WHERE` clause. These optimizations
    are applicable to `WHERE` clauses in `SELECT`, `DELETE`, or `UPDATE` queries,
    equally:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是优化`WHERE`子句的指导方针。这些优化适用于`SELECT`、`DELETE`或`UPDATE`查询中的`WHERE`子句：
- en: 'Unnecessary parentheses should be removed. The following is an example of parentheses
    removal:'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不必要的括号应该被移除。以下是一个括号移除的例子：
- en: '[PRE15]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Constant folding is the process of evaluating values at compile time instead
    of runtime. If we have assigned a constant value to a variable and then use that
    variable in an expression, we should use the constant value instead. The following
    is an example of constant folding:'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量折叠是在编译时而不是运行时评估值的过程。如果我们已经将一个常量值赋给一个变量，然后在表达式中使用该变量，我们应该使用常量值。以下是一个常量折叠的例子：
- en: '[PRE16]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Because of constant folding, we should remove constant conditions. The following
    is an example of constant condition removal:'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于常量折叠，我们应该移除常量条件。以下是一个常量条件移除的例子：
- en: '[PRE17]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Optimizing indexes
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化索引
- en: The basic use of indexes is to quickly find the rows with specific column values.
    If the index is not present, MySQL begins with the first row and reads through
    the entire table to find all the matching rows. It takes more time, depending
    on how large a table is. If the index is present for the appropriate columns,
    MySQL is able to quickly determine the position to seek to in the middle of the
    data file, without looking at the whole table data.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 索引的基本用途是快速查找具有特定列值的行。如果索引不存在，MySQL将从第一行开始并读取整个表以查找所有匹配的行。这需要更多时间，取决于表有多大。如果索引存在于适当的列中，MySQL能够快速确定在数据文件中寻找的位置，而不必查看整个表数据。
- en: 'The following is a list of operations for which MySQL uses indexes:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是MySQL使用索引的操作列表：
- en: To find matching rows, based on a `WHERE` clause, quickly.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于`WHERE`子句快速查找匹配行。
- en: MySQL uses the index with the smallest number of rows (most selective index)
    in the case of choosing from multiple indexes to eliminate rows from consideration.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在选择多个索引以消除考虑的行时，MySQL使用行数最少的索引（最具选择性的索引）。
- en: The optimizer uses the leftmost prefix of the index to look up rows if the table
    has a composite index. For example, in a table with three columns indexed (on
    col1, col2, col3), the optimizer can look for rows with indexed search capabilities
    on (col1), (col1, col2), and (col1, col2, col3).
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表具有复合索引，优化器使用索引的最左前缀来查找行。例如，在一个有三列索引的表中（在col1、col2、col3上），优化器可以查找具有索引搜索能力的行（col1）、（col1，col2）和（col1，col2，col3）。
- en: MySQL uses indexes while it fetches rows from other tables using joins. If the
    indexes are declared as the same type and size, MySQL can use them efficiently
    on the column. The `VARCHAR` and `CHAR` are considered the same when declared
    as the same size.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL在使用连接从其他表中提取行时使用索引。如果索引声明为相同类型和大小，MySQL可以在列上有效地使用它们。当声明为相同大小时，`VARCHAR`和`CHAR`被视为相同。
- en: MySQL also uses indexes to find the `minimum(MIN())` or `maximum(MAX())` value
    for an indexed column `key_col`. The preprocessor checks whether it is using `WHERE
    key_part_N = constant` on all key parts to optimize it.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL还使用索引查找索引列`key_col`的`最小值（MIN（））`或`最大值（MAX（））`。预处理器检查是否在所有关键部分上使用`WHERE
    key_part_N = constant`来优化它。
- en: It is also possible to optimize the query to retrieve values without consulting
    the data rows. (A covering index is an index that provides all the results for
    a query.) If the query uses only those columns from a table which are included
    in some index, the selected values will be fetched from the index tree. This will
    have a higher speed in retrieving values.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还可以优化查询以检索值而不需要查询数据行。（覆盖索引是为查询提供所有结果的索引。）如果查询仅使用某个索引中包含的表中的那些列，所选值将从索引树中获取。这将更快地检索值。
- en: Query execution plan
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询执行计划
- en: The MySQL optimizer considers optimization techniques to efficiently perform
    the lookups involved in the query, depending on the details of the tables, columns,
    and indexes, and the conditions in the `WHERE` clause. A query can also be performed
    without reading all the rows on a huge table. An SQL join can also be performed
    without comparing every combination of rows. A query execution plan is a set of
    operations that the MySQL optimizer chooses to perform the most efficient query.
    It is also known as the `EXPLAIN` plan. As an administrator, the goal is to recognize
    the aspects of the query execution plan which indicate if a query is optimized.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL优化器考虑优化技术，以有效地执行查询中涉及的查找，具体取决于表、列和索引的细节，以及`WHERE`子句中的条件。查询也可以在不读取大表上的所有行的情况下执行。SQL连接也可以在不比较每个行的组合的情况下执行。查询执行计划是MySQL优化器选择执行最有效查询的一组操作。它也被称为`EXPLAIN`计划。作为管理员，目标是识别查询执行计划的方面，以确定查询是否经过优化。
- en: 'The `EXPLAIN` statement is used to determine the query execution plan. The
    following is the set of information provided by the `EXPLAIN` statement:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPLAIN`语句用于确定查询执行计划。以下是`EXPLAIN`语句提供的信息集：'
- en: The `EXPLAIN` statement works with `SELECT`, `DELETE`, `INSERT`, `UPDATE`, and
    `REPLACE` statements.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPLAIN`语句与`SELECT`、`DELETE`、`INSERT`、`UPDATE`和`REPLACE`语句一起工作。'
- en: MySQL displays information from the MySQL optimizer about the query execution
    plan when `EXPLAIN` is used with the SQL statement. This means MySQL explains
    the process with which the statement is executed. It includes information about
    how tables are joined, and in which order.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`EXPLAIN`与SQL语句一起使用时，MySQL显示有关查询执行计划的MySQL优化器的信息。这意味着MySQL解释了语句执行的过程。它包括有关表如何连接以及连接顺序的信息。
- en: If `EXPLAIN` displays the execution plan for the statement execution in the
    named connection if it is used with `FOR CONNECTION` connection_id instead of
    explainable SQL statement.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`EXPLAIN`显示了命名连接中语句执行的执行计划，而不是可解释的SQL语句，则使用`FOR CONNECTION`连接ID。
- en: '`EXPLAIN` displays additional execution plan information for `SELECT` statements.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPLAIN`为`SELECT`语句显示了额外的执行计划信息。'
- en: '`EXPLAIN` is also useful in examining queries which involve partitioned tables.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPLAIN`还可用于检查涉及分区表的查询。'
- en: '`EXPLAIN` supports a `FORMAT` option, which can be used to select the output
    format. The `TRADITIONAL` format displays the output in a tabular format. This
    is the default format option. The **JavaScript Object Notation** (**JSON**) format
    option produces information in the JSON format.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPLAIN`支持`FORMAT`选项，可用于选择输出格式。`TRADITIONAL`格式以表格格式显示输出。这是默认的格式选项。**JavaScript对象表示**（**JSON**）格式选项以JSON格式生成信息。'
- en: Based on the output from the `EXPLAIN` statement, it can be figured out where
    indexes can be added to the tables, so that the statement executes faster. It
    can also be found whether the optimizer joins the tables in the optimized order.
    Begin the statement with `SELECT STRAIGHT_JOIN`, instead of just `SELECT`, to
    give a hint to the optimizer to use the join order corresponding to the order
    the tables are named in the `SELECT` statement. As `STRAIGHT_JOIN` disables semi-join
    transformations, it may prevent the use of indexes.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`EXPLAIN`语句的输出，可以确定在表中添加索引的位置，以便语句执行更快。还可以确定优化器是否按优化顺序连接表。使用`SELECT STRAIGHT_JOIN`开始语句，而不仅仅是`SELECT`，以向优化器提供使用与`SELECT`语句中命名表的顺序相对应的连接顺序的提示。由于`STRAIGHT_JOIN`禁用半连接转换，它可能会阻止索引的使用。
- en: The optimizer trace is another tool to find the information on the query execution.
    It is possible that the optimizer trace may provide information differing from
    that of `EXPLAIN`. The format and content of the optimizer trace are subject to
    variation, based on the versions.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 优化器跟踪是另一个工具，用于查找有关查询执行的信息。优化器跟踪可能提供与`EXPLAIN`不同的信息。优化器跟踪的格式和内容会根据版本而有所不同。
- en: 'The following table shows the output format of the `EXPLAIN` statement:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了`EXPLAIN`语句的输出格式：
- en: '| **Column** | **JSON Name** | **Details** |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| **列** | **JSON名称** | **细节** |'
- en: '| `id` | `select_id` | The `SELECT` identifier |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| `id` | `select_id` | `SELECT`标识符 |'
- en: '| `select_type` | `None` | The `SELECT` type |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| `select_type` | `None` | `SELECT`类型 |'
- en: '| `table` | `table_name` | The table for the output row |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| `table` | `table_name` | 输出行的表 |'
- en: '| `partitions` | `partitions` | The matching partitions |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `partitions` | `partitions` | 匹配的分区 |'
- en: '| `type` | `access_type` | The join type |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| `type` | `access_type` | 连接类型 |'
- en: '| `possible_keys` | `possible_keys` | The possible indexes to choose |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `possible_keys` | `possible_keys` | 可能选择的索引 |'
- en: '| `key` | `key` | The index actually chosen |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `key` | `key` | 实际选择的索引 |'
- en: '| `key_len` | `key_length` | The length of the chosen key |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `key_len` | `key_length` | 所选键的长度 |'
- en: '| `ref` | `ref` | The columns compared to the index |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `ref` | `ref` | 与索引进行比较的列 |'
- en: '| `rows` | `rows` | Estimate of rows to be examined |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `rows` | `rows` | 预计要检查的行数 |'
- en: '| `filtered` | `filtered` | Percentage of rows filtered by table condition
    |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `filtered` | `filtered` | 表条件过滤的行的百分比 |'
- en: '| `Extra` | `None` | Additional Information |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `Extra` | `None` | 附加信息 |'
- en: Reference: [https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-output-column-table](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-output-column-table)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 参考：[https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-output-column-table](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-output-column-table)
- en: Optimizing tables
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化表
- en: Database tables are the most basic building blocks for any database. In this
    section of the chapter, we will focus on optimizing tables. The section provides
    detailed guidelines for improving performance through table optimization techniques.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库表是任何数据库的最基本构建块。在本章节的这一部分，我们将专注于优化表。本节提供了通过表优化技术来改善性能的详细指南。
- en: Optimization for InnoDB tables
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InnoDB表的优化
- en: The `InnoDB` storage engine is preferred in production environments in situations
    where reliability and concurrency are important. It is the default storage engine
    for MySQL tables. This section focuses on optimizing database operations for `InnoDB`
    tables.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，`InnoDB`存储引擎是首选，特别是在可靠性和并发性很重要的情况下。它是MySQL表的默认存储引擎。本节重点介绍了优化`InnoDB`表的数据库操作。
- en: 'The following are the guidelines to optimize `InnoDB` tables:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是优化`InnoDB`表的指南：
- en: Use of the `OPTIMIZE TABLE` statement should be considered to reorganize the
    table and compact the wasted space once the data reaches a stable size or the
    table has increased by tens of megabytes. It requires less disk I/O to perform
    full table scans for reorganized tables.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应考虑使用`OPTIMIZE TABLE`语句来重新组织表并压缩浪费空间，一旦数据达到稳定大小或表增加了数十兆字节。对于重新组织的表来说，执行完整的表扫描需要更少的磁盘I/O。
- en: The `OPTIMIZE TABLE` statement copies the data in the table and rebuilds the
    indexes. It is beneficial because of improved packing of the data within indexes,
    and fragmentation reduction within the table spaces on the disk. The benefits
    may vary, depending on the data in each table. It may be noticeable that the gains
    are significant in some cases, and not for others. The gains may also decrease
    over time until the next table optimization is done. The operation can be slow
    if the table is large or the indexes being rebuilt do not fit in the buffer pool.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPTIMIZE TABLE`语句会复制表中的数据并重建索引。这是有益的，因为它可以改善索引内数据的打包，并减少磁盘上表空间的碎片。收益可能会有所不同，取决于每个表中的数据。在某些情况下，收益可能是显著的，而在其他情况下则不是。收益也可能随着时间的推移而减少，直到进行下一次表优化。如果表很大或正在重建的索引不适合缓冲池，操作可能会很慢。'
- en: A long primary key in a `InnoDB` table wastes a lot of disk space. It should
    be avoided.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`InnoDB`表中，长主键会浪费大量磁盘空间，应该避免使用。
- en: In `InnoDB` tables, preference should be given to the `VARCHAR` data type instead
    of the `CHAR` data type to store variable length strings, or for columns which
    are expected to contain `NULL` values. A `CHAR(N)` column always occupies *N*
    characters to store data, even if the value is `NULL`. Smaller tables are more
    suitable to fit in the buffer pool and reduced disk I/O.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`InnoDB`表中，应优先选择`VARCHAR`数据类型，而不是`CHAR`数据类型来存储可变长度字符串，或者用于预期包含`NULL`值的列。`CHAR(N)`列始终占用*N*个字符来存储数据，即使值为`NULL`。较小的表更适合适应缓冲池并减少磁盘I/O。
- en: Consider using a `COMPRESSED` row format for big tables, or tables containing
    lots of repetitive text or numeric data.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑为大表或包含大量重复文本或数字数据的表使用`COMPRESSED`行格式。
- en: Optimization for MyISAM tables
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MyISAM表的优化
- en: For read-only or read-mostly data, or for low concurrency operations, the `MyISAM`
    storage engine fits the best. This is because table locks limit the ability to
    perform simultaneous updates. In this section, the focus will be on optimizing
    queries to be executed on `MyISAM` tables.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 对于只读或读取频率较高的数据，或低并发操作，`MyISAM`存储引擎最适合。这是因为表锁限制了同时进行更新的能力。在本节中，重点将放在优化要在`MyISAM`表上执行的查询上。
- en: 'The following are the guidelines for speeding up queries on `MyISAM` tables:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是加快`MyISAM`表查询的指南：
- en: Avoid executing complex `SELECT` queries on frequently updated `MyISAM` tables.
    It prevents problems with table locking that occur because of contention between
    writers and readers.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在频繁更新的`MyISAM`表上执行复杂的`SELECT`查询。这样可以避免由于写入者和读取者之间的争用而导致的表锁定问题。
- en: The `MyISAM` storage engine supports concurrent inserts. If the table data file
    does not have free blocks in the middle, we can `INSERT` new rows in it at the
    same time that other threads are reading from the table. Consider using the table
    to avoid deleting rows if it is important to be able to do concurrent read-write
    operations. Another option is to execute `OPTIMIZE TABLE` to defragment the table
    after deletion of the rows. This behavior can be controlled or modified by setting
    the `concurrent_insert` system variable.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyISAM`存储引擎支持并发插入。如果表数据文件中间没有空闲块，我们可以在其他线程从表中读取数据的同时向其中`INSERT`新行。如果重要的是能够进行并发读写操作，可以考虑使用该表来避免删除行。另一个选择是在删除行后执行`OPTIMIZE
    TABLE`来对表进行碎片整理。这种行为可以通过设置`concurrent_insert`系统变量来进行控制或修改。'
- en: Avoid all variable-length columns for frequently changing `MyISAM` tables. The
    dynamic row format is used by the table if it includes even a single variable
    length column.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于频繁更改的`MyISAM`表，应避免所有可变长度列。如果表中包含至少一个可变长度列，则使用动态行格式。
- en: The `myisamchk --sort-index --sort-records=1` command can be used to sort an
    index. It also sorts data according to the index. This makes the queries run faster
    if we have unique indexes, based on which we want to read all rows in the order
    according to the index. It takes a long time when we sort a large table this way
    for the first time.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`myisamchk --sort-index --sort-records=1`命令可用于对索引进行排序。它还根据索引对数据进行排序。如果我们有唯一索引，并且希望按照索引的顺序读取所有行，这样可以使查询运行更快。第一次对大表进行这种排序会花费很长时间。'
- en: If we usually retrieve rows in the order of `expression1`, `expression2`, and
    so on, use `ALTER TABLE ... ORDER BY expression1, expression2,..`, and so on.
    This will give higher performance, if this option is used after extensive changes
    to the table.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们通常按照`expression1`，`expression2`等顺序检索行，可以使用`ALTER TABLE ... ORDER BY expression1,
    expression2,..`，这样会提高性能，如果在对表进行大量更改后使用此选项。
- en: Optimization for MEMORY tables
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存表的优化
- en: MySQL `MEMORY` tables should be considered for use only for noncritical data
    that is accessed often and is read-only and rarely updated. The application should
    be benchmarked against equivalent `InnoDB` or `MyISAM` tables under realistic
    workloads to confirm that additional performance is worth the risk of losing data.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL的`MEMORY`表应该只用于经常访问的非关键数据，而且是只读且很少更新的数据。应该对应用程序进行基准测试，以确认额外的性能是否值得冒失去数据的风险。
- en: We should examine the kinds of queries against each table for best performance
    with `MEMORY` tables. We should also specify the type of use for each associated
    index. It can be a B-tree index or a hash index. Use the `USING BTREE` or `USING
    HASH` clause on the `CREATE INDEX` statement.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该检查针对每个表的查询类型，以获得`MEMORY`表的最佳性能。我们还应该指定每个相关索引的使用类型。它可以是B树索引或哈希索引。在`CREATE
    INDEX`语句上使用`USING BTREE`或`USING HASH`子句。
- en: Leveraging buffering and caching
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用缓冲和缓存
- en: This section focuses on using buffering and caching techniques to increase the
    performance.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分关注使用缓冲和缓存技术来提高性能。
- en: InnoDB buffer pool optimization
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InnoDB缓冲池优化
- en: The `InnoDB` storage engine maintains a storage area known as the buffer pool.
    It is used for caching data and indexes in the memory. It is important to know
    how the `InnoDB` buffer pool works, so as to take advantage of it to keep frequently
    accessed data in memory. It is an important aspect of MySQL tuning.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`InnoDB`存储引擎维护一个称为缓冲池的存储区域，用于在内存中缓存数据和索引。了解`InnoDB`缓冲池的工作原理非常重要，以便利用它将经常访问的数据保留在内存中。这是MySQL调优的一个重要方面。'
- en: 'The following are the general guidelines for improving performance with the
    `InnoDB` buffer pool:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是改进`InnoDB`缓冲池性能的一般指导方针：
- en: In an ideal case, the size of the buffer pool should be set large enough, while
    leaving enough memory for other processes on the server to run without excessive
    paging. With larger buffer pools, more `InnoDB` functions, like an in-memory database.
    In this case, it reads data from the disk once, and then accesses the data from
    memory in subsequent reads.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在理想情况下，缓冲池的大小应该足够大，同时留出足够的内存供服务器上的其他进程运行，而不会过度分页。有了更大的缓冲池，`InnoDB`的功能也更多，比如内存数据库。在这种情况下，它只需从磁盘读取数据一次，然后在后续读取中从内存中访问数据。
- en: We can consider splitting the buffer pool into many parts for 64-bit systems
    with large memory sizes. This minimizes contention for memory during concurrent
    operations.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以考虑将缓冲池分成多个部分，用于具有大内存的64位系统。这样可以在并发操作期间最大程度地减少内存争用。
- en: The frequently accessed data should be kept in memory.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经常访问的数据应该保留在内存中。
- en: It is possible to control when and how `InnoDB` performs read-ahead requests
    to prefetch pages into the buffer pool asynchronously. `InnoDB` uses two read-ahead
    algorithms to improve I/O performance. Linear read ahead predicts what pages might
    be needed soon, based on the pages being accessed in the buffer pool sequentially.
    Random read ahead predicts when pages might be needed based on the pages in the
    buffer pool, regardless of the order in which pages are read. The `innodb_read_ahead_threshold`
    configuration parameter controls the sensitivity of linear read ahead. We can
    enable random read a heads by setting `innodb_random_read_ahead` to `ON`.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以控制`InnoDB`何时以及如何执行预读请求，以异步方式将页面预取到缓冲池中。`InnoDB`使用两种预读算法来提高I/O性能。线性预读可以根据顺序访问缓冲池中的页面来预测可能很快需要的页面。随机预读可以根据缓冲池中的页面来预测可能需要的页面，而不考虑页面读取的顺序。`innodb_read_ahead_threshold`配置参数控制线性预读的灵敏度。我们可以通过将`innodb_random_read_ahead`设置为`ON`来启用随机预读。
- en: '`innodb_buffer_pool_read_ahead` determines the number of pages read into the
    `InnoDB` buffer pool. `innodb_buffer_pool_read_ahead_evicted` determines the number
    of pages read into the buffer pool by the read-ahead background thread that was
    subsequently evicted without having been accessed by queries. The `innodb_buffer_pool_read_ahead_rnd`
    determines the number of random read aheads initiated by `InnoDB`.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innodb_buffer_pool_read_ahead`确定读入`InnoDB`缓冲池的页面数。`innodb_buffer_pool_read_ahead_evicted`确定后台预读线程读入缓冲池的页面数，随后被查询访问。`innodb_buffer_pool_read_ahead_rnd`确定`InnoDB`发起的随机预读次数。'
- en: MyISAM key cache
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MyISAM键缓存
- en: 'The `MyISAM` storage engine incorporates a strategy that is supported by many
    database management systems to minimize the disk I/O. The cache mechanism is employed
    by `MyISAM` to keep the most frequently accessed table blocks in memory as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyISAM`存储引擎采用了一种被许多数据库管理系统支持的策略，以最小化磁盘I/O。`MyISAM`使用缓存机制将最常访问的表块保留在内存中。'
- en: A special structure known as a key cache is maintained for index blocks. The
    most used index blocks are placed in the structure containing a number of block
    buffers.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为索引块维护了一个称为键缓存的特殊结构。最常用的索引块被放置在包含多个块缓冲区的结构中。
- en: MySQL relies on the native operating system filesystem cache for data blocks.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL依赖于本机操作系统文件系统缓存来存储数据块。
- en: The `key_buffer_size` system variable determines the size of the key cache.
    If it is set to zero, no key cache is used. The key cache is also not used if
    the `key_buffer_size` value is too small to allocate the minimum order of block
    buffers. All the block buffers in the key cache structure are of the same size.
    This size can be equal to, greater than, or less than the size of the table index
    block. In usual cases, one of these two values is a multiple of the other.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`key_buffer_size`系统变量确定关键缓存的大小。如果设置为零，则不使用关键缓存。如果`key_buffer_size`值太小而无法分配最小顺序的块缓冲区，则也不使用关键缓存。关键缓存结构中的所有块缓冲区大小相同。这个大小可以等于、大于或小于表索引块的大小。通常情况下，这两个值中的一个是另一个的倍数。'
- en: When it is required to access data from any table index block, the server first
    checks if it is available in some block buffer of the key cache. If the data is
    available, the server accesses data from the key cache rather than on the disk.
    If the data is not available, the server selects a cache block buffer that contains
    a different table index block and replaces the data in it by copying the required
    table index block. The index data can be accessed as soon as the new index block
    is available in the cache.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要从任何表索引块访问数据时，服务器首先检查它是否在关键缓存的某个块缓冲区中可用。如果数据可用，服务器将从关键缓存中访问数据，而不是从磁盘上访问。如果数据不可用，服务器选择包含不同表索引块的缓存块缓冲区，并通过复制所需的表索引块来替换其中的数据。一旦新的索引块在缓存中可用，就可以访问索引数据。
- en: The MySQL server follows the **Least Recently Used** (**LRU**) strategy. According
    to it, it selects the least recently used index block while choosing a block for
    replacement. The key cache module contains all used blocks in the LRU chain (a
    special list). The list is ordered by the time of use. It is the most recently
    used when the block is accessed. The block is placed at the end of the list. Blocks
    at the beginning of the list are the least recently used when the blocks need
    to be replaced. So, the block at the top becomes the first candidate for eviction.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL服务器遵循**最近最少使用**（LRU）策略。根据这个策略，在选择要替换的块时，它选择最近最少使用的索引块。关键缓存模块包含LRU链中的所有使用的块（一个特殊列表）。列表按使用时间排序。当访问块时，它是最近使用的。块被放置在列表的末尾。当需要替换块时，列表开头的块是最近最少使用的。因此，顶部的块成为首选的驱逐候选。
- en: The block is considered dirty if the block selected for replacement has been
    modified. The block contents are flushed to the table index from which they came
    prior to replacement.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择用于替换的块已被修改，则该块被视为脏块。在替换之前，块内容被刷新到它们来自的表索引中。
- en: 'Based on the following conditions, the threads can access key cache buffers
    simultaneously:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下条件，线程可以同时访问关键缓存缓冲区：
- en: The buffer which is not being updated can be accessed by multiple sessions
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未被更新的缓冲区可以被多个会话访问。
- en: The buffer which is being updated causes sessions that require waiting until
    the update is complete to use it
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在更新的缓冲区会导致需要等待更新完成的会话使用它
- en: As long as the sessions are independent and do not interfere with each other,
    multiple sessions can initiate requests resulting in cache block replacements
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要会话是独立的并且不相互干扰，多个会话可以发起请求，导致缓存块替换。
- en: In this way, shared access to the key cache improves performance significantly.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，对关键缓存的共享访问显著提高了性能。
- en: Summary
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned, in detail, the techniques to optimize MySQL 8 components.
    The chapter started with the basics of optimization, including hardware and software
    optimization guidelines. We also discussed optimization guidelines for the MySQL
    8 server and client, database structure, queries, and tables. We also covered
    optimization for tables belonging to different storage engines, such as `MyISAM`, `InnoDB`,
    and `MEMORY`. We learned the tools, such as `EXPLAIN` and `EXPLAIN ANALYZE`, needed
    to understand the query execution plan. In the later part of the chapter, we learned
    buffering and caching techniques to improve performance.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细学习了优化MySQL 8组件的技术。该章节从优化的基础知识开始，包括硬件和软件优化指南。我们还讨论了MySQL 8服务器和客户端、数据库结构、查询和表的优化指南。我们还涵盖了属于不同存储引擎的表的优化，如`MyISAM`、`InnoDB`和`MEMORY`。我们学习了工具，如`EXPLAIN`和`EXPLAIN
    ANALYZE`，以了解查询执行计划。在本章的后部分，我们学习了缓冲和缓存技术以提高性能。
- en: It's time to move on to the next chapter now. The next chapter focuses on techniques
    to extend MySQL 8\. The chapter will cover in-depth details of MySQL 8 plugins,
    which help to extend the default MySQL 8 features. It will also explain the services
    to call these plugins. The chapter will discuss adding new functions, debugging,
    and porting methods. It is going to be an important chapter for database administrators.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候转到下一章了。下一章将重点介绍扩展MySQL 8的技术。该章节将详细介绍MySQL 8插件，这些插件有助于扩展默认的MySQL 8功能。它还将解释调用这些插件的服务。该章节将讨论添加新功能、调试和移植方法。这对数据库管理员来说将是一个重要的章节。
