# 第十三章：扩展 MySQL 8

在上一章中，我们学习了如何优化 MySQL 8。我们还了解了需要进行哪些配置才能实现优化，以及如何利用缓存和缓冲进行优化。我们逐步进行了用例研究，以实现以下组件的优化：

+   优化 MySQL 8 服务器和客户端

+   优化数据结构

+   优化查询

+   优化表

在本章中，我们将学习如何扩展 MySQL 8。我们将检查允许扩展的 MySQL 8 组件，并了解如何根据特定业务需求自定义 MySQL 8。在扩展 MySQL 8 之前，您将了解基本组件以及用于扩展 MySQL 8 的 MySQL 插件 API 的功能。以下是本章涵盖的主题列表：

+   扩展 MySQL 8 的概述

+   扩展插件并使用服务来调用它们

+   添加新功能

+   调试和移植

# 扩展 MySQL 8 的概述

在这一部分，您将学习如何根据自己的需求扩展 MySQL 8 中最令人兴奋的主题之一。在尝试扩展 MySQL 8 之前，您应该充分了解 MySQL 8 的几个组件。以下是扩展 MySQL 8 重要的组件列表：

+   MySQL 8 内部

+   MySQL 8 插件 API

+   MySQL 8 组件和插件的服务

+   向 MySQL 8 添加新功能

+   调试和移植 MySQL 8

# MySQL 8 内部

在开始处理 MySQL 代码之前，您应该了解一些事项。要贡献或跟踪 MySQL 开发，您应该按照系统或操作系统平台的源代码分发安装说明。源代码包括内部文档，这对于从开发人员的角度了解 MySQL 的内部工作非常重要。您还可以订阅 internals 邮件列表，网址为[`lists.mysql.com/internals`](https://lists.mysql.com/internals)，其中包括从事 MySQL 代码工作的人员，您还可以讨论与 MySQL 开发相关的主题或发布补丁：

+   **MySQL 8 线程**：MySQL 服务器创建线程，例如连接管理器线程、信号线程、读写线程（如果使用 InnoDB 存储引擎）、调度器线程来处理连接以及复制和事件处理。

+   **MySQL 8 测试套件**：MySQL 8 提供了包含在 Unix 源代码分发中的测试系统，以帮助用户和开发人员对 MySQL 代码进行回归测试。您还可以使用测试框架编写自己的测试用例。

# MySQL 8 插件 API

MySQL 8 通过插件 API 提供对服务器组件本身的支持。插件可以在服务器启动期间加载，也可以在运行时加载和卸载；无需重新启动服务器。该 API 非常通用，不限制插件在限制方面可以做什么，而是允许它们做的比内置组件更多。该 API 支持用于组件的接口，例如存储引擎插件、全文解析器插件、服务器扩展等。

插件接口利用 MySQL 8 数据库中的`plugin`表来存储有关已安装插件的信息，通过使用`INSTALL PLUGIN`语句来永久安装插件。在 MySQL 8 安装过程中，将创建`plugin`表。对于单个服务器调用，也可以使用`--plugin--load`选项安装插件，但使用此选项不会将已安装的插件记录到`plugin`表中。

MySQL 8 还为客户端插件提供支持 API，用于特定目的，例如通过不同的身份验证方法启用客户端的服务器连接。

# MySQL 8 组件和插件的服务

MySQL 8 服务器插件可以访问和启动服务器插件服务；同样，服务器组件也可以访问和请求组件服务。MySQL 8 插件服务接口通过公开服务器功能来补充 API 插件，插件可以调用这些功能。以下是插件服务的特点：

+   这些服务使插件能够使用普通函数调用访问服务器代码，并且还可以调用用户定义的函数。

+   这些服务是可移植的，可以在多个平台上运行

+   服务提供版本支持，防止插件和服务之间的不兼容性

+   这些服务还支持测试插件服务

MySQL 提供了两种插件和组件的服务类型，如下所示：

1.  **锁定服务**：提供两个级别的锁定服务接口，即 C 级别和 SQL 级别。接口在锁定命名空间、锁定名称和锁定模式属性上工作。

1.  **密钥环服务**：密钥环服务提供了一个接口，用于安全存储内部服务器组件和插件以便以后检索的敏感信息。

# 向 MySQL 8 添加新函数

您可以向 MySQL 8 添加自己的函数，可以使用三种支持的函数类型之一来完成。新函数可以像调用内置函数`ABS()`一样调用，而不管您新增了哪种函数类型都是如此。以下是 MySQL 8 中支持的三种新函数类型的列表：

1.  通过**用户定义函数**（**UDF**）接口添加函数。

1.  将函数添加为本机（内置）MySQL 函数。

1.  通过创建存储函数添加函数。

# 调试和移植 MySQL 8

将 MySQL 8 移植到其他操作系统目前受到许多操作系统的支持；支持的操作系统列表提供在[`www.mysql.com/support/supportedplatforms/database.html`](http://www.mysql.com/support/supportedplatforms/database.html)。如果您添加了新的端口并且在新的端口上遇到问题，您可以使用 MySQL 8 的调试。

根据您遇到问题的位置，可以以不同的方式开始调试——可能是在 MySQL 服务器中或在 MySQL 客户端中。根据问题的位置，您可以分别在 MySQL 服务器或客户端开始调试，并从`DBUG`包中获取帮助来跟踪程序的活动。

# 扩展插件并使用服务调用它们

在本节中，您将了解插件 API、其接口和 MySQL 服务如何相互交互，并在 MySQL 8 中提供扩展。插件在 MySQL 8 架构中也被视为组件，因此您可以使用它们提供可插拔的功能。插件 API 和插件服务接口有以下区别：

+   插件 API 使服务器能够使用插件。服务器启动和调用插件，因此插件可以扩展服务器的功能或注册自己以接收服务器处理通知。

+   插件服务接口允许插件调用服务器代码。插件启动和调用服务函数，以便许多插件可以利用相同的服务器功能，而无需为功能单独实现。

# 编写插件

要创建一个插件库，必须提供所需的描述符信息，因为它指定了库文件包含哪些插件。还必须为指定的每个插件编写接口函数。

每个服务器插件必须具有通用描述符，提供信息给插件 API，并具有特定类型的描述符，提供指定插件类型的接口信息。用于指定通用描述符的结构对所有插件类型都是相同的，而特定类型的描述符可以根据插件行为或功能的要求而变化。服务器插件接口允许插件公开系统变量和状态。

客户端插件的架构与服务器端插件略有不同。例如，每个插件必须具有描述符信息，但通用和特定类型的描述符之间没有单独的区分。

插件可以用 C 或 C++或任何其他可以使用 C 调用约定的语言编写。插件是动态加载和卸载的，因此操作系统必须动态支持您动态编译调用应用程序的地方。特别是对于服务器插件，这意味着`mysqld`必须动态链接。

由于我们无法确定哪个应用程序将使用插件，因此客户端插件编写者应避免对调用应用程序的符号的依赖。

以下是支持的插件创建类型，可以实现多种功能：

+   身份验证

+   密码验证和强度检查

+   协议跟踪

+   查询重写

+   安全钥匙存储和检索

+   存储引擎

+   全文解析器

+   守护进程

+   `INFORMATION_SCHEMA`表

+   半同步复制

+   审计

# 组件和插件服务

您可以通过查看 MySQL 8 源代码分发的`include/mysql/components`和相应的`services`目录来识别 MySQL 提供的组件服务和函数。

同样，您可以通过查看 MySQL 8 源代码分发的`include/mysql`目录和相关文件来识别 MySQL 提供的插件服务和函数，如下所示：

+   `plugin.h`文件包括`services.h`文件，`services.h`文件包含其中所有可用的特定服务头文件

+   特定服务头文件的名称将以`service_xxx.h`的形式命名

以下是 MySQL 8 中可用的组件服务列表：

+   `component_sys_variable_register`，`component_sys_variable_unregister`：用于注册和注销系统变量

+   `log_builtins`，`log_builtins_string`：用于日志组件服务

+   `mysql_service_udf_registration`，`mysql_service_udf_registration_aggregate`：用于在组件和插件中启用标量和聚合用户定义函数的注册和注销

+   `mysql_string`：用于字符串服务 API

+   `pfs_plugin_table`：用于动态性能模式表操作

以下是 MySQL 8 中可用的插件服务列表：

+   `get_sysvar_source`：用于检索系统变量设置

+   `locking_service`：用于使用 C 语言和 SQL 级接口实现锁定，具有命名空间、名称和模式属性

+   `my_plugin_log_service`：用于将错误消息写入日志

+   `my_snprintf`：用于字符串格式化，以保持输出在各个平台上的一致性

+   `status_variable_registration`：用于注册状态变量

+   `my_thd_scheduler`：用于线程调度器选择

+   `mysql_keyring`：用于钥匙存储服务

+   `mysql_password_policy`：用于密码强度和验证检查

+   `plugin_registry_service`：用于访问组件注册表和相关服务

+   `security_context`：用于管理线程安全上下文

+   `thd_alloc`：用于内存分配

+   `thd_wait`：用于报告休眠或停滞

现在，您对插件服务和组件服务有了清楚的了解。MySQL 8 提供以下类型的服务来支持插件和组件服务：

1.  锁定服务

1.  钥匙存储服务

以下部分详细介绍了两种类型的服务。

# 锁定服务

锁定服务接口提供两个级别：C 级别和 SQL 级别。该接口在锁命名空间、锁名称和锁模式属性上工作。C 语言接口可作为插件服务从用户定义的函数或服务器插件调用，SQL 级别接口用作一组用户定义的函数，映射到调用服务例程。

以下是锁定接口的特征：

+   锁命名空间、锁名称和锁模式是锁的三个属性。

+   通过形成锁命名空间和锁名称的组合来识别锁。 

+   锁模式可以是读或写。读锁是共享的，而写锁是排他的。

+   锁名称和命名空间最多可以有 64 个字符，并且必须是非 NULL 和非空字符串。

+   锁名称和命名空间被视为二进制字符串，因此比较将区分大小写。

+   提供了获取和释放锁的函数，不需要特殊权限来调用这些函数。

+   在不同会话中的锁获取调用期间检测死锁；选择一个调用者并终止其锁获取请求，优先选择持有读锁的调用者会话，而不是持有写锁的会话。

+   典型的会话可以通过单个锁获取调用请求多个锁获取。它为请求提供原子行为，并且如果所有锁都被获取则成功，如果任何锁获取失败则失败。

+   同一锁标识符的多个锁可以由会话获取，其中锁实例可以是写锁、读锁或读写锁的混合。

+   通过显式调用释放锁函数或者如果会话终止则隐式释放会话中获取的锁。

+   在给定命名空间中释放的所有锁都在会话内一起释放。

# 密钥环服务

密钥环服务提供了一个接口，用于安全地存储内部服务器组件和插件以便以后检索的敏感信息。在密钥环服务中，来自密钥库本身的记录由数据组成——密钥和可以访问密钥的唯一标识符。标识符由以下两部分组成：

1.  `key_id`：名称。以`mysql_`开头的`key_id`或密钥 ID 值由 MySQL 服务器保留。

1.  `user_id`：`user_id`代表每个会话的有效`user_id`。如果没有用户上下文，则可以为`NULL`，并且该值不一定需要是实际的`user`，而是取决于应用程序。

以下是密钥环服务函数的常见特征：

+   每个函数返回 1 表示失败，返回 0 表示成功

+   `user_id`和`key_id`参数的唯一组合指示在密钥环中使用哪个密钥

+   通过`key_type`参数值提供有关密钥的附加信息，例如其预期用途、加密方法或其他信息

+   在密钥环服务函数中，用户名称、密钥 ID、类型和值被视为二进制字符串，因此比较是区分大小写的

以下是可用的密钥环服务函数列表：

+   `my_key_generate()`: 正如其名称所示，它生成给定类型和长度的新随机密钥，并存储在密钥环中。该函数由参数`key_id`、`user_id`、`key_type`和`key_len`组成，以及以下函数语法：

```go
 bool my_key_generate(const char *key_id, const char*key_type, 
          const char *user_id, size_t key_len)
```

+   `my_key_fetch()`: 对参数值进行解密并从密钥环中检索密钥及其类型。该函数由参数`key_id`、`user_id`、`key_type`、`key`和`key_len`组成，以及以下函数语法：

```go
 bool my_key_fetch(const char *key_id, const char **key_type, 
          const char* user_id, void **key, size_t *key_len)
```

+   `my_key_remove()`: 从密钥环中删除关联的密钥。该函数由参数`key_id`和`user_id`组成，以及以下函数语法：

```go
 bool my_key_remove(const char *key_id, const char* user_id)
```

+   `my_key_store()`: 对参数值进行混淆并将密钥存储在密钥环中。该函数包括参数`key_id`、`user_id`、`key_type`、`key`和`key_len`，以及以下函数语法：

```go
 bool my_key_store(const char *key_id, const char *key_type, 
          const char* user_id, void *key, size_t key_len)
```

# 添加新函数

可以在 MySQL 8 中添加任何三种支持的类型的新函数。每种类型都有其自己的优点和缺点。应该根据函数的要求决定在何处以及应该添加或实现哪种类型的函数。

以下是 MySQL 8 中支持的三种新函数类型的列表，我们将在下一节中进行讨论：

1.  通过用户定义函数接口添加函数。

1.  将函数添加为本机（内置）MySQL 函数。

1.  通过创建存储函数添加函数。

# 用户定义函数接口的特点

用户定义的函数接口为用户目的函数提供独立的功能。

MySQL 用户定义函数接口提供以下功能和能力：

+   函数可以接受整数、字符串或实数值的参数，并且可以返回相同类型的值

+   可以定义简单函数以一次操作一行，也可以是聚合函数以操作行组

+   函数被提供信息以使它们能够检查传递的参数的类型、名称和数量

+   在将参数传递给给定函数之前，还可以要求 MySQL 强制参数

+   如果函数导致任何错误或返回`NULL`，可以进行指示

# 添加新的用户定义函数

UDF 函数必须用 C 或 C++编写，并且底层操作系统必须支持动态加载行为。有一个文件`sql/udf_example.cc`，定义了五个 UDF 函数，并包含在 MySQL 源分发中。分析该文件将让您了解 UDF 的调用约定如何工作。用户定义的函数相关符号和数据结构在`include/mysql_com.h`文件中定义，并且该文件包含在`mysql.h`头文件中。

UDF 中包含的典型代码在运行服务器中执行，因此在编写 UDF 代码时适用所有约束-服务器代码。当前适用的约束可能在服务器升级时得到修订，并且这可能导致需要重写 UDF 代码，因此在编写 UDF 代码时要小心。

为了使用 UDF，必须动态链接`mysqld`。对于在 SQL 语句中使用的任何函数，必须有底层的 C 或 C++函数。遵循将 SQL 和 C/C++代码分开的约定，其中大写的`xxx()`表示 SQL 函数调用，而小写的`xxx()`表示 C/C++函数调用。

当您使用 C++时，将您的 C 函数封装如下所示：`extern "C"` `{ ... }`，以确保您的 C++函数名称在完成的用户定义函数中可读。

要编写和实现接口函数名`XXX()`，必须有主函数`xxx()`，并且还需要从以下功能中实现一个或多个功能：

+   `xxx()`: 生成函数结果的主函数

+   `xxx_init()`: 主函数`xxx()`的初始化函数，可用于以下任何目的：

+   检查要传递给`XXX()`的参数数量

+   在调用主函数时，使用声明验证参数类型

+   在需要时为主函数分配内存

+   结果的最大长度验证

+   为结果设置最大的十进制数限制

+   指定结果是否可以为`NULL`

+   `xxx_deinit()`: 代表主函数的去初始化，并在需要时释放主函数的初始化函数分配的内存

在 MySQL 8 中，聚合 UDF 按以下顺序处理：

1.  调用`xxx_init()`以便它分配所需的内存来存储结果信息。

1.  按照`GROUP BY`函数指定的表/结果进行排序。

1.  调用`xxx_clear()`来重置每个新组中第一行的当前聚合值。

1.  调用`xxx_add()`来将参数添加到当前的聚合值。

1.  调用`xxx()`来获取按组更改或在处理最后一行后的聚合数据结果。

1.  重复步骤 3-5，直到处理完所有指定/结果行。

1.  调用`xxx_deinit()`来释放为 UDF 分配的任何内存。

所有函数必须是线程安全的，包括主要函数以及其他所需的附加函数，以及初始化和去初始化函数。

与上述顺序类似，以下是在添加新的用户定义函数时需要注意的重要方面：

+   UDF 参数处理

+   UDF 返回值和错误处理

+   UDF 编译和安装

+   UDF 安全预防措施

# 添加新的本机函数

为了使用包含新本机函数的修改源代码进行编译，需要源分发文件。当迁移到另一个 MySQL 版本时，也需要重复这一过程。

如果在语句中引用新的本机函数，并且还要在从服务器上复制，确保每个从服务器都有新的本机函数可用，否则当尝试调用新的本机函数时，从服务器上的复制将失败。

以下是在`sql`目录的源分发文件中添加新本机函数的步骤：

1.  函数的子类需要在`item_create.cc`中添加：

+   在参数数量固定的情况下，子类应该从`Create_func_arg0`、`Create_func_arg1`、`Create_func_arg2`或`Create_func_arg3`中创建，具体取决于您的本机函数需要的参数数量。您可以参考`Create_func_abs`、`Create_func_uuid`和`Create_func_pow`类。

+   在参数数量可变的情况下，子类应该从`Create_native_func`中创建。您可以参考`Creat_func_concat`类。

1.  在 SQL 语句中引用的函数名称需要在`item_create.cc`中注册，通过向数组添加以下行：`static Native_func_registry func_array[]`：

+   如果需要，可以为同一个函数注册多个名称。您可以参考`LOWER`和`LCASE`的行，它们是`Create_func_lcase`的别名。

1.  根据您的函数返回类型是字符串还是数字，在`item_func.h`文件中，需要声明从`Item_str_func`或`Item_num_func`继承的类。

1.  根据您的函数在`item_func.cc`文件中定义为字符串还是数字函数，需要添加以下声明之一：

```go
 double Item_func_newname::val()
 longlong Item_func_newname::val_int() 
        String *Item_func_newname::Str(String *str)
```

+   +   如果您的对象是从任何标准项继承的，那么您可能只需要定义前面的函数之一，因为父对象将处理其他函数。您可以参考定义了`val()`函数的`Item_str_func`类，该函数在`::str()`函数的返回值上执行`atof()`函数。

1.  如果函数是非确定性的 - 也就是说，如果对于固定给定的参数，返回的结果在不同的调用中会有所不同 - 那么需要在项目构造函数中包含以下语句，表示函数结果不应被缓存：`current_thd->lex->safe_to_cache_query=0;`。

1.  您可能还需要为您的本机函数定义以下对象函数：

+   `void Item_func_newname::fix_length_and_dec()`

+   函数至少应包括对给定参数的`max_length`计算。

+   如果您的主要函数不能返回任何`NULL`值，还应该设置`maybenull = 0`。

+   您可以参考`Item_func_mod::fix_length_and_dec`。

所有函数都必须具有线程安全性。在没有受到互斥保护的情况下，您不应该在函数中使用任何静态或全局变量。

# 调试和移植

将 MySQL 8 移植到其他操作系统目前受到许多操作系统的支持。最新支持的操作系统列表提供在[`www.mysql.com/support/supportedplatforms/database.html`](http://www.mysql.com/support/supportedplatforms/database.html)。如果您已添加或尝试添加新的端口（受支持的平台）并遇到问题，您可以使用 MySQL 8 的调试来查找并解决问题。

首先，在调试`mysqld`之前，您应该让测试程序`mysys/thr_lock`工作。这可以确保您的线程安装有远程工作的可能性！

根据您遇到问题的位置，可以在 MySQL 服务器或 MySQL 客户端中开始调试。根据问题的位置，您可以分别在 MySQL 服务器或 MySQL 客户端中开始调试，并且可以从`DEBUG`包中获得程序活动的跟踪帮助。

MySQL 源代码包括使用`Doxygen`编写的内部文档，这对于理解 MySQL 的开发者视角非常有帮助。

在本节中，您将看到以下主题的详细信息：

+   调试 MySQL 服务器

+   调试 MySQL 客户端

+   `DBUG`包

# 调试 MySQL 服务器

如果您在 MySQL 中使用了一些非常新的功能并遇到了一些问题——比如服务器崩溃——您可以尝试使用`--skip-new`选项运行`mysqld`。此选项告诉 MySQL 服务器禁用所有新的可能不安全的功能。

在`mysqld`无法启动的情况下，请验证`my.cnf`文件，因为它们可能会干扰设置！您可以使用`mysqld --print-defaults`选项检查`my.cnf`中的参数，然后使用`--no-defaults`选项启动`mysqld`以避免使用它们。

如果`mysqld`开始占用内存或 CPU 或挂起，您可以检查`mysqladmin processlist status`，并查找是否有某个查询执行时间过长。如果您遇到性能问题或问题，并且新客户端无法连接，您可以使用`mysqladmin -i10` process list status。

您还可以使用调试命令`mysqladmin`，它会将有关查询使用、内存使用和正在使用的锁的信息转储到 MySQL 日志文件中，并且可以为您解决一些问题。如果您没有为调试编译 MySQL，此命令也可以提供一些有用的信息。

如果您遇到表变慢的问题，您应该尝试使用`myisamchk`或`OPTIMIZE_TABLE`来优化表。如果有任何慢查询，您应该使用`EXPLAIN`来查找并修复查询中的问题。

在调试 MySQL 8 时，以下是需要考虑的重要领域：

+   **为调试编译 MySQL**：在出现非常特定的问题时，您可以尝试调试 MySQL。为此，您必须使用`-DWITH_DEBUG=1`选项配置 MySQL。调试配置会自动启用大量额外的安全检查功能，以监视`mysqld`的健康状况。

+   **创建跟踪文件**：您可以尝试通过创建跟踪文件来找到问题。为此，您必须使用带有调试支持的`mysqld`编译。然后，您可以使用`--debug`选项，在 Unix 上将在`/tmp/mysqld.trace`中添加跟踪日志，在 Windows 上将在`\mysqld.trace`中添加跟踪日志。

+   **使用 PDB 和 WER 创建 Windows 崩溃转储**：程序数据库文件包含在 ZIP 存档调试二进制文件和测试套件中，作为 MySQL 的单独分发。这些文件提供了有关 MySQL 安装问题的调试信息。它们可以与 WinDbg 或 Visual Studio 一起使用来调试`mysqld`。

+   **在 gdb 下调试 mysqld**：当您遇到线程问题或`mysqld`服务器在`ready for connections`之前挂起时，可以使用此选项。

+   **使用堆栈跟踪**：当`mysqld`意外死机时，您也可以使用此选项找出问题。

+   **使用服务器日志查找`mysqld`错误原因**：您可以通过启用常规查询日志来使用此选项 - 在此之前，您应该使用`myisamchk`实用程序检查所有表，并从日志中验证是否存在任何问题。

+   **创建一个测试用例，如果您遇到表损坏**：当您遇到表损坏问题时使用此选项，仅适用于`MyISAM`表。

# 调试 MySQL 客户端

在您在 MySQL 客户端遇到问题的情况下，您也可以在 MySQL 客户端内部进行调试，但是为了这样做，您必须具有集成的调试包。您需要配置 MySQL 以启用 MySQL 客户端中的调试，使用`-DWITH_DEBUG=1`。

在运行 MySQL 客户端之前，您应该设置环境变量`MYSQL_DEBUG`如下：

```go
shell> MYSQL_DEBUG=d:t:O,/tmp/client.trace 
shell> export MYSQL_DEBUG

```

这将使 MySQL 客户端在 Unix 的`/tmp/client.trace`或 Windows 的`\client.trace`中生成一个跟踪文件。

在您自己的客户端代码出现问题的情况下，您可以尝试使用已知可用的客户端运行您的查询来连接服务器。为此，您应该以调试模式运行`mysqld`：

```go
shell> mysql --debug=d:t:O,/tmp/client.trace
```

如果您想要为问题发送错误报告，此跟踪将提供有用的信息。

在某些情况下，如果您的客户端在一些`合法`的代码处崩溃，您可以检查您的`mysql.h`头文件是否与您的 MySQL 库文件匹配。这是一个非常常见的错误，使用旧的`mysql.h`文件从旧的 MySQL 安装中与新的 MySQL 库一起，导致此问题。

# DBUG 包

Fred Fish 最初创建了 MySQL 服务器和大多数 MySQL 客户端的`DBUG`包。如果 MySQL 配置为调试模式，此包使得生成有关程序正在执行的信息的跟踪文件成为可能。

有调试选项可供指定，以便使用`DBUG`包将特定信息写入跟踪文件。它可以在程序调用中使用`-#[debug_options]`选项或`--debug[=debug_options]`选项。

大多数 MySQL 程序将使用默认值，如果指定了`--debug`或`-#`选项，而没有指定`debug_options`值。服务器默认值是 Windows 上的`d:t:i:O,\mysqld.trace`和 Unix 上的`d:t:i:o,/tmp/mysqld.trace`。此默认值的效果如下所列：

+   `d`：启用所有调试宏的输出

+   `t`: 跟踪函数调用和退出

+   `i`：在跟踪文件中添加`PID`到输出行

+   `o,/tmp/mysqld.trace`，`O,\mysqld.trace`：在 Unix 和 Windows 中分别设置调试输出文件

在大多数情况下，对于大多数客户端程序，无论平台如何，都应使用默认的`debug_options`值`d:t:o,/tmp/myprogram_name.trace`。对于 Windows，请使用`\myprogram_name.trace`。

以下是一些在 shell 命令行上指定的调试控制字符串的示例：

```go
--debug=d:t 
--debug=d:f,main,subr1:F:L:t,20 
--debug=d,input,output,files:n 
--debug=d:t:i:O,\\mysqld.trace
```

# 摘要

在本章中，您学习了如何通过自定义函数和 API 扩展 MySQL 8。您还了解了编写函数以及插件服务和 API 的相关特性。您现在可以创建自己的函数或插件，满足特定的业务需求，并在函数不符合预期时进行调试和测试。

在下一章中，您将学习 MySQL 8 的最佳实践和基准测试。您将了解基准测试和用于基准测试的工具。您还将学习 MySQL 8 一些非常重要功能的最佳实践，例如 memcached、复制、数据分区和索引。
