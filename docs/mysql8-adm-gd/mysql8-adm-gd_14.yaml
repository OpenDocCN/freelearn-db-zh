- en: MySQL 8 Best Practices and Benchmarking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQL 8最佳实践和基准测试
- en: In the previous chapter, you learned how to extend MySQL 8\. It covered a lot
    of interesting aspects, such as extending plugins and calling them by using services
    in MySQL 8, adding and debugging new functions to MySQL 8, and so on. In this
    chapter, we will go through the best practices of MySQL 8, which is a much-awaited
    version that promises to address many of the shortfalls of the prior versions
    and has exciting new features. MySQL 8 promises not to be just a standalone database,
    but it will also play a significant role in various areas, including big data
    solutions. We will learn how best practices can be implemented for optimal use
    of features in MySQL 8\. Benchmarking will enhance our understanding further.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何扩展MySQL 8。它涵盖了许多有趣的方面，比如扩展插件并通过MySQL 8中的服务调用它们，向MySQL 8添加和调试新功能等等。在本章中，我们将介绍MySQL
    8的最佳实践，这是一个备受期待的版本，承诺解决之前版本的许多不足之处，并具有令人兴奋的新功能。MySQL 8承诺不仅是一个独立的数据库，而且还将在包括大数据解决方案在内的各个领域发挥重要作用。我们将学习如何在MySQL
    8中实施最佳实践以最大程度地利用其功能。基准测试将进一步增进我们的理解。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下主题：
- en: MySQL benchmarking and tools
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL基准测试和工具
- en: Best practices for the memcached
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: memcached的最佳实践
- en: Best practices for replication
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制的最佳实践
- en: Best practices for data partitioning
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据分区的最佳实践
- en: Best practices for queries and indexing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询和索引的最佳实践
- en: Due to prominent optimizations and changes, MySQL 8 advanced its version directly
    from the release of MySQL 5.7\. MySQL 8 will not have the limitation of files,
    which was previously restricting the number of databases that you could have.
    There are many more exciting features, which we have covered in [Chapter 1](c24bf065-eb70-47cb-9482-807a8431c1ba.xhtml),
    *Introduction to MySQL 8*. MySQL 8 can now store millions of tables in a database.
    It will also make modifications to tables swiftly.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由于突出的优化和改变，MySQL 8直接从MySQL 5.7的发布中提升了版本。MySQL 8将不再有文件限制，这之前限制了你可以拥有的数据库数量。还有许多令人兴奋的功能，我们在《MySQL
    8简介》[第1章](c24bf065-eb70-47cb-9482-807a8431c1ba.xhtml)中已经介绍了。MySQL 8现在可以在一个数据库中存储数百万个表。它还可以快速修改表。
- en: 'I am excited to go through this chapter, as MySQL 8 best practices not only
    impact your database performance, scalability, security, and availability, but
    will also, on the whole, expose how your system performs for the end user. This
    is our end goal, isn''t it? Let''s look at some benchmarks that have been derived
    in our test lab, which will raise your eyebrows for sure:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我很兴奋地阅读这一章，因为MySQL 8的最佳实践不仅影响着你的数据库性能、可伸缩性、安全性和可用性，而且整体上还会暴露出你的系统对最终用户的表现。这是我们的最终目标，不是吗？让我们看看在我们的测试实验室中得出的一些基准测试结果，这些结果肯定会让你眼前一亮：
- en: '![](img/a2c522ae-4e7a-492e-9109-48619517320c.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2c522ae-4e7a-492e-9109-48619517320c.png)'
- en: MySQL benchmarking and tools
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQL基准测试和工具
- en: We have gone through various new features and improvements in MySQL 8\. It makes
    us more excited, as performance is always what we crave. With MySQL 8 not being
    generally available yet, Oracle hasn't published its benchmark results. We didn't
    wait for it to do so and carried out our own analysis in a few areas.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了MySQL 8中的各种新功能和改进。这让我们更加兴奋，因为性能一直是我们渴望的。由于MySQL 8尚未普遍可用，Oracle还没有发布其基准测试结果。我们没有等待它这样做，而是在一些领域进行了自己的分析。
- en: Configuration best practices of MySQL is the cherry on the cake; without the
    cherry, the cake seems incomplete. In addition to configurations, benchmarking
    helps us validate and find bottlenecks and address them. Let's look at a few specific
    areas that will help us understand the best practices for configuration and performance
    benchmarking.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL的最佳配置实践是锦上添花；没有樱桃，蛋糕看起来就不完整。除了配置，基准测试还帮助我们验证并找到瓶颈并解决它们。让我们看看一些特定领域，这将帮助我们了解配置和性能基准测试的最佳实践。
- en: Resource utilization
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源利用
- en: IO activity, CPU, and memory usage is something that you should not miss out.
    These metrics help us know how the system is performing while doing benchmarking
    and at the time of scaling. It also helps us derive impacts per transaction.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: IO活动、CPU和内存使用是你不应该错过的东西。这些指标帮助我们了解系统在进行基准测试和扩展时的表现。它还帮助我们推导每个事务的影响。
- en: Stretching your benchmarking timelines
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延长基准测试时间
- en: We may often like to have a quick glance at performance metrics; however, ensuring
    that MySQL behaves in the same way for a longer duration of testing is also a
    key element. There is some basic stuff that might impact on performance when you
    stretch your benchmark timelines, such as memory fragmentation, degradation of
    IO, impact after data accumulation, cache management, and so on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能经常希望快速查看性能指标；然而，确保MySQL在较长时间的测试中表现一致也是一个关键因素。有一些基本的东西可能会影响性能，比如内存碎片化、IO的退化、数据积累后的影响、缓存管理等等。
- en: We don't want our database to get restarted just to clean up junk items, correct?
    Therefore, it is suggested to run benchmarking for a long duration for stability
    and performance validation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望我们的数据库因为清理垃圾而重新启动，对吧？因此，建议长时间运行基准测试以验证稳定性和性能。
- en: Replicating production settings
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制生产设置
- en: Let's benchmark in a production-replicated environment. Wait! Let's disable
    database replication in a replica environment until we are done with benchmarking.
    Gotcha! We have got some good numbers!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个生产复制环境中进行基准测试。等等！在复制环境中禁用数据库复制，直到我们完成基准测试。搞定！我们得到了一些不错的数字！
- en: It often happens that we don't simulate everything completely that we are going
    to configure in the production environment. It could prove to be costly, as we
    might unintentionally be benchmarking something in an environment that might have
    an adverse impact when it's in production. Replicate production settings, data,
    workload, and so on in your replicated environment while you do benchmarking.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 经常发生的情况是，我们并没有完全模拟我们将在生产环境中配置的所有内容。这可能会证明是代价高昂的，因为我们可能无意中在一个可能在生产中产生不利影响的环境中进行基准测试。在进行基准测试时，在你的复制环境中复制生产设置、数据、工作负载等。
- en: Consistency of throughput and latency
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 吞吐量和延迟的一致性
- en: Throughput and latency go hand in hand. It is important to keep your eyes primarily
    focused on throughput; however, latency over time might be something to look out
    for. Performance dips, slowness, or stalls were noticed in `InnoDB` in its earlier
    days. It has improved a lot since then, but as there might be other cases depending
    on your workload, it is always good to keep an eye on throughput along with latency.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 吞吐量和延迟是相辅相成的。重点应该放在吞吐量上；然而，随着时间的推移，延迟可能是需要注意的。在`InnoDB`的早期版本中注意到了性能下降、缓慢或停顿。自那时以来它已经有了很大的改进，但由于可能有其他情况取决于你的工作负载，所以始终关注吞吐量和延迟是很好的。
- en: Sysbench can do more
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sysbench可以做更多
- en: Sysbench is a wonderful tool to simulate your workloads, whether it be thousands
    of tables, transaction intensive, data in-memory, and so on. It is a splendid
    tool to simulate and gives you nice representation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Sysbench是一个很好的工具，可以模拟你的工作负载，无论是成千上万的表、事务密集型、内存中的数据等等。它是一个很好的模拟工具，并为你提供了很好的表示。
- en: Virtualization world
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟化世界
- en: I would like to keep this simple; bare metal as compared to virtualization isn't
    the same. Hence, while doing benchmarking, measure your resources according to
    your environment. You might be surprised to see the difference in results if you
    compare both.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我想保持简单；裸金属与虚拟化并不相同。因此，在进行基准测试时，根据你的环境来衡量你的资源。如果你进行比较，你可能会惊讶地看到结果的差异。
- en: Concurrency
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发
- en: Big data is seated on heavy data workload; high concurrency is important. MySQL
    8 is extending its maximum CPU core support in every new release, optimizing concurrency
    based on your requirements and hardware resources should be taken care of.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 大数据坐落在沉重的数据工作负载上；高并发是重要的。MySQL 8在每个新版本中都在扩展其最大CPU核心支持，根据你的需求和硬件资源优化并发应该得到关注。
- en: Hidden workloads
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐藏的工作负载
- en: Do not miss out factors that run in the background, such as reporting for big
    data analytics, backups, and on-the-fly operations while you are benchmarking.
    The impact of such hidden workloads or obsolete benchmarking workloads can make
    your days (and nights) miserable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不要错过在后台运行的因素，比如用于大数据分析的报告、备份以及在基准测试时进行的即时操作。这些隐藏的工作负载或过时的基准测试工作负载的影响可能会让你的日子（和夜晚）变得痛苦。
- en: Nerves of your query
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的查询的神经
- en: Oops! Did we miss the optimizer? Not yet. An optimizer is a powerful tool that
    will read the nerves of your query and provide recommendations. It's a tool that
    I use before making changes to a query in production. It's a savior when you have
    complex queries to be optimized.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！我们错过了优化器吗？还没有。优化器是一个强大的工具，它会读取你的查询的神经并提供建议。这是我在对查询进行更改之前在生产环境中使用的工具。当你需要优化复杂的查询时，它就是救星。
- en: These are a few areas that we should look out for. Let's now look at a few benchmarks
    that we did on MySQL 8 and compare them with the ones on MySQL 5.7.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们应该注意的几个领域。现在让我们看一下我们在MySQL 8上进行的一些基准测试，并将它们与MySQL 5.7上的基准测试进行比较。
- en: Benchmarks
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试
- en: 'To start with, let''s fetch all the column names from all the `InnoDB` tables.
    The following is the query that we executed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从所有的`InnoDB`表中获取所有列名。以下是我们执行的查询：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following figure shows how MySQL 8 performed a thousand times faster when
    having four instances:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了当有四个实例时，MySQL 8的性能比MySQL 5.7快一千倍：
- en: '![](img/876aec71-3b72-4bf0-b7c9-15628da2a272.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/876aec71-3b72-4bf0-b7c9-15628da2a272.png)'
- en: 'Following this, we also performed a benchmark to find static table metadata.
    The following is the query that we executed:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们还进行了基准测试，以查找静态表元数据。以下是我们执行的查询：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following figure shows how MySQL 8 performed around 30 times faster than
    MySQL 5.7:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了MySQL 8的性能比MySQL 5.7快大约30倍：
- en: '![](img/a6e32571-2a40-4490-89e1-5565083dd017.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6e32571-2a40-4490-89e1-5565083dd017.png)'
- en: It made us eager to go into a bit more detail. So, we thought of doing one last
    test to find dynamic table metadata.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们渴望更详细地了解一下。因此，我们想做最后一次测试，以找到动态表元数据。
- en: 'The following is the query that we executed:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们执行的查询：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following figure shows how MySQL 8 performed around 30 times faster than
    MySQL 5.7:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了MySQL 8的性能比MySQL 5.7快大约30倍：
- en: '![](img/0b1fa168-25c6-4b45-a79d-5e1fafd21ebe.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b1fa168-25c6-4b45-a79d-5e1fafd21ebe.png)'
- en: MySQL 8.0 brings enormous performance improvements to the table. Scaling to
    one million tables, which is a need for many big data requirements, is now achievable.
    We look forward to many more benchmarks being officially released once MySQL 8
    is available for general purposes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8.0为表带来了巨大的性能改进。扩展到一百万个表，这是许多大数据需求的需要，现在是可以实现的。一旦MySQL 8可用于一般用途，我们期待着更多的基准测试被正式发布。
- en: Let's now look at our next topic, which will make your life easier. It's all
    about taking things into consideration for best practices of memcached.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们的下一个主题，这将让你的生活更轻松。这一切都是关于考虑memcached的最佳实践。
- en: Best practices for memcached
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: memcached的最佳实践
- en: Multiple `get` operations are now possible with the `InnoDB` memcached plugin,
    which will really help in improving the read performance. Now, multiple key value
    pairs can be fetched in a single memcached query. Frequent communication traffic
    has also been minimized, as we can get multiple data in a single shot.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用`InnoDB` memcached插件进行多个`get`操作，这将真正有助于提高读取性能。现在可以在单个memcached查询中获取多个键值对。频繁的通信流量也已经最小化，因为我们可以一次获取多个数据。
- en: The key takeaways that you should consider for memcached configuration best
    practices are what we will be going through now.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于memcached配置最佳实践，您应该考虑的关键要点现在将要介绍。
- en: Resource allocation
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源分配
- en: Memory allocation for memcached shouldn't be allocated over the available physical
    memory or without considering other resources that would be utilizing memory.
    If we over-allocate memory, there is a high chance that memcached would have memory
    allocated from the swap space. This may lead to delays while inserting or fetching
    values because the swap space is stored on the disk, which is slower than in-memory.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于memcached的内存分配不应超过可用物理内存，也不应忽视其他可能使用内存的资源。如果我们过度分配内存，memcached有很高的机会从交换空间中分配内存。这可能导致在插入或提取值时出现延迟，因为交换空间存储在磁盘上，比内存慢。
- en: Operating system architecture
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作系统架构
- en: As the operating system architecture has 32-bits, one needs to be cautious.
    As we know, there are limitations to provision resources in a 32-bit operating
    system architecture.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于操作系统架构为32位，需要谨慎。我们知道，在32位操作系统架构中，资源分配存在限制。
- en: Similarly, memcached with 4 GB RAM with a 32-bit operating system architecture
    shouldn't be set more than 3.5 GB RAM, as it can behave strangely in performance
    and can also result in crashes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，具有32位操作系统架构的4 GB RAM的memcached不应设置超过3.5 GB RAM，因为这可能会导致性能异常和崩溃。
- en: Default configurations
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认配置
- en: 'Some key default configuration parameters should always be fine-tuned based
    on your needs:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一些关键的默认配置参数应该根据您的需求进行调整：
- en: '**Memory allocation**: By default, this is 64 MB; instead it should be reconfigured
    based on your requirements and testing'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存分配**：默认情况下，这是64 MB；而应该根据您的需求和测试重新配置'
- en: '**Connections**: By default, this is 1,024 concurrent connections; instead
    it should be reconfigured based on your requirements and testing'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接**：默认情况下，这是1,024个并发连接；而应该根据您的需求和测试重新配置'
- en: '**Port**: By default, this listens on port `11211`; instead it should listen
    to another port for security purposes'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口**：默认情况下，这在端口`11211`上监听；而应该出于安全考虑监听另一个端口'
- en: '**Network interface**: By default, this accepts connections from all network
    interfaces; instead it should be limited for security purposes'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络接口**：默认情况下，这接受来自所有网络接口的连接；为了安全起见，应该限制'
- en: Max object size
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最大对象大小
- en: You should look at configuring the maximum object size, which by default is
    1 MB. However, it can be bumped up to 128 MB. It is purely based on what type
    of data you are going to store and, accordingly, its maximum object size should
    be allowed. Allowing overhead data to be stored in memcached can have an adverse
    impact, as there may be much more data to retrieve, which can cause failures.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该考虑配置最大对象大小，默认情况下为1 MB。但是，它可以增加到128 MB。这纯粹取决于您要存储的数据类型，因此应允许其最大对象大小。允许将开销数据存储在memcached中可能会产生不利影响，因为可能有更多的数据需要检索，这可能会导致失败。
- en: Backlog queue limit
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 积压队列限制
- en: The backlog queue limit is all about the number of connections to memcached
    that should be kept in queue if it reaches the limit of allowed connections. Ideally,
    your number of connections allowed should be configured in a way that should suffice
    for most of your needs. The backlog queue limit can be helpful when there is an
    unexpected peak load on memcached. Ideally, it should not go beyond 20% of the
    total connections or it could impact the experience of system fetching information
    from memcached because of heavy delays.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 积压队列限制是关于如果达到允许的连接限制，应该保留在memcached队列中的连接数。理想情况下，您允许的连接数应该配置得足够满足大部分需求。当memcached出现意外的高负载时，积压队列限制可能会有所帮助。理想情况下，它不应超过总连接数的20%，否则可能会影响系统从memcached中获取信息的体验，因为会出现严重延迟。
- en: Large pages support
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大页支持
- en: On systems that support large memory pages, you should enable memcached to leverage
    them. Large pages support helps allocate a large data chunk to store data and
    also reduces the number of caches missed calls using this.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持大内存页的系统上，您应该启用memcached来利用它们。大页支持有助于分配大数据块来存储数据，并且还减少了使用这种方法的缓存未命中调用的数量。
- en: Sensitive data
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敏感数据
- en: Storing sensitive data in memcached could be a security threat, as somebody
    with access to memcached could view the sensitive information. You should obviously
    take precautions to limit the exposure of memcached. You can also have sensitive
    information encrypted before storing it on memcached.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在memcached中存储敏感数据可能构成安全威胁，因为可以访问memcached的人可以查看敏感信息。您显然应该采取预防措施来限制memcached的曝光。您还可以在将敏感信息存储在memcached之前对其进行加密。
- en: Restricting exposure
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制曝光
- en: Memcached doesn't have many security features built in. One measure involves
    exposing memcached access within the required boundaries. If your application
    server needs to talk to memcached, it only allows memcached to be accessed from
    that server with the help of system firewall rules, such as IP Tables or similar
    techniques.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Memcached没有许多内置的安全功能。其中一项措施涉及在所需边界内暴露memcached访问。如果您的应用服务器需要与memcached通信，它只允许从该服务器访问memcached，借助系统防火墙规则，如IP
    Tables或类似技术。
- en: Failover
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障转移
- en: Memcached doesn't have good failover techniques. It is suggested that you have
    your application configured in a way to failover to an unavailable node and regenerate
    data into another instance. It is good to have at least two memcached configured
    to avoid failure owing to the unavailability of the instance.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Memcached没有良好的故障转移技术。建议您配置应用程序以使其能够故障转移到不可用节点，并在另一个实例中重新生成数据。最好至少配置两个memcached以避免由于实例不可用而导致的故障。
- en: Namespaces
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: You can leverage namespaces provided by memcached, which basically adds prefixes
    to the data before storing it in memcached. It can help when you have multiple
    applications talking to memcached. This is helpful and, using some basic principles
    of naming conventions, you can derive a solution. If there is data that is storing
    first names and last names, you can use prefixes, such as FN and LN, respectively.
    This would help you easily identify and retrieve data from the application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以利用memcached提供的命名空间，在将数据存储在memcached中之前基本上添加前缀。当您有多个应用程序与memcached通信时，这将会有所帮助。这是有帮助的，使用一些基本的命名约定原则，您可以得出一个解决方案。如果有存储名和姓的数据，您可以分别使用前缀，例如FN和LN。这将帮助您轻松地从应用程序中识别和检索数据。
- en: Caching mechanism
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存机制
- en: One of the easiest ways to start leveraging caching in memcached is to use a
    two-column table; you can leverage namespaces provided by memcached, which basically
    adds prefixes. The first columns would be a primary key, and database schema should
    be the address requirement of a unique identifier with the help of primary key
    mapping along with unique constraints. In case you want to have a single item
    value by combining multiple column values, you should make sure you choose appropriate
    data types.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 开始利用memcached中的缓存的最简单方法之一是使用两列表；您可以利用memcached提供的命名空间，基本上添加前缀。第一列将是主键，并且数据库架构应该是通过主键映射以及唯一约束的地址要求的唯一标识符。如果您想通过组合多个列值来获得单个项目值，您应该确保选择适当的数据类型。
- en: Queries with a single `WHERE` clause can be mapped easily into memcached lookups
    while using `=` or `IN` operators in the queries themselves. In cases where multiple
    `WHERE` clauses are used or complex operations are parsed, such as `<`, `>`, `LIKE`,
    and `BETWEEN`, memcached would get you through challenges. It is suggested that
    you have such complex operations using traditional SQL queries added to your database.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 具有单个`WHERE`子句的查询可以轻松映射到memcached查找，同时在查询本身中使用`=`或`IN`运算符。在使用多个`WHERE`子句或解析复杂操作（如`<`、`>`、`LIKE`和`BETWEEN`）的情况下，memcached可以帮助您解决挑战。建议您使用传统的SQL查询将这些复杂操作添加到数据库中。
- en: It would be beneficial to cache entire objects in memcached instead of opting
    to cache individual rows from MySQL 8\. For instance, for a blogging website,
    you should cache the entire object of the blog port in memcached.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将整个对象缓存在memcached中，而不是选择缓存来自MySQL 8的单个行，这将是有益的。例如，对于博客网站，应该在memcached中缓存博客端的整个对象。
- en: Memcached general statistics
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Memcached常规统计信息
- en: 'To help you understand the statistics of memcached better, we will provide
    an overview of health and performance. Statistics returned by memcached and their
    meaning are shown in the following table:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您更好地了解memcached的统计信息，我们将提供健康和性能的概述。下表显示了memcached返回的统计信息及其含义：
- en: 'Terms used to define the value for each of the statistics are:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 用于定义每个统计信息值的术语是：
- en: '**32u**: 32-bit unsigned integer'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**32u**：32位无符号整数'
- en: '**64u**: 64-bit unsigned integer'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**64u**：64位无符号整数'
- en: '**32u:32u**: Two 32-bit unsigned integers separated by a colon'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**32u:32u**：由冒号分隔的两个32位无符号整数'
- en: '**String**: Character string'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串**：字符字符串'
- en: '| **Statistic** | **Datatype** | **Description** |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '**统计** | **数据类型** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `pid` | 32u | Process ID of the memcached instance. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '`pid` | 32u | memcached实例的进程ID。'
- en: '| `uptime` | 32u | Uptime (in seconds) for this memcached instance. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '`uptime` | 32u | 该memcached实例的正常运行时间（以秒为单位）。'
- en: '| `time` | 32u | Current time (as epoch). |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '`time` | 32u | 当前时间（作为时期）。'
- en: '| `version` | string | Version string of this instance. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '`version` | 字符串 | 该实例的版本字符串。'
- en: '| `pointer_size` | string | Size of pointers for this host specified in bits
    (32 or 64). |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '`pointer_size` | 字符串 | 该主机指定的指针大小（32位或64位）。'
- en: '| `rusage_user` | 32u:32u | Total user time for this instance (seconds:microseconds).
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '`rusage_user` | 32u:32u | 该实例的总用户时间（秒：微秒）。'
- en: '| `rusage_system` | 32u:32u | Total system time for this instance (seconds:microseconds).
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '`rusage_system` | 32u:32u | 该实例的总系统时间（秒：微秒）。'
- en: '| `curr_items` | 32u | Current number of items stored by this instance. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '`curr_items` | 32u | 该实例存储的当前项目数量。'
- en: '| `total_items` | 32u | Total number of items stored during the life of this
    instance. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '`total_items` | 32u | 在该实例的生命周期内存储的项目总数。'
- en: '| `bytes` | 64u | Current number of bytes used by this server to store items.
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '`bytes` | 64u | 该服务器用于存储项目的当前字节数。'
- en: '| `curr_connections` | 32u | Current number of open connections. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '`curr_connections` | 32u | 当前打开连接的数量。'
- en: '| `total_connections` | 32u | Total number of connections opened since the
    server started running. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '`total_connections` | 32u | 服务器运行以来打开的连接总数。'
- en: '| `connection_structures` | 32u | Number of connection structures allocated
    by the server. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '`connection_structures` | 32u | 服务器分配的连接结构的数量。'
- en: '| `cmd_get` | 64u | Total number of retrieval requests (`get` operations).
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '`cmd_get` | 64u | 检索请求（`get`操作）的总数。'
- en: '| `cmd_set` | 64u | Total number of storage requests (`set` operations). |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '`cmd_set` | 64u | 存储请求（`set`操作）的总数。'
- en: '| `get_hits` | 64u | Number of keys that have been requested and found present.
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '`get_hits` | 64u | 请求并找到的键的数量。'
- en: '| `get_misses` | 64u | Number of items that have been requested and not found.
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '`get_misses` | 64u | 请求但未找到的项目数。'
- en: '| `delete_hits` | 64u | Number of keys that have been deleted and found present.
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '`delete_hits` | 64u | 已删除并找到的键的数量。'
- en: '| `delete_misses` | 64u | Number of items that have been delete and not found.
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '`delete_misses` | 64u | 删除但未找到的项目数。'
- en: '| `incr_hits` | 64u | Number of keys that have been incremented and found present.
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '`incr_hits` | 64u | 增加并找到的键的数量。'
- en: '| `incr_misses` | 64u | Number of items that have been incremented and not
    found. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '`incr_misses` | 64u | 增加但未找到的项目数。'
- en: '| `decr_hits` | 64u | Number of keys that have been decremented and found present.
    |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '`decr_hits` | 64u | 已减少并找到的键的数量。'
- en: '| `decr_misses` | 64u | Number of items that have been decremented and not
    found. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '`decr_misses` | 64u | 减少但未找到的项目数。'
- en: '| `cas_hits` | 64u | Number of keys that have been compared and swapped and
    found present. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `cas_hits` | 64u | 已比较并交换并找到的键的数量。|'
- en: '| `cas_misses` | 64u | Number of items that have been compared and swapped
    and not found. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `cas_misses` | 64u | 已比较并交换但未找到的项目数量。|'
- en: '| `cas_badvalue` | 64u | Number of keys that have been compared and swapped,
    but the comparison (original) value did not match the supplied value. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `cas_badvalue` | 64u | 已比较并交换，但比较（原始）值与提供的值不匹配的键的数量。|'
- en: '| `evictions` | 64u | Number of valid items removed from cache to free memory
    for new items. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `驱逐` | 64u | 从缓存中移除的有效项目数量，以释放内存供新项目使用。|'
- en: '| `bytes_read` | 64u | Total number of bytes read by this server from network.
    |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `bytes_read` | 64u | 该服务器从网络中读取的总字节数。|'
- en: '| `bytes_written` | 64u | Total number of bytes sent by this server to network.
    |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `bytes_written` | 64u | 该服务器发送到网络的总字节数。|'
- en: '| `limit_maxbytes` | 32u | Number of bytes this server is permitted to use
    for storage. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `limit_maxbytes` | 32u | 该服务器允许用于存储的字节数。|'
- en: '| `threads` | 32u | Number of worker threads requested. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `threads` | 32u | 请求的工作线程数量。|'
- en: '| `conn_yields` | 64u | Number of yields for connections (related to the -R
    option). |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `conn_yields` | 64u | 连接的让步次数（与-R选项相关）。|'
- en: 'Reference: [https://dev.mysql.com/doc/refman/8.0/en/ha-memcached-stats-general.html](https://dev.mysql.com/doc/refman/8.0/en/ha-memcached-stats-general.html)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 参考：[https://dev.mysql.com/doc/refman/8.0/en/ha-memcached-stats-general.html](https://dev.mysql.com/doc/refman/8.0/en/ha-memcached-stats-general.html)
- en: These are a few useful items that should be kept handy for best practices of
    memcached. It's now time for us to move ahead and look at best practices for replication.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些有用的项目，应该随时掌握memcached的最佳实践。现在是时候继续前进，看看复制的最佳实践了。
- en: Best practices for replication
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制的最佳实践
- en: MySQL 8 has made some great improvements on the replication side. MySQL 8 is
    all about scalability, performance, and security with the utmost integrity of
    data, which is expected to be a game-changer in big data too.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8在复制方面取得了一些重大进展。MySQL 8主要关注的是扩展性、性能和安全性，以及数据的最高完整性，这有望成为大数据领域的一个改变者。
- en: Throughput in group replication
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组复制中的吞吐量
- en: Group replication basically takes care of committing transactions once most
    of the members in group replication have acknowledged the transaction received
    concurrently. This results in a better throughput if the overall number of writes
    doesn't exceeding the capacity of the members in group replication. If there is
    a case where capacity is not planned appropriately, you would notice lags on affected
    members as compared to other members in the group.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 组复制基本上负责在大多数组复制成员同时确认接收事务后提交事务。如果写入的总数不超过组复制成员的容量，这将导致更好的吞吐量。如果容量规划不合适，受影响的成员会出现滞后，与组内其他成员相比。
- en: Infrastructure sizing
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施规模
- en: Infrastructure sizing is a common success factor for performance and the best
    practices checklist. If infrastructure sizing is not proper or uneven across the
    nodes in group replication, it could adversely impact the replication fundamentals
    topology. Each component should be considered while considering the throughput
    required from the components.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施规模是性能和最佳实践清单的常见成功因素。如果基础设施规模不合适或在组复制的节点之间不均匀，可能会对复制基本拓扑产生不利影响。在考虑所需的组件吞吐量时，应考虑每个组件。
- en: Constant throughput
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恒定的吞吐量
- en: To achieve constant throughput is a good success factor. What if you start experiencing
    a workload that starts affecting the rest of the members in group replication?
    It might be a case where your master keeps on accepting additional workload and
    is lagging behind, after which it might return to an acceptable level before burning
    out all the resources. Additionally, you can implement a queuing methodology that
    can prevent you from burning down resources and only allows you to pass on workloads
    to the members that are predefined based on capacity.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 实现恒定的吞吐量是一个很好的成功因素。如果您开始经历影响组复制中其他成员的工作负载，可能是您的主服务器不断接受额外的工作负载并滞后，然后在耗尽所有资源之前可能返回到可接受的水平。此外，您可以实施一个排队方法，可以防止资源耗尽，并且只允许您将工作负载传递给根据容量预定义的成员。
- en: While considering a queuing methodology, you mustn't allow queues grow exponentially.
    This would impact the end user, as there would be a lag in the data being updated.
    However, you needs to decide based on your needs and the business requirement
    to achieve constant throughput across the system.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑排队方法时，您不能允许队列呈指数增长。这会影响最终用户，因为数据更新会有延迟。但是，您需要根据自己的需求和业务需求来决定，以实现系统的恒定吞吐量。
- en: Contradictory workloads
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矛盾的工作负载
- en: Fundamentally, group replication is designed to allow updates from any of the
    members in the group. Rollback of transactions based on overlap of rows is checked
    for each of the transactions; the rest are committed and sent to be updated to
    other members in the group. If several updates on the same row happen frequently,
    it can result in multiple rollbacks. You might come across cyclic situations where
    one server updates, requests others to update, and, in parallel, another has already
    updated for the same row. This would result in rollback.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，组复制旨在允许来自组中任何成员的更新。基于行重叠的事务回滚会检查每个事务；其余的将被提交并发送以更新到组中的其他成员。如果同一行上频繁发生多次更新，可能会导致多次回滚。您可能会遇到循环情况，其中一个服务器更新，请求其他服务器更新，并且同时另一个服务器已经为同一行更新。这将导致回滚。
- en: To prevent such a scenario, you can have the last member of the group apply
    the update, after which you proceed to another one. You can have similar updates
    routed only from the same node where the earlier one had been executed to prevent
    the chances of cyclic rollback conditions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况，您可以让组中的最后一个成员应用更新，然后再进行下一个成员。您可以从先前执行更新的相同节点路由类似的更新，以防止循环回滚条件的发生。
- en: Write scalability
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写扩展性
- en: Distribute your write workload by sharing out write operations, which might
    result in better throughput and better scalability on write performance. It would
    be dependent on contradictory workloads that you would be expecting in the system.
    This is helpful when your peak workload is being executed is one that can share
    the load. In common cases, if you have good capacity planning done with write
    scalability, you would see trivial improvement.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分享写操作来分配您的写入工作负载，这可能会导致更好的吞吐量和更好的写入性能可伸缩性。这将取决于您在系统中预期的矛盾工作负载。当您的高峰工作负载是可以共享负载的情况下，这是有帮助的。通常情况下，如果您对写入可伸缩性进行了良好的容量规划，您将看到微不足道的改进。
- en: 'Refer to the following diagram that depicts this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考下面的图表：
- en: '![](img/075cbe70-3905-4d30-a306-147bdfb015ff.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/075cbe70-3905-4d30-a306-147bdfb015ff.png)'
- en: You will notice that with the help of multi-masters to distribute, your load
    has better throughput. It also considers the group size in multi-master configuration.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，通过多主分发，您的负载具有更好的吞吐量。它还考虑了多主配置中的组大小。
- en: Best practices for data partitioning
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据分区的最佳实践
- en: In general terms, partitioning is logically dividing anything into multiple
    subgroups so that each subgroup can be identified independently and can be combined
    into a single partition.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，分区是将任何东西逻辑上分成多个子组，以便每个子组可以独立识别并组合成一个单一分区。
- en: Let's now learn different partitioning methods and how partitioning can help
    where there are large data tables.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们学习不同的分区方法以及分区如何在存在大型数据表的情况下提供帮助。
- en: For any organization, it is very important to store data in such a way that
    the database provides scalability, performance, availability, and security. For
    instance, in a highly accessed e-commerce store, there are thousands, or more,
    of orders placed frequently. So to maintain day-to-day order delivery showing
    a dashboard of current orders, what is required is to query a table showing orders
    from the past five years; the process will take a long time to execute with the
    current data. Here, historical order data is needed for the analytical purpose
    of finding user behavior or trends, but this will be required to be performed
    on limited datasets.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何组织来说，以一种能够提供可伸缩性、性能、可用性和安全性的方式存储数据非常重要。例如，在一个访问量很高的电子商务商店中，经常会有成千上万的订单。因此，为了维护日常订单交付并显示当前订单的仪表板，需要查询显示过去五年的订单表；使用当前数据执行这个过程将需要很长时间。在这里，历史订单数据用于分析用户行为或趋势，但这将需要在有限的数据集上执行。
- en: There are various ways to achieve the best suitable solution for high availability,
    scalability, and highly performing architecture; the key ingredient is partitioning.
    In a database, data in each table is stored in physical file groups. So by dividing
    this data table from a single file group to a multiple file group can reduce the
    file size and help us create a scalable and high-performing database.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种方法可以实现高可用性、可伸缩性和高性能架构的最佳解决方案；关键因素是分区。在数据库中，每个表中的数据存储在物理文件组中。因此，将这些数据表从单个文件组分割为多个文件组可以减少文件大小，并帮助我们创建一个可伸缩和高性能的数据库。
- en: 'The following are the key benefits of using partitioning in a database:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在数据库中使用分区的关键好处：
- en: '**Scalability**: As data will be shared among more than one partition, servers
    can be configured to use multiple nodes and partitions can be configured among
    multiple nodes. Doing so will eliminate any hardware limits and allow the database
    to scale up to a large extent to accommodate high volume data.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：由于数据将在多个分区之间共享，服务器可以配置为使用多个节点，并且可以在多个节点之间配置分区。这样做将消除任何硬件限制，并允许数据库大规模扩展以容纳大量数据。'
- en: '**High performance**: As data is stored among multiple partitions, each query
    will be executed on a small portion of the data. For example, in an e-commerce
    store with an order history of more than two years, to get a list of orders placed
    in the current month will require checking only a single partition and not the
    entire order history, thus reducing the query execution time. To fetch the query
    on more than one partition, we can also run this in parallel, thus reducing the
    overall time to fetch data from the database.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高性能**：由于数据存储在多个分区中，每个查询将在数据的一小部分上执行。例如，在一个订单历史超过两年的电子商务商店中，要获取本月下的订单列表只需要检查一个分区而不是整个订单历史，从而减少查询执行时间。为了在多个分区上获取查询，我们也可以并行运行，从而减少从数据库获取数据的总时间。'
- en: '**High availability**: In partitioning, data is divided across multiple file
    groups. Each file group is logically connected but can be accessed and worked
    on independently. So if one of the file groups or partitions gets corrupted or
    one of the nodes in the server fails, then we will not lose access to the entire
    table, but only a section of the database will not be available, thus eliminating
    the chances of system failure and making your system highly available.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高可用性**：在分区中，数据被分割到多个文件组中。每个文件组在逻辑上连接在一起，但可以独立访问和处理。因此，如果一个文件组或分区损坏，或者服务器中的一个节点失败，那么我们不会失去对整个表的访问权限，而只是数据库的一部分不可用，从而消除了系统故障的可能性，使您的系统高度可用。'
- en: '**Security**: It may be that some of the data in tables requires high security
    measurements to avoid data theft or data leaks. By partitioning, you can provide
    additional security to one or more partitions to avoid any security issues, thus
    improving data accessibility with data security.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：可能有些表中的数据需要高安全措施以避免数据窃取或数据泄漏。通过分区，您可以为一个或多个分区提供额外的安全性，以避免任何安全问题，从而提高数据的可访问性和安全性。'
- en: In general terms, partitioning is logically dividing anything into multiple
    subgroups so that each subgroup can be identified independently and can be combined
    into a single partition. Let's understand what partitioning means in terms of
    RDBMS.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，分区是将任何东西逻辑上分成多个子组，以便每个子组可以独立识别并组合成一个单一分区。让我们了解在关系型数据库管理系统中分区意味着什么。
- en: Partitioning is generally used to divide data into multiple logical file groups
    for the purpose of performance, availability, and manageability. When dealing
    with big data, the normal tendency of data is to be in terms of billions of records.
    So to improve performance of the database, it is better to divide data among multiple
    file groups. These file groups can be on a single machine or shared across multiple
    machines and identified by a key. These file groups are known as partitioned data.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 分区通常用于将数据分成多个逻辑文件组，以提高性能、可用性和可管理性。在处理大数据时，数据通常以数十亿条记录的形式存在。因此，为了提高数据库的性能，最好将数据分成多个文件组。这些文件组可以在单台机器上或跨多台机器共享，并由一个键标识。这些文件组被称为分区数据。
- en: 'Data in the table can be partitioned in two ways:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 表中的数据可以通过两种方式进行分区：
- en: Horizontal partitioning
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水平分区
- en: Vertical partitioning
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垂直分区
- en: Horizontal partitioning
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 水平分区
- en: When the number of rows in the table is very large, the table can be divided
    into multiple partitions; this is known as **horizontal partitioning**. When horizontal
    partitioning is used, each partition of the table contains the same number of
    columns. It is possible to access all partitions at once, or you can access each
    partition individually.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当表中的行数非常大时，表可以被分成多个分区；这被称为**水平分区**。使用水平分区时，表的每个分区包含相同数量的列。可以同时访问所有分区，也可以单独访问每个分区。
- en: Vertical partitioning
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垂直分区
- en: In vertical partitioning, the columns of the tables are partitioned to achieve
    performance and better management of the database. Vertical partitioning can be
    achieved in two ways. The first one is by normalizing tables. Instead of having
    too many columns in the table, columns can be divided into multiple tables by
    dividing the data. The second one is by creating separate physical file groups
    for defined columns in the table. Vertical partitioning is currently not supported
    in MySQL 8.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在垂直分区中，表的列被分区以实现性能和更好地管理数据库。垂直分区可以通过两种方式实现。第一种是通过规范化表。可以将表中的列分成多个表，通过数据的划分。第二种是通过为表中定义的列创建单独的物理文件组。MySQL
    8目前不支持垂直分区。
- en: 'Let''s look at a few of the benefits associated with partitioning:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看与分区相关的一些好处：
- en: If a table contains historical data, such as logs of an application, data older
    than six months does not provide any significance to the application to be active.
    If partitioning is created based on months, you can easily remove one of the partitions.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表包含历史数据，比如应用程序的日志，六个月前的数据对于应用程序的活跃性没有任何意义。如果基于月份创建分区，可以轻松地删除其中一个分区。
- en: In the same preceding case of logs, if we want to filter data between two dates,
    the MySQL optimizer can identify the specific partitions, where it can find the
    filtered records, which can result in much faster query results, as the number
    of rows to check is reduced drastically.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的日志案例中，如果我们想要在两个日期之间过滤数据，MySQL优化器可以识别特定的分区，从中找到过滤记录，这可能会导致查询结果更快，因为要检查的行数大大减少。
- en: MySQL 8 also supports querying data on particular partitions. It can reduce
    the number of records to check when you know the partition that needs to be queried
    for the data required.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL 8还支持在特定分区上查询数据。当您知道需要查询所需数据的分区时，可以减少要检查的记录数。
- en: Pruning partitions in MySQL
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在MySQL中修剪分区
- en: Pruning is the selective extraction of data. As we have multiple partitions,
    it will go through each partition during retrieval, which is time consuming and
    impacts on performance. Some of the partitions will also be included in searching
    while the requested data is not available inside that partition, which is an overhead
    process. Pruning helps here to search for only those partitions that have the
    relevant data, which will avoid the unnecessary inclusion of those partitions
    during retrieval.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 修剪是数据的选择性提取。由于我们有多个分区，在检索过程中将遍历每个分区，这是耗时的并且会影响性能。在搜索时，一些分区也会被包括在内，而请求的数据在该分区内并不可用，这是一个额外的过程。修剪在这里有助于仅搜索具有相关数据的分区，这将避免在检索过程中不必要地包括这些分区。
- en: This optimization that avoids the scanning of partitions where there can be
    no matching values is known as the **pruning of partitions**. In partition pruning,
    the optimizer analyzes `FROM` and `WHERE` clauses in SQL statements to eliminate
    unneeded partitions, and scans those database partitions that are relevant to
    the SQL statement.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种优化避免了扫描可能没有匹配值的分区，被称为**分区修剪**。在分区修剪中，优化器分析SQL语句中的`FROM`和`WHERE`子句，以消除不必要的分区，并扫描与SQL语句相关的数据库分区。
- en: Best practices for queries and indexing
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询和索引的最佳实践
- en: It would be difficult to write the best queries for reference and reuse. It
    will always vary based on the nature of your application, architecture, design,
    table structure, and so on. However, precautions can be taken while writing MySQL
    queries for better performance, scalability, and integrity.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 很难为参考和重用编写最佳查询。它将始终根据您的应用程序性质、架构、设计、表结构等而变化。但是，在编写MySQL查询时可以采取预防措施，以获得更好的性能、可扩展性和完整性。
- en: Let's go through a few of the best practices that we should keep in mind while
    designing or writing MySQL queries.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看在设计或编写MySQL查询时应该牢记的一些最佳实践。
- en: Data types
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'A database table could consist of multiple columns with data types, such as
    numerics or strings. MySQL 8 provides various data types rather than just limiting
    to numerics or strings:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库表可能包含多个具有数字或字符串等数据类型的列。MySQL 8提供了各种数据类型，而不仅仅限于数字或字符串：
- en: Small is good. As MySQL loads data in memory, a large data size would have an
    adverse impact on its performance. Smaller sets can accommodate more data in memory
    and reduce overheads of resource utilization.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小尺寸是好的。由于MySQL将数据加载到内存中，大数据量会对其性能产生不利影响。较小的数据集可以在内存中容纳更多数据，并减少资源利用的开销。
- en: Fix your length. If you don't fix the data type length, it would have to go
    and fetch the required information each time it needs to. So, wherever it's possible,
    you can limit the data length by using the char data type.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复您的长度。如果不修复数据类型长度，每次需要时它都必须去获取所需的信息。因此，无论在哪里，您都可以使用char数据类型来限制数据长度。
- en: Not null
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非空
- en: Not null data is something that MySQL doesn't like much. Not null columns use
    more storage, impact the performance, and require additional processing within
    MySQL.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL不太喜欢非空数据。非空列使用更多存储空间，影响性能，并需要在MySQL中进行额外处理。
- en: Optimizing such queries referring to null data is difficult as well. When a
    null data column is indexed, it uses additional bytes for each entry.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 优化引用空数据的查询也很困难。当空数据列被索引时，它会为每个条目使用额外的字节。
- en: Indexing
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引
- en: Indexing is important, as it can improve the performance of your badly designed
    query and table structure or it can even turn a well-designed query into a bad
    one, which can impact performance too.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 索引很重要，因为它可以改善您设计不良的查询和表结构的性能，甚至可以将一个设计良好的查询变成一个性能不佳的查询，这也会影响性能。
- en: Search fields index
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索字段索引
- en: Generally, we do indexing on fields that are used as filters in MySQL queries.
    It obviously helps reading faster but can adversely impact writes/updates so indexing
    only what you need would be a smart decision.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们在MySQL查询中用作过滤器的字段上进行索引。这显然有助于更快地读取，但可能会对写入/更新产生不利影响，因此只索引您需要的内容将是一个明智的决定。
- en: Data types and joins
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型和连接
- en: MySQL can do joins for data types that are different but the performance can
    be impacted if MySQL is asked to use different data types for join fields, as
    it would have to convert from one to another for each row.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL可以对不同数据类型进行连接，但如果要求MySQL使用不同的数据类型进行连接字段，性能可能会受到影响，因为它必须将每一行从一种类型转换为另一种类型。
- en: Compound index
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合索引
- en: If a query is supposed to refer to multiple columns of a table, a composite
    index for such columns might be helpful. A compound index refers the columns from
    the results set by the first column, second column, and so on.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个查询要引用表的多个列，那么为这些列创建一个复合索引可能会有所帮助。复合索引按照第一列、第二列等结果集中的列进行引用。
- en: The order of columns plays a significant role in the performance of the query,
    so while designing the table structure and index, you need to use it effectively.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 列的顺序在查询的性能中起着重要作用，因此在设计表结构和索引时，您需要有效地使用它。
- en: Shortening up primary keys
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩短主键
- en: Small is good for primary keys too. Shortening up primary keys would benefit
    analogously to how we discussed datatypes. Because of smaller primary keys, your
    index size would be smaller and hence the usage of cache would be less, so it
    can accommodate more data in memory.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主键来说，小尺寸也是好的。缩短主键会像我们讨论数据类型那样有益。由于主键较小，您的索引大小将更小，因此缓存的使用量将更少，因此可以在内存中容纳更多数据。
- en: It is preferred to use numeric types, as these would be much smaller than characters
    to achieve the goal of shortening up primary keys. It can be helpful while doing
    joins, as generally, primary keys are referred for the joining.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最好使用数字类型，因为这些比字符要小得多，以实现缩短主键的目标。在进行连接时可能会有所帮助，因为通常会引用主键进行连接。
- en: Indexing everything
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引一切
- en: Indexing everything is a good idea; however, MySQL won't do this. Do you know
    that MySQL will do a full table scan if it is supposed to scan an index higher
    than 30%? Do not index values that don't need to be indexed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 索引一切是一个好主意；然而，MySQL不会这样做。您知道吗，如果MySQL要扫描的索引高于30%，它将执行全表扫描吗？不要对不需要索引的值进行索引。
- en: We need to keep in mind that indexing helps—if done correctly—in fetching data;
    however, while writing/updating data, it is an overhead.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住，索引在正确使用时有助于获取数据；然而，在编写/更新数据时，它是一种负担。
- en: Fetching all data
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取所有数据
- en: '`select *...` - Arrghh! Do not use this unless it is really needed. So far,
    my experience hasn''t needed this. Fetching all data will slow down the execution
    time and impact heavily on resource utilization of the MySQL server. You need
    to provide a specific column name or appropriate conditions.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`select *...` - 啊！除非真的需要，否则不要使用这个。到目前为止，我的经验还没有需要这个。获取所有数据会减慢执行时间，并且严重影响MySQL服务器的资源利用率。您需要提供一个特定的列名或适当的条件。'
- en: Letting the application do the job
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让应用程序来完成工作
- en: Let the application also do the job for MySQL. You can avoid having clauses
    such as `order by` by letting applications do the ordering. Doing ordering in
    MySQL is much slower than in applications. You can identify queries that should
    be planned to be taken care of by the application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让应用程序也为MySQL完成工作。您可以通过让应用程序进行排序来避免使用`order by`等子句。在MySQL中进行排序比在应用程序中慢得多。您可以确定应该由应用程序处理的查询。
- en: Existence of data
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据的存在
- en: Checking the existence of data with the help of the `EXISTS` clause is much
    faster. The `EXISTS` clause will return the output as soon as it fetches the first
    row from the fetched data.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`EXISTS`子句检查数据的存在要快得多。`EXISTS`子句将在从获取的数据中获取第一行后立即返回输出。
- en: Limiting yourself
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制自己
- en: Limit yourself to the data that you need to fetch. Always ensure that you use
    appropriate limits while fetching the data, as unwanted data being fetched wouldn't
    be useful and would impact performance. Use the `LIMIT` clause in your SQL queries.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 限制自己只获取需要的数据。在获取数据时，始终确保使用适当的限制，因为获取不需要的数据将毫无用处，并影响性能。在你的SQL查询中使用`LIMIT`子句。
- en: Analyzing slow queries
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析慢查询
- en: This is a good practice to follow. We might miss out queries to either optimize
    or realize having adverse impact as data grows. You might have changes in the
    requirement of the data to be fetched where we might miss seeing the impact of
    the queries. It is good to always keep a watch on slow queries that can be configured
    in MySQL and optimize them.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个要遵循的良好实践。随着数据的增长，我们可能会错过要么优化要么意识到对查询产生不利影响的查询。你可能会对需要获取的数据的需求发生变化，而我们可能会忽视查询的影响。始终密切关注可以在MySQL中配置并优化的慢查询是很好的。
- en: Query cost
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询成本
- en: What is the cost of your query? Explain is the right answer to this. Use the
    `explain` query parameter to know what is impacting your query—whether it is a
    full table scan, index scans, range access, and so on. Use the information provided
    by explain wisely, to optimize the query further. It is a wonderful, quick handy
    tool of MySQL. If you know that you have done your best, indexing comes as a savior
    to optimize it further based on your needs.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你的查询成本是多少？解释是对这个问题的正确回答。使用`explain`查询参数来了解你的查询受到了什么影响——无论是全表扫描、索引扫描、范围访问等等。明智地利用`explain`提供的信息，进一步优化查询。这是MySQL的一个奇妙、快速、方便的工具。如果你知道你已经尽力了，索引将成为一个救世主，根据你的需求进一步优化它。
- en: Best practices while writing a query start with requirements, designs, implementations,
    and ongoing maintenance. It's a complete life cycle that we can't diversify. Understanding
    schemas, indexes, and analyses plays a significant role. What matters to us is
    the response time and optimum resource utilization.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 编写查询的最佳实践始于需求、设计、实施和持续维护。这是一个我们无法分散的完整生命周期。理解模式、索引和分析起着重要作用。对我们来说，响应时间和最佳资源利用率至关重要。
- en: I personally love to deep dive into this much more than we can mention here—it's
    a world of relations! Your query will meet a row or column of a table or get joined
    with another table. On top of this, if you haven't done it right, you are trying
    to find a relation from a subset that is not required. How do we forget indexes
    that are saviors if used appropriately? All these together would show our relations
    and would promptly respond to a requested query.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人喜欢深入研究这个领域，远远超出我们在这里所能提及的范围——这是一个关系的世界！你的查询将会遇到表的行或列，或者与另一个表连接。除此之外，如果你没有做对，你会试图从一个不需要的子集中找到一个关系。我们怎么能忘记适当使用的索引是救世主呢？所有这些加在一起将展示我们的关系，并迅速响应请求的查询。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: I am sure that while reading the chapter, you have kept in mind the things to
    be taken care of or recollecting them, if there's anything missing in your MySQL
    8 implementation. In these chapter, we discussed best practices for MySQL 8 which
    would be helpful at various stages, such as implementation, usage, management,
    and troubleshooting and would act as pointers for best practices of MySQL 8; these
    might vary based on different use cases. Proper testing and verification would
    help affirm the benefits of having best practices implemented.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信在阅读本章时，你已经记住了需要注意的事项，或者在回忆这些事项，如果你的MySQL 8实现中有任何遗漏。在这些章节中，我们讨论了MySQL 8的最佳实践，这些最佳实践在实施、使用、管理和故障排除等各个阶段都会有所帮助，并且会成为MySQL
    8最佳实践的指引；这些可能会根据不同的用例而有所不同。适当的测试和验证将有助于确认实施最佳实践的好处。
- en: We have broadly covered some exciting topics about MySQL 8 benchmarks and a
    few configuration parameters along with best practices of memcached. We discussed
    MySQL replication best practices, in which we went through a few critical pointers.
    Lastly, MySQL queries and indexing pointers were also discussed with best practices
    for data partitioning. Anything written in this chapter would be less, but the
    pointers provided are necessary.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们广泛涵盖了一些关于MySQL 8基准测试和一些配置参数以及memcached最佳实践的令人兴奋的主题。我们讨论了MySQL复制的最佳实践，其中我们经历了一些关键要点。最后，还讨论了MySQL查询和索引的指针，以及数据分区的最佳实践。这一章中的任何内容都不足以涵盖所有内容，但提供的指针是必要的。
- en: By now, we should have a good understanding of MySQL 8; it's now time to solve
    problems.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该对MySQL 8有了很好的理解；现在是解决问题的时候了。
- en: Let's now move on to the next chapter and look at how we could come across many
    common issues, identifying error codes along with real-world scenarios for troubleshooting
    MySQL 8.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转到下一章，看看我们如何可能遇到许多常见问题，识别错误代码以及用于排除MySQL 8故障的真实场景。
