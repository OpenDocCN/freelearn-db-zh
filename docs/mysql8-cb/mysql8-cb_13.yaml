- en: Performance Tuning
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能调优
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: The explain plan
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释计划
- en: Benchmarking queries and the server
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试查询和服务器
- en: Adding indexes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加索引
- en: Invisible index
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可见索引
- en: Descending index
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降序索引
- en: Analyzing slow queries using pt-query-digest
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pt-query-digest分析慢查询
- en: Optimizing datatypes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化数据类型
- en: Removing duplicate and redundant indexes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除重复和冗余索引
- en: Checking index usage
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查索引使用
- en: Controlling the query optimizer
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制查询优化器
- en: Using index hints
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用索引提示
- en: Indexing for JSON using generated columns
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生成列为JSON建立索引
- en: Using resource groups
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用资源组
- en: Using performance_schema
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用performance_schema
- en: Using the sys schema
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用sys模式
- en: Introduction
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: This chapter will take you through query and schema tuning. The database is
    meant for the execution of queries; making it run faster is the end goal of tuning.
    The database's performance depends on many factors, mainly queries, schema, configuration
    settings, and hardware.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带您了解查询和模式调优。数据库是用于执行查询的，使其运行更快是调优的最终目标。数据库的性能取决于许多因素，主要是查询、模式、配置设置和硬件。
- en: In this chapter, we are going to take the employees database to explain all
    the examples. You might have transformed the employees database in many ways in
    the preceding chapters. It is recommended to load the sample employees data again
    before trying the examples mentioned in this chapter. You can refer to *Section
    Loading sample data in Chapter 2* to know how to load sample data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用employees数据库来解释所有示例。您可能已经在前面的章节中以多种方式转换了employees数据库。建议在尝试本章中提到的示例之前，再次加载示例employees数据。您可以参考*第2章加载示例数据*了解如何加载示例数据。
- en: The explain plan
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释计划
- en: How MySQL executes queries is one of the major factors of database performance.
    You can verify the MySQL execution plan using the `EXPLAIN` command. Starting
    from MySQL 5.7.2, you can use `EXPLAIN` to examine queries currently executing
    in other sessions. `EXPLAIN FORMAT=JSON` gives detailed information.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL执行查询的方式是数据库性能的主要因素之一。您可以使用`EXPLAIN`命令验证MySQL执行计划。从MySQL 5.7.2开始，您可以使用`EXPLAIN`来检查其他会话中当前执行的查询。`EXPLAIN
    FORMAT=JSON`提供了详细信息。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's get into the details.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解细节。
- en: Using EXPLAIN
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EXPLAIN
- en: 'The explain plan gives information on how the optimizer is going to execute
    the query. You just need to prefix the `EXPLAIN` keyword to the query:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 解释计划提供了优化器执行查询的信息。您只需要在查询前加上`EXPLAIN`关键字：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using EXPLAIN JSON
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EXPLAIN JSON
- en: 'Using the explain plan in JSON format gives complete information about the
    query execution:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以JSON格式使用解释计划提供了关于查询执行的完整信息：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using EXPLAIN for connection
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用连接的EXPLAIN
- en: 'You can run the explain plan for an already-running session. You need to specify
    the connection ID:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为已运行的会话运行解释计划。您需要指定连接ID：
- en: 'To get connection ID, execute:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取连接ID，请执行：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If the connection is not running any `SELECT`/`UPDATE`/`INSERT`/`DELETE`/`REPLACE`
    queries, it will throw an error:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接没有运行任何`SELECT`/`UPDATE`/`INSERT`/`DELETE`/`REPLACE`查询，它将抛出一个错误：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Refer to [https://dev.mysql.com/doc/refman/8.0/en/explain-output.html](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html)
    to learn more about the explain plan format. The JSON format is very clearly explained
    at [https://www.percona.com/blog/category/explain-2/explain-formatjson-is-cool/](https://www.percona.com/blog/category/explain-2/explain-formatjson-is-cool/).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://dev.mysql.com/doc/refman/8.0/en/explain-output.html](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html)了解更多关于解释计划格式的信息。JSON格式在[https://www.percona.com/blog/category/explain-2/explain-formatjson-is-cool/](https://www.percona.com/blog/category/explain-2/explain-formatjson-is-cool/)中有非常清晰的解释。
- en: Benchmarking queries and the server
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试查询和服务器
- en: Suppose you want to find out which of the queries is faster. The explain plan
    gives you an idea, but sometimes you cannot decide based on it. You can execute
    them on the server and find which one is faster if the query time is in the order
    of tens of seconds. However, if the query time is in the order of a few milliseconds,
    you cannot decide based on a single execution.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要找出哪个查询更快。解释计划给了您一个想法，但有时您不能根据它来决定。如果查询时间在几十秒的数量级上，您可以在服务器上执行它们，并找出哪个更快。但是，如果查询时间在几毫秒的数量级上，您不能仅根据单次执行来决定。
- en: You can use the `mysqlslap` utility (it comes along with MySQL-client installation),
    which emulates client load for a MySQL server and reports the timing of each stage.
    It works as if multiple clients are accessing the server. In this section, you
    will learn about the usage of `mysqlslap`; in later sections, you will learn about
    the power of the `mysqlslap`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`mysqlslap`实用程序（它随MySQL客户端安装一起提供），它模拟了MySQL服务器的客户端负载，并报告每个阶段的时间。它的工作方式就好像多个客户端正在访问服务器。在本节中，您将了解`mysqlslap`的用法；在后续章节中，您将了解`mysqlslap`的强大之处。
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Suppose you want to measure the query time of a query; if you execute that
    in the MySQL client, you can know the approximate execution time with a granularity
    of 100 milliseconds:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要测量查询的时间；如果您在MySQL客户端中执行它，您可以知道大约的执行时间，精度为100毫秒：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can emulate the client load using `mysqlslap` and run the preceding SQL
    concurrently over multiple iterations:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`mysqlslap`模拟客户端负载，并在多次迭代中同时运行前述SQL：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding query was executed with 1,000 concurrencies and 100 iterations,
    and on average, it took 3.216 seconds.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前述查询以1,000并发和100次迭代执行，平均耗时3.216秒。
- en: 'You can specify multiple SQLs in a file and specify the delimiter. `mysqlslap`
    runs all the queries in the file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在文件中指定多个SQL并指定分隔符。`mysqlslap`运行文件中的所有查询：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can even autogenerate the table and SQL statements. In this way, you can
    compare the results with earlier server settings:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以自动生成表和SQL语句。这样，您可以将结果与先前的服务器设置进行比较：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can also use `performance_schema` for all query-related metrics, which is
    explained in the *Using performance_schema* section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`performance_schema`来获取所有与查询相关的指标，这在*使用performance_schema*部分有解释。
- en: Adding indexes
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加索引
- en: Without an index, MySQL must scan the entire table row by row to find the relevant
    rows. If the table has an index on the columns that you are filtering for, MySQL
    can quickly find the rows in the big data file without scanning the whole file.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 没有索引，MySQL必须逐行扫描整个表来找到相关的行。如果表上有你正在过滤的列的索引，MySQL可以快速在大数据文件中找到行，而不必扫描整个文件。
- en: MySQL can use an index for filtering of rows in `WHERE`, `ORDER BY`, and `GROUP
    BY` clauses, and also for joining tables. If there are multiple indexes on a column,
    MySQL chooses the index that gives maximum filtering of rows.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL可以在`WHERE`、`ORDER BY`和`GROUP BY`子句中使用索引来过滤行，也可以用于连接表。如果一个列上有多个索引，MySQL会选择能够最大程度过滤行的索引。
- en: You can execute the `ALTER TABLE` command to add or drop the index. Both index
    addition and dropping are online operations and do not hinder the DMLs on the
    table, but they take lot of time on larger tables.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以执行`ALTER TABLE`命令来添加或删除索引。索引的添加和删除都是在线操作，不会影响表上的DML操作，但在较大的表上需要很长时间。
- en: Primary key (clustered index) and secondary indexes
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主键（聚集索引）和次要索引
- en: Before you proceed further, it is important to understand what a primary key
    (or clustered index) is, and what a secondary index is.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，重要的是要理解主键（或聚集索引）是什么，以及次要索引是什么。
- en: '`InnoDB` stores rows in a primary key in order to speed up queries and sorts
    involving the primary key columns. This is also called an **index-organized table**,
    in Oracle terms. All other indexes are referred to as secondary keys, which store
    the value of primary keys (they do not refer to the row directly).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`InnoDB`按照主键的顺序存储行，以加快涉及主键列的查询和排序。这也被称为**索引组织表**，在Oracle术语中。所有其他索引都被称为次要键，它们存储主键的值（它们不直接引用行）。'
- en: 'Suppose the table is:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 假设表是：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The table rows are sorted and stored based on the value of `col1`. If you search
    for any value of `col1`, it can directly point to the physical row; this is why
    a clustered index is lightning-fast. The index on `col2` also contains the value
    of `col1`, and if you search for `col2`, the value of `col1` is returned, which
    in turn is searched in the clustered index to return the actual row.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 表行根据`col1`的值进行排序和存储。如果你搜索`col1`的任何值，它可以直接指向物理行；这就是为什么聚集索引非常快。`col2`上的索引也包含`col1`的值，如果你搜索`col2`，`col1`的值会返回，然后在聚集索引中搜索实际行。
- en: 'Tips on choosing the primary key:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 选择主键的提示：
- en: It should be `UNIQUE` and `NOT NULL`.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该是`UNIQUE`和`NOT NULL`。
- en: Choose the smallest possible key because all the secondary indexes store the
    primary key. So if it is large, the overall index size uses more space.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择尽可能小的键，因为所有的次要索引都存储主键。所以如果它很大，整体索引大小会占用更多的空间。
- en: Choose a monotonically increasing value. The physical rows are ordered based
    on the primary key. So if you choose a random key, more rearrangement of rows
    is needed, which leads to degraded performance. `AUTO_INCREMENT` is a perfect
    fit for primary key.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个单调递增的值。物理行是根据主键排序的。所以如果你选择一个随机键，需要更多的行重新排列，这会导致性能下降。`AUTO_INCREMENT`是主键的完美选择。
- en: Always choose a primary key; if you cannot find any, add an `AUTO_INCREMENT`
    column. If you do not choose any, `InnoDB` internally generates a hidden clustered
    index with a 6-byte row ID.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终选择一个主键；如果找不到任何主键，添加一个`AUTO_INCREMENT`列。如果你不选择任何主键，`InnoDB`内部会生成一个隐藏的聚集索引，带有6字节的行ID。
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'You can see the indexes of a table by viewing its definition. You will notice
    that there is an index on `first_name` and `last_name`. If you filter the rows
    by specifying `first_name` or by both (`first_name` and `last_name`), MySQL can
    use the index to speed up the query. However, if you specify only `last_name`,
    the index cannot be used; this is because the optimizer can only use any of the
    leftmost prefixes of the index. Refer to [https://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html](https://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html)
    for more detailed examples:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看表的定义来查看表的索引。你会注意到`first_name`和`last_name`上有一个索引。如果你通过指定`first_name`或者两者（`first_name`和`last_name`）来过滤行，MySQL可以使用索引来加快查询。然而，如果你只指定`last_name`，索引就不能被使用；这是因为优化器只能使用索引的最左边的前缀。更详细的例子请参考[https://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html](https://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html)：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Add index
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加索引
- en: 'You can add an index by executing the `ALTER TABLE ADD INDEX` command. For
    example, if you want to add an index on `last_name`, see the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过执行`ALTER TABLE ADD INDEX`命令添加索引。例如，如果你想在`last_name`上添加一个索引，请参考以下代码：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can specify the name of the index; if not, the leftmost prefix will be used
    as the name. If there are any duplicates, the name will be appended by `_2`, `_3`,
    and so on.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定索引的名称；如果不指定，最左边的前缀将被用作名称。如果有任何重复，名称将被附加`_2`、`_3`等。
- en: 'For example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: UNIQUE index
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 唯一索引
- en: 'If you want the index to be unique, you can specify the keyword `UNIQUE`. For
    example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望索引是唯一的，可以指定关键字`UNIQUE`。例如：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Prefix index
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前缀索引
- en: 'For string columns, indexes that use only the leading part of column values,
    rather than the full column, can be created. You need to specify the length of
    the leading part:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字符串列，可以创建只使用列值前导部分而不是整个列的索引。你需要指定前导部分的长度：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The maximum length of `last_name` is `16` characters, but the index is created
    only on the first 10 characters.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`last_name`的最大长度是`16`个字符，但索引只在前10个字符上创建。'
- en: Drop index
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除索引
- en: 'You can drop an index using the `ALTER TABLE` command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`ALTER TABLE`命令删除索引：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Index on generated columns
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在生成的列上创建索引
- en: 'An index cannot be used on a column wrapped in a function. Suppose you add
    an index on `hire_date`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 不能在函数中使用列上的索引。假设你在`hire_date`上添加了一个索引：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The index on `hire_date` can be used for queries having `hire_date` in the
    `WHERE` clause:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WHERE`子句中有`hire_date`的查询可以使用`hire_date`上的索引：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Instead, if you put `hire_date` inside a function, MySQL has to scan the full
    table:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果将`hire_date`放在函数中，MySQL必须扫描整个表：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'So try to avoid putting an indexed column inside a function. If you cannot
    avoid using a function, create a virtual column and add an index on the virtual
    column:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽量避免在函数内部放置一个带索引的列。如果无法避免使用函数，则创建一个虚拟列并在虚拟列上添加索引：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, instead of using the `YEAR()` function in the query, you can directly
    use `hire_date_year` in the `WHERE` clause:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不再在查询中使用`YEAR()`函数，而是可以直接在`WHERE`子句中使用`hire_date_year`：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that even if you use `YEAR(hire_date)`, the optimizer recognizes that
    the expression `YEAR()` matches the definition of `hire_date_year` and that `hire_date_year`
    is indexed; so it considers that index during execution plan construction:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使使用`YEAR(hire_date)`，优化器也会认识到`YEAR()`表达式与`hire_date_year`的定义相匹配，并且`hire_date_year`被索引；因此在执行计划构建过程中会考虑该索引：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Invisible index
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可见索引
- en: If you want to drop an unused index, then instead of dropping immediately, you
    can mark it as invisible, monitor the application behavior, and later drop it.
    Later, if you need that index, you can mark it as visible, which is very fast
    compared to dropping and re-adding indexes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要删除未使用的索引，而不是立即删除，可以将其标记为不可见，监视应用程序行为，然后再删除。以后，如果需要该索引，可以将其标记为可见，这与删除和重新添加索引相比非常快。
- en: 'To explain the invisible index, you need to add normal index if not already
    there. Example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 解释不可见索引，如果尚未添加普通索引，则需要添加普通索引。例如：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How to do it...
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'If you wish to drop the index on `last_name`, rather than directly dropping,
    you can mark it as invisible using the `ALTER TABLE` command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望删除`last_name`上的索引，而不是直接删除，可以使用`ALTER TABLE`命令将其标记为不可见：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You will notice that the query filtering through `last_name` is using the `last_name`
    index; after marking it as invisible, it is not able to use. You can mark it as
    visible again:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到通过`last_name`进行查询过滤时使用了`last_name`索引；标记为不可见后，它无法使用。您可以再次将其标记为可见：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Descending index
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 降序索引
- en: Prior to MySQL 8, an index definition could contain the order (ascending or
    descending), but it was only parsed and not implemented. The index values were
    always stored in ascending order. MySQL 8.0 introduced support for descending
    indexes. Thus, the specified order in the index definition is not ignored. A descending
    index actually stores key values in descending order. Remember that scanning an
    ascending index in reverse is not efficient for a descending query.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在MySQL 8之前，索引定义可以包含顺序（升序或降序），但它只是被解析而不是被实现。索引值总是以升序存储的。MySQL 8.0引入了对降序索引的支持。因此，索引定义中指定的顺序不会被忽略。降序索引实际上以降序存储键值。请记住，对降序查询来说，以相反的方式扫描升序索引是低效的。
- en: Consider a case where, in a multi-column index, you can specify certain columns
    to be descending. This can help for queries wherein we have both ascending and
    descending `ORDER BY` clauses.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一种情况，在多列索引中，可以指定某些列为降序。这对于查询中有升序和降序`ORDER BY`子句的查询很有帮助。
- en: 'Suppose you want to sort the `employees` table with `first_name` ascending
    and `last_name` descending; MySQL cannot use the index on `first_name` and `last_name`.
    Without a descending index:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想对`employees`表进行排序，按`first_name`升序和`last_name`降序；MySQL无法使用`first_name`和`last_name`上的索引。没有降序索引：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the explain plan, you will notice that the index name (`first_name` and
    `last_name`) is not used:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释计划中，您会注意到索引名称（`first_name`和`last_name`）未被使用：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Add a descending index:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个降序索引：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After adding the descending index, the query is able to use the index:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加降序索引后，查询可以使用索引：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The same index can be used for the other way of ordering, that is, ordering
    by `first_name` descending and `last_name` ascending through the backward index
    scan:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相同的索引可以用于另一种排序方式，即通过反向索引扫描按`first_name`降序和`last_name`升序排序：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Analyzing slow queries using pt-query-digest
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`pt-query-digest`分析慢查询
- en: '`pt-query-digest`, which is part of the Percona Toolkit, is used for analyzing
    queries. The queries can be collected through any of the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`pt-query-digest`是Percona Toolkit的一部分，用于分析查询。可以通过以下任何一种方式收集查询：'
- en: Slow query log
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 慢查询日志
- en: General query log
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般查询日志
- en: Process list
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程列表
- en: Binary log
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制日志
- en: TCP dump
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP转储
- en: Installation of the Percona Toolkit is covered in [Chapter 10](part0337.html#A1CDI0-faa69fe6f4c04957afca3568dcd9cd83), *Table
    Maintenance*, *Installing Percona Toolkit* section. In this section, you will
    learn how to use `pt-query-digest`. There are drawbacks for each method. The slow
    query log does not include all queries unless you specify `long_query_time` as `0`,
    which drastically slows down a system. The general query log does not include
    query time. You cannot get complete queries from the process list. Only writes
    can be analyzed using binary log and using TCP dump causes server degradation.
    Usually, this tool is used on the slow query log with a `long_query_time` of 1
    second or higher.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Percona Toolkit的安装在[第10章](part0337.html#A1CDI0-faa69fe6f4c04957afca3568dcd9cd83)中有介绍，*表维护*，*安装Percona
    Toolkit*部分。在本节中，您将学习如何使用`pt-query-digest`。每种方法都有缺点。慢查询日志不包括所有查询，除非指定`long_query_time`为`0`，这会严重减慢系统。一般查询日志不包括查询时间。您无法从进程列表中获取完整的查询。只能使用二进制日志分析写入，并且使用TCP转储会导致服务器降级。通常，此工具用于具有1秒或更高`long_query_time`的慢查询日志。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's get into the details of analyzing slow queries using `pt-query-digest`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析使用`pt-query-digest`分析慢查询的细节。
- en: Slow query log
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 慢查询日志
- en: Enabling and configuring the slow query log is explained in [Chapter 12](part0417.html#CDLQI0-faa69fe6f4c04957afca3568dcd9cd83),
    *Managing Logs*, *Managing the general query log and slow query log*. Once the
    slow query log is enabled and queries are collected, you can run `pt-query-digest`
    by passing the slow query log.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 启用和配置慢查询日志在[第12章](part0417.html#CDLQI0-faa69fe6f4c04957afca3568dcd9cd83)中有解释，*管理日志*，*管理一般查询日志和慢查询日志*。一旦启用慢查询日志并收集查询，就可以通过传递慢查询日志来运行`pt-query-digest`。
- en: 'Suppose the slow query file is at `/var/lib/mysql/mysql-slow.log`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 假设慢查询文件位于`/var/lib/mysql/mysql-slow.log`：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The digest report contains queries ranked by the number of query executions
    multiplied by the query time. Query details such as the query checksum (a unique
    value for each type of query), average time, percentage time, and number of executions
    are shown for all queries in the summary. You can drill down to the specific query
    by searching for the query checksum.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要报告包含按查询执行次数乘以查询时间排名的查询。摘要中显示了查询的详细信息，如查询校验和（每种查询的唯一值）、平均时间、百分比时间和执行次数。您可以通过搜索查询校验和来深入了解特定查询。
- en: 'The digest report looks like the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要报告如下所示：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The query profile will look like:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 查询概要将如下所示：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: From the preceding output, you can infer that for query `#1` (`0x55F499860A034BCB`),
    the cumulative response time for all executions is `76560` seconds. This accounts
    for 42.7% of the cumulative response time of all queries. The number of executions
    is 47 and the average query time is `1628` seconds.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，您可以推断出对于查询`#1`（`0x55F499860A034BCB`），所有执行的累积响应时间为`76560`秒。这占所有查询的累积响应时间的42.7%。执行次数为47，平均查询时间为`1628`秒。
- en: 'You can go to any query by searching for the checksum. The complete query,
    commands for the explain plan, and the table status are displayed. For example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过搜索校验和来查找任何查询。完整的查询、解释计划的命令和表状态都会显示出来。例如：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: General query log
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常规查询日志
- en: 'You can use `pt-query-digest` to analyze the general query log by passing the
    argument `--type genlog`. Since general logs do not report query times, only the
    count aggregate is shown:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过传递参数`--type genlog`来使用`pt-query-digest`分析常规查询日志。由于常规日志不报告查询时间，因此只显示计数聚合：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output will be something like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于这样：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The query profile will look something like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 查询概要将类似于这样：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Process list
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程列表
- en: 'Instead of a log file, you can use `pt-query-digest` to read queries from the
    process list:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`pt-query-digest`从进程列表中读取查询，而不是使用日志文件：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`run-time` specifies how long each iteration should run. In the preceding example,
    the tool generates reports every minute for 10 minutes.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`run-time`指定每次迭代应运行多长时间。在前面的示例中，该工具将在10分钟内每分钟生成一次报告。'
- en: Binary log
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制日志
- en: 'To analyze the binary log using `pt-query-digest`, you should convert it to
    text format using the `mysqlbinlog` utility:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`pt-query-digest`分析二进制日志，您应该使用`mysqlbinlog`实用程序将其转换为文本格式：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: TCP dump
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP转储
- en: 'You can capture TCP traffic using the `tcpdump` command and send it to `pt-query-digest`
    for analysis:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`tcpdump`命令捕获TCP流量，并将其发送到`pt-query-digest`进行分析：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There are plenty of options available in `pt-query-digest`, such as filtering
    queries for a specific time window, filtering a specific query, and generating
    reports. Please refer to the Percona documentation at [https://www.percona.com/doc/percona-toolkit/LATEST/pt-query-digest.html](https://www.percona.com/doc/percona-toolkit/LATEST/pt-query-digest.html) for more
    details.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`pt-query-digest`中有很多选项可用，例如过滤特定时间窗口的查询、过滤特定查询和生成报告。有关更多详细信息，请参阅Percona文档[https://www.percona.com/doc/percona-toolkit/LATEST/pt-query-digest.html](https://www.percona.com/doc/percona-toolkit/LATEST/pt-query-digest.html)。'
- en: See also
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Refer to [https://engineering.linkedin.com/blog/2017/09/query-analyzer--a-tool-for-analyzing-mysql-queries-without-overh](https://engineering.linkedin.com/blog/2017/09/query-analyzer--a-tool-for-analyzing-mysql-queries-without-overh)
    to know more about the new way of analyzing all queries without any overhead.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://engineering.linkedin.com/blog/2017/09/query-analyzer--a-tool-for-analyzing-mysql-queries-without-overh](https://engineering.linkedin.com/blog/2017/09/query-analyzer--a-tool-for-analyzing-mysql-queries-without-overh)以了解有关分析所有查询的新方法而无需任何开销的更多信息。
- en: Optimizing datatypes
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化数据类型
- en: You should define tables such that they occupy minimum space on disk while accommodating
    all possible values.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该定义表，使其在磁盘上占用最少的空间，同时容纳所有可能的值。
- en: 'If the size is smaller:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果大小较小：
- en: Less data is written to or read from the disk, which makes queries faster.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入或从磁盘读取的数据较少，这使得查询更快。
- en: The contents on the disk are loaded to the main memory while processing queries.
    So, smaller tables occupy less space in the main memory.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理查询时，磁盘上的内容会加载到主内存中。因此，较小的表在主内存中占用的空间较小。
- en: Less space is occupied by indexes.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引占用的空间较少。
- en: How to do it...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: If you want to store an employee number, for which the maximum possible value
    is 500,000, the optimum datatype is `MEDIUMINT UNSIGNED` (which occupies 3 bytes).
    If you are storing it as `INT`, which occupies 4 bytes, you are wasting a byte
    for each row.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想存储最大可能值为500,000的员工编号，则最佳数据类型是`MEDIUMINT UNSIGNED`（占用3个字节）。如果您将其存储为占用4个字节的`INT`，则每行都会浪费一个字节。
- en: If you want to store the first name, for which the length is varying and the
    maximum possible value is 20, it is optimal to declare it as `varchar(20)`. If
    you are storing it as `char(20)`, and just a few names are 20 characters long
    while the remaining are less than 10 characters long, you are wasting space of
    10 characters.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想存储长度可变且最大可能值为20的名字，最好将其声明为`varchar(20)`。如果您将其存储为`char(20)`，并且只有少数名字长度为20个字符，而其余名字长度都不到10个字符，那么您就浪费了10个字符的空间。
- en: While declaring `varchar` columns, you should consider the length. Though `varchar`
    is optimized on-disk, while loading into memory, it occupies the full length.
    For example, if you store `first_name` in `varchar(255)` and the actual length
    is 10, on the disk it occupies 10 + 1 (an additional byte for storing length);
    but in the memory, it occupies the full length of 255 bytes.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在声明`varchar`列时，您应该考虑长度。虽然`varchar`在磁盘上进行了优化，但在加载到内存时，它会占用全部长度。例如，如果您将`first_name`存储在`varchar(255)`中，实际长度为10，在磁盘上占用10+1（用于存储长度的额外字节）；但在内存中，它将占用255个字节的全部长度。
- en: If the length of the `varchar` column is more than 255 chars, it requires 2
    bytes to store the length.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`varchar`列的长度超过255个字符，则需要2个字节来存储长度。
- en: 'Declare the columns as `NOT NULL` if you are not storing null values. This
    avoids the overhead for testing whether each value is null and also saves some
    storage space: 1 bit per column.'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不存储空值，请将列声明为`NOT NULL`。这样可以避免测试每个值是否为空的开销，还可以节省一些存储空间：每列1位。
- en: If the length is fixed, use `char` instead of `varchar`, because `varchar` takes
    a byte or two to store the length of the string.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果长度是固定的，请使用`char`而不是`varchar`，因为`varchar`需要一个或两个字节来存储字符串的长度。
- en: If the values are fixed, use `ENUM` rather than `varchar`. For example, if you
    want to store values that can be pending, approved, rejected, deployed, undeployed,
    failed, or deleted, you can use `ENUM`. It takes 1 or 2 bytes, rather than `char(10)`,
    which occupies 10 bytes.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果值是固定的，请使用`ENUM`而不是`varchar`。例如，如果要存储可以是pending、approved、rejected、deployed、undeployed、failed或deleted的值，可以使用`ENUM`。它只占用1或2个字节，而`char(10)`占用10个字节。
- en: Prefer integers over strings.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 优先使用整数而不是字符串。
- en: Try to leverage the prefix index.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试利用前缀索引。
- en: Try to leverage the `InnoDB` compression.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试利用`InnoDB`压缩。
- en: Refer to [https://dev.mysql.com/doc/refman/8.0/en/storage-requirements.html](https://dev.mysql.com/doc/refman/8.0/en/storage-requirements.html)
    to know more about the storage requirements of each datatype and [https://dev.mysql.com/doc/refman/8.0/en/integer-types.html](https://dev.mysql.com/doc/refman/8.0/en/integer-types.html)
    to know about the range of each integer type.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 参考[https://dev.mysql.com/doc/refman/8.0/en/storage-requirements.html](https://dev.mysql.com/doc/refman/8.0/en/storage-requirements.html)了解每种数据类型的存储要求，以及[https://dev.mysql.com/doc/refman/8.0/en/integer-types.html](https://dev.mysql.com/doc/refman/8.0/en/integer-types.html)了解每种整数类型的范围。
- en: 'If you want to know the optimized datatype, you can use the function `PROCEDURE
    ANALYZE`. Though it is not accurate, it gives a fair idea of the fields. Unfortunately,
    it is deprecated in MySQL 8:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道优化的数据类型，可以使用`PROCEDURE ANALYZE`函数。虽然不太准确，但可以对字段有一个大致的了解。不幸的是，它在MySQL 8中已被弃用：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Removing duplicate and redundant indexes
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除重复和冗余索引
- en: You can define several indexes on a column. By mistake, you might have defined
    the same index again (same column, same order of columns, or same order of keys),
    which is called a **duplicate index**. If only partial indexes (leftmost columns)
    are repetitive, they are called **redundant indexes**. A duplicate index has no
    advantages. Redundant indexes might be useful in some cases (a use case is mentioned
    in the note at the end of this section), but both slow down the inserts. So, it
    is important to identify and remove them.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在一列上定义多个索引。可能会错误地再次定义相同的索引（相同的列，相同的列顺序或相同的键顺序），这被称为**重复索引**。如果只有部分索引（最左边的列）是重复的，则称为**冗余索引**。重复索引没有优势。冗余索引在某些情况下可能有用（在本节末尾的注释中提到了一个用例），但两者都会减慢插入速度。因此，识别并删除它们非常重要。
- en: 'There are three tools that can help with finding out duplicate indexes:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个工具可以帮助找出重复的索引：
- en: '`pt-duplicate-key-checker`, which is part of the Percona Toolkit. Installing
    the Percona Toolkit is covered in [Chapter 10](part0337.html#A1CDI0-faa69fe6f4c04957afca3568dcd9cd83), *Table
    Maintenance*, *Installing Percona Toolkit* section.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pt-duplicate-key-checker`是Percona Toolkit的一部分。安装Percona Toolkit在[第10章](part0337.html#A1CDI0-faa69fe6f4c04957afca3568dcd9cd83)，*表维护*，*安装Percona
    Toolkit*部分有介绍。'
- en: '`mysqlindexcheck`, which is part of MySQL utilities. Installing MySQL utilities
    is covered in [Chapter 1](part0025.html#NQU20-faa69fe6f4c04957afca3568dcd9cd83),
    *MySQL 8.0 – Installing and Upgrading*.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mysqlindexcheck`是MySQL实用程序的一部分。安装MySQL实用程序在[第1章](part0025.html#NQU20-faa69fe6f4c04957afca3568dcd9cd83)中有介绍，*MySQL
    8.0 – 安装和升级*。'
- en: Using the `sys` schema, which will be covered in the next section.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`sys`模式，这将在下一节中介绍。
- en: 'Consider the following `employees` table:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下`employees`表：
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The index `full_name_1` is the duplicate of `full_name` because both indexes
    are on the same columns, the same order of columns, and the same order of keys
    (ascending or descending).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 索引`full_name_1`是`full_name`的重复，因为两个索引都在相同的列上，列的顺序相同，键的顺序也相同（升序或降序）。
- en: The index `first_name` is a redundant index because the column `first_name`
    is already covered in the leftmost suffix of the `first_name` index.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 索引`first_name`是冗余索引，因为列`first_name`已经包含在`first_name`索引的最左边的后缀中。
- en: 'The index `first_name_emp_no` is a redundant index because it contains the
    primary key in the rightmost suffix. The `InnoDB` secondary indexes already contain
    the primary key, so it is redundant to declare the primary key as part of the
    secondary index. However, it can be useful in queries that filter by `first_name`
    and sort by `emp_no`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 索引`first_name_emp_no`是冗余索引，因为它包含了最右边的后缀中的主键。`InnoDB`的次要索引已经包含了主键，因此在次要索引中声明主键是多余的。但是，在过滤`first_name`并按`emp_no`排序的查询中可能会有用：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `full_name_desc` option is not a duplicate of `full_name` because the ordering
    of keys is different.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`full_name_desc`选项不是`full_name`的重复，因为键的排序不同。'
- en: How to do it...
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's get into the details of removing duplicate and redundant indexes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解一下删除重复和冗余索引。
- en: pt-duplicate-key-checker
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pt-duplicate-key-checker
- en: '`pt-duplicate-key-checker` gives the exact `ALTER` statements to drop duplicate
    keys:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`pt-duplicate-key-checker`给出了删除重复键的确切`ALTER`语句：'
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The tool suggests that you shorten the duplicate clustered index by removing
    the `PRIMARY KEY` from the rightmost suffix. Note that it may result in another
    duplicate index. If you wish to ignore the duplicate clustered indexes, you can
    pass the `--noclustered` option.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具建议您通过从最右边的后缀中删除`PRIMARY KEY`来缩短重复的聚集索引。请注意，这可能会导致另一个重复的索引。如果您希望忽略重复的聚集索引，可以传递`--noclustered`选项。
- en: 'To check the duplicate indexes of a particular database, you can pass the `--databases
    <database name>` option:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查特定数据库的重复索引，可以传递`--databases <database name>`选项：
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To drop the keys, you can even pipe the output of `pt-duplicate-key-checker`
    to `mysql`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除键，甚至可以将`pt-duplicate-key-checker`的输出导入到`mysql`中：
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: mysqlindexcheck
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mysqlindexcheck
- en: 'Note that `mysqlindexcheck` ignores descending indexes. For example, `full_name_desc`
    (`first_name` descending and `last_name`) is treated as a duplicate index of `full_name`
    (`first_name` and `last_name`):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`mysqlindexcheck`忽略降序索引。例如，`full_name_desc`（`first_name`降序和`last_name`）被视为`full_name`（`first_name`和`last_name`）的重复索引：
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As mentioned earlier, redundant indexes can be useful in some cases. You have
    to consider whether these kinds of cases are needed by your application.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，多余的索引在某些情况下可能有用。您必须考虑您的应用程序是否需要这些情况。
- en: Create indexes to understand the following examples
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 创建索引以了解以下示例
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Consider the following `employees` and `salaries` tables:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下`employees`和`salaries`表：
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'It seems like `from_date` is a redundant index of `from_date_2`, but check
    the explain plan of the following query! It is using an intersection of both the
    indexes. The `from_date` index is used for filtering and `from_date_2` is used
    for joining with the `employees` table. The optimizer is scanning only one row
    in each table:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎`from_date`是`from_date_2`的多余索引，但是检查以下查询的解释计划！它使用了两个索引的交集。`from_date`索引用于过滤，`from_date_2`用于与`employees`表进行连接。优化器在每个表中只扫描一行：
- en: '[PRE49]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now drop the redundant index `from_date` and check the explain plan. You can
    see that the optimizer is scanning 90 rows in the `salaries` table and one row
    in the `employees` table. But look at the `ref` column; it shows that constants
    are compared to the index named in the `key` column (`from_date_2`) to select
    rows from the table. Rather than dropping the indexes, you can test this behavior
    by passing optimizer hints or index hints, which are covered in the next section:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在删除多余的`from_date`索引并检查解释计划。您可以看到优化器在`salaries`表中扫描90行和`employees`表中的一行。但是看一下`ref`列；它显示常量与`key`列中命名的索引（`from_date_2`）进行比较，以从表中选择行。您可以通过传递优化器提示或索引提示来测试这种行为，这将在下一节中介绍：
- en: '[PRE50]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now you need to determine which of the queries is faster:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要确定哪个查询更快：
- en: '**Plan 1**: Using `intersect(from_date, from_date_2)`; scanning one row with
    ref as null'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计划1**：使用`intersect(from_date, from_date_2)`；扫描一行，ref为空'
- en: '**Plan 2**: Using `from_date_2`; scanning 90 rows with ref as constant'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计划2**：使用`from_date_2`；扫描90行，ref为常量'
- en: You can use the `mysqlslap` utility to find that (do not run this directly on
    the production host) and make sure that the concurrency is less than `max_connections`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`mysqlslap`实用程序来查找（不要直接在生产主机上运行），并确保并发小于`max_connections`。
- en: 'The benchmark for plan 1 is as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 计划1的基准测试如下：
- en: '[PRE51]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The benchmark for plan 2 is:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 计划2的基准测试如下：
- en: '[PRE52]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: It turns out that the average query time for plan 1 and plan 2 are 0.466 seconds
    and 0.435 seconds, respectively. Since the results are very close, you can take
    a call and drop the redundant index. Use plan 2.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，计划1和计划2的平均查询时间分别为0.466秒和0.435秒。由于结果非常接近，您可以选择删除多余的索引。使用计划2。
- en: This is just an example that will enable you to learn and apply the concept
    in your application scenarios.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个示例，可以让您学习并应用在您的应用程序场景中。
- en: Checking index usage
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查索引使用情况
- en: In the preceding section, you learned about removing redundant and duplicate
    indexes. While designing an application, you might have thought about filtering
    a query based on a column and added index. But over a period of time, because
    of changes in the application, you might not need that index. In this section,
    you will learn about identifying those unused indexes.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，您了解了如何删除多余和重复的索引。在设计应用程序时，您可能已经考虑过根据列过滤查询并添加索引。但是随着应用程序的变化，您可能不再需要该索引。在本节中，您将了解如何识别这些未使用的索引。
- en: 'There are two ways you can find unused indexes:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过两种方式找到未使用的索引：
- en: Using `pt-index-usage` (covered in this section)
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pt-index-usage`（在本节中介绍）
- en: Using `sys` schema (covered in the next section)
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`sys`模式（在下一节中介绍）
- en: How to do it...
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'We can use the `pt-index-usage` tool from the Percona Toolkit to get the index
    analysis. It takes queries from the slow query log, runs the explain plan for
    each and every query, and identifies the unused indexes. If you have a list of
    queries, you can save them in slow query format and pass that to the tool. Note
    that this is only an approximation because the slow query log does not include
    all the queries:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Percona Toolkit中的`pt-index-usage`工具进行索引分析。它从慢查询日志中获取查询，为每个查询运行解释计划，并识别未使用的索引。如果您有一系列查询，可以将它们保存为慢查询格式并将其传递给该工具。请注意，这只是一个近似值，因为慢查询日志不包括所有查询：
- en: '[PRE53]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Controlling the query optimizer
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制查询优化器
- en: The task of the query optimizer is to find an optimal plan for executing a SQL
    query. There can be multiple plans to execute a query, especially when joining
    a table, where the number of plans to be examined increases exponentially. In
    this section, you will learn about adjusting the optimizer to your needs.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 查询优化器的任务是为执行SQL查询找到最佳计划。在连接表时，可能有多个执行查询的计划，特别是要检查的计划数量呈指数增长。在本节中，您将了解如何调整优化器以满足您的需求。
- en: Take the example of the `employees` table and add the necessary index;
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以`employees`表为例，添加必要的索引；
- en: '[PRE54]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Suppose you want to check whether any of `first_name` or `last_name` is `Adam`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想检查`first_name`或`last_name`是否为`Adam`：
- en: 'The explain plan is as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 解释计划如下：
- en: '[PRE55]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You will notice that there are many options available for the optimizer to
    fulfill the query. It can use any of the indexes listed in `possible_keys: (full_name,full_name_desc,first_name,full_name_1,first_name_emp_no,last_name_2)`.
    The optimizer verifies all the plans and determines which plan involves the least
    cost.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到优化器有许多选项可用于满足查询。它可以使用`possible_keys`中列出的任何索引：（full_name,full_name_desc,first_name,full_name_1,first_name_emp_no,last_name_2）。优化器验证所有计划，并确定哪个计划涉及的成本最低。
- en: Some examples of costs involved in the query are accessing data from the disk,
    accessing data from the memory, creating a temp table, sorting the results in
    the memory, and so on. MySQL assigns a relative value for each operation and sums
    the total cost for each plan. It executes the plan that involves the least cost.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 查询中涉及的一些成本示例包括从磁盘访问数据，从内存访问数据，创建临时表，在内存中对结果进行排序等。MySQL为每个操作分配一个相对值，并对每个计划的总成本进行求和。它执行涉及最小成本的计划。
- en: How to do it...
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: You can control the optimizer either by passing hints to the query or by adjusting
    the variable at a global or session level. You can even adjust the cost of the
    operations. It is recommended to leave these values as default unless you know
    what you are doing.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过向查询传递提示或调整全局或会话级别的变量来控制优化器。甚至可以调整操作的成本。建议将这些值保留为默认值，除非您知道自己在做什么。
- en: optimizer_search_depth
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: optimizer_search_depth
- en: 'The Jørgen''s point of view, taken from [http://jorgenloland.blogspot.in/2012/04/improvements-for-many-table-joins-in.html](http://jorgenloland.blogspot.in/2012/04/improvements-for-many-table-joins-in.html),
    states that:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[http://jorgenloland.blogspot.in/2012/04/improvements-for-many-table-joins-in.html](http://jorgenloland.blogspot.in/2012/04/improvements-for-many-table-joins-in.html)的Jørgen观点如下：
- en: '"MySQL uses greedy search algorithm to to find the best order to join tables.
    When you join just a few tables, there''s no problem calculating the cost of all
    join order combinations and then pick the best plan. However, since there are
    (#tables)! possible combinations, the cost of calculating them all soon becomes
    too high: for five tables, e.g., there are 120 combinations which is no problem
    to compute. For 10 tables there are 3.6 million combinations and for 15 tables
    there are 1307 billion. For this reason, MySQL makes a trade off: use heuristics
    to only explore promising plans. This is supposed to significantly reduce the
    number of plans MySQL needs to calculate, but at the same time you risk not finding
    the best one."'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '"MySQL使用贪婪搜索算法来找到最佳的表连接顺序。当你只连接几个表时，计算所有连接顺序组合的成本然后选择最佳计划是没有问题的。然而，由于可能的组合数为(#tables)!，计算它们的成本很快变得太高：例如，对于五个表，有120种组合是可以计算的。对于10个表，有360万种组合，对于15个表，有1307亿种组合。因此，MySQL做出了一个权衡：使用启发式方法只探索有前途的计划。这应该显著减少MySQL需要计算的计划数量，但同时也存在风险找不到最佳计划。"'
- en: 'The MySQL documentation says:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL文档中说：
- en: '"The optimizer_search_depth variable tells how far into the "future" of each
    incomplete plan the optimizer should look to evaluate whether it should be expanded
    further. Smaller values of optimizer_search_depth may result in orders of magnitude
    smaller query compilation times. For example, queries with 12, 13, or more tables
    may easily require hours and even days to compile if optimizer_search_depth is
    close to the number of tables in the query. At the same time, if compiled with
    optimizer_search_depth equal to 3 or 4, the optimizer may compile in less than
    a minute for the same query. If you are unsure of what a reasonable value is for
    optimizer_search_depth, this variable can be set to 0 to tell the optimizer to
    determine the value automatically."'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '"optimizer_search_depth变量告诉优化器应该查看每个不完整计划的“未来”多远，以评估是否应进一步扩展。较小的optimizer_search_depth值可能导致查询编译时间减少数个数量级。例如，如果使用optimizer_search_depth接近查询中的表数，查询可能需要几个小时甚至几天才能编译。同时，如果使用optimizer_search_depth等于3或4进行编译，对于相同的查询，优化器可能在不到一分钟内编译。如果您不确定optimizer_search_depth的合理值是多少，可以将该变量设置为0，告诉优化器自动确定值。"'
- en: The default value of `optimizer_search_depth` is `62`, which is very greedy,
    but because of heuristics, MySQL picks up the plan very quickly. It is not clear
    from the documentation why the default value is set to `62` instead of `0`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`optimizer_search_depth`的默认值为`62`，非常贪婪，但由于启发式方法，MySQL很快选择了计划。从文档中不清楚为什么默认值设置为`62`而不是`0`。'
- en: 'If you are joining more than seven tables, you can set `optimizer_search_depth`
    to `0` or pass the optimizer hint (you will learn that in the next section). Automatic
    selection picks the value of min (number of tables, seven), limiting the search
    depth to a reasonable value:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要连接超过七个表，可以将`optimizer_search_depth`设置为`0`或传递优化器提示（您将在下一节中了解到）。自动选择最小值（表的数量，七），将搜索深度限制为合理值：
- en: '[PRE56]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How to know that the query is spending time in evaluating plans?
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何知道查询在评估计划时花费了多少时间？
- en: If you are joining 10 tables (mostly autogenerated by ORM), run an explain plan.
    If it takes more time, it means that the query is spending too much time in evaluating
    plans. Adjust the value of `optimizer_search_depth` (probably set to `0`) and
    check how much time the explain plan takes. Also note down the change in plans
    when you adjust the value of `optimizer_search_depth`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要连接10个表（通常是ORM自动生成的），运行一个解释计划。如果花费更多时间，这意味着查询在评估计划时花费了太多时间。调整`optimizer_search_depth`的值（可能设置为`0`），并检查解释计划花费了多少时间。还要注意调整`optimizer_search_depth`的值时计划的变化。
- en: optimizer_switch
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化器开关
- en: The `optimizer_switch` system variable is a set of flags. You can set each of
    those flags to `ON` or `OFF` to enable or disable the corresponding optimizer
    behavior. You can set it at the session level or global level dynamically. If
    you adjust the optimizer switch at the session level, all the queries in that
    session are affected, and if it is at the global level, all queries are affected.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`optimizer_switch`系统变量是一组标志。您可以将这些标志中的每一个设置为`ON`或`OFF`以启用或禁用相应的优化器行为。您可以在会话级别或全局级别动态设置它。如果您在会话级别调整了优化器开关，则该会话中的所有查询都会受到影响，如果在全局级别，则所有查询都会受到影响。'
- en: 'For example, you have noticed that the preceding query, `SELECT emp_no FROM
    employees WHERE first_name=''Adam'' OR last_name=''Adam''`, is using `sort_union(first_name,last_name_2)`.
    If you think that optimization is not correct for that query, you can adjust `optimizer_switch`
    to switch to another optimization:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您已经注意到前面的查询，`SELECT emp_no FROM employees WHERE first_name='Adam' OR last_name='Adam'`，正在使用`sort_union(first_name,last_name_2)`。如果您认为该优化对该查询不正确，您可以调整`optimizer_switch`以切换到另一种优化：
- en: '[PRE57]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Initially, `index_merge_union` is on:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，`index_merge_union`是打开的：
- en: '[PRE58]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The optimizer is able to use `sort_union`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 优化器能够使用`sort_union`：
- en: '[PRE59]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You can turn off `index_merge_sort_union` optimization at the session level
    so that only queries in this session are affected:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在会话级别关闭`index_merge_sort_union`优化，以便只有该会话中的查询受到影响：
- en: '[PRE60]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You will notice the plan change after `index_merge_sort_union` is turned off;
    it is no longer using `sort_union` optimization:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到在关闭`index_merge_sort_union`后计划发生变化；它不再使用`sort_union`优化：
- en: '[PRE61]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: You can further find that, in this case, using `sort_union` is the best choice.
    Refer to [https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html)
    for more details on all types of optimizer switches.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以进一步发现，在这种情况下，使用`sort_union`是最佳选择。请参阅[https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html)获取有关所有类型优化器开关的更多详细信息。
- en: Optimizer hints
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化器提示
- en: Instead of adjusting the optimizer switch or `optimizer_search_depth` variables
    at session level, you can hint the optimizer to use, or not to use, certain optimizations.
    The scope of the optimizer hint is limited to the statement that gives you finer
    control over the queries, whereas the optimizer switch can be at session or global
    level.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在会话级别调整优化器开关或`optimizer_search_depth`变量，您可以提示优化器使用或不使用某些优化。优化器提示的范围仅限于给您更好地控制查询的语句，而优化器开关可以在会话或全局级别设置。
- en: 'Again, take the example of the preceding query; if you feel that using `sort_union`
    is not optimal, you can turn it off by passing it as a hint in the query itself:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 再次以前面的查询为例；如果您觉得使用`sort_union`不是最佳选择，您可以通过在查询本身中传递提示来关闭它：
- en: '[PRE62]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Remember that in the redundant index section, we dropped the redundant index
    to find which plan was better. Instead, you can use the optimizer hint to ignore
    the intersect of `from_date` and `from_date_2`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在冗余索引部分，我们删除了冗余索引以找出哪个计划更好。而不是这样做，您可以使用优化器提示来忽略`from_date`和`from_date_2`的交集：
- en: '[PRE63]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Another good example of using optimizer hints is setting the `JOIN` order:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用优化器提示的很好的例子是设置`JOIN`顺序：
- en: '[PRE64]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In the preceding query, the optimizer is first considering the `employees`
    table, and joining with the `salaries` table. You can change that by passing the
    hint, `/*+ JOIN_ORDER(s,e ) */`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的查询中，优化器首先考虑`employees`表，并与`salaries`表进行连接。您可以通过传递提示`/*+ JOIN_ORDER(s,e )
    */`来更改这一点：
- en: '[PRE65]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: You will now notice that the `salaries` table is considered first, which avoids
    creating a temporary table, but it is going for a full table scan on the `salaries`
    table.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在会注意到首先考虑`salaries`表，这样可以避免创建临时表，但它会对`salaries`表进行全表扫描。
- en: 'Another use case of optimizer hints is as follows: rather than setting the
    session variables for each statement or session, you can set them only for the
    statement. Suppose you are using an `ORDER BY` clause that sorts the query results,
    but you do not have index on the `ORDER BY` clause. Optimizer makes use of `sort_buffer_size`
    to speed up sorting. By default, the value of `sort_buffer_size` is `256K`. If
    `sort_buffer_size` is not sufficient, the number of merge passes that the sort
    algorithm has to do increases. You can measure this through the session variable `sort_merge_passes`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 优化器提示的另一个用例如下：而不是为每个语句或会话设置会话变量，您可以仅为该语句设置它们。假设您使用了一个对查询结果进行排序的`ORDER BY`子句，但在`ORDER
    BY`子句上没有索引。优化器使用`sort_buffer_size`来加速排序。默认情况下，`sort_buffer_size`的值为`256K`。如果`sort_buffer_size`不足，排序算法必须执行的合并次数会增加。您可以通过会话变量`sort_merge_passes`来衡量这一点：
- en: '[PRE66]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'You will notice that MySQL did not have enough `sort_buffer_size`, and it has
    to do eight `sort_merge_passes`. You can set `sort_buffer_size` to some large
    value such as `16M` through an optimizer hint and check `sort_merge_passes`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到MySQL没有足够的`sort_buffer_size`，必须执行八次`sort_merge_passes`。您可以通过优化器提示将`sort_buffer_size`设置为诸如`16M`之类的大值，并检查`sort_merge_passes`：
- en: '[PRE67]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: You will notice that `sort_merge_passes` is `0` when `sort_buffer_size` is set
    to `16M`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当`sort_buffer_size`设置为`16M`时，您会注意到`sort_merge_passes`为`0`。
- en: It is highly recommended to optimize your queries by using indexes rather than
    relying on `sort_buffer_size`. You can consider increasing the `sort_buffer_size`
    value to speed up `ORDER BY` or `GROUP BY` operations that cannot be improved
    with query optimization or improved indexing.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议通过使用索引来优化您的查询，而不是依赖于`sort_buffer_size`。您可以考虑增加`sort_buffer_size`的值，以加快无法通过查询优化或改进索引的`ORDER
    BY`或`GROUP BY`操作的速度。
- en: 'Using `SET_VAR`, you can set `optimizer_switch` at the statement level:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`SET_VAR`，您可以在语句级别设置`optimizer_switch`：
- en: '[PRE68]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You can also set the maximum execution time for a query, meaning the query
    is automatically terminated after the specified time using `/*+ MAX_EXECUTION_TIME(milli
    seconds) */`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以为查询设置最大执行时间，这意味着查询在指定时间后会自动终止使用`/*+ MAX_EXECUTION_TIME(毫秒) */`：
- en: '[PRE69]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: You can hint many other things to the optimizer, refer to [https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html](https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html)
    to get complete list and more examples.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以提示优化器做很多其他事情，请参阅[https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html](https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html)获取完整列表和更多示例。
- en: Adjusting the optimizer cost model
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整优化器成本模型
- en: 'To generate execution plans, the optimizer uses a cost model that is based
    on estimates of the cost of various operations that occur during query execution.
    The optimizer has a set of compiled-in default cost constants available to it,
    to make decisions regarding execution plans. You can adjust them by updating or
    inserting the `mysql.engine_cost` table and executing the `FLUSH OPTIMIZER_COSTS`
    command:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成执行计划，优化器使用基于查询执行过程中各种操作成本的估算的成本模型。优化器具有一组编译的默认成本常量可供其使用，以便决定执行计划。您可以通过更新或插入`mysql.engine_cost`表并执行`FLUSH
    OPTIMIZER_COSTS`命令来调整它们：
- en: '[PRE70]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Suppose you have a superfast disk; you can decrease the `cost_value` for `io_block_read_cost`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个超快的磁盘；您可以减少`io_block_read_cost`的`cost_value`：
- en: '[PRE71]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: To know more about the optimizer cost model, refer to [https://dev.mysql.com/doc/refman/8.0/en/cost-model.html](https://dev.mysql.com/doc/refman/8.0/en/cost-model.html).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多有关优化器成本模型的信息，请参阅[https://dev.mysql.com/doc/refman/8.0/en/cost-model.html](https://dev.mysql.com/doc/refman/8.0/en/cost-model.html)。
- en: Using index hints
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用索引提示
- en: Using index hints, you can hint the optimizer to use or ignore indexes. This
    is different from optimizer hints. In optimizer hints, you hint the optimizer
    to use or ignore certain optimization methods. Index and optimizer hints can be
    used separately or together to achieve the desired plan. Index hints are specified
    following a table name.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用索引提示，您可以提示优化器使用或忽略索引。这与优化器提示不同。在优化器提示中，您提示优化器使用或忽略某些优化方法。索引和优化器提示可以分别或一起使用以实现所需的计划。索引提示是在表名后指定的。
- en: When you are executing a complex query involving multiple table joins, and if
    the optimizer is taking too much time in evaluating the plans, you can determine
    the best plan and give it a hint to the query. But make sure that the plan you
    are suggesting is the best and should work in all cases.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行涉及多个表连接的复杂查询时，如果优化器在评估计划时花费太多时间，您可以确定最佳计划并给出查询的提示。但请确保您建议的计划是最佳的，并且在所有情况下都应该有效。
- en: How to do it...
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Take the same query where you evaluated the use of the redundant index as an
    example; it is using `intersect(from_date,from_date_2)`. By passing the optimizer
    hint `(/*+ NO_INDEX_MERGE(s from_date,from_date_2) */)`, you avoided the use of
    intersect. You can achieve the same behavior by hinting the optimizer to ignore
    the `from_date_2` index:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 以评估冗余索引的使用为例，使用相同的查询；它使用`intersect(from_date,from_date_2)`。通过传递优化器提示`(/*+ NO_INDEX_MERGE(s
    from_date,from_date_2) */)`，您避免了使用intersect。您可以通过提示优化器忽略`from_date_2`索引来实现相同的行为：
- en: '[PRE72]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Another use case is hinting the optimizer and saving the cost of evaluating
    multiple plans. Consider the following `employees` table and the query (the same
    as the one discussed at the beginning of the *Controlling query optimizer* section):'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用例是提示优化器并节省评估多个计划的成本。考虑以下`employees`表和查询（与*控制查询优化器*部分开头讨论的相同）：
- en: '[PRE73]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'You can see that the optimizer has to evaluate the indexes `full_name`, `full_name_desc`, `first_name`, `full_name_1`, `first_name_emp_no`, `last_name_2`
    to arrive at the best plan. You can hint the optimizer by passing `USE INDEX(first_name,last_name_2)`,
    which will eliminate scanning of other indexes:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到优化器必须评估`full_name`、`full_name_desc`、`first_name`、`full_name_1`、`first_name_emp_no`、`last_name_2`索引以得出最佳计划。您可以通过传递`USE
    INDEX(first_name,last_name_2)`来提示优化器，这将消除对其他索引的扫描：
- en: '[PRE74]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Since this is a simple query and the table is very small, the performance gain
    is negligible. The performance gain can be significant when the query is complex
    and is executed millions of times an hour.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个简单的查询，表非常小，性能提升可以忽略不计。当查询复杂且每小时执行数百万次时，性能提升可能会显著。
- en: Indexing for JSON using generated columns
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用生成的列进行JSON索引
- en: JSON columns cannot be indexed directly. So if you want to use an index on a
    JSON column, you can extract the information using virtual columns and a created
    index on the virtual column.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: JSON列不能直接建立索引。因此，如果您想在JSON列上使用索引，可以使用虚拟列和虚拟列上的创建索引来提取信息。
- en: How to do it...
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Consider the `emp_details` table that you created in [Chapter 3](part0166.html#4U9TC0-faa69fe6f4c04957afca3568dcd9cd83),
    *Using MySQL (Advanced)*, *Using JSON* section:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑您在[第3章](part0166.html#4U9TC0-faa69fe6f4c04957afca3568dcd9cd83)中创建的`emp_details`表，*使用MySQL（高级）*，*使用JSON*部分：
- en: '[PRE75]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Insert a few dummy records:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入一些虚拟记录：
- en: '[PRE76]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Suppose you want to retrieve the `emp_no` whose city is `Bangalore`:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设您想检索城市为`Bangalore`的`emp_no`：
- en: '[PRE77]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: You will notice that the query is not able to use the index and scan all the
    rows.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到查询无法使用索引并扫描所有行。
- en: 'You can retrieve the city as a virtual column and add an index on it:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以将城市作为虚拟列检索并在其上添加索引：
- en: '[PRE78]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'If you check the explain plan now, you can notice that the query is able to
    use the index on `city` and scan only one row:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您现在检查解释计划，您会注意到查询能够使用`city`上的索引并且只扫描一行：
- en: '[PRE79]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: To know more about secondary indexes on generated columns, refer to [https://dev.mysql.com/doc/refman/8.0/en/create-table-secondary-indexes.html](https://dev.mysql.com/doc/refman/8.0/en/create-table-secondary-indexes.html).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关生成列上的辅助索引的更多信息，请参阅[https://dev.mysql.com/doc/refman/8.0/en/create-table-secondary-indexes.html](https://dev.mysql.com/doc/refman/8.0/en/create-table-secondary-indexes.html)。
- en: Using resource groups
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用资源组
- en: You can restrict the queries to use only a certain number of system resources
    using the resource groups. Currently, only CPU time is a manageable resource represented
    by **virtual CPU** (**VCPU**), which includes CPU cores, hyperthreads, hardware
    threads, and more. You can create a resource group and assign the VCPUs to it.
    Apart from the CPU, the attribute to the resource group is thread priority.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以限制查询仅使用一定数量的系统资源，使用资源组。目前，只有CPU时间是可管理的资源，由**虚拟CPU**（**VCPU**）表示，其中包括CPU核心、超线程、硬件线程等。您可以创建一个资源组并将VCPUs分配给它。除了CPU外，资源组的属性是线程优先级。
- en: You can assign a resource group to a thread, set the default resource group
    at the session level, or pass the resource group as an optimizer hint. For example,
    you want to run some queries (say, reporting queries) with lowest priority; you
    can assign them to a resource group that has minimum resources.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为线程分配资源组，在会话级别设置默认资源组，或将资源组作为优化器提示传递。例如，您想要以最低优先级运行一些查询（比如报告查询）；您可以将它们分配给具有最少资源的资源组。
- en: How to do it...
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Set the `CAP_SYS_NICE` capability to `mysqld`:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`CAP_SYS_NICE`功能设置为`mysqld`：
- en: '[PRE80]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Create a resource group using the `CREATE RESOURCE GROUP` statement. You have
    to mention the resource group name, number of VCPUS, thread priority, and type,
    which can be either `USER` or `SYSTEM`. If you do not specify the VCPU, all the
    CPUs will be used:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`CREATE RESOURCE GROUP`语句创建资源组。您必须提到资源组名称、VCPUS数量、线程优先级和类型，可以是`USER`或`SYSTEM`。如果不指定VCPUs，将使用所有CPU：
- en: '[PRE81]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The VCPU represents the CPU number as 0-5, including CPUs 0, 1, 2, 3, 4, and
    5; and 0-3, 8-9, and 11 include CPUs 0, 1, 2, 3, 8, 9, and 11.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: VCPU表示CPU编号为0-5，包括CPU 0、1、2、3、4和5；0-3、8-9和11包括CPU 0、1、2、3、8、9和11。
- en: The `THREAD_PRIORITY` is like a nice value for the CPU; it ranges from -20 to
    0 for system resource groups and 0 to 19 for user groups. -20 is the highest priority
    and 19 is the lowest priority.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREAD_PRIORITY`类似于CPU的优先级；系统资源组的范围为-20到0，用户组的范围为0到19。-20是最高优先级，19是最低优先级。'
- en: You can also enable or disable a resource group. By default, the resource group
    is enabled at creation. A disabled group cannot have threads assigned to it.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以启用或禁用资源组。默认情况下，在创建时启用资源组。禁用的组不能分配线程。
- en: 'After creating, you can verify the resource groups created:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建后，您可以验证已创建的资源组：
- en: '[PRE82]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '`USR_default` and `SYS_default` are default resource groups which cannot be
    dropped or modified.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`USR_default`和`SYS_default`是默认资源组，不能被删除或修改。'
- en: 'Assign a group to a thread:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为线程分配一个组：
- en: '[PRE83]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Set the sessions resource group; all the queries in that session will be executed
    under `report_group`:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置会话资源组；该会话中的所有查询将在`report_group`下执行：
- en: '[PRE84]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Use the `RESOURCE_GROUP` optimizer hint to execute a single statement using `report_group`:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`RESOURCE_GROUP`优化器提示使用`report_group`执行单个语句：
- en: '[PRE85]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Alter and drop resource group
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改和删除资源组
- en: 'You can dynamically adjust the number of CPUs or `thread_priority` of a resource
    group. If the system is heavily loaded, you can decrease the thread priority:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以动态调整资源组的CPU数量或`thread_priority`。如果系统负载过重，可以降低线程优先级：
- en: '[PRE86]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Similarly, you can increase the priority when the system is lightly loaded:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当系统负载较轻时，您可以增加优先级：
- en: '[PRE87]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'You can disable a resource group:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以禁用资源组：
- en: '[PRE88]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'You can also drop a resource group using the `DROP RESOURCE GROUP` statement:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`DROP RESOURCE GROUP`语句删除资源组：
- en: '[PRE89]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: If `FORCE` is given, the threads running are moved to the default resource group
    (system threads to `SYS_default` and user threads to `USR_default`).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定`FORCE`，则正在运行的线程将移动到默认资源组（系统线程移动到`SYS_default`，用户线程移动到`USR_default`）。
- en: If `FORCE` is not given, existing threads in the group continue to run until
    they terminate, but new threads cannot be assigned to the group.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未给出`FORCE`，则组中的现有线程将继续运行直到终止，但新线程不能分配给该组。
- en: The resource group is restricted to the local server, and none of the resource-group-related
    statements are replicated. To know more about resource groups, refer to [https://dev.mysql.com/doc/refman/8.0/en/resource-groups.html](https://dev.mysql.com/doc/refman/8.0/en/resource-groups.html).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 资源组仅限于本地服务器，并且与资源组相关的语句都不会被复制。要了解有关资源组的更多信息，请参阅[https://dev.mysql.com/doc/refman/8.0/en/resource-groups.html](https://dev.mysql.com/doc/refman/8.0/en/resource-groups.html)。
- en: Using performance_schema
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用performance_schema
- en: You can inspect the internal execution of the server at runtime using `performance_schema`.
    This should not be confused with information schema, which is used to inspect
    metadata.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`performance_schema`在运行时检查服务器的内部执行。这不应与信息模式混淆，信息模式用于检查元数据。
- en: There are many event consumers in `performance_schema` that influence the timings
    of a server, such as a function call, a wait for the operating system, a stage
    of an SQL statement execution (say, parsing or sorting), a single statement, or
    a group of statements. All the collected information is stored in `performance_schema`
    and is not replicated.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`performance_schema`中有许多事件消费者，会影响服务器的时间，例如函数调用、等待操作系统、SQL语句执行阶段（如解析或排序）、单个语句或一组语句。所有收集的信息都存储在`performance_schema`中，不会被复制。'
- en: '`performance_schema` is enabled by default; if you want to disable it, you
    can set `performance_schema=OFF` in the `my.cnf` file. By default, not all the
    consumers and instruments are enabled; you can turn them off/on by updating the
    `performance_schema.setup_instruments` and `performance_schema.setup_consumers` 
    tables.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`performance_schema`默认启用；如果要禁用它，可以在`my.cnf`文件中设置`performance_schema=OFF`。默认情况下，并非所有消费者和仪器都启用；您可以通过更新`performance_schema.setup_instruments`和`performance_schema.setup_consumers`表来关闭/打开它们。'
- en: How to do it...
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We will see how to use the `performance_schema`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看看如何使用`performance_schema`。
- en: Enable/disable performance_schema
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用/禁用performance_schema
- en: 'To disable it, set `performance_schema` to `0`:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用它，请将`performance_schema`设置为`0`：
- en: '[PRE90]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Enable/disable consumers and instruments
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用/禁用消费者和仪器
- en: 'You see a list of consumers available in the `setup_consumers` table, as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`setup_consumers`表中看到可用的消费者列表，如下所示：
- en: '[PRE91]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Suppose you want to enable `events_waits_current`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要启用`events_waits_current`：
- en: '[PRE92]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Similarly, you can disable or enable instruments from the `setup_instruments`
    table. There are around 1182 instruments (depending on the version):'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，您可以从`setup_instruments`表中禁用或启用仪器。有大约1182个仪器（取决于版本）：
- en: '[PRE93]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: performance_schema tables
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: performance_schema表
- en: 'There are five main types of table in `performance_schema`. They are current
    events tables, event history tables, event summary tables, object instances tables,
    and setup (configuration) tables:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`performance_schema`中有五种主要类型的表。它们是当前事件表、事件历史表、事件摘要表、对象实例表和设置（配置）表：'
- en: '[PRE94]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Suppose you want to find out which file is accessed the most:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要找出哪个文件被访问最多：
- en: '[PRE95]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Or you want to find out which file has taken the most time in writing:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您想要找出哪个文件在写入时花费了最多的时间：
- en: '[PRE97]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'You can use the `events_statements_summary_by_digest` table to get the query
    report, just like you did for `pt-query-digest`. Top query by amount of time taken:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`events_statements_summary_by_digest`表来获取查询报告，就像您为`pt-query-digest`所做的那样。花费时间最多的顶级查询：
- en: '[PRE98]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Top query by number of executions:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 按执行次数最多的顶级查询：
- en: '[PRE99]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Suppose you want to find the statistics of a particular query; rather than
    depending on `mysqlslap` benchmark, you can check all the statistics using `performance_schema`:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要查找特定查询的统计信息；而不是依赖于`mysqlslap`基准测试，您可以使用`performance_schema`来检查所有统计信息：
- en: '[PRE100]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Using the sys schema
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用sys模式
- en: The `sys` schema helps you interpret the data collected from the `performance_schema`
    in an easy and more understandable form. `performance_schema` should be enabled
    for `sys` schema to work. To use the `sys` schema to its fullest extent, you need
    to enable all the consumers and timers on `performance_schema`, but this impacts
    the performance of the server. So, enable consumers for only those that you are
    looking for.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys`模式帮助您以更简单和更易理解的形式解释从`performance_schema`收集的数据。`performance_schema`应该启用`sys`模式才能工作。要充分利用`sys`模式，您需要在`performance_schema`上启用所有的消费者和计时器，但这会影响服务器的性能。因此，只为您寻找的那些启用消费者。'
- en: A view with the `x$` prefix displays data in picoseconds, which is used by other
    tools for further processing; other tables are human readable.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`x$`前缀的视图以皮秒显示数据，其他表是人类可读的，这些数据被其他工具用于进一步处理。
- en: How to do it...
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Enable a instrument from the `sys` schema:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 从`sys`模式启用一个工具：
- en: '[PRE101]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'If you want to reset to default, do this:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要重置为默认值，请执行以下操作：
- en: '[PRE102]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: There are numerous tables in the `sys` schema; some of the most used ones are
    shown in this section.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys`模式中有许多表；本节显示了一些最常用的表。'
- en: Statement by type (INSERT and SELECT) from each host
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个主机的类型声明（INSERT和SELECT）
- en: '[PRE103]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Statement by type from each user
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个用户的类型声明
- en: '[PRE104]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Redundant indexes
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冗余索引
- en: '[PRE105]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Unused indexes
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未使用的索引
- en: '[PRE106]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Statements executed from each host
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个主机执行的语句
- en: '[PRE107]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Table statistics
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表统计
- en: '[PRE108]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Table statistics with buffer
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有缓冲区的表统计
- en: '[PRE109]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Statement analysis
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语句分析
- en: This output is similar to the output of  `performance_schema.events_statements_summary_by_digest`
    and `pt-query-digest`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出类似于`performance_schema.events_statements_summary_by_digest`和`pt-query-digest`的输出。
- en: 'The top query by execution count is as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 按执行次数最多的查询如下：
- en: '[PRE110]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The statement that consumed maximum `tmp_disk_tables`:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 消耗最大`tmp_disk_tables`的语句：
- en: '[PRE111]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: To know more about the `sys` schema objects, refer to [https://dev.mysql.com/doc/refman/8.0/en/sys-schema-object-index.html](https://dev.mysql.com/doc/refman/8.0/en/sys-schema-object-index.html).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`sys`模式对象的信息，请参阅[https://dev.mysql.com/doc/refman/8.0/en/sys-schema-object-index.html](https://dev.mysql.com/doc/refman/8.0/en/sys-schema-object-index.html)。
